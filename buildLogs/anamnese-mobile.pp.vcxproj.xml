<!--
============================================================================================================================================
C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
<!-- This project was created with react-native-windows 0.73.22 -->
<Project ToolsVersion="Current" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" InitialTargets="ReactNativeWindowsValidateProps">
  <!--<Import Project="$(SolutionDir)\ExperimentalFeatures.props" Condition="Exists('$(SolutionDir)\ExperimentalFeatures.props')" />-->
  <PropertyGroup Label="Globals">
    <CppWinRTOptimized>true</CppWinRTOptimized>
    <CppWinRTRootNamespaceAutoMerge>true</CppWinRTRootNamespaceAutoMerge>
    <MinimalCoreWin>true</MinimalCoreWin>
    <ProjectGuid>{930d2be6-e26a-4586-b3df-587ac6b40610}</ProjectGuid>
    <ProjectName>anamnese-mobile</ProjectName>
    <RootNamespace>anamnese-mobile</RootNamespace>
    <DefaultLanguage>en-US</DefaultLanguage>
    <MinimumVisualStudioVersion>17.0</MinimumVisualStudioVersion>
    <AppContainerApplication>true</AppContainerApplication>
    <ApplicationType>Windows Store</ApplicationType>
    <ApplicationTypeRevision>10.0</ApplicationTypeRevision>
    <TargetPlatformMinVersion>10.0.17763.0</TargetPlatformMinVersion>
  </PropertyGroup>
  <PropertyGroup Label="ReactNativeWindowsProps">
    <SolutionDir Condition="'$(SolutionDir)' == ''">$(MSBuildThisFileDirectory)..\</SolutionDir>
    <ReactNativeWindowsDir Condition="'$(ReactNativeWindowsDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(SolutionDir), 'node_modules\react-native-windows\package.json'))\node_modules\react-native-windows\</ReactNativeWindowsDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.WindowsSdk.Default.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.WindowsSdk.Default.props
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.
-->
  <!--
    This defines the default Windows SDK used to build both the app and 0.66+
    template community modules.

    See https://microsoft.github.io/react-native-windows/docs/win10-compat
  -->
  <PropertyGroup Label="Globals" Condition="'$(MSBuildProjectExtension)' == '.vcxproj'">
    <WindowsTargetPlatformVersion Condition="'$(WindowsTargetPlatformVersion)'=='' Or '$(WindowsTargetPlatformVersion)'=='10.0.0.0'">10.0.19041.0</WindowsTargetPlatformVersion>
    <WindowsTargetPlatformMinVersion Condition="'$(WindowsTargetPlatformMinVersion)'=='' Or '$(WindowsTargetPlatformMinVersion)'=='10.0.0.0'">10.0.17763.0</WindowsTargetPlatformMinVersion>
    <WindowsTargetPlatformMinVersion Condition="'$(UseWinUI3)'=='true' And $([MSBuild]::VersionLessThan('$(WindowsTargetPlatformMinVersion)', '10.0.17763.0'))">10.0.17763.0</WindowsTargetPlatformMinVersion>
  </PropertyGroup>
  <PropertyGroup Label="Globals" Condition="'$(MSBuildProjectExtension)' == '.csproj' Or '$(MSBuildProjectExtension)' == '.wapproj'">
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)'==''">10.0.19041.0</TargetPlatformVersion>
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)'==''">10.0.17763.0</TargetPlatformMinVersion>
    <TargetPlatformMinVersion Condition="'$(UseWinUI3)'=='true' And $([MSBuild]::VersionLessThan('$(TargetPlatformMinVersion)', '10.0.17763.0'))">10.0.17763.0</TargetPlatformMinVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Default.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Default.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <VCTargetsPathActual>$(VCTargetsPath)</VCTargetsPathActual>
    <CurrentVCTargetsPath>$(VCTargetsPath)</CurrentVCTargetsPath>
    <CurrentVsInstallRoot>$(VsInstallRoot)</CurrentVsInstallRoot>
    <ClearDevCommandPromptEnvVars Condition="'$(ClearDevCommandPromptEnvVars)' == '' and '$(VSCMD_VER)' != '' and '$(DisableRegistryUse)' != 'true' and '$(UseEnv)' != 'true'">true</ClearDevCommandPromptEnvVars>
  </PropertyGroup>
  <!-- ensure that IDE is always using current version of CLCommandLine task for designtime builds -->
  <UsingTask TaskName="CLCommandLine" AssemblyFile="$(CurrentVCTargetsPath)\Microsoft.Build.CPPTasks.Common.dll" />
  <!-- ensure that build is always using current version of CallVcpkg task -->
  <UsingTask TaskName="CallVcpkg" AssemblyFile="$(CurrentVCTargetsPath)Microsoft.Build.CppTasks.Common.dll" />
  <!-- clear out properties defined as env vars in dev command prompt and which interfere with the project settings -->
  <PropertyGroup Condition="'$(ClearDevCommandPromptEnvVars)' == 'true'">
    <Framework40Version />
    <FrameworkDir />
    <FrameworkDIR32 />
    <FrameworkVersion />
    <FrameworkVersion32 />
    <IFCPATH />
    <NETFXSDKDir />
    <UCRTVersion />
    <UniversalCRTSdkDir />
    <VCIDEInstallDir />
    <VCINSTALLDIR />
    <VCToolsInstallDir />
    <VCToolsRedistDir />
    <VCToolsVersion />
    <WindowsLibPath />
    <WindowsSdkBinPath />
    <WindowsSdkDir />
    <WindowsSDKLibVersion />
    <WindowsSdkVerBinPath />
    <WindowsSDKVersion />
    <WindowsSDK_ExecutablePath_x64 />
    <WindowsSDK_ExecutablePath_x86 />
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
    <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonProps>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonProps>
    <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">true</ImportDirectoryBuildProps>
  </PropertyGroup>
  <!--
      Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
      they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''" xmlns="">
    <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
    <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildProps)" Condition="'$(CustomBeforeDirectoryBuildProps)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <!-- Force MSBuild to use an installed Windows SDK version.
         This machine only has Windows 10/11 SDK 10.0.26100.0, while many RNW
         templates default to 10.0.19041.0. -->
    <WindowsTargetPlatformVersion Condition="'$(WindowsTargetPlatformVersion)' == '' or '$(WindowsTargetPlatformVersion)' == '10.0.19041.0'">10.0.26100.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterDirectoryBuildProps)" Condition="'$(CustomAfterDirectoryBuildProps)' != ''" />-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
        $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props

      Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
      management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup xmlns="">
    <!--
        The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
        in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
    -->
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
    <MSBuildProjectExtensionsPath Condition="'$(MSBuildProjectExtensionsPath)' == '' ">$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
    <!--
        Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
        defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
        it needs to be made absolute based on the project directory.
    -->
    <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
    <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionProps
    -->
    <ImportProjectExtensionProps Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionProps)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionProps>
    <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
    <_InitialMSBuildProjectExtensionsPath Condition=" '$(ImportProjectExtensionProps)' == 'true' ">$(MSBuildProjectExtensionsPath)</_InitialMSBuildProjectExtensionsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.props
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">$(UserProfile)\.nuget\packages\</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">C:\Users\tubbeTEC\.nuget\packages\;C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.14.2</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="C:\Users\tubbeTEC\.nuget\packages\" />
    <SourceRoot Include="C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages\" />
  </ItemGroup>
  <!--<ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.windows.cppwinrt\2.0.211028.7\build\native\Microsoft.Windows.CppWinRT.props" Condition="Exists('$(NuGetPackageRoot)microsoft.windows.cppwinrt\2.0.211028.7\build\native\Microsoft.Windows.CppWinRT.props')">

C:\Users\tubbeTEC\.nuget\packages\microsoft.windows.cppwinrt\2.0.211028.7\build\native\Microsoft.Windows.CppWinRT.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--Set compiler and linker options for projects requiring C++/WinRT. -->
  <PropertyGroup>
    <!-- Only do this for MSBuild versions below 16.0
             as it is since done automatically, see https://github.com/microsoft/msbuild/pull/3605-->
    <MSBuildAllProjects Condition="'$(MSBuildToolsVersion)'  &lt;= '15'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
    <CanReferenceWinRT>true</CanReferenceWinRT>
    <CppWinRTPackage Condition="'$(CppWinRTEnabled)' != 'true'">true</CppWinRTPackage>
    <CppWinRTPackage Condition="'$(CppWinRTPackage)' != 'true'">false</CppWinRTPackage>
    <XamlLanguage Condition="'$(XamlLanguage)' == ''">CppWinRT</XamlLanguage>
    <IsNativeLanguage>true</IsNativeLanguage>
    <!-- This causes VS to add the platform WinMD references for the target SDK -->
    <WinMDAssembly>true</WinMDAssembly>
    <!--Set a value to prevent SDK's uap.props from setting it and pointing to the wrong headers-->
    <CppWinRT_IncludePath>PreventSdkUapPropsAssignment</CppWinRT_IncludePath>
    <CppWinRTEnableDefaultCopyLocalFalse Condition="'$(CppWinRTEnableDefaultCopyLocalFalse)' == ''">true</CppWinRTEnableDefaultCopyLocalFalse>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <CompileAsWinRT Condition="'$(CppWinRTProjectLanguage)' != 'C++/CX' And '%(ClCompile.CompileAsWinRT)' == ''">false</CompileAsWinRT>
      <LanguageStandard Condition="'%(ClCompile.LanguageStandard)' == ''">stdcpp17</LanguageStandard>
    </ClCompile>
    <Midl Condition="'$(CppWinRTModernIDL)' != 'false'">
      <EnableWindowsRuntime>true</EnableWindowsRuntime>
      <MetadataFileName>$(IntDir)Unmerged\%(Filename).winmd</MetadataFileName>
      <GenerateClientFiles Condition="'%(Midl.GenerateClientFiles)'==''">None</GenerateClientFiles>
      <GenerateServerFiles Condition="'%(Midl.GenerateServerFiles)'==''">None</GenerateServerFiles>
      <GenerateStublessProxies Condition="'%(Midl.GenerateStublessProxies)'==''">false</GenerateStublessProxies>
      <GenerateTypeLibrary Condition="'%(Midl.GenerateTypeLibrary)'==''">false</GenerateTypeLibrary>
      <HeaderFileName Condition="'%(Midl.HeaderFileName)'==''">nul</HeaderFileName>
      <DllDataFileName Condition="'%(Midl.DllDataFileName)'==''">nul</DllDataFileName>
      <InterfaceIdentifierFileName Condition="'%(Midl.InterfaceIdentifierFileName)'==''">nul</InterfaceIdentifierFileName>
      <ProxyFileName Condition="'%(Midl.ProxyFileName)'==''">nul</ProxyFileName>
      <TypeLibraryName Condition="'%(Midl.TypeLibraryName)'==''" />
    </Midl>
    <ProjectReference Condition="'$(XamlLanguage)' != 'C++' and '$(CppWinRTEnableDefaultCopyLocalFalse)' == 'true'">
      <!-- By default, for a C++/WinRT project,
                 don't copy project reference output to the output directory
                 of the current project for projects that are not an exe. -->
      <Private Condition="'$(ConfigurationType)' != 'Application' and '$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe'">false</Private>
    </ProjectReference>
    <Reference Condition="'$(XamlLanguage)' != 'C++' and '$(CppWinRTEnableDefaultCopyLocalFalse)' == 'true'">
      <!-- By default, for a C++/WinRT project,
                 don't copy reference output to the output directory
                 of the current project for projects that are not an exe. -->
      <Private Condition="'$(ConfigurationType)' != 'Application' and '$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe'">false</Private>
    </Reference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)\CppWinrtRules.Project.xml" />
    <ProjectCapability Include="CppWinRT" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.ui.xaml\2.8.0\buildTransitive\Microsoft.UI.Xaml.props" Condition="Exists('$(NuGetPackageRoot)microsoft.ui.xaml\2.8.0\buildTransitive\Microsoft.UI.Xaml.props')">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\buildTransitive\Microsoft.UI.Xaml.props
============================================================================================================================================
-->
  <!-- Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License. See LICENSE in the project root for license information. -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\MicrosoftUIXamlVersion.props">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\buildTransitive\MicrosoftUIXamlVersion.props
============================================================================================================================================
-->
  <PropertyGroup>
    <MicrosoftUIXamlAppxVersion>8.2207.14002.0</MicrosoftUIXamlAppxVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\buildTransitive\Microsoft.UI.Xaml.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Common.targets">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\buildTransitive\Common.targets
============================================================================================================================================
-->
  <!-- Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License. See LICENSE in the project root for license information. -->
  <!-- Check TargetPlatformMinVersion during build to block unsupported configurations. -->
  <Target Name="MicrosoftUIXamlCheckTargetPlatformVersion" BeforeTargets="PrepareForBuild" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetPlatformMinVersion)' != '' and '$(SkipMicrosoftUIXamlCheckTargetPlatformVersion)'==''">
    <PropertyGroup>
      <MicrosoftUIXamlTargetPlatformMinCheckValue>$([System.Version]::Parse('$(TargetPlatformMinVersion)').Build)</MicrosoftUIXamlTargetPlatformMinCheckValue>
    </PropertyGroup>
    <Error Text="Microsoft.UI.Xaml nuget package requires TargetPlatformMinVersion &gt;= 10.0.17763.0 (current project is $(MicrosoftUIXamlTargetPlatformMinCheckValue))" Condition="$(MicrosoftUIXamlTargetPlatformMinCheckValue) &lt; 17763" />
    <PropertyGroup>
      <MicrosoftUIXamlTargetPlatformCheckValue>$([System.Version]::Parse('$(TargetPlatformVersion)').Build)</MicrosoftUIXamlTargetPlatformCheckValue>
    </PropertyGroup>
    <Error Text="Microsoft.UI.Xaml nuget package requires TargetPlatformVersion &gt;= 10.0.18362.0 (current project is $(MicrosoftUIXamlTargetPlatformCheckValue))" Condition="$(MicrosoftUIXamlTargetPlatformCheckValue) &lt; 18362" />
  </Target>
  <!-- WACK certification requires that types referenced by dependent packages exist in WinMD files in the root of the AppX.
       However, the BuildNativePackage target requires that it *not* be in that location, or else that target will return an error.
       In order to enable apps to pass WACK certification that reference packages that reference us, we'll add it to the package payload
       after that target has completed. -->
  <ItemGroup>
    <XamlWinmd Include="$(MSBuildThisFileDirectory)..\lib\uap10.0\Microsoft.UI.Xaml.winmd">
      <SkipHarvestingWinmdRegistration Condition="'$(MicrosoftUIXamlAppxVersion)' != ''">true</SkipHarvestingWinmdRegistration>
      <TargetPath>Microsoft.UI.Xaml.winmd</TargetPath>
      <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
      <ProjectName>$(ProjectName)</ProjectName>
      <Implementation Condition="'$(MicrosoftUIXamlAppxVersion)' == ''">Microsoft.UI.Xaml.dll</Implementation>
    </XamlWinmd>
  </ItemGroup>
  <PropertyGroup>
    <XamlWinmdName>Microsoft.UI.Xaml.winmd</XamlWinmdName>
    <XamlCompactXbfName>Microsoft.UI.Xaml\DensityStyles\Compact.xbf</XamlCompactXbfName>
    <WebView2UseWinRT Condition="'$(WebView2UseWinRT)' ==''">true</WebView2UseWinRT>
  </PropertyGroup>
  <Target Name="_FixWinmdCopyLocal" AfterTargets="ResolveNuGetPackageAssets">
    <ItemGroup>
      <XamlWinMdCopyLocal Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)' == '$(XamlWinmdName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinMdCopyLocal)' != ''">
      <ReferenceCopyLocalPaths Remove="@(XamlWinMdCopyLocal)" />
    </ItemGroup>
  </Target>
  <Target Name="_FixWinmdPackaging" BeforeTargets="_ComputeAppxPackagePayload">
    <ItemGroup>
      <XamlWinmdPackagingOutput Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Filename)%(PackagingOutputs.Extension)' == '$(XamlWinmdName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinmdPackagingOutput)' != ''">
      <PackagingOutputs Remove="@(XamlWinmdPackagingOutput)" />
    </ItemGroup>
    <ItemGroup>
      <PackagingOutputs Include="@(XamlWinmd)" />
    </ItemGroup>
  </Target>
  <Target Name="_RemoveXamlWinmdFromWinMetadataFolder" AfterTargets="BuildNativePackage" BeforeTargets="_AddXamlWinmdToPackageLayoutRoot">
    <ItemGroup>
      <XamlWinmdAppxPackagePayload Include="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == '$(WinMetadataDir)\$(XamlWinmdName)'" />
      <XamlWinmdAppxUploadPackagePayload Include="@(AppxUploadPackagePayload)" Condition="'%(AppxUploadPackagePayload.TargetPath)' == '$(WinMetadataDir)\$(XamlWinmdName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinmdAppxPackagePayload)' != ''">
      <AppxPackagePayload Remove="@(XamlWinmdAppxPackagePayload)" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinmdAppxUploadPackagePayload)' != ''">
      <AppxUploadPackagePayload Remove="@(XamlWinmdAppxUploadPackagePayload)" />
    </ItemGroup>
  </Target>
  <Target Name="_AddXamlWinmdToPackageLayoutRoot" AfterTargets="BuildNativePackage">
    <ItemGroup>
      <AppxPackagePayload Include="@(XamlWinmd)">
        <TargetPath>Microsoft.UI.Xaml.winmd</TargetPath>
      </AppxPackagePayload>
      <AppxUploadPackagePayload Include="@(XamlWinmd)">
        <TargetPath>Microsoft.UI.Xaml.winmd</TargetPath>
      </AppxUploadPackagePayload>
    </ItemGroup>
    <Copy SourceFiles="@(XamlWinmd)" DestinationFiles="@(XamlWinmd -> '$(OutDir)\%(Filename)%(Extension)')" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\buildTransitive\Microsoft.UI.Xaml.props
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\x86\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>x86</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <!-- Some C++/CX projects use Platform=Win32 instead of Platform=x86 -->
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\x86\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>Win32</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\x64\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>x64</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\arm\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>arm</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\arm64\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>arm64</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!-- Add a dependency for the app against VCLibs since we need it but the consuming app might be .NET only. -->
  <ItemGroup Condition="('$(OutputType)' == 'AppContainerExe')">
    <SDKReference Include="Microsoft.VCLibs, Version=14.0" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <PkgMicrosoft_Web_WebView2 Condition=" '$(PkgMicrosoft_Web_WebView2)' == '' ">C:\Users\tubbeTEC\.nuget\packages\microsoft.web.webview2\1.0.1264.42</PkgMicrosoft_Web_WebView2>
    <PkgMicrosoft_UI_Xaml Condition=" '$(PkgMicrosoft_UI_Xaml)' == '' ">C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0</PkgMicrosoft_UI_Xaml>
    <PkgMicrosoft_JavaScript_Hermes Condition=" '$(PkgMicrosoft_JavaScript_Hermes)' == '' ">C:\Users\tubbeTEC\.nuget\packages\microsoft.javascript.hermes\0.1.27</PkgMicrosoft_JavaScript_Hermes>
    <Pkgruntime_win10-x86_Microsoft_Net_UWPCoreRuntimeSdk Condition=" '$(Pkgruntime_win10-x86_Microsoft_Net_UWPCoreRuntimeSdk)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-x86.microsoft.net.uwpcoreruntimesdk\2.2.12</Pkgruntime_win10-x86_Microsoft_Net_UWPCoreRuntimeSdk>
    <Pkgruntime_win10-x86_Microsoft_Net_Native_SharedLibrary Condition=" '$(Pkgruntime_win10-x86_Microsoft_Net_Native_SharedLibrary)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-x86.microsoft.net.native.sharedlibrary\2.2.8-rel-29722-00</Pkgruntime_win10-x86_Microsoft_Net_Native_SharedLibrary>
    <Pkgruntime_win10-x86_Microsoft_Net_Native_Compiler Condition=" '$(Pkgruntime_win10-x86_Microsoft_Net_Native_Compiler)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-x86.microsoft.net.native.compiler\2.2.10-rel-29722-00</Pkgruntime_win10-x86_Microsoft_Net_Native_Compiler>
    <Pkgruntime_win10-x64_Microsoft_Net_UWPCoreRuntimeSdk Condition=" '$(Pkgruntime_win10-x64_Microsoft_Net_UWPCoreRuntimeSdk)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-x64.microsoft.net.uwpcoreruntimesdk\2.2.12</Pkgruntime_win10-x64_Microsoft_Net_UWPCoreRuntimeSdk>
    <Pkgruntime_win10-x64_Microsoft_Net_Native_SharedLibrary Condition=" '$(Pkgruntime_win10-x64_Microsoft_Net_Native_SharedLibrary)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-x64.microsoft.net.native.sharedlibrary\2.2.8-rel-29722-00</Pkgruntime_win10-x64_Microsoft_Net_Native_SharedLibrary>
    <Pkgruntime_win10-x64_Microsoft_Net_Native_Compiler Condition=" '$(Pkgruntime_win10-x64_Microsoft_Net_Native_Compiler)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-x64.microsoft.net.native.compiler\2.2.10-rel-29722-00</Pkgruntime_win10-x64_Microsoft_Net_Native_Compiler>
    <Pkgruntime_win10-arm64_Microsoft_Net_Native_SharedLibrary Condition=" '$(Pkgruntime_win10-arm64_Microsoft_Net_Native_SharedLibrary)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-arm64.microsoft.net.native.sharedlibrary\2.2.8-rel-29722-00</Pkgruntime_win10-arm64_Microsoft_Net_Native_SharedLibrary>
    <Pkgruntime_win10-arm64_Microsoft_Net_Native_Compiler Condition=" '$(Pkgruntime_win10-arm64_Microsoft_Net_Native_Compiler)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-arm64.microsoft.net.native.compiler\2.2.10-rel-29722-00</Pkgruntime_win10-arm64_Microsoft_Net_Native_Compiler>
    <Pkgruntime_win10-arm_Microsoft_Net_UWPCoreRuntimeSdk Condition=" '$(Pkgruntime_win10-arm_Microsoft_Net_UWPCoreRuntimeSdk)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-arm.microsoft.net.uwpcoreruntimesdk\2.2.12</Pkgruntime_win10-arm_Microsoft_Net_UWPCoreRuntimeSdk>
    <Pkgruntime_win10-arm_Microsoft_Net_Native_SharedLibrary Condition=" '$(Pkgruntime_win10-arm_Microsoft_Net_Native_SharedLibrary)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-arm.microsoft.net.native.sharedlibrary\2.2.8-rel-29722-00</Pkgruntime_win10-arm_Microsoft_Net_Native_SharedLibrary>
    <Pkgruntime_win10-arm_Microsoft_Net_Native_Compiler Condition=" '$(Pkgruntime_win10-arm_Microsoft_Net_Native_Compiler)' == '' ">C:\Users\tubbeTEC\.nuget\packages\runtime.win10-arm.microsoft.net.native.compiler\2.2.10-rel-29722-00</Pkgruntime_win10-arm_Microsoft_Net_Native_Compiler>
    <PkgMicrosoft_Net_UWPCoreRuntimeSdk Condition=" '$(PkgMicrosoft_Net_UWPCoreRuntimeSdk)' == '' ">C:\Users\tubbeTEC\.nuget\packages\microsoft.net.uwpcoreruntimesdk\2.2.12</PkgMicrosoft_Net_UWPCoreRuntimeSdk>
    <PkgMicrosoft_Net_Native_Compiler Condition=" '$(PkgMicrosoft_Net_Native_Compiler)' == '' ">C:\Users\tubbeTEC\.nuget\packages\microsoft.net.native.compiler\2.2.10-rel-29722-00</PkgMicrosoft_Net_Native_Compiler>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <!--
      Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ directory.
      This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
      the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory.

      Unfortunately, there is already a file named "Microsoft.Common.props" in this directory,
      so we have to have a slightly different directory name to hold extensions.
  -->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Imports\Microsoft.Common.props\ImportBefore\Microsoft.NuGet.ImportBefore.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NuGet.ImportBefore.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
  <PropertyGroup>
    <NuGetProps Condition="'$(NuGetProps)'==''">$(MSBuildExtensionsPath)\Microsoft\NuGet\$(VisualStudioVersion)\Microsoft.NuGet.props</NuGetProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetProps)" Condition="Exists('$(NuGetProps)') and '$(SkipImportNuGetProps)' != 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\NuGet\17.0\Microsoft.NuGet.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NuGet.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.props" Condition="Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.props') AND '$(IncludeNuGetImports)' != 'false'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Imports\Microsoft.Common.props\ImportBefore\Microsoft.NuGet.ImportBefore.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Imports\Microsoft.Common.props\ImportBefore\Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportBefore.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportBefore.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
    This .props file conditionally includes a dedicated .props file with common item groups for UWP projects on .NET 9 and above,
    that should be imported before the .csproj file (such as globs for XAML items). These are in a separate file entirely so that
    the conditional import can bypass the "ignore conditions" feature of design-time builds in Visual Studio. Without that, those
    items would also be evaluated for legacy-style projects and non-UWP projects, which would cause issues and perf regressions.

    Note: because imports are evaluated in the same order they're found, we cannot actually check 'UseUwpTools' here, because that
    property is set either in the .csproj file, or in 'Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportBefore.targets'. Because of that,
    we can simply filter this on when the modern SDK-style format is used for .csproj files (which we check with 'UsingMicrosoftNETSdk').
    This lets us skip importing this file entirely on all legacy-style .csproj projects (such as legacy UWP), to avoid regressions.
    On SDK-style projects, it's fine if design-time builds evaluate the item groups anyway, because that matches what the .NET SDK is
    already doing anyway for all C# files, all .resx files, etc.

    To further reduce design-time evaluation performance regressions as much as possible, we also include conditions for all well-known
    .NET SDKs, which we know for sure will not apply to UWP scenarios. In all of those cases, we also skip importing the .props file.
    This ensures that for projects using any of those SDKs, there will be no design-time evaluation impact at all.
  -->
  <PropertyGroup>
    <UwpToolsMicrosoftWindowsUIXamlCSharpProps Condition="'$(UwpToolsMicrosoftWindowsUIXamlCSharpProps)' == ''">$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v$(VisualStudioVersion)\8.21\Microsoft.Windows.UI.Xaml.CSharp.ModernNET.props</UwpToolsMicrosoftWindowsUIXamlCSharpProps>
  </PropertyGroup>
  <!--<Import Project="$(UwpToolsMicrosoftWindowsUIXamlCSharpProps)" Condition="'$(UsingMicrosoftNETSdk)' == 'true' AND
                     '$(UsingMicrosoftNETSdkBlazorWebAssembly)' != 'true' AND
                     '$(UsingMicrosoftNETSdkPublish)' != 'true' AND
                     '$(UsingMicrosoftNETSdkRazor)' != 'true' AND
                     '$(UsingMicrosoftNETSdkStaticWebAssets)' != 'true' AND
                     '$(UsingMicrosoftNETSdkWeb)' != 'true' AND
                     '$(UsingMicrosoftNETSdkWebProjectSystem)' != 'true' AND
                     '$(UsingMicrosoftNETSdkWebAssembly)' != 'true' AND
                     '$(UsingMicrosoftNETSdkWorker)' != 'true' AND
                     Exists('$(UwpToolsMicrosoftWindowsUIXamlCSharpProps)') AND '$(SkipImportUwpToolsMicrosoftWindowsUIXamlCSharpProps)' != 'true'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
    <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)')" />-->
  <!-- This is used to determine whether Microsoft.Common.targets needs to import
      Microsoft.Common.props itself, or whether it has been imported previously,
      e.g. by the project itself. -->
  <PropertyGroup xmlns="">
    <MicrosoftCommonPropsHasBeenImported>true</MicrosoftCommonPropsHasBeenImported>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <Configuration Condition=" '$(Configuration)' == '' and '$(DefaultProjectConfiguration)' != '' ">$(DefaultProjectConfiguration)</Configuration>
    <Platform Condition=" '$(Platform)' == '' and '$(DefaultProjectPlatform)' != '' ">$(DefaultProjectPlatform)</Platform>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <WMSJSProject Condition="'$(WMSJSProject)' == ''">WJProject</WMSJSProject>
    <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--
      Import NuGet.props file.
  -->
  <PropertyGroup xmlns="">
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPropsFile)" Condition="Exists('$(NuGetPropsFile)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
      Import 'Directory.Packages.props' which will contain centralized packages for all the projects and solutions under
      the directory in which the file is present. This is similar to 'Directory.Build.props/targets' logic which is present
      in the common props/targets which serve a similar purpose.
  -->
  <PropertyGroup xmlns="">
    <ImportDirectoryPackagesProps Condition="'$(ImportDirectoryPackagesProps)' == ''">true</ImportDirectoryPackagesProps>
  </PropertyGroup>
  <!--
      Determine the path to the 'Directory.Packages.props' file, if the user did not disable $(ImportDirectoryPackagesProps) and
      they did not already specify an absolute path to use via $(DirectoryPackagesPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' == ''" xmlns="">
    <_DirectoryPackagesPropsFile Condition="'$(_DirectoryPackagesPropsFile)' == ''">Directory.Packages.props</_DirectoryPackagesPropsFile>
    <_DirectoryPackagesPropsBasePath Condition="'$(_DirectoryPackagesPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(MSBuildProjectDirectory)', '$(_DirectoryPackagesPropsFile)'))</_DirectoryPackagesPropsBasePath>
    <DirectoryPackagesPropsPath Condition="'$(_DirectoryPackagesPropsBasePath)' != '' and '$(_DirectoryPackagesPropsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryPackagesPropsBasePath)', '$(_DirectoryPackagesPropsFile)'))</DirectoryPackagesPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(DirectoryPackagesPropsPath)" Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')" />-->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')" xmlns="">
    <CentralPackageVersionsFileImported>true</CentralPackageVersionsFileImported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.props
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' " xmlns="">
    <DisableLogTaskParameter_ConvertToAbsolutePath_Path>true</DisableLogTaskParameter_ConvertToAbsolutePath_Path>
    <DisableLogTaskParameter_FindUnderPath_OutOfPath>true</DisableLogTaskParameter_FindUnderPath_OutOfPath>
    <DisableLogTaskParameter_RemoveDuplicates_Inputs>true</DisableLogTaskParameter_RemoveDuplicates_Inputs>
    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>true</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>
    <DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>true</DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>
    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>true</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>true</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_Files>true</DisableLogTaskParameterItemMetadata_FindUnderPath_Files>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>true</DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>
    <DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>true</DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>
    <DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>true</DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>
    <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
    <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Default.props
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(DisableInstalledVCTargetsUse)' == 'true'">
    <DisableInstalledVCTargetsDefaultsUse Condition="'$(DisableInstalledVCTargetsDefaultsUse)' == ''">true</DisableInstalledVCTargetsDefaultsUse>
    <VCTargetsPath17 Condition="'$(VCTargetsPath17)' != '' and !HasTrailingSlash('$(VCTargetsPath17)')">$(VCTargetsPath17)\</VCTargetsPath17>
    <VCTargetsPath16 Condition="'$(VCTargetsPath16)' != '' and !HasTrailingSlash('$(VCTargetsPath16)')">$(VCTargetsPath16)\</VCTargetsPath16>
    <VCTargetsPath15 Condition="'$(VCTargetsPath15)' != '' and !HasTrailingSlash('$(VCTargetsPath15)')">$(VCTargetsPath15)\</VCTargetsPath15>
    <VCTargetsPath14 Condition="'$(VCTargetsPath14)' != '' and !HasTrailingSlash('$(VCTargetsPath14)')">$(VCTargetsPath14)\</VCTargetsPath14>
    <VCTargetsPath12 Condition="'$(VCTargetsPath12)' != '' and !HasTrailingSlash('$(VCTargetsPath12)')">$(VCTargetsPath12)\</VCTargetsPath12>
    <VCTargetsPath11 Condition="'$(VCTargetsPath11)' != '' and !HasTrailingSlash('$(VCTargetsPath11)')">$(VCTargetsPath11)\</VCTargetsPath11>
    <VCTargetsPath10 Condition="'$(VCTargetsPath10)' != '' and !HasTrailingSlash('$(VCTargetsPath10)')">$(VCTargetsPath10)\</VCTargetsPath10>
  </PropertyGroup>
  <!--<Import Project="$(VCTargetsPath)\ImportBefore\Default\*.props" Condition="'$(DisableInstalledVCTargetsDefaultsUse)' != 'true' and Exists('$(VCTargetsPath)\ImportBefore\Default')" />-->
  <!--<Import Project="$(VCTargetsPath17)\ImportBefore\Default\*.props" Condition="'$(DisableInstalledVCTargetsUse)' == 'true' and '$(VCTargetsPath17)' != '' and Exists('$(VCTargetsPath17)\ImportBefore\Default')" />-->
  <PropertyGroup Condition="'$(DisableInstalledVCTargetsUse)' != 'true'">
    <VCTargetsPath10 Condition="'$(VCTargetsPath10)' == '' or ('$(VCTargetsPath10)' != '' and !exists('$(VCTargetsPath10)'))">$(MSBuildProgramFiles32)\MSBuild\Microsoft.Cpp\v4.0\</VCTargetsPath10>
    <VCTargetsPath11 Condition="'$(VCTargetsPath11)' == '' or ('$(VCTargetsPath11)' != '' and !exists('$(VCTargetsPath11)'))">$(MSBuildProgramFiles32)\MSBuild\Microsoft.Cpp\v4.0\V110\</VCTargetsPath11>
    <VCTargetsPath12 Condition="'$(VCTargetsPath12)' == '' or ('$(VCTargetsPath12)' != '' and !exists('$(VCTargetsPath12)'))">$(MSBuildProgramFiles32)\MSBuild\Microsoft.Cpp\v4.0\V120\</VCTargetsPath12>
    <VCTargetsPath14 Condition="'$(VCTargetsPath14)' == '' or ('$(VCTargetsPath14)' != '' and !exists('$(VCTargetsPath14)'))">$(MSBuildProgramFiles32)\MSBuild\Microsoft.Cpp\v4.0\V140\</VCTargetsPath14>
    <VCTargetsPath15 Condition="'$(VCTargetsPath15)' == '' or ('$(VCTargetsPath15)' != '' and !exists('$(VCTargetsPath15)'))">$(MSBuildExtensionsPath32)\Microsoft\VC\v150\</VCTargetsPath15>
    <VCTargetsPath16 Condition="'$(VCTargetsPath16)' == '' or ('$(VCTargetsPath16)' != '' and !exists('$(VCTargetsPath16)'))">$(MSBuildExtensionsPath32)\Microsoft\VC\v160\</VCTargetsPath16>
    <VCTargetsPath17 Condition="'$(VCTargetsPath17)' == '' or ('$(VCTargetsPath17)' != '' and !exists('$(VCTargetsPath17)'))">$(MSBuildExtensionsPath32)\Microsoft\VC\v170\</VCTargetsPath17>
  </PropertyGroup>
  <PropertyGroup>
    <MinSupportedVCTargetsVersion Condition="'$(MinimumVisualStudioVersion)' == '17.0'">v170</MinSupportedVCTargetsVersion>
    <MinSupportedVCTargetsVersion Condition="'$(MinimumVisualStudioVersion)' == '16.0'">v160</MinSupportedVCTargetsVersion>
    <MinSupportedVCTargetsVersion Condition="'$(MinimumVisualStudioVersion)' == '15.0'">v150</MinSupportedVCTargetsVersion>
    <MinSupportedVCTargetsVersion Condition="'$(MinimumVisualStudioVersion)' == '14.0'">v140</MinSupportedVCTargetsVersion>
    <MinSupportedVCTargetsVersion Condition="'$(MinimumVisualStudioVersion)' == '12.0'">v120</MinSupportedVCTargetsVersion>
    <MinSupportedVCTargetsVersion Condition="'$(MinimumVisualStudioVersion)' == '11.0'">v110</MinSupportedVCTargetsVersion>
  </PropertyGroup>
  <PropertyGroup>
    <Platform_Actual Condition="'$(Platform_Actual)' == ''">$(Platform)</Platform_Actual>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <Platform Condition="'$(Platform)' == 'x86' or '$(Platform)' == 'Any CPU' or '$(Platform)' == 'AnyCPU'">Win32</Platform>
    <_DefaultPlatform>win32</_DefaultPlatform>
    <!-- ApplicationTypeRevision was changed from 8.2 to 10.0 for Dev14 Store projects - So alias 8.2 to 10.0 for compatibility of older projects -->
    <ApplicationTypeRevision Condition="'$(ApplicationType)' == 'Windows Store' and '$(ApplicationTypeRevision)' == '8.2'">10.0</ApplicationTypeRevision>
    <!-- When the Framework Version is <= 3.5, set PlatformToolset to use the 9.0 toolset.
         When the Framework Version is >= 4.0, set PlatformToolset to use the 10.0 toolset.
         If Targetframeworkversion does not exist, then leave the default toolset -->
    <PlatformToolset Condition="'$(PlatformToolset)' == '' and&#xD;&#xA;                                 ('$(TargetFrameworkVersion)' == 'v3.5' or&#xD;&#xA;                                  '$(TargetFrameworkVersion)' == 'v3.0' or&#xD;&#xA;                                  '$(TargetFrameworkVersion)' == 'v2.0')">v90</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup>
    <_RelativeApplicationTypeFolder />
    <_RelativeApplicationTypeRevisionFolder />
    <_RelativeApplicationTypeFolder Condition="'$(ApplicationType)' != ''">Application Type\$(ApplicationType)\</_RelativeApplicationTypeFolder>
    <_RelativeApplicationTypeRevisionFolder Condition="'$(ApplicationType)' != '' and '$(ApplicationTypeRevision)' != ''">$(_RelativeApplicationTypeFolder)$(ApplicationTypeRevision)\</_RelativeApplicationTypeRevisionFolder>
    <_ApplicationTypeDefaultProps Condition="'$(_RelativeApplicationTypeFolder)' != ''">$(VCTargetsPath)\$(_RelativeApplicationTypeFolder)Default.props</_ApplicationTypeDefaultProps>
    <_ApplicationTypeDefaultPropsFound Condition="'$(_ApplicationTypeDefaultProps)' != '' and Exists('$(_ApplicationTypeDefaultProps)')">true</_ApplicationTypeDefaultPropsFound>
    <_ApplicationTypeRevisionDefaultProps Condition="'$(_RelativeApplicationTypeRevisionFolder)' != ''">$(VCTargetsPath)\$(_RelativeApplicationTypeRevisionFolder)Default.props</_ApplicationTypeRevisionDefaultProps>
    <_ApplicationTypeRevisionDefaultPropsFound Condition="'$(_ApplicationTypeRevisionDefaultProps)' != '' and Exists('$(_ApplicationTypeRevisionDefaultProps)')">true</_ApplicationTypeRevisionDefaultPropsFound>
  </PropertyGroup>
  <!-- import Application Type default props. Note that they can change Platform value -->
  <!--
============================================================================================================================================
  <Import Project="$(_ApplicationTypeDefaultProps)" Condition="'$(_ApplicationTypeDefaultPropsFound)' == 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\Default.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Default.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Before -->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportBefore\Default\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportBefore\Default')" />-->
  <PropertyGroup>
    <HostOsVersion Condition="'$(HostOsVersion)' == ''">$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentVersion)</HostOsVersion>
    <HostOsVersion Condition="'$(HostOsVersion)' == ''">6.4</HostOsVersion>
    <CurrentMajorVersionNumber>$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentMajorVersionNumber)</CurrentMajorVersionNumber>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Defaults for advanced deployment properties -->
    <RemoteDeploymentType Condition="'$(RemoteDeploymentType)' == ''">CopyToDevice</RemoteDeploymentType>
    <RemoveNonLayoutFiles Condition="'$(RemoveNonLayoutFiles)' == ''">No</RemoveNonLayoutFiles>
    <_ApplicationTypeShortName>UWP</_ApplicationTypeShortName>
  </PropertyGroup>
  <!-- Import After -->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportAfter\Default\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportAfter\Default')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Default.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(_ApplicationTypeRevisionDefaultProps)" Condition="'$(_ApplicationTypeRevisionDefaultPropsFound)' == 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Default.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Default.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Before -->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportBefore\Default\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportBefore\Default')" />-->
  <PropertyGroup>
    <RealOSVersion>6.4</RealOSVersion>
    <!-- First PlatformToolset of Window Store 10.0 -->
    <PlatformToolset Condition="'$(PlatformToolset)' == ''">v143</PlatformToolset>
  </PropertyGroup>
  <!-- Import After -->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportAfter\Default\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportAfter\Default')" />-->
  <PropertyGroup Condition="'$(ApplicationType)' == 'Windows Store' and '$(ApplicationTypeRevision)' == '10.0'">
    <!-- Clear the value of TargetPlatformVersion and set a default value for WindowsTargetPlatformVersion and Min version, if it is unset -->
    <TargetPlatformVersion />
    <TargetPlatformMinVersion />
    <WindowsTargetPlatformVersion Condition="'$(WindowsTargetPlatformVersion)' == ''">10.0.0.0</WindowsTargetPlatformVersion>
    <WindowsTargetPlatformMinVersion Condition="'$(WindowsTargetPlatformMinVersion)' == ''">10.0.0.0</WindowsTargetPlatformMinVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Default.props
============================================================================================================================================
-->
  <PropertyGroup>
    <_RelativePlatformFolder>$(_RelativeApplicationTypeRevisionFolder)Platforms\$(Platform)\</_RelativePlatformFolder>
    <_RelativePlatformDefaultProps>$(_RelativePlatformFolder)Platform.Default.props</_RelativePlatformDefaultProps>
    <_PlatformDefaultProps>$(VCTargetsPath)\$(_RelativePlatformDefaultProps)</_PlatformDefaultProps>
    <_PlatformDefaultPropsFound Condition="Exists('$(_PlatformDefaultProps)')">true</_PlatformDefaultPropsFound>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <ConfigurationType Condition="'$(ConfigurationType)' == ''">Application</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Short names for platform toolsets (added to project name in Solution Explorer) -->
    <_PlatformToolsetShortNameFor_v142 Condition="'$(_PlatformToolsetShortNameFor_v142)' == ''">Visual Studio 2019</_PlatformToolsetShortNameFor_v142>
    <_PlatformToolsetShortNameFor_v141 Condition="'$(_PlatformToolsetShortNameFor_v141)' == ''">Visual Studio 2017</_PlatformToolsetShortNameFor_v141>
    <_PlatformToolsetShortNameFor_v140 Condition="'$(_PlatformToolsetShortNameFor_v140)' == ''">Visual Studio 2015</_PlatformToolsetShortNameFor_v140>
    <_PlatformToolsetShortNameFor_v140_xp Condition="'$(_PlatformToolsetShortNameFor_v140_xp)' == ''">Visual Studio 2015 - Windows XP</_PlatformToolsetShortNameFor_v140_xp>
    <_PlatformToolsetShortNameFor_v120 Condition="'$(_PlatformToolsetShortNameFor_v120)' == ''">Visual Studio 2013</_PlatformToolsetShortNameFor_v120>
    <_PlatformToolsetShortNameFor_v120_xp Condition="'$(_PlatformToolsetShortNameFor_v120_xp)' == ''">Visual Studio 2013 - Windows XP</_PlatformToolsetShortNameFor_v120_xp>
    <_PlatformToolsetShortNameFor_v110 Condition="'$(_PlatformToolsetShortNameFor_v110)' == ''">Visual Studio 2012</_PlatformToolsetShortNameFor_v110>
    <_PlatformToolsetShortNameFor_v110_xp Condition="'$(_PlatformToolsetShortNameFor_v110_xp)' == ''">Visual Studio 2012 - Windows XP</_PlatformToolsetShortNameFor_v110_xp>
    <_PlatformToolsetShortNameFor_v100 Condition="'$(_PlatformToolsetShortNameFor_v100)' == ''">Visual Studio 2010</_PlatformToolsetShortNameFor_v100>
    <_PlatformToolsetShortNameFor_v90 Condition="'$(_PlatformToolsetShortNameFor_v90)' == ''">Visual Studio 2008</_PlatformToolsetShortNameFor_v90>
    <!-- Friendly names added to the PlatformToolset in the property pages. -->
    <_PlatformToolsetFriendlyNameFor_v143 Condition="'$(_PlatformToolsetFriendlyNameFor_v143)' == ''">Visual Studio 2022 (v143)</_PlatformToolsetFriendlyNameFor_v143>
    <_PlatformToolsetFriendlyNameFor_v142 Condition="'$(_PlatformToolsetFriendlyNameFor_v142)' == ''">Visual Studio 2019 (v142)</_PlatformToolsetFriendlyNameFor_v142>
    <_PlatformToolsetFriendlyNameFor_v141_xp Condition="'$(_PlatformToolsetFriendlyNameFor_v141_xp)' == ''">Visual Studio 2017 - Windows XP (v141_xp)</_PlatformToolsetFriendlyNameFor_v141_xp>
    <_PlatformToolsetFriendlyNameFor_v141 Condition="'$(_PlatformToolsetFriendlyNameFor_v141)' == ''">Visual Studio 2017 (v141)</_PlatformToolsetFriendlyNameFor_v141>
    <_PlatformToolsetFriendlyNameFor_v140_xp Condition="'$(_PlatformToolsetFriendlyNameFor_v140_xp)' == ''">Visual Studio 2015 - Windows XP (v140_xp)</_PlatformToolsetFriendlyNameFor_v140_xp>
    <_PlatformToolsetFriendlyNameFor_v140 Condition="'$(_PlatformToolsetFriendlyNameFor_v140)' == ''">Visual Studio 2015 (v140)</_PlatformToolsetFriendlyNameFor_v140>
    <_PlatformToolsetFriendlyNameFor_v140_clang_3_7 Condition="'$(_PlatformToolsetFriendlyNameFor_v140_clang_3_7)' == ''">Clang 3.7 with Microsoft CodeGen (v140_clang_3_7)</_PlatformToolsetFriendlyNameFor_v140_clang_3_7>
    <_PlatformToolsetFriendlyNameFor_v140_clang_c2 Condition="'$(_PlatformToolsetFriendlyNameFor_v140_clang_c2)' == ''">Visual Studio 2015 - Clang with Microsoft CodeGen (v140_clang_c2)</_PlatformToolsetFriendlyNameFor_v140_clang_c2>
    <_PlatformToolsetFriendlyNameFor_v120_xp Condition="'$(_PlatformToolsetFriendlyNameFor_v120_xp)' == ''">Visual Studio 2013 - Windows XP (v120_xp)</_PlatformToolsetFriendlyNameFor_v120_xp>
    <_PlatformToolsetFriendlyNameFor_v120 Condition="'$(_PlatformToolsetFriendlyNameFor_v120)' == ''">Visual Studio 2013 (v120)</_PlatformToolsetFriendlyNameFor_v120>
    <_PlatformToolsetFriendlyNameFor_v110_xp Condition="'$(_PlatformToolsetFriendlyNameFor_v110_xp)' == ''">Visual Studio 2012 - Windows XP (v110_xp)</_PlatformToolsetFriendlyNameFor_v110_xp>
    <_PlatformToolsetFriendlyNameFor_v110 Condition="'$(_PlatformToolsetFriendlyNameFor_v110)' == ''">Visual Studio 2012 (v110)</_PlatformToolsetFriendlyNameFor_v110>
    <_PlatformToolsetFriendlyNameFor_v100 Condition="'$(_PlatformToolsetFriendlyNameFor_v100)' == ''">Visual Studio 2010 (v100)</_PlatformToolsetFriendlyNameFor_v100>
    <_PlatformToolsetFriendlyNameFor_v90 Condition="'$(_PlatformToolsetFriendlyNameFor_v90)' == ''">Visual Studio 2008 (v90)</_PlatformToolsetFriendlyNameFor_v90>
    <v143_Installed Condition="Exists('$(VCTargetsPath)\Platforms\Win32\PlatformToolsets\v143\Toolset.props')">true</v143_Installed>
    <v141_xp_Installed Condition="Exists('$(VCTargetsPath15)\Platforms\Win32\PlatformToolsets\v141_xp\Toolset.props')">true</v141_xp_Installed>
    <!-- Define the upgrade toolsets for each old toolset -->
    <_UpgradePlatformToolsetFor_v143 Condition="'$(_UpgradePlatformToolsetFor_v143)' == ''">v143</_UpgradePlatformToolsetFor_v143>
    <_UpgradePlatformToolsetFor_v142 Condition="'$(_UpgradePlatformToolsetFor_v142)' == '' and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v142>
    <_UpgradePlatformToolsetFor_v141 Condition="'$(_UpgradePlatformToolsetFor_v141)' == '' and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v141>
    <_UpgradePlatformToolsetFor_v141_xp Condition="'$(_UpgradePlatformToolsetFor_v141_xp)' == ''">v141_xp</_UpgradePlatformToolsetFor_v141_xp>
    <_UpgradePlatformToolsetFor_v140 Condition="'$(_UpgradePlatformToolsetFor_v140)' == '' and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v140>
    <_UpgradePlatformToolsetFor_v140_xp Condition="'$(_UpgradePlatformToolsetFor_v140_xp)' == '' and '$(v141_xp_Installed)' == 'true'">v141_xp</_UpgradePlatformToolsetFor_v140_xp>
    <_UpgradePlatformToolsetFor_v120 Condition="'$(_UpgradePlatformToolsetFor_v120)' == '' and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v120>
    <_UpgradePlatformToolsetFor_v120_xp Condition="'$(_UpgradePlatformToolsetFor_v120_xp)' == '' and '$(v141_xp_Installed)' == 'true'">v141_xp</_UpgradePlatformToolsetFor_v120_xp>
    <_UpgradePlatformToolsetFor_v110 Condition="'$(_UpgradePlatformToolsetFor_v110)' == '' and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v110>
    <_UpgradePlatformToolsetFor_v110_xp Condition="'$(UpgradePlatformToolsetFor_v110_xp)' == '' and '$(v141_xp_Installed)' == 'true'">v141_xp</_UpgradePlatformToolsetFor_v110_xp>
    <_UpgradePlatformToolsetFor_v100 Condition="'$(_UpgradePlatformToolsetFor_v100)' == '' and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v100>
    <_UpgradePlatformToolsetFor_v90 Condition="'$(_UpgradePlatformToolsetFor_v90)' == ''  and '$(v143_Installed)' == 'true'">v143</_UpgradePlatformToolsetFor_v90>
    <!-- Short name for platform toolset (appended to project name in Solution Explorer) -->
    <_PlatformToolsetShortNameFor_v110_wp80>Windows Phone 8.0</_PlatformToolsetShortNameFor_v110_wp80>
    <_PlatformToolsetShortNameFor_v120_wp81>Windows Phone 8.1</_PlatformToolsetShortNameFor_v120_wp81>
    <!-- Friendly name for platform toolset (used in project property page) -->
    <_PlatformToolsetFriendlyNameFor_v110_wp80 Condition="'$(_PlatformToolsetFriendlyNameFor_v110_wp80)' == ''">Windows Phone 8.0 (v110_wp80)</_PlatformToolsetFriendlyNameFor_v110_wp80>
    <_PlatformToolsetFriendlyNameFor_v120_wp81 Condition="'$(_PlatformToolsetFriendlyNameFor_v120_wp81)' == ''">Windows Phone 8.1 (v120_wp81)</_PlatformToolsetFriendlyNameFor_v120_wp81>
    <!-- clangcl -->
    <!-- Short name for platform toolset (appended to project name in Solution Explorer) -->
    <_PlatformToolsetShortNameFor_ClangCl Condition="'$(_PlatformToolsetShortNameFor_ClangCl)' == ''">LLVM - clang-cl</_PlatformToolsetShortNameFor_ClangCl>
    <!-- Friendly name for platform toolset (used in project property page) -->
    <_PlatformToolsetFriendlyNameFor_ClangCl Condition="'$(_PlatformToolsetFriendlyNameFor_ClangCl)' == ''">LLVM (clang-cl)</_PlatformToolsetFriendlyNameFor_ClangCl>
    <!-- Llvm_ClangCl_1_0 only used in d16.1 preview 1 -->
    <_UpgradePlatformToolsetFor_Llvm_ClangCl_1_0 Condition="'$(_UpgradePlatformToolsetFor_Llvm_ClangCl_1_0)' == ''">ClangCl</_UpgradePlatformToolsetFor_Llvm_ClangCl_1_0>
    <!-- Define the TargetApplicationTypeAndVersion property if the project is an ApplicationType-project -->
    <TargetOSAndVersion Condition="'$(TargetOSAndVersion)' == '' and '$(ApplicationType)' != '' and  '$(ApplicationTypeRevision)' != ''">$(ApplicationType) $(ApplicationTypeRevision)</TargetOSAndVersion>
  </PropertyGroup>
  <!-- import platform defaults if it exists in the current version -->
  <!--
============================================================================================================================================
  <Import Project="$(_PlatformDefaultProps)" Condition="'$(_PlatformDefaultPropsFound)' == 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\Platform.Default.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Platform.default.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Before -->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportBefore\Default\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportBefore\Default')" />-->
  <PropertyGroup>
    <PlatformShortName>x64</PlatformShortName>
    <PlatformArchitecture>64</PlatformArchitecture>
    <PlatformTarget>x64</PlatformTarget>
    <DefaultPlatformToolset Condition="'$(DefaultPlatformToolset)' == ''">v143</DefaultPlatformToolset>
    <!-- Required for ASAN libraries -->
    <LlvmPlatformName>x86_64</LlvmPlatformName>
    <!-- Have to maintain compatibility with VS2010 projects, which might not have toolset defined in the project-->
    <PlatformToolset Condition="'$(PlatformToolset)' == '' and '$(DefaultX64PlatformToolset)' != ''">$(DefaultX64PlatformToolset)</PlatformToolset>
    <LegacyPlatformToolset>v100</LegacyPlatformToolset>
    <!-- Required for enabling Team Build for packaging Windows Store app projects -->
    <OutDirWasSpecified Condition=" '$(OutDir)'!='' AND '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
    <OutDirWasSpecified Condition=" '$(OutDir)'=='' AND '$(OutDirWasSpecified)'=='' ">false</OutDirWasSpecified>
  </PropertyGroup>
  <!-- Import After -->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportAfter\Default\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportAfter\Default')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Default.props
============================================================================================================================================
-->
  <PropertyGroup>
    <LangID Condition="'$(LangID)' == ''">1033</LangID>
    <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
    <TargetName Condition=" '$(TargetName)' == '' and '$(AssemblyName)' != ''">$(AssemblyName)</TargetName>
    <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>
    <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>
    <ProjectDir Condition=" '$(ProjectDir)' == '' ">$(MSBuildProjectDirectory)\</ProjectDir>
    <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>
    <PlatformName Condition=" '$(PlatformName)' == '' ">$(Platform)</PlatformName>
    <SolutionDir Condition="'$(SolutionDir)'==''">$(ProjectDir)</SolutionDir>
    <UserRootDir Condition="'$(UserRootDir)' == '' ">$(LocalAppData)\Microsoft\MSBuild\v4.0</UserRootDir>
    <MultiToolTask Condition="'$(MultiToolTask)' == ''">false</MultiToolTask>
    <WholeProgramOptimizationDelayImport Condition="'$(WholeProgramOptimization)' != ''">true</WholeProgramOptimizationDelayImport>
    <WholeProgramOptimization Condition="'$(WholeProgramOptimization)' == ''">false</WholeProgramOptimization>
    <AppContainerApplication Condition="'$(AppContainerApplication)' == '' and '$(WindowsPackageType)'=='MSIX'">true</AppContainerApplication>
    <WindowsAppContainer Condition="'$(WindowsAppContainer)' == '' and '$(AppContainerApplication)' == 'true'">true</WindowsAppContainer>
    <WindowsAppContainer Condition="'$(WindowsAppContainer)' == ''">false</WindowsAppContainer>
    <WindowsStoreApp Condition="'$(WindowsStoreApp)' == '' and '$(ApplicationType)' == 'Windows Store'">true</WindowsStoreApp>
    <WindowsStoreApp Condition="'$(WindowsAppContainer)' == 'true'">true</WindowsStoreApp>
    <WindowsStoreApp Condition="'$(WindowsStoreApp)' == ''">false</WindowsStoreApp>
    <!-- Default Project Reunion projects (which have WindowsPackageType set) to DesktopCompatible -->
    <DesktopCompatible Condition="'$(DesktopCompatible)' == '' and '$(WindowsPackageType)' == '' and '$(WindowsStoreApp)' == 'true'">false</DesktopCompatible>
    <DesktopCompatible Condition="'$(DesktopCompatible)' == '' and '$(WindowsPackageType)' != ''">true</DesktopCompatible>
    <CLRSupport Condition="'$(CLRSupport)' == ''">false</CLRSupport>
    <!-- Set the default value for supporting PackageReference's -->
    <EnableManagedPackageReferenceSupport Condition="'$(EnableManagedPackageReferenceSupport)' == ''">false</EnableManagedPackageReferenceSupport>
    <UseOfATL Condition="'$(UseOfATL)' == ''">false</UseOfATL>
    <UseOfMFC Condition="'$(UseOfMFC)' == ''">false</UseOfMFC>
    <SpectreMitigation Condition="'$(SpectreMitigation)' == ''">false</SpectreMitigation>
    <SQLDebugging Condition="'$(SQLDebugging)' == ''">false</SQLDebugging>
    <Attach Condition="'$(Attach)' == ''">false</Attach>
    <EnableUnitySupport Condition="'$(EnableUnitySupport)' == ''">false</EnableUnitySupport>
    <UseDebugLibraries Condition="'$(UseDebugLibraries)' == ''">false</UseDebugLibraries>
    <CharacterSet Condition="'$(CharacterSet)' == ''">NotSet</CharacterSet>
    <EnableASAN Condition="'$(EnableASAN)' == ''">false</EnableASAN>
    <EnableFuzzer Condition="'$(EnableFuzzer)' == ''">false</EnableFuzzer>
    <UseDynamicDebugging Condition="'$(UseDynamicDebugging)' == ''">false</UseDynamicDebugging>
  </PropertyGroup>
  <PropertyGroup>
    <LLVMToolsVersion Condition="'$(LLVMToolsVersion)' == ''">19.1.5</LLVMToolsVersion>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <BuildLog>
      <Path>$(IntDir)$(MSBuildProjectName).log</Path>
    </BuildLog>
  </ItemDefinitionGroup>
  <!--<Import Project="$(VCTargetsPath)\ImportAfter\Default\*.props" Condition="'$(DisableInstalledVCTargetsDefaultsUse)' != 'true' and Exists('$(VCTargetsPath)\ImportAfter\Default')" />-->
  <!--<Import Project="$(VCTargetsPath17)\ImportAfter\Default\*.props" Condition="'$(DisableInstalledVCTargetsUse)' == 'true' and '$(VCTargetsPath17)' != '' and Exists('$(VCTargetsPath17)\ImportAfter\Default')" />-->
  <!--<Import Project="$(ForceImportAfterCppDefaultProps)" Condition="Exists('$(ForceImportAfterCppDefaultProps)')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
    <UseDebugLibraries>true</UseDebugLibraries>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(ForceImportBeforeCppProps)" Condition="Exists('$(ForceImportBeforeCppProps)')" />-->
  <!-- prevent unnesessary redirection to older toolsets for makefile projects -->
  <PropertyGroup Condition="'$(PlatformToolset)' == '' and '$(ConfigurationType)' == 'Makefile'">
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(PlatformToolset)' == '' and '$(ConfigurationType)' != 'Makefile'">
    <PlatformToolset Condition="'$(LegacyPlatformToolset)' == ''">$(DefaultPlatformToolset)</PlatformToolset>
    <PlatformToolset Condition="'$(LegacyPlatformToolset)' != ''">$(LegacyPlatformToolset)</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(EnableVcpkgArtifactsIntegration)' == 'true'">
    <!-- Find the directory of vcpkg-configuration.json. If vcpkg.json exists, only vcpkg-configuration.json in the same directory will be used -->
    <VcpkgManifestDirectory>$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), vcpkg.json))</VcpkgManifestDirectory>
    <VcpkgManifestDirectory Condition="'$(VcpkgManifestDirectory)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), vcpkg-configuration.json))</VcpkgManifestDirectory>
  </PropertyGroup>
  <PropertyGroup>
    <!-- check if vcpkg-configuration.json exists and allowed to be used -->
    <VcpkgManifestDirectory Condition="'$(EnableVcpkgArtifactsIntegration)' != 'true' or !Exists('$(VcpkgManifestDirectory)\vcpkg-configuration.json')" />
    <UsingVcpkgArtifacts Condition="'$(VcpkgManifestDirectory)' != ''">true</UsingVcpkgArtifacts>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VcpkgManifestDirectory)' != ''">
    <VcpkgMsbuildOnlyActivationOptions>$(VcpkgMsbuildOnlyActivationOptions);tag=msbuild-only;Configuration=$(Configuration);Platform=$(Platform)</VcpkgMsbuildOnlyActivationOptions>
    <VcpkgMsbuildOnlyActivationOptions Condition="'$(PlatformToolset)' != ''">$(VcpkgMsbuildOnlyActivationOptions);PlatformToolset=$(PlatformToolset)</VcpkgMsbuildOnlyActivationOptions>
    <VcpkgMsbuildOnlyActivationOptions Condition="'$(ApplicationType)' != ''">$(VcpkgMsbuildOnlyActivationOptions);ApplicationType=$(ApplicationType)</VcpkgMsbuildOnlyActivationOptions>
    <VcpkgMsbuildOnlyActivationOptions Condition="'$(ApplicationTypeRevision)' != ''">$(VcpkgMsbuildOnlyActivationOptions);ApplicationTypeRevision=$(ApplicationTypeRevision)</VcpkgMsbuildOnlyActivationOptions>
  </PropertyGroup>
  <!-- If vcpkg-configuiration.json has a dependency on msbuild packages this will download them for the current project configuration/platform -->
  <!--<Import Project="vcpkg-artifacts.props" Sdk="vcpkg:ManifestDirectory=$(VcpkgManifestDirectory);VcpkgRoot=$(VcpkgRoot);$(VcpkgMsbuildOnlyActivationOptions)" Condition="'$(VcpkgManifestDirectory)' != ''" />-->
  <!-- workaround for improper vcpkg SDK.props generation -->
  <PropertyGroup>
    <VCTargetsPath17 Condition="'$(VCTargetsPath17)' != '' and !HasTrailingSlash('$(VCTargetsPath17)')">$(VCTargetsPath17)\</VCTargetsPath17>
  </PropertyGroup>
  <PropertyGroup>
    <_RelativeToolsetFolder>$(_RelativePlatformFolder)PlatformToolsets\$(PlatformToolset)\</_RelativeToolsetFolder>
    <_RelativePlatformProps>$(_RelativePlatformFolder)Platform.props</_RelativePlatformProps>
    <_RelativePlatformTargets>$(_RelativePlatformFolder)Platform.targets</_RelativePlatformTargets>
    <_RelativeToolsetProps>$(_RelativeToolsetFolder)Toolset.props</_RelativeToolsetProps>
    <_RelativeToolsetTargets>$(_RelativeToolsetFolder)Toolset.targets</_RelativeToolsetTargets>
    <_RelativeToolsetFiles>$(_RelativeToolsetProps);$(_RelativeToolsetTargets);$(_RelativePlatformProps);$(_RelativePlatformTargets)</_RelativeToolsetFiles>
  </PropertyGroup>
  <!-- check if the toolset exists in the current install -->
  <PropertyGroup Condition="'$(DisableInstalledVCTargetsUse)' != 'true'">
    <_VCTargetsPathFolders>$(CurrentVCTargetsPath);$(AdditionalVCTargetsPath)</_VCTargetsPathFolders>
    <_VCTargetsPathForToolset>$([MSBuild]::Unescape($([Microsoft.Build.Utilities.ToolLocationHelper]::FindRootFolderWhereAllFilesExist($(_VCTargetsPathFolders), $(_RelativeToolsetFiles)))))</_VCTargetsPathForToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_VCTargetsPathForToolset)' != ''">
    <_ToolsetFound>true</_ToolsetFound>
    <_ToolsetVCTargetsVersion>v170</_ToolsetVCTargetsVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.ToolsetLocation.props" Condition="'$(_ToolsetFound)' == 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.ToolsetLocation.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.ToolsetLocation.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- set VCTargetsPath and VsInstallRoot to where the toolset is found -->
  <PropertyGroup>
    <VCTargetsPath>$(_VCTargetsPathForToolset)</VCTargetsPath>
    <VsInstallRoot Condition="'$(_VsInstallRootForToolset)' != ''">$(_VsInstallRootForToolset)</VsInstallRoot>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VcpkgInstalledVCTargets)' != 'true' and '$(_ToolsetVCTargetsVersion)'!= '$(CurrentVCTargetsVersion)'">
    <_OldApplicationTypeDefaultProps Condition="'$(_RelativeApplicationTypeFolder)' != '' and '$(_ApplicationTypeDefaultPropsFound)' != 'true'">$(_VCTargetsPathForToolset)\$(_RelativeApplicationTypeFolder)Default.props</_OldApplicationTypeDefaultProps>
    <_OldApplicationTypeRevisionDefaultProps Condition="'$(_RelativeApplicationTypeRevisionFolder)' != ''  and '$(_ApplicationTypeRevisionDefaultPropsFound)' != 'true'">$(_VCTargetsPathForToolset)\$(_RelativeApplicationTypeRevisionFolder)Default.props</_OldApplicationTypeRevisionDefaultProps>
    <_OldPlatformDefaultProps Condition="'$(_PlatformDefaultPropsFound)' != 'true'">$(_VCTargetsPathForToolset)\$(_RelativePlatformDefaultProps)</_OldPlatformDefaultProps>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VcpkgInstalledVCTargets)' == 'true' and '$(ApplicationType)' != ''">
    <_OldApplicationTypeDefaultProps Condition="'$(ApplicationTypeDirectory)' != ''">$([MSBuild]::NormalizePath('$(ApplicationTypeDirectory)', "Default.props))</_OldApplicationTypeDefaultProps>
    <_OldApplicationTypeRevisionDefaultProps Condition="'$(ApplicationTypeRevisionDirectory)' != ''">$([MSBuild]::NormalizePath('$(ApplicationTypeRevisionDirectory)', "Default.props))</_OldApplicationTypeRevisionDefaultProps>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VcpkgInstalledVCTargets)' == 'true'">
    <_PlatformFolder>$([MSBuild]::NormalizePath('$(PlatformDirectory)'))</_PlatformFolder>
    <_ToolsetFolder>$([MSBuild]::NormalizePath('$(ToolsetDirectory)'))</_ToolsetFolder>
    <_OldPlatformDefaultProps>$(_PlatformFolder)\Platform.default.props</_OldPlatformDefaultProps>
    <_PlatformProps>$(_PlatformFolder)\Platform.props</_PlatformProps>
    <_PlatformTargets>$(_PlatformFolder)\Platform.targets</_PlatformTargets>
    <_ToolsetPropsPath>$(_ToolsetFolder)\Toolset.props</_ToolsetPropsPath>
    <_ToolsetTargetsPath>$(_ToolsetFolder)\Toolset.targets</_ToolsetTargetsPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VcpkgInstalledVCTargets)' != 'true'">
    <_PlatformFolder>$(_VCTargetsPathForToolset)$(_RelativePlatformFolder)</_PlatformFolder>
    <_ToolsetFolder>$(_VCTargetsPathForToolset)$(_RelativeToolsetFolder)</_ToolsetFolder>
    <_PlatformProps>$(_VCTargetsPathForToolset)$(_RelativePlatformProps)</_PlatformProps>
    <_PlatformTargets>$(_VCTargetsPathForToolset)$(_RelativePlatformTargets)</_PlatformTargets>
    <_ToolsetPropsPath>$(_VCTargetsPathForToolset)$(_RelativeToolsetProps)</_ToolsetPropsPath>
    <_ToolsetTargetsPath>$(_VCTargetsPathForToolset)$(_RelativeToolsetTargets)</_ToolsetTargetsPath>
  </PropertyGroup>
  <PropertyGroup>
    <VCTargetsPathEffective>$(_VCTargetsPathForToolset)</VCTargetsPathEffective>
    <!-- The following properties are not directly used now, but we'll define them for compatibility with older versions-->
    <ToolsetPropsFound>true</ToolsetPropsFound>
    <ToolsetTargetsFound>true</ToolsetTargetsFound>
    <PlatformPropsFound>true</PlatformPropsFound>
    <PlatformTargetsFound>true</PlatformTargetsFound>
  </PropertyGroup>
  <!-- import defaults from old versions if they were not found in the current one -->
  <!--<Import Project="$(_OldApplicationTypeDefaultProps)" Condition="'$(_OldApplicationTypeDefaultProps)' != '' and Exists('$(_OldApplicationTypeDefaultProps)')" />-->
  <!--<Import Project="$(_OldApplicationTypeRevisionDefaultProps)" Condition="'$(_OldApplicationTypeRevisionDefaultProps)' != '' and Exists('$(_OldApplicationTypeRevisionDefaultProps)')" />-->
  <!--<Import Project="$(_OldPlatformDefaultProps)" Condition="'$(_OldPlatformDefaultProps)' != '' and Exists('$(_OldPlatformDefaultProps)')" />-->
  <PropertyGroup>
    <!-- UseNativeEnvironment and _IsNativeEnvironment was used in prev versions to define if we want to use 64-bit tools when building for x64 platform. -->
    <PreferredToolArchitecture Condition="'$(PreferredToolArchitecture)' == '' and ('$(UseNativeEnvironment)' == 'true' or '$(_IsNativeEnvironment)' == 'true')">x64</PreferredToolArchitecture>
    <!-- By default we use the same bitness as the hosting platform -->
    <PreferredToolArchitecture Condition="'$(PreferredToolArchitecture)' == '' and ('$(PROCESSOR_ARCHITECTURE)' == 'AMD64' and '$(Platform)' == 'x64')">x64</PreferredToolArchitecture>
    <!-- prefer arm64 tools when on arm64 -->
    <PreferredToolArchitecture Condition="'$(PreferredToolArchitecture)' == '' and '$(PROCESSOR_ARCHITECTURE)' == 'ARM64' and '$(HostARM64Suported)' != 'false'">arm64</PreferredToolArchitecture>
    <PreferredToolArchitecture Condition="'$(PreferredToolArchitecture)' == ''">x86</PreferredToolArchitecture>
    <!-- If OS is not x64, we cannot use x64 tools even if preferred -->
    <PreferredToolArchitecture Condition="'$(PreferredToolArchitecture)' == 'x64' and ('$(PROCESSOR_ARCHITECTURE)' != 'AMD64' and '$(PROCESSOR_ARCHITEW6432)' != 'AMD64' and '$(PROCESSOR_ARCHITECTURE)' != 'ARM64')">x86</PreferredToolArchitecture>
    <!-- If OS is not arm64, we cannot use arm64 tools even if preferred -->
    <PreferredToolArchitecture Condition="'$(PreferredToolArchitecture)' == 'arm64' and '$(PROCESSOR_ARCHITECTURE)' != 'ARM64'">x86</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VcpkgManifestDirectory)' != ''">
    <VcpkgTargetOS Condition="'$(VcpkgTargetOS)' == ''">windows</VcpkgTargetOS>
    <VcpkgActivationOptions Condition="'$(UseDefaultVcpkgActivationOptions)' != 'false'">$(VcpkgTargetOS)=;$(PreferredToolArchitecture)=;target=$(PlatformTarget);$(VcpkgActivationOptions)</VcpkgActivationOptions>
  </PropertyGroup>
  <!--<Import Project="vcpkg-artifacts.props" Sdk="vcpkg:ManifestDirectory=$(VcpkgManifestDirectory);VcpkgRoot=$(VcpkgRoot);$(VcpkgActivationOptions)" Condition="'$(VcpkgManifestDirectory)' != '' and '$(VcpkgActivationOptions)' != ''" />-->
  <!-- Generate props/targets if any of the msbuild packages downloaded by vcpkg specified that it has custom props/targets to import -->
  <!--<Import Project="Imports.props" Sdk="vcpkg:ManifestDirectory=$(VcpkgManifestDirectory);ImportFiles=$(ImportBeforeCppProps)" Condition="'$(VcpkgManifestDirectory)' != '' and '$(ImportBeforeCppProps)' != ''" />-->
  <!-- import platform.props which will import the toolset props -->
  <!--
============================================================================================================================================
  <Import Project="$(_PlatformProps)" Condition="'$(_VCTargetsPathForToolset)' != '$(VCTargetsPath10)'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\Platform.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Platform.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_PlatformFolder>$(MSBuildThisFileDirectory)</_PlatformFolder>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Platform.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Platform.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Platform.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Before -->
  <!--<Import Project="$(_PlatformFolder)ImportBefore\*.props" Condition="Exists('$(_PlatformFolder)ImportBefore')" />-->
  <!-- Import Toolset specific properties -->
  <!--
============================================================================================================================================
  <Import Project="$(_ToolsetPropsPath)">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\PlatformToolsets\v143\Toolset.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Toolset.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportBefore\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportBefore')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.MSVC.Toolset.x64.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.MSVC.Toolset.x64.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Toolset.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.MSVC.Toolset.Common.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.MSVC.Toolset.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.MSVC.Toolset.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Required for enabling Team Build for packaging Windows Store app projects -->
    <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
    <OutDirWasSpecified Condition=" '$(OutDir)'=='' and '$(OutDirWasSpecified)'=='' ">false</OutDirWasSpecified>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IntDir)' == '' and '$(IntermediateOutputPath)' != ''">
    <IntDir>$(IntermediateOutputPath)</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ShortProjectName)' == '' and '$(ProjectName)' != '' and '$(ProjectGuid)' != ''">
    <ShortProjectName>$(ProjectName)</ShortProjectName>
    <ShortProjectName Condition="'$(ProjectName.Length)' &gt; '16'">$(ProjectName.Substring(0,8)).$(ProjectGuid.Substring(1,8))</ShortProjectName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IntDir)' == '' and '$(ShortProjectName)' != '' and ('$(SolutionDir)' == '$(MSBuildProjectDirectory)\' OR '$(SolutionDir)' == '')">
    <IntDir Condition="'$(Platform)' == 'Win32'">$(ShortProjectName)\$(Configuration)\</IntDir>
    <IntDir Condition="'$(Platform)' != 'Win32'">$(ShortProjectName)\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IntDir)'==''">
    <IntDir Condition="'$(Platform)' == 'Win32'">$(Configuration)\</IntDir>
    <IntDir Condition="'$(Platform)' != 'Win32'">$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OutDir)'==''">
    <OutDir Condition="'$(Platform)' == 'Win32'">$(SolutionDir)$(Configuration)\</OutDir>
    <OutDir Condition="'$(Platform)' != 'Win32'">$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.WindowsSDK.props" Condition="Exists('$(VCTargetsPath)\Microsoft.Cpp.WindowsSDK.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.WindowsSDK.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.WindowsSDK.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Get the windows 10 and 8.1 SDK root folder from registry -->
  <PropertyGroup Condition="'$(DisableRegistryUse)' != 'true'">
    <WindowsSdkDir_10 Condition="'$(WindowsSdkDir_10)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v10.0@InstallationFolder)</WindowsSdkDir_10>
    <WindowsSdkDir_10 Condition="'$(WindowsSdkDir_10)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v10.0@InstallationFolder)</WindowsSdkDir_10>
    <!-- Set the WindowsSdkDir to windows 10 path -->
    <WindowsSdkDir Condition="'$(UseEnv)' != 'true'">$(WindowsSdkDir_10)</WindowsSdkDir>
    <UniversalCRTSdkDir_10 Condition="'$(UniversalCRTSdkDir_10)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows Kits\Installed Roots@KitsRoot10)</UniversalCRTSdkDir_10>
    <UniversalCRTSdkDir_10 Condition="'$(UniversalCRTSdkDir_10)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots@KitsRoot10)</UniversalCRTSdkDir_10>
    <WindowsSdkDir_81 Condition="'$(WindowsSdkDir_81)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1@InstallationFolder)</WindowsSdkDir_81>
    <WindowsSdkDir_81 Condition="'$(WindowsSdkDir_81)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v8.1@InstallationFolder)</WindowsSdkDir_81>
    <WindowsSdkDir_81A Condition="'$(WindowsSdkDir_81A)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1A@InstallationFolder)</WindowsSdkDir_81A>
    <WindowsSdkDir_81A Condition="'$(WindowsSdkDir_81A)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v8.1A@InstallationFolder)</WindowsSdkDir_81A>
    <FrameworkDir_110 Condition="'$(FrameworkDir_110)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework@InstallRoot)</FrameworkDir_110>
    <FrameworkDir_110 Condition="'$(FrameworkDir_110)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\.NETFramework@InstallRoot)</FrameworkDir_110>
    <NETFXSDK_UseAnyInstalledVersion Condition="'$(NETFXSDK_Version)' == ''">true</NETFXSDK_UseAnyInstalledVersion>
    <NETFXSDK_Version Condition="'$(NETFXSDK_Version)' == ''">4.8.1</NETFXSDK_Version>
  </PropertyGroup>
  <!-- NETFX SDK locations -->
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.8.1' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1@InstallationFolder)</NETFXSDKDir>
    <NETFXSDK_Version Condition="('$(NETFXKitsDir)' == '' or '$(NETFXSDKDir)' == '') and '$(NETFXSDK_UseAnyInstalledVersion)' == 'true'">4.8</NETFXSDK_Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.8' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.8@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.8@InstallationFolder)</NETFXSDKDir>
    <NETFXSDK_Version Condition="('$(NETFXKitsDir)' == '' or '$(NETFXSDKDir)' == '') and '$(NETFXSDK_UseAnyInstalledVersion)' == 'true'">4.7.3</NETFXSDK_Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.7.3' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.3@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.3@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.3@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.3@InstallationFolder)</NETFXSDKDir>
    <NETFXSDK_Version Condition="('$(NETFXKitsDir)' == '' or '$(NETFXSDKDir)' == '') and '$(NETFXSDK_UseAnyInstalledVersion)' == 'true'">4.7.2</NETFXSDK_Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.7.2' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2@InstallationFolder)</NETFXSDKDir>
    <NETFXSDK_Version Condition="('$(NETFXKitsDir)' == '' or '$(NETFXSDKDir)' == '') and '$(NETFXSDK_UseAnyInstalledVersion)' == 'true'">4.7.1</NETFXSDK_Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.7.1' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1@InstallationFolder)</NETFXSDKDir>
    <NETFXSDK_Version Condition="('$(NETFXKitsDir)' == '' or '$(NETFXSDKDir)' == '') and '$(NETFXSDK_UseAnyInstalledVersion)' == 'true'">4.6.2</NETFXSDK_Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.6.2' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.6.2@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.6.2@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.6.2@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.6.2@InstallationFolder)</NETFXSDKDir>
    <NETFXSDK_Version Condition="('$(NETFXKitsDir)' == '' or '$(NETFXSDKDir)' == '') and '$(NETFXSDK_UseAnyInstalledVersion)' == 'true'">4.6.1</NETFXSDK_Version>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NETFXSDK_Version)' == '4.6.1' and '$(DisableRegistryUse)' != 'true'">
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.6.1@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.6.1@KitsInstallationFolder)</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.6.1@InstallationFolder)</NETFXSDKDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.6.1@InstallationFolder)</NETFXSDKDir>
  </PropertyGroup>
  <!-- Get the location of Windows SDK 7.1 if xp toolsets ask for it -->
  <PropertyGroup Condition="'$(DisableRegistryUse)' != 'true' and '$(DefineWindowsSDK_71A)' == 'true'">
    <WindowsSdkDir_71A Condition="'$(WindowsSdkDir_71A)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v7.1A@InstallationFolder)</WindowsSdkDir_71A>
    <WindowsSdkDir_71A Condition="'$(WindowsSdkDir_71A)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v7.1A@InstallationFolder)</WindowsSdkDir_71A>
    <FrameworkSdkDir_71A Condition="'$(FrameworkSdkDir_71A)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v7.1A@InstallationFolder)</FrameworkSdkDir_71A>
    <FrameworkSdkDir_71A Condition="'$(FrameworkSdkDir_71A)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\Windows\v7.1A@InstallationFolder)</FrameworkSdkDir_71A>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsSdkDir_10)' != ''">
    <SDKIdentifier Condition="'$(SDKIdentifier)' == ''">Windows</SDKIdentifier>
    <SDKVersion Condition="'$(SDKVersion)' == ''">10.0</SDKVersion>
    <SDKDisplayName Condition="'$(SDKDisplayName)' == ''">Windows 10</SDKDisplayName>
    <_LatestWindowsTargetPlatformVersion>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion($(SDKIdentifier), $(SDKVersion)))</_LatestWindowsTargetPlatformVersion>
    <WindowsTargetPlatformVersion Condition="'$(WindowsTargetPlatformVersion)' == '' and '$(_LatestWindowsTargetPlatformVersion)' != ''">10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <!-- Windows 10 SDK is not installed and WindowsTargetPlatformVersion is not defined in the project. Fallback to 8.1 if it is installed -->
  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)' == ''">
    <WindowsTargetPlatformVersion Condition="'$(WindowsSdkDir_81)' != ''">8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <PropertyGroup>
    <!-- WindowsSDKVersion is stamped in the project file - It translates to "TargetPlatformVersion" msbuild common targets are using -->
    <TargetPlatformVersion Condition="'$(WindowsTargetPlatformVersion)' == '10.0'">$(_LatestWindowsTargetPlatformVersion)</TargetPlatformVersion>
    <TargetPlatformVersion Condition="'$(WindowsTargetPlatformVersion)' != '10.0'">$(WindowsTargetPlatformVersion)</TargetPlatformVersion>
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)' == ''">$(WindowsTargetPlatformMinVersion)</TargetPlatformMinVersion>
    <RetargetAlwaysSupported Condition="'$(_ToolsetFound)' == 'true' and '$(SharedAssetsProject)' != 'true' and '$(RetargetAlwaysSupported)' == ''">true</RetargetAlwaysSupported>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsPackageType)'==''">
    <TargetOsAndVersion Condition="'$(WindowsAppContainer)' == 'true'">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(SDKIdentifier), $(SDKVersion)))</TargetOsAndVersion>
    <TargetOsAndVersion Condition="'$(WindowsAppContainer)' == 'false' and '$(WindowsStoreApp)' == 'true'">Desktop</TargetOsAndVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsPackageType)'!=''">
    <TargetOsAndVersion>Desktop</TargetOsAndVersion>
    <AppxPackage Condition="'$(AppxPackage)'=='' and '$(WindowsPackageType)'!='None'">true</AppxPackage>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DisableRegistryUse)' == 'true'">
    <UniversalCRTSdkDir_10 Condition="'$(UniversalCRTSdkDir_10)' == ''">UniversalCRTSdkDir_10_is_not_defined</UniversalCRTSdkDir_10>
    <WindowsSdkDir_10 Condition="'$(WindowsSdkDir_10)' == ''">WindowsSdkDir_10_is_not_defined</WindowsSdkDir_10>
    <WindowsSdkDir_81 Condition="'$(WindowsSdkDir_81)' == ''">WindowsSdkDir_81_is_not_defined</WindowsSdkDir_81>
    <FrameworkDir_110 Condition="'$(FrameworkDir_110)' == ''">FrameworkDir_110_is_not_defined</FrameworkDir_110>
    <WindowsSdkDir_71A Condition="'$(WindowsSdkDir_71A)' == ''">WindowsSdkDir_71A_is_not_defined</WindowsSdkDir_71A>
    <FrameworkSdkDir_71A Condition="'$(FrameworkSdkDir_71A)' == ''">FrameworkSdkDir_71A_is_not_defined</FrameworkSdkDir_71A>
    <NETFXKitsDir Condition="'$(NETFXKitsDir)' == ''">NETFXKitsDir_is not_defined</NETFXKitsDir>
    <NETFXSDKDir Condition="'$(NETFXSDKDir)' == ''">NETFXSDKDir_is not_defined</NETFXSDKDir>
    <_CheckDev11ToolsInstalled>false</_CheckDev11ToolsInstalled>
  </PropertyGroup>
  <PropertyGroup>
    <UniversalCRTSdkDir>$(UniversalCRTSdkDir_10)</UniversalCRTSdkDir>
    <!-- Fall back to 8.1 if windows 10 SDK is not found or WindowsTargetPlatformVersion is set to "8.1" or is not set at all -->
    <WindowsSdkDir Condition="'$(TargetPlatformVersion)' == '8.1'">$(WindowsSdkDir_81)</WindowsSdkDir>
    <WindowsSDKDir Condition="'$(DefineWindowsSDK_71A)' == 'true'">$(WindowsSdkDir_71A)</WindowsSDKDir>
    <Windows81SdkInstalled Condition="'$(WindowsSdkDir_81)' != ''">true</Windows81SdkInstalled>
    <FrameworkDir Condition="'$(UseEnv)' != 'true'">$(FrameworkDir_110)</FrameworkDir>
    <FrameworkSdkDir Condition="'$(UseEnv)' != 'true'">$(WindowsSdkDir)</FrameworkSdkDir>
    <FrameworkVersion Condition="'$(UseEnv)' != 'true'">v4.7.2</FrameworkVersion>
    <!-- 10.0.10240.0 is the hardcoded checked-in version of uCRT that we use in case we target 8.1 SDK -->
    <TargetUniversalCRTVersion Condition="'$(TargetUniversalCRTVersion)' == ''  and ('$(TargetPlatformVersion)' == '8.1' or '$(DefineWindowsSDK_71A)' == 'true')">10.0.10240.0</TargetUniversalCRTVersion>
    <UniversalCRT_PropsPath Condition="'$(UniversalCRT_PropsPath)' == ''">$(UniversalCRTSdkDir)\DesignTime\CommonConfiguration\Neutral\ucrt.props</UniversalCRT_PropsPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.1'">
    <SDKDisplayName>Windows</SDKDisplayName>
  </PropertyGroup>
  <!-- Windows 10 SDK's UAP.props uses DotNetSdkRoot to add NETFX SDK libs and includes to WindowsSDK_LibraryPath_* and WindowsSDK_IncludePath. -->
  <PropertyGroup>
    <DotNetSdkRoot>$(NETFXKitsDir)</DotNetSdkRoot>
  </PropertyGroup>
  <!-- Get include and lib paths for the Universal CRT -->
  <!--
============================================================================================================================================
  <Import Project="$(UniversalCRT_PropsPath)" Condition="Exists('$(UniversalCRT_PropsPath)')">

C:\Program Files (x86)\Windows Kits\10\DesignTime\CommonConfiguration\Neutral\ucrt.props
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Check Wow64 registry key first, since some Kits will record an incorrect root in this registry key. Still fallback to usual reg key for architectures without a Wow6432Node. -->
    <UCRTContentRoot Condition="'$(UCRTContentRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows Kits\Installed Roots@KitsRoot10)</UCRTContentRoot>
    <UCRTContentRoot Condition="'$(UCRTContentRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots@KitsRoot10)</UCRTContentRoot>
    <TargetUniversalCRTVersion Condition="'$(TargetUniversalCRTVersion)' == ''">$(TargetPlatformVersion)</TargetUniversalCRTVersion>
    <UniversalCRT_IncludePath>$(UCRTContentRoot)Include\$(TargetUniversalCRTVersion)\ucrt;</UniversalCRT_IncludePath>
    <UniversalCRT_LibraryPath_x86 Condition="'$(UniversalCRT_LibraryPath_x86)' == ''">$(UCRTContentRoot)lib\$(TargetUniversalCRTVersion)\ucrt\x86;</UniversalCRT_LibraryPath_x86>
    <UniversalCRT_LibraryPath_x64 Condition="'$(UniversalCRT_LibraryPath_x64)' == ''">$(UCRTContentRoot)lib\$(TargetUniversalCRTVersion)\ucrt\x64;</UniversalCRT_LibraryPath_x64>
    <UniversalCRT_LibraryPath_arm Condition="'$(UniversalCRT_LibraryPath_arm)' == ''">$(UCRTContentRoot)lib\$(TargetUniversalCRTVersion)\ucrt\arm;</UniversalCRT_LibraryPath_arm>
    <UniversalCRT_LibraryPath_arm64 Condition="'$(UniversalCRT_LibraryPath_arm64)' == ''">$(UCRTContentRoot)lib\$(TargetUniversalCRTVersion)\ucrt\arm64;</UniversalCRT_LibraryPath_arm64>
    <UniversalCRT_SourcePath>$(UCRTContentRoot)Source\$(TargetUniversalCRTVersion)\ucrt;</UniversalCRT_SourcePath>
    <UniversalCRT_TargetsC11C17>true</UniversalCRT_TargetsC11C17>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.WindowsSDK.props
============================================================================================================================================
-->
  <!-- import Windows SDK props -->
  <PropertyGroup Condition="'$(WindowsSDKProps)' == ''">
    <WindowsSDKProps Condition="'$(TargetPlatformVersion)' == '8.1'">$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\Windows.props</WindowsSDKProps>
    <WindowsSDKProps Condition="'$(TargetPlatformVersion)' != '8.1'">$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\$(TargetPlatformVersion)\UAP.props</WindowsSDKProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(WindowsSDKProps)" Condition="Exists($(WindowsSDKProps))">

C:\Program Files (x86)\Windows Kits\10\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.props
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Force WindowsSdkDir to always be a parent to this props file -->
    <WindowsSdkDir>$([MSBUILD]::GetDirectoryNameOfFileAbove('$(MSBUILDTHISFILEDIRECTORY)', 'sdkmanifest.xml'))\</WindowsSdkDir>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.3@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.3@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.8@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.6.1@KitsInstallationFolder)</DotNetSdkRoot>
    <DotNetSdkRoot Condition="'$(DotNetSdkRoot)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Microsoft SDKs\NETFXSDK\4.6.1@KitsInstallationFolder)</DotNetSdkRoot>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Properties to be appended to the IncludePath should not be treated as paths, hence should not end in a trailing slash -->
    <!-- These properties can be identified by the trailing _IncludePath in their names -->
    <UM_IncludePath Condition="'$(UM_IncludePath)' == ''">$(WindowsSdkDir)Include\10.0.26100.0\um</UM_IncludePath>
    <KIT_SHARED_IncludePath Condition="'$(KIT_SHARED_IncludePath)' == ''">$(WindowsSdkDir)Include\10.0.26100.0\shared</KIT_SHARED_IncludePath>
    <WinRT_IncludePath Condition="'$(WinRT_IncludePath)' == ''">$(WindowsSdkDir)Include\10.0.26100.0\winrt</WinRT_IncludePath>
    <CppWinRT_IncludePath Condition="'$(CppWinRT_IncludePath)' == ''">$(WindowsSdkDir)Include\10.0.26100.0\cppwinrt</CppWinRT_IncludePath>
    <DotNetSdk_IncludePath Condition="'$(DotNetSdk_IncludePath)' == ''">$(DotNetSdkRoot)Include\um</DotNetSdk_IncludePath>
    <DotNetSdk_LibraryPath Condition="'$(DotNetSdk_LibraryPath)' == ''">$(DotNetSdkRoot)lib\um</DotNetSdk_LibraryPath>
    <DotNetSdk_LibraryPath_x86 Condition="'$(DotNetSdk_LibraryPath_x86)' == ''">$(DotNetSdkRoot)lib\um\x86</DotNetSdk_LibraryPath_x86>
    <DotNetSdk_LibraryPath_x64 Condition="'$(DotNetSdk_LibraryPath_x64)' == ''">$(DotNetSdkRoot)lib\um\x64</DotNetSdk_LibraryPath_x64>
    <WindowsSDK_IncludePath>$(UM_IncludePath);$(KIT_SHARED_IncludePath);$(WinRT_IncludePath);$(CppWinRT_IncludePath);$(DotNetSdk_IncludePath)</WindowsSDK_IncludePath>
    <WindowsSDK_MetadataFoundationPath Condition="'$(WindowsSDK_MetadataFoundationPath)' == ''">$(WindowsSdkDir)References\10.0.26100.0\windows.foundation.foundationcontract\4.0.0.0</WindowsSDK_MetadataFoundationPath>
    <WindowsSDK_MetadataPath>$(WindowsSdkDir)References</WindowsSDK_MetadataPath>
    <WindowsSDK_MetadataPathVersioned Condition="'$(WindowsSDK_MetadataPathVersioned)' == ''">$(WindowsSdkDir)References\10.0.26100.0</WindowsSDK_MetadataPathVersioned>
    <!-- These files provide the Windows Store supported API list for this version of the Windows SDK.-->
    <WindowsSDK_SupportedAPIs_arm>$(WindowsSdkDir)bin\10.0.26100.0\arm\PInvoke\SupportedAPIs.xml</WindowsSDK_SupportedAPIs_arm>
    <WindowsSDK_SupportedAPIs_arm64>$(WindowsSdkDir)bin\10.0.26100.0\arm64\PInvoke\SupportedAPIs.xml</WindowsSDK_SupportedAPIs_arm64>
    <WindowsSDK_SupportedAPIs_x64>$(WindowsSdkDir)bin\10.0.26100.0\x64\PInvoke\SupportedAPIs.xml</WindowsSDK_SupportedAPIs_x64>
    <WindowsSDK_SupportedAPIs_x86>$(WindowsSdkDir)bin\10.0.26100.0\x86\PInvoke\SupportedAPIs.xml</WindowsSDK_SupportedAPIs_x86>
    <!-- Setting executablePath to versioned path if Dev 15. Otherwise to non-versioned bin path if Dev14 or prior or if VisualStudioVersion is not set. -->
    <WindowsSDK_LibraryPath>$(WindowsSdkDir)lib\10.0.26100.0\um</WindowsSDK_LibraryPath>
    <WindowsSDK_LibraryPath_x86 Condition="'$(WindowsSDK_LibraryPath_x86)' == ''">$(WindowsSdkDir)lib\10.0.26100.0\um\x86;$(DotNetSdk_LibraryPath_x86);</WindowsSDK_LibraryPath_x86>
    <WindowsSDK_LibraryPath_x64 Condition="'$(WindowsSDK_LibraryPath_x64)' == ''">$(WindowsSdkDir)lib\10.0.26100.0\um\x64;$(DotNetSdk_LibraryPath_x64);</WindowsSDK_LibraryPath_x64>
    <WindowsSDK_PlatformPath>$(WindowsSdkDir)Platforms\UAP;</WindowsSDK_PlatformPath>
    <WindowsSDK_UnionMetadataPath>$(WindowsSdkDir)UnionMetadata\10.0.26100.0</WindowsSDK_UnionMetadataPath>
    <WindowsSDK_HasVersionedContent>true</WindowsSDK_HasVersionedContent>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &lt;= '14.0'">
    <WindowsSDK_ExecutablePath_x86>$(WindowsSdkDir)bin\x86;</WindowsSDK_ExecutablePath_x86>
    <WindowsSDK_ExecutablePath_x64>$(WindowsSdkDir)bin\x64;</WindowsSDK_ExecutablePath_x64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VisualStudioVersion)' == '' or '$(VisualStudioVersion)' &gt; '14.0'">
    <WindowsSDK_ExecutablePath_x86>$(WindowsSdkDir)bin\10.0.26100.0\x86;</WindowsSDK_ExecutablePath_x86>
    <WindowsSDK_ExecutablePath_x64>$(WindowsSdkDir)bin\10.0.26100.0\x64;</WindowsSDK_ExecutablePath_x64>
  </PropertyGroup>
  <!--<Import Project="$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.desktop.arm.props" Condition="Exists('$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.desktop.arm.props') and ('$(PlatformToolset)' == 'WindowsKernelModeDriver10.0' or '$(PlatformToolset)' == 'WindowsUserModeDriver10.0' or '$(PlatformToolset)' == 'WindowsApplicationForDrivers10.0')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.arm.props" Condition="Exists('$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.arm.props')">

C:\Program Files (x86)\Windows Kits\10\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.arm.props
============================================================================================================================================
-->
  <PropertyGroup>
    <WindowsSDK_ExecutablePath_arm>$(WindowsSdkDir)bin\10.0.26100.0\arm;</WindowsSDK_ExecutablePath_arm>
    <DotNetSdk_LibraryPath_arm Condition="'$(DotNetSdk_LibraryPath_arm)' == ''">$(DotNetSdkRoot)lib\um\arm</DotNetSdk_LibraryPath_arm>
    <WindowsSDK_LibraryPath_arm Condition="'$(WindowsSDK_LibraryPath_arm)' == ''">$(WindowsSdkDir)lib\10.0.26100.0\um\arm;$(DotNetSdk_LibraryPath_arm);</WindowsSDK_LibraryPath_arm>
    <WindowsSDK_ExecutablePath_arm64>$(WindowsSdkDir)bin\10.0.26100.0\arm64;</WindowsSDK_ExecutablePath_arm64>
    <DotNetSdk_LibraryPath_arm64 Condition="'$(DotNetSdk_LibraryPath_arm64)' == ''">$(DotNetSdkRoot)lib\um\arm64</DotNetSdk_LibraryPath_arm64>
    <WindowsSDK_LibraryPath_arm64 Condition="'$(WindowsSDK_LibraryPath_arm64)' == ''">$(WindowsSdkDir)lib\10.0.26100.0\um\arm64;$(DotNetSdk_LibraryPath_arm64);</WindowsSDK_LibraryPath_arm64>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Windows Kits\10\DesignTime\CommonConfiguration\Neutral\UAP\10.0.26100.0\UAP.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.WindowsSDK.props
============================================================================================================================================
-->
  <!-- define Universal CRT locations if not defined in the ucrt.props -->
  <PropertyGroup Condition="Exists('$(UniversalCRT_PropsPath)') and '$(UniversalDebugCRT_ExecutablePath_x86)' == ''">
    <UniversalDebugCRT_ExecutablePath_x86>$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x86\ucrt</UniversalDebugCRT_ExecutablePath_x86>
    <UniversalDebugCRT_ExecutablePath_x64>$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\ucrt</UniversalDebugCRT_ExecutablePath_x64>
    <UniversalDebugCRT_ExecutablePath_ARM>$(WindowsSdkDir)bin\$(TargetPlatformVersion)\ARM\ucrt</UniversalDebugCRT_ExecutablePath_ARM>
    <UniversalDebugCRT_ExecutablePath_ARM64>$(WindowsSdkDir)bin\$(TargetPlatformVersion)\ARM64\ucrt</UniversalDebugCRT_ExecutablePath_ARM64>
  </PropertyGroup>
  <PropertyGroup>
    <WindowsSDK_ExecutablePath_x86 Condition="'$(NETFXSDKDir)' != ''">$(WindowsSDK_ExecutablePath_x86);$(NETFXSDKDir)bin\NETFX $(NETFXSDK_Version) Tools</WindowsSDK_ExecutablePath_x86>
    <WindowsSDK_ExecutablePath_x64 Condition="'$(NETFXSDKDir)' != ''">$(WindowsSDK_ExecutablePath_x64);$(NETFXSDKDir)bin\NETFX $(NETFXSDK_Version) Tools\x64</WindowsSDK_ExecutablePath_x64>
    <WindowsSDK_IncludePath Condition="'$(NETFXKitsDir)' != '' and '$(TargetPlatformVersion)' == '8.1'">$(WindowsSDK_IncludePath);$(NETFXKitsDir)Include\um</WindowsSDK_IncludePath>
    <SDK_ExecutablePath_x86>$(WindowsSDK_ExecutablePath_x86)</SDK_ExecutablePath_x86>
    <SDK_ExecutablePath_x64>$(WindowsSDK_ExecutablePath_x64)</SDK_ExecutablePath_x64>
  </PropertyGroup>
  <!-- Some Windows SDK versions did not include .NET SDK lib path, so we need to add it -->
  <PropertyGroup Condition="'$(NETFXKitsDir)' != ''">
    <WindowsSDK_LibraryPath_x86 Condition="'$(WindowsSDK_LibraryPath_x86)' != '' and '$(DotNetSdk_LibraryPath_x86)' == ''">$(WindowsSDK_LibraryPath_x86);$(NETFXKitsDir)Lib\um\x86</WindowsSDK_LibraryPath_x86>
    <WindowsSDK_LibraryPath_x64 Condition="'$(WindowsSDK_LibraryPath_x64)' != '' and '$(DotNetSdk_LibraryPath_x64)' == ''">$(WindowsSDK_LibraryPath_x64);$(NETFXKitsDir)Lib\um\x64</WindowsSDK_LibraryPath_x64>
    <WindowsSDK_LibraryPath_ARM Condition="'$(WindowsSDK_LibraryPath_ARM)' != '' and '$(DotNetSdk_LibraryPath_ARM)' == ''">$(WindowsSDK_LibraryPath_ARM);$(NETFXKitsDir)Lib\um\arm</WindowsSDK_LibraryPath_ARM>
    <WindowsSDK_LibraryPath_ARM64 Condition="'$(WindowsSDK_LibraryPath_ARM64)' != '' and '$(DotNetSdk_LibraryPath_ARM64)' == ''">$(WindowsSDK_LibraryPath_ARM64);$(NETFXKitsDir)Lib\um\arm64</WindowsSDK_LibraryPath_ARM64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsSdkDir_71A)' != ''">
    <WindowsSdk_71A_ExecutablePath_x86>$(WindowsSdkDir_71A)\bin</WindowsSdk_71A_ExecutablePath_x86>
    <WindowsSdk_71A_ExecutablePath_x64>$(WindowsSdkDir_71A)\bin\x64</WindowsSdk_71A_ExecutablePath_x64>
    <WindowsSdk_71A_IncludePath>$(WindowsSdkDir_71A)include</WindowsSdk_71A_IncludePath>
    <WindowsSdk_71A_LibraryPath_x86>$(WindowsSdkDir_71A)lib</WindowsSdk_71A_LibraryPath_x86>
    <WindowsSdk_71A_LibraryPath_x64>$(WindowsSdkDir_71A)lib\x64</WindowsSdk_71A_LibraryPath_x64>
  </PropertyGroup>
  <PropertyGroup>
    <SDK_ExecutablePath_x86>$(WindowsSDK_ExecutablePath_x86)</SDK_ExecutablePath_x86>
    <SDK_ExecutablePath_x64>$(WindowsSDK_ExecutablePath_x64)</SDK_ExecutablePath_x64>
  </PropertyGroup>
  <!-- Set the property used in Microsoft.Cpp.AppContainerApplication.props and in Microsoft.Common.targets for reference resolution -->
  <PropertyGroup>
    <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == ''">$(WindowsSDK_MetadataPath)</TargetPlatformWinMDLocation>
  </PropertyGroup>
  <PropertyGroup>
    <WindowsTargetPlatformMinVersion Condition="'$(WindowsTargetPlatformMinVersion)' == '' and '$(CLRSupport)' == 'NetCore'">7.0</WindowsTargetPlatformMinVersion>
  </PropertyGroup>
  <PropertyGroup>
    <WindowsSdkVersionARMSupportRemoved>10.0.26100.0</WindowsSdkVersionARMSupportRemoved>
  </PropertyGroup>
  <!-- Project capabiltities are used to filter which Extension SDKs appear in the Add/Remove References dialog -->
  <ItemGroup Condition="'$(SharedAssetsProject)' != 'true' and '$(WindowsPackageType)'==''">
    <ProjectCapability Include="WindowsAppContainer" Condition="'$(WindowsAppContainer)' == 'true'" />
    <ProjectCapability Include="desktop" Condition="'$(WindowsAppContainer)' != 'true'" />
  </ItemGroup>
  <ItemGroup Condition="'$(SharedAssetsProject)' != 'true' and '$(WindowsPackageType)'!=''">
    <ProjectCapability Include="desktop" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.MSVC.Toolset.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Common.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Common.props

Common properties for native toolsets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- *******************************************************************************************
        Cpp settings mapping file
       ******************************************************************************************* -->
  <!-- Default values -->
  <PropertyGroup>
    <TargetExt />
  </PropertyGroup>
  <!-- Specific values -->
  <PropertyGroup Condition="'$(ConfigurationType)' == 'Application'">
    <LinkCompiled>true</LinkCompiled>
    <TargetExt>.exe</TargetExt>
    <OutputType>exe</OutputType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ConfigurationType)' == 'DynamicLibrary'">
    <LinkCompiled>true</LinkCompiled>
    <!-- $(GenerateImportLib) should be set to true when you want to generate the import library as part of the BuildCompile pass rather than wait
         until the BuildLink pass for Linker to generate it. This allows circular dependencies between dlls to be satisfied when building using passes -->
    <ImpLibCompiled Condition="'$(GenerateImportLib)'=='true'">true</ImpLibCompiled>
    <TargetExt>.dll</TargetExt>
    <OutputType>library</OutputType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ConfigurationType)' == 'StaticLibrary'">
    <LibCompiled>true</LibCompiled>
    <TargetExt>.lib</TargetExt>
    <OutputType>staticlibrary</OutputType>
  </PropertyGroup>
  <!-- prevent check for target framework of the referenced projects for Utility and Makefile projects-->
  <ItemDefinitionGroup Condition="'$(ConfigurationType)' == 'Utility' or '$(ConfigurationType)' == 'Makefile'">
    <ProjectReference />
  </ItemDefinitionGroup>
  <!-- VsInstallRoot should be defined by msbuild -->
  <PropertyGroup>
    <VSInstallDir>$(VsInstallRoot)\</VSInstallDir>
    <VCIDEInstallDir>$(VSInstallDir)Common7\IDE\VC\</VCIDEInstallDir>
  </PropertyGroup>
  <!-- import vc tools props -->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.VCTools.props" Condition="'$(UseVCTools)' != 'false'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.VCTools.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DisableRegistryUse)' == 'true'">
    <VCInstallDir_170 Condition="'$(VCInstallDir_170)' == ''">VCInstallDir_170_is_not_defined</VCInstallDir_170>
    <VCToolsInstallDir_170 Condition="'$(VCToolsInstallDir_170)' == ''">VCToolsInstallDir_170_is_not_defined</VCToolsInstallDir_170>
    <VCToolsVersion Condition="'$(VCToolsVersion)' == ''">VCToolsVersion_is_not_defined</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup>
    <VCInstallDir_170 Condition="'$(VCInstallDir_170)' == ''">$(VSInstallDir)VC\</VCInstallDir_170>
    <!-- default platform toolset -->
    <PlatformToolsetVersion Condition="'$(PlatformToolsetVersion)' == ''">143</PlatformToolsetVersion>
  </PropertyGroup>
  <PropertyGroup>
    <_VCToolsVersionProps Condition="'$(_VCToolsVersionProps)' == ''">$(VCInstallDir_170)Auxiliary\Build\Microsoft.VCToolsVersion.v$(PlatformToolsetVersion).default.props</_VCToolsVersionProps>
    <_VCToolsVersionProps Condition="!Exists('$(_VCToolsVersionProps)')">$(VCInstallDir_170)Auxiliary\Build\Microsoft.VCToolsVersion.default.props</_VCToolsVersionProps>
  </PropertyGroup>
  <!-- this file defines default VCToolsVersion -->
  <!--
============================================================================================================================================
  <Import Project="$(_VCToolsVersionProps)" Condition="Exists('$(_VCToolsVersionProps)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\Microsoft.VCToolsVersion.v143.default.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$([System.IO.Path]::GetFullPath($(MSBuildThisFileDirectory)Microsoft.VCRedistVersion.v143.default.props))">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\Microsoft.VCRedistVersion.v143.default.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCToolsRedistVersion Condition="'$(VCToolsRedistVersion)' == ''">14.44.35112</VCToolsRedistVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\Microsoft.VCToolsVersion.v143.default.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCToolsVersion Condition="'$(VCToolsVersion)' == ''">14.44.35207</VCToolsVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCToolsInstallDir_170 Condition="'$(VCToolsInstallDir_170)' == '' and '$(VCToolsVersion)' != ''">$(VCInstallDir_170)Tools\MSVC\$(VCToolsVersion)\</VCToolsInstallDir_170>
    <VCToolsRedistInstallDir_170 Condition="'$(VCToolsRedistInstallDir_170)' == '' and '$(VCToolsRedistVersion)' != ''">$(VCInstallDir_170)Redist\MSVC\$(VCToolsRedistVersion)\</VCToolsRedistInstallDir_170>
  </PropertyGroup>
  <PropertyGroup>
    <VCInstallDir>$(VCInstallDir_170)</VCInstallDir>
    <VCToolsInstallDir>$(VCToolsInstallDir_170)</VCToolsInstallDir>
    <VCToolsetsDir>$(VCInstallDir_170)Tools\MSVC\</VCToolsetsDir>
    <VCToolsRedistInstallDir>$(VCToolsRedistInstallDir_170)</VCToolsRedistInstallDir>
  </PropertyGroup>
  <PropertyGroup>
    <_VCToolsServicingVersionsProps Condition="'$(VCToolsInstallDir)' != ''">$(VCToolsInstallDir)Auxiliary\Microsoft.VC.ServicingVersion.props</_VCToolsServicingVersionsProps>
    <_VCToolsInternalCLFeatureProps Condition="'$(VCToolsInstallDir)' != ''">$(VCToolsInstallDir)Auxiliary\Microsoft.VC.Internal.CL.Features.props</_VCToolsInternalCLFeatureProps>
    <_VCToolsInternalLinkFeatureProps Condition="'$(VCToolsInstallDir)' != ''">$(VCToolsInstallDir)Auxiliary\Microsoft.VC.Internal.Link.Features.props</_VCToolsInternalLinkFeatureProps>
  </PropertyGroup>
  <!-- Import vc tools servicing versions props if available -->
  <!--
============================================================================================================================================
  <Import Project="$(_VCToolsServicingVersionsProps)" Condition="Exists($(_VCToolsServicingVersionsProps))">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.VC.ServicingVersion.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.ATL.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.ATL.props')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.CAExtensions.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.CAExtensions.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.CAExtensions.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCServicingVersionCAExtensions Condition="'$(VCServicingVersionCAExtensions)' == ''">14.44.35207</VCServicingVersionCAExtensions>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.CARulesets.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.CARulesets.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.CARulesets.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCServicingVersionCARulesets Condition="'$(VCServicingVersionCARulesets)' == ''">14.44.35207</VCServicingVersionCARulesets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.Compilers.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.Compilers.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.Compilers.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCServicingVersionCompilers Condition="'$(VCServicingVersionCompilers)' == ''">14.44.35207</VCServicingVersionCompilers>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.CrtHeaders.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.CrtHeaders.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.CrtHeaders.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCServicingVersionCrtHeaders Condition="'$(VCServicingVersionCrtHeaders)' == ''">14.44.35207</VCServicingVersionCrtHeaders>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.DIASDK.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.DIASDK.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.DIASDK.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCServicingVersionDIASDK Condition="'$(VCServicingVersionDIASDK)' == ''">14.44.35207</VCServicingVersionDIASDK>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.ServicingVersion.props
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.MFC.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.MFC.props')" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.ToolsCore.props" Condition="Exists('$(MSBuildThisFileDirectory)\Microsoft.VC.ServicingVersion.ToolsCore.props')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.props
============================================================================================================================================
-->
  <!-- Import vc tools feature props if available -->
  <!--
============================================================================================================================================
  <Import Project="$(_VCToolsInternalCLFeatureProps)" Condition="Exists($(_VCToolsInternalCLFeatureProps))">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.Internal.CL.Features.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.VC.Internal.CL.Features.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_ClExternalIncludesSupported>true</_ClExternalIncludesSupported>
    <!-- /external:I, /external:env, etc -->
    <_ClStdCpp20Supported>true</_ClStdCpp20Supported>
    <!-- /std:c++20 -->
    <_ClStructuredDiagnosticsPipeSupported>true</_ClStructuredDiagnosticsPipeSupported>
    <!-- SARIF_OUTPUT_PIPE -->
    <_CodeAnalysisExtensions>true</_CodeAnalysisExtensions>
    <!-- code analysis extensions are installed with mspft dll -->
    <MSVC_STL_MODULES_JSON>$(VCToolsInstallDir)modules\modules.json</MSVC_STL_MODULES_JSON>
    <!-- describes std.ixx and std.compat.ixx -->
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(_VCToolsInternalLinkFeatureProps)" Condition="Exists($(_VCToolsInternalLinkFeatureProps))">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Tools\MSVC\14.44.35207\Auxiliary\Microsoft.VC.Internal.Link.Features.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.VC.Internal.Link.Features.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_LinkILKSupported>true</_LinkILKSupported>
    <_LinkLTCGOUTSupported>true</_LinkLTCGOUTSupported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.VCTools.Content.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.Content.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.VCTools.Content.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- This property should not be used, but needs to be defined for backward compatibility -->
  <PropertyGroup>
    <VCLibDirMod Condition="'$(VCLibDirMod)' == '' and '$(SpectreMitigation)' != '' and '$(SpectreMitigation)' != 'false'">Spectre\</VCLibDirMod>
  </PropertyGroup>
  <!--Auxiliary VS Dir in VC root-->
  <PropertyGroup>
    <VC_VS_IncludePath Condition="'$(VC_VS_IncludePath)' == ''">$(VCInstallDir)Auxiliary\VS\include;</VC_VS_IncludePath>
    <VC_VS_SourcePath Condition="'$(VC_VS_SourcePath)' == ''">$(VCInstallDir)Auxiliary\VS\src;</VC_VS_SourcePath>
    <VC_VS_LibraryPath_VC_VS_x86 Condition="'$(VC_VS_LibraryPath_VC_VS_x86)' == ''">$(VCInstallDir)Auxiliary\VS\lib\x86;</VC_VS_LibraryPath_VC_VS_x86>
    <VC_VS_LibraryPath_VC_VS_x64 Condition="'$(VC_VS_LibraryPath_VC_VS_x64)' == ''">$(VCInstallDir)Auxiliary\VS\lib\x64;</VC_VS_LibraryPath_VC_VS_x64>
    <VC_VS_LibraryPath_VC_VS_ARM Condition="'$(VC_VS_LibraryPath_VC_VS_ARM)' == ''">$(VCInstallDir)Auxiliary\VS\lib\ARM;</VC_VS_LibraryPath_VC_VS_ARM>
  </PropertyGroup>
  <!-- VC directories -->
  <PropertyGroup>
    <VC_ExecutablePath_x86_x86 Condition="'$(VC_ExecutablePath_x86_x86)' == ''">$(VCToolsInstallDir)bin\HostX86\x86</VC_ExecutablePath_x86_x86>
    <VC_ExecutablePath_x86_x64 Condition="'$(VC_ExecutablePath_x86_x64)' == ''">$(VCToolsInstallDir)bin\HostX86\x64</VC_ExecutablePath_x86_x64>
    <VC_ExecutablePath_x86_ARM Condition="'$(VC_ExecutablePath_x86_ARM)' == ''">$(VCToolsInstallDir)bin\HostX86\arm</VC_ExecutablePath_x86_ARM>
    <VC_ExecutablePath_x86_ARM64 Condition="'$(VC_ExecutablePath_x86_ARM64)' == ''">$(VCToolsInstallDir)bin\HostX86\arm64</VC_ExecutablePath_x86_ARM64>
    <VC_ExecutablePath_x64_x86 Condition="'$(VC_ExecutablePath_x64_x86)' == ''">$(VCToolsInstallDir)bin\HostX64\x86</VC_ExecutablePath_x64_x86>
    <VC_ExecutablePath_x64_x64 Condition="'$(VC_ExecutablePath_x64_x64)' == ''">$(VCToolsInstallDir)bin\HostX64\x64</VC_ExecutablePath_x64_x64>
    <VC_ExecutablePath_x64_ARM Condition="'$(VC_ExecutablePath_x64_ARM)' == ''">$(VCToolsInstallDir)bin\HostX64\arm</VC_ExecutablePath_x64_ARM>
    <VC_ExecutablePath_x64_ARM64 Condition="'$(VC_ExecutablePath_x64_ARM64)' == ''">$(VCToolsInstallDir)bin\HostX64\arm64</VC_ExecutablePath_x64_ARM64>
    <VC_ExecutablePath_arm64_x86 Condition="'$(VC_ExecutablePath_arm64_x86)' == ''">$(VCToolsInstallDir)bin\HostArm64\x86</VC_ExecutablePath_arm64_x86>
    <VC_ExecutablePath_arm64_x64 Condition="'$(VC_ExecutablePath_arm64_x64)' == ''">$(VCToolsInstallDir)bin\HostArm64\x64</VC_ExecutablePath_arm64_x64>
    <VC_ExecutablePath_arm64_ARM Condition="'$(VC_ExecutablePath_arm64_ARM)' == ''">$(VCToolsInstallDir)bin\HostArm64\arm</VC_ExecutablePath_arm64_ARM>
    <VC_ExecutablePath_arm64_ARM64 Condition="'$(VC_ExecutablePath_arm64_ARM64)' == ''">$(VCToolsInstallDir)bin\HostArm64\arm64</VC_ExecutablePath_arm64_ARM64>
    <VC_ReferencesPath_VC_x86 Condition="'$(VC_ReferencesPath_VC_x86)' == ''">$(VCToolsInstallDir)lib\x86</VC_ReferencesPath_VC_x86>
    <VC_ReferencesPath_ATL_x86 Condition="'$(VC_ReferencesPath_ATL_x86)' == ''">$(VCToolsInstallDir)atlmfc\lib\x86;</VC_ReferencesPath_ATL_x86>
    <VC_ReferencesPath_VC_x86_spectre Condition="'$(VC_ReferencesPath_VC_x86_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\x86</VC_ReferencesPath_VC_x86_spectre>
    <VC_ReferencesPath_ATL_x86_spectre Condition="'$(VC_ReferencesPath_ATL_x86_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\x86;</VC_ReferencesPath_ATL_x86_spectre>
    <VC_ReferencesPath_VC_x64 Condition="'$(VC_ReferencesPath_VC_x64)' == ''">$(VCToolsInstallDir)lib\x64</VC_ReferencesPath_VC_x64>
    <VC_ReferencesPath_ATL_x64 Condition="'$(VC_ReferencesPath_ATL_x64)' == ''">$(VCToolsInstallDir)atlmfc\lib\x64;</VC_ReferencesPath_ATL_x64>
    <VC_ReferencesPath_VC_x64_spectre Condition="'$(VC_ReferencesPath_VC_x64_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\x64</VC_ReferencesPath_VC_x64_spectre>
    <VC_ReferencesPath_ATL_x64_spectre Condition="'$(VC_ReferencesPath_ATL_x64_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\x64;</VC_ReferencesPath_ATL_x64_spectre>
    <VC_ReferencesPath_VC_ARM Condition="'$(VC_ReferencesPath_VC_ARM)' == ''">$(VCToolsInstallDir)lib\ARM</VC_ReferencesPath_VC_ARM>
    <VC_ReferencesPath_ATL_ARM Condition="'$(VC_ReferencesPath_ATL_ARM)' == ''">$(VCToolsInstallDir)atlmfc\lib\ARM;</VC_ReferencesPath_ATL_ARM>
    <VC_ReferencesPath_VC_ARM_spectre Condition="'$(VC_ReferencesPath_VC_ARM_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\ARM</VC_ReferencesPath_VC_ARM_spectre>
    <VC_ReferencesPath_ATL_ARM_spectre Condition="'$(VC_ReferencesPath_ATL_ARM_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\ARM;</VC_ReferencesPath_ATL_ARM_spectre>
    <VC_ReferencesPath_VC_ARM64 Condition="'$(VC_ReferencesPath_VC_ARM64)' == ''">$(VCToolsInstallDir)lib\ARM64</VC_ReferencesPath_VC_ARM64>
    <VC_ReferencesPath_ATL_ARM64 Condition="'$(VC_ReferencesPath_ATL_ARM64)' == ''">$(VCToolsInstallDir)atlmfc\lib\ARM64;</VC_ReferencesPath_ATL_ARM64>
    <VC_ReferencesPath_VC_ARM64_spectre Condition="'$(VC_ReferencesPath_VC_ARM64_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\ARM64</VC_ReferencesPath_VC_ARM64_spectre>
    <VC_ReferencesPath_ATL_ARM64_spectre Condition="'$(VC_ReferencesPath_ATL_ARM64_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\ARM64;</VC_ReferencesPath_ATL_ARM64_spectre>
    <LibrariesArchitecture Condition="'$(LibrariesArchitecture)' == ''">$(PlatformTarget)</LibrariesArchitecture>
    <VC_LibraryPath_VC_x86_Desktop Condition="'$(VC_LibraryPath_VC_x86_Desktop)' == ''">$(VCToolsInstallDir)lib\x86</VC_LibraryPath_VC_x86_Desktop>
    <VC_LibraryPath_VC_x64_Desktop Condition="'$(VC_LibraryPath_VC_x64_Desktop)' == ''">$(VCToolsInstallDir)lib\x64</VC_LibraryPath_VC_x64_Desktop>
    <VC_LibraryPath_VC_ARM_Desktop Condition="'$(VC_LibraryPath_VC_ARM_Desktop)' == ''">$(VCToolsInstallDir)lib\ARM</VC_LibraryPath_VC_ARM_Desktop>
    <VC_LibraryPath_VC_ARM64_Desktop Condition="'$(VC_LibraryPath_VC_ARM64_Desktop)' == ''">$(VCToolsInstallDir)lib\ARM64</VC_LibraryPath_VC_ARM64_Desktop>
    <VC_LibraryPath_VC_x86_Desktop_spectre Condition="'$(VC_LibraryPath_VC_x86_Desktop_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\x86</VC_LibraryPath_VC_x86_Desktop_spectre>
    <VC_LibraryPath_VC_x64_Desktop_spectre Condition="'$(VC_LibraryPath_VC_x64_Desktop_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\x64</VC_LibraryPath_VC_x64_Desktop_spectre>
    <VC_LibraryPath_VC_ARM_Desktop_spectre Condition="'$(VC_LibraryPath_VC_ARM_Desktop_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\ARM</VC_LibraryPath_VC_ARM_Desktop_spectre>
    <VC_LibraryPath_VC_ARM64_Desktop_spectre Condition="'$(VC_LibraryPath_VC_ARM64_Desktop_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\ARM64</VC_LibraryPath_VC_ARM64_Desktop_spectre>
    <VC_LibraryPath_VC_Desktop_CurrentPlatform_spectre>$(VCToolsInstallDir)lib\spectre\$(LibrariesArchitecture)</VC_LibraryPath_VC_Desktop_CurrentPlatform_spectre>
    <VC_LibraryPath_VC_x86_Store Condition="'$(VC_LibraryPath_VC_x86_Store)' == ''">$(VCToolsInstallDir)lib\x86\store</VC_LibraryPath_VC_x86_Store>
    <VC_LibraryPath_VC_x64_Store Condition="'$(VC_LibraryPath_VC_x64_Store)' == ''">$(VCToolsInstallDir)lib\x64\store</VC_LibraryPath_VC_x64_Store>
    <VC_LibraryPath_VC_ARM_Store Condition="'$(VC_LibraryPath_VC_ARM_Store)' == ''">$(VCToolsInstallDir)lib\ARM\store</VC_LibraryPath_VC_ARM_Store>
    <VC_LibraryPath_VC_ARM64_Store Condition="'$(VC_LibraryPath_VC_ARM64_Store)' == ''">$(VCToolsInstallDir)lib\ARM64\store</VC_LibraryPath_VC_ARM64_Store>
    <VC_LibraryPath_VC_x86_UWP Condition="'$(VC_LibraryPath_VC_x86_UWP)' == ''">$(VCToolsInstallDir)lib\x86\uwp</VC_LibraryPath_VC_x86_UWP>
    <VC_LibraryPath_VC_x64_UWP Condition="'$(VC_LibraryPath_VC_x64_UWP)' == ''">$(VCToolsInstallDir)lib\x64\uwp</VC_LibraryPath_VC_x64_UWP>
    <VC_LibraryPath_VC_ARM_UWP Condition="'$(VC_LibraryPath_VC_ARM_UWP)' == ''">$(VCToolsInstallDir)lib\ARM\uwp</VC_LibraryPath_VC_ARM_UWP>
    <VC_LibraryPath_VC_ARM64_UWP Condition="'$(VC_LibraryPath_VC_ARM64_UWP)' == ''">$(VCToolsInstallDir)lib\ARM64\uwp</VC_LibraryPath_VC_ARM64_UWP>
    <VC_LibraryPath_VC_x86_OneCore Condition="'$(VC_LibraryPath_VC_x86_OneCore)' == ''">$(VCToolsInstallDir)lib\onecore\x86</VC_LibraryPath_VC_x86_OneCore>
    <VC_LibraryPath_VC_x64_OneCore Condition="'$(VC_LibraryPath_VC_x64_OneCore)' == ''">$(VCToolsInstallDir)lib\onecore\x64</VC_LibraryPath_VC_x64_OneCore>
    <VC_LibraryPath_VC_ARM_OneCore Condition="'$(VC_LibraryPath_VC_ARM_OneCore)' == ''">$(VCToolsInstallDir)lib\onecore\ARM</VC_LibraryPath_VC_ARM_OneCore>
    <VC_LibraryPath_VC_ARM64_OneCore Condition="'$(VC_LibraryPath_VC_ARM64_OneCore)' == ''">$(VCToolsInstallDir)lib\onecore\ARM64</VC_LibraryPath_VC_ARM64_OneCore>
    <VC_LibraryPath_VC_x86_OneCore_spectre Condition="'$(VC_LibraryPath_VC_x86_OneCore_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\onecore\x86</VC_LibraryPath_VC_x86_OneCore_spectre>
    <VC_LibraryPath_VC_x64_OneCore_spectre Condition="'$(VC_LibraryPath_VC_x64_OneCore_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\onecore\x64</VC_LibraryPath_VC_x64_OneCore_spectre>
    <VC_LibraryPath_VC_ARM_OneCore_spectre Condition="'$(VC_LibraryPath_VC_ARM_OneCore_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\onecore\ARM</VC_LibraryPath_VC_ARM_OneCore_spectre>
    <VC_LibraryPath_VC_ARM64_OneCore_spectre Condition="'$(VC_LibraryPath_VC_ARM64_OneCore_spectre)' == ''">$(VCToolsInstallDir)lib\spectre\onecore\ARM64</VC_LibraryPath_VC_ARM64_OneCore_spectre>
    <VC_LibraryPath_VC_OneCore_CurrentPlatform_spectre>$(VCToolsInstallDir)lib\spectre\onecore\$(LibrariesArchitecture)</VC_LibraryPath_VC_OneCore_CurrentPlatform_spectre>
    <VC_LibraryPath_ATL_x86 Condition="'$(VC_LibraryPath_ATL_x86)' == ''">$(VCToolsInstallDir)atlmfc\lib\x86;</VC_LibraryPath_ATL_x86>
    <VC_LibraryPath_ATL_x64 Condition="'$(VC_LibraryPath_ATL_x64)' == ''">$(VCToolsInstallDir)atlmfc\lib\x64;</VC_LibraryPath_ATL_x64>
    <VC_LibraryPath_ATL_ARM Condition="'$(VC_LibraryPath_ATL_ARM)' == ''">$(VCToolsInstallDir)atlmfc\lib\ARM;</VC_LibraryPath_ATL_ARM>
    <VC_LibraryPath_ATL_ARM64 Condition="'$(VC_LibraryPath_ATL_ARM64)' == ''">$(VCToolsInstallDir)atlmfc\lib\ARM64;</VC_LibraryPath_ATL_ARM64>
    <VC_LibraryPath_ATL_x86_spectre Condition="'$(VC_LibraryPath_ATL_x86_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\x86;</VC_LibraryPath_ATL_x86_spectre>
    <VC_LibraryPath_ATL_x64_spectre Condition="'$(VC_LibraryPath_ATL_x64_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\x64;</VC_LibraryPath_ATL_x64_spectre>
    <VC_LibraryPath_ATL_ARM_spectre Condition="'$(VC_LibraryPath_ATL_ARM_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\ARM;</VC_LibraryPath_ATL_ARM_spectre>
    <VC_LibraryPath_ATL_ARM64_spectre Condition="'$(VC_LibraryPath_ATL_ARM64_spectre)' == ''">$(VCToolsInstallDir)atlmfc\lib\spectre\ARM64;</VC_LibraryPath_ATL_ARM64_spectre>
    <VC_LibraryPath_ATL_CurrentPlatform_spectre>$(VCToolsInstallDir)atlmfc\lib\spectre\$(LibrariesArchitecture)</VC_LibraryPath_ATL_CurrentPlatform_spectre>
    <VC_VC_IncludePath Condition="'$(VC_VC_IncludePath)' == ''">$(VCToolsInstallDir)include;</VC_VC_IncludePath>
    <VC_ATLMFC_IncludePath Condition="'$(VC_ATLMFC_IncludePath)' == ''">$(VCToolsInstallDir)atlmfc\include;</VC_ATLMFC_IncludePath>
    <VC_IncludePath>$(VC_VC_IncludePath);$(VC_ATLMFC_IncludePath);$(VC_VS_IncludePath);$(UniversalCRT_IncludePath);</VC_IncludePath>
    <VC_CRT_SourcePath Condition="'$(VC_CRT_SourcePath)' == ''">$(VCToolsInstallDir)crt\src;</VC_CRT_SourcePath>
    <VC_ATLMFC_SourcePath Condition="'$(VC_ATLMFC_SourcePath)' == ''">$(VCToolsInstallDir)atlmfc\src\mfc;$(VCToolsInstallDir)atlmfc\src\mfcm;$(VCToolsInstallDir)atlmfc\src\atl;</VC_ATLMFC_SourcePath>
    <VC_SourcePath>$(VC_ATLMFC_SourcePath);$(VC_CRT_SourcePath);$(VC_VS_SourcePath);$(UniversalCRT_SourcePath);</VC_SourcePath>
    <VC_IFCPath Condition="'$(VC_IFCPath)' == ''">$(VCToolsInstallDir)ifc\$(PlatformTarget)</VC_IFCPath>
  </PropertyGroup>
  <Choose>
    <When Condition="'$(SpectreMitigation)' != '' and '$(SpectreMitigation)' != 'false'">
      <PropertyGroup>
        <_VC_LibraryPath_VC_x86_Desktop>$(VC_LibraryPath_VC_x86_Desktop_spectre)</_VC_LibraryPath_VC_x86_Desktop>
        <_VC_LibraryPath_VC_x64_Desktop>$(VC_LibraryPath_VC_x64_Desktop_spectre)</_VC_LibraryPath_VC_x64_Desktop>
        <_VC_LibraryPath_VC_ARM_Desktop>$(VC_LibraryPath_VC_ARM_Desktop_spectre)</_VC_LibraryPath_VC_ARM_Desktop>
        <_VC_LibraryPath_VC_ARM64_Desktop>$(VC_LibraryPath_VC_ARM64_Desktop_spectre)</_VC_LibraryPath_VC_ARM64_Desktop>
        <_VC_LibraryPath_VC_x86_OneCore>$(VC_LibraryPath_VC_x86_OneCore_spectre)</_VC_LibraryPath_VC_x86_OneCore>
        <_VC_LibraryPath_VC_x64_OneCore>$(VC_LibraryPath_VC_x64_OneCore_spectre)</_VC_LibraryPath_VC_x64_OneCore>
        <_VC_LibraryPath_VC_ARM_OneCore>$(VC_LibraryPath_VC_ARM_OneCore_spectre)</_VC_LibraryPath_VC_ARM_OneCore>
        <_VC_LibraryPath_VC_ARM64_OneCore>$(VC_LibraryPath_VC_ARM64_OneCore_spectre)</_VC_LibraryPath_VC_ARM64_OneCore>
        <_VC_LibraryPath_ATL_x86>$(VC_LibraryPath_ATL_x86_spectre)</_VC_LibraryPath_ATL_x86>
        <_VC_LibraryPath_ATL_x64>$(VC_LibraryPath_ATL_x64_spectre)</_VC_LibraryPath_ATL_x64>
        <_VC_LibraryPath_ATL_ARM>$(VC_LibraryPath_ATL_ARM_spectre)</_VC_LibraryPath_ATL_ARM>
        <_VC_LibraryPath_ATL_ARM64>$(VC_LibraryPath_ATL_ARM64_spectre)</_VC_LibraryPath_ATL_ARM64>
        <VC_ReferencesPath_x86>$(VC_ReferencesPath_ATL_x86_spectre);$(VC_ReferencesPath_VC_x86_spectre)</VC_ReferencesPath_x86>
        <VC_ReferencesPath_x64>$(VC_ReferencesPath_ATL_x64_spectre);$(VC_ReferencesPath_VC_x64_spectre)</VC_ReferencesPath_x64>
        <VC_ReferencesPath_ARM>$(VC_ReferencesPath_ATL_ARM_spectre);$(VC_ReferencesPath_VC_ARM_spectre)</VC_ReferencesPath_ARM>
        <VC_ReferencesPath_ARM64>$(VC_ReferencesPath_ATL_ARM64_spectre);$(VC_ReferencesPath_VC_ARM64_spectre)</VC_ReferencesPath_ARM64>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <_VC_LibraryPath_VC_x86_Desktop>$(VC_LibraryPath_VC_x86_Desktop)</_VC_LibraryPath_VC_x86_Desktop>
        <_VC_LibraryPath_VC_x64_Desktop>$(VC_LibraryPath_VC_x64_Desktop)</_VC_LibraryPath_VC_x64_Desktop>
        <_VC_LibraryPath_VC_ARM_Desktop>$(VC_LibraryPath_VC_ARM_Desktop)</_VC_LibraryPath_VC_ARM_Desktop>
        <_VC_LibraryPath_VC_ARM64_Desktop>$(VC_LibraryPath_VC_ARM64_Desktop)</_VC_LibraryPath_VC_ARM64_Desktop>
        <_VC_LibraryPath_VC_x86_Store>$(VC_LibraryPath_VC_x86_Store)</_VC_LibraryPath_VC_x86_Store>
        <_VC_LibraryPath_VC_x64_Store>$(VC_LibraryPath_VC_x64_Store)</_VC_LibraryPath_VC_x64_Store>
        <_VC_LibraryPath_VC_ARM_Store>$(VC_LibraryPath_VC_ARM_Store)</_VC_LibraryPath_VC_ARM_Store>
        <_VC_LibraryPath_VC_ARM64_Store>$(VC_LibraryPath_VC_ARM64_Store)</_VC_LibraryPath_VC_ARM64_Store>
        <_VC_LibraryPath_VC_x86_UWP>$(VC_LibraryPath_VC_x86_UWP)</_VC_LibraryPath_VC_x86_UWP>
        <_VC_LibraryPath_VC_x64_UWP>$(VC_LibraryPath_VC_x64_UWP)</_VC_LibraryPath_VC_x64_UWP>
        <_VC_LibraryPath_VC_ARM_UWP>$(VC_LibraryPath_VC_ARM_UWP)</_VC_LibraryPath_VC_ARM_UWP>
        <_VC_LibraryPath_VC_ARM64_UWP>$(VC_LibraryPath_VC_ARM64_UWP)</_VC_LibraryPath_VC_ARM64_UWP>
        <_VC_LibraryPath_VC_x86_OneCore>$(VC_LibraryPath_VC_x86_OneCore)</_VC_LibraryPath_VC_x86_OneCore>
        <_VC_LibraryPath_VC_x64_OneCore>$(VC_LibraryPath_VC_x64_OneCore)</_VC_LibraryPath_VC_x64_OneCore>
        <_VC_LibraryPath_VC_ARM_OneCore>$(VC_LibraryPath_VC_ARM_OneCore)</_VC_LibraryPath_VC_ARM_OneCore>
        <_VC_LibraryPath_VC_ARM64_OneCore>$(VC_LibraryPath_VC_ARM64_OneCore)</_VC_LibraryPath_VC_ARM64_OneCore>
        <_VC_LibraryPath_ATL_x86>$(VC_LibraryPath_ATL_x86)</_VC_LibraryPath_ATL_x86>
        <_VC_LibraryPath_ATL_x64>$(VC_LibraryPath_ATL_x64)</_VC_LibraryPath_ATL_x64>
        <_VC_LibraryPath_ATL_ARM>$(VC_LibraryPath_ATL_ARM)</_VC_LibraryPath_ATL_ARM>
        <_VC_LibraryPath_ATL_ARM64>$(VC_LibraryPath_ATL_ARM64)</_VC_LibraryPath_ATL_ARM64>
        <VC_ReferencesPath_x86>$(VC_ReferencesPath_ATL_x86);$(VC_ReferencesPath_VC_x86)</VC_ReferencesPath_x86>
        <VC_ReferencesPath_x64>$(VC_ReferencesPath_ATL_x64);$(VC_ReferencesPath_VC_x64)</VC_ReferencesPath_x64>
        <VC_ReferencesPath_ARM>$(VC_ReferencesPath_ATL_ARM);$(VC_ReferencesPath_VC_ARM)</VC_ReferencesPath_ARM>
        <VC_ReferencesPath_ARM64>$(VC_ReferencesPath_ATL_ARM64);$(VC_ReferencesPath_VC_ARM64)</VC_ReferencesPath_ARM64>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup Condition="'$(PlatformShortName)' != ''">
    <_SpectreLibsDir Condition="'$(SpectreMitigation)' != '' and '$(SpectreMitigation)' != 'false'">spectre\</_SpectreLibsDir>
    <!-- the file to check in $(_VC_LibraryPath_ATL_*) folders to figure out if MFC was installed -->
    <MFC_KeyFile>$(VCToolsInstallDir)atlmfc\lib\$(_SpectreLibsDir)$(PlatformShortName)\mfcs140.lib</MFC_KeyFile>
    <!-- the file to check in $(_VC_LibraryPath_ATL_*) folders to figure out if ATL was installed -->
    <ATL_KeyFile>$(VCToolsInstallDir)atlmfc\lib\$(_SpectreLibsDir)$(PlatformShortName)\atls.lib</ATL_KeyFile>
  </PropertyGroup>
  <PropertyGroup>
    <_VC_x64_ToolsInstalled Condition="'$(_VC_x64_ToolsInstalled)' == '' and Exists('$(VCToolsInstallDir)bin\HostX64')">true</_VC_x64_ToolsInstalled>
    <_VC_arm64_ToolsInstalled Condition="'$(_VC_arm64_ToolsInstalled)' == '' and Exists('$(VCToolsInstallDir)bin\HostArm64')">true</_VC_arm64_ToolsInstalled>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.VCTools.props
============================================================================================================================================
-->
  <!-- We want to use a "public" property, but  we need to keep _VC_Target_Library_Platform for backward compatibility -->
  <PropertyGroup>
    <VC_Target_Library_Platform Condition="$(VC_Target_Library_Platform) == '' and '$(_VC_Target_Library_Platform)' != ''">$(_VC_Target_Library_Platform)</VC_Target_Library_Platform>
  </PropertyGroup>
  <!-- Abstract the Target Library platform so users can easily pick OneCore that isn't currently supported in the IDE -->
  <PropertyGroup Condition="'$(VC_Target_Library_Platform)' == ''">
    <VC_Target_Library_Platform Condition="'$(WindowsAppContainer)' != 'true'">Desktop</VC_Target_Library_Platform>
    <VC_Target_Library_Platform Condition="'$(WindowsAppContainer)' == 'true' and '$(DesktopCompatible)' != 'true'">Store</VC_Target_Library_Platform>
    <VC_Target_Library_Platform Condition="'$(WindowsAppContainer)' == 'true' and '$(DesktopCompatible)' == 'true'">UWP</VC_Target_Library_Platform>
  </PropertyGroup>
  <PropertyGroup>
    <_VC_Target_Library_Platform>$(VC_Target_Library_Platform)</_VC_Target_Library_Platform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VC_Target_Library_Platform)' == 'Desktop'">
    <VC_LibraryPath_VC_x86 Condition="'$(VC_LibraryPath_VC_x86)' == ''">$(_VC_LibraryPath_VC_x86_Desktop);</VC_LibraryPath_VC_x86>
    <VC_LibraryPath_VC_x64 Condition="'$(VC_LibraryPath_VC_x64)' == ''">$(_VC_LibraryPath_VC_x64_Desktop);</VC_LibraryPath_VC_x64>
    <VC_LibraryPath_VC_ARM Condition="'$(VC_LibraryPath_VC_ARM)' == ''">$(_VC_LibraryPath_VC_ARM_Desktop);</VC_LibraryPath_VC_ARM>
    <VC_LibraryPath_VC_ARM64 Condition="'$(VC_LibraryPath_VC_ARM64)' == ''">$(_VC_LibraryPath_VC_ARM64_Desktop);</VC_LibraryPath_VC_ARM64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VC_Target_Library_Platform)' == 'Store'">
    <VC_LibraryPath_VC_x86 Condition="'$(VC_LibraryPath_VC_x86)' == ''">$(_VC_LibraryPath_VC_x86_Store);</VC_LibraryPath_VC_x86>
    <VC_LibraryPath_VC_x64 Condition="'$(VC_LibraryPath_VC_x64)' == ''">$(_VC_LibraryPath_VC_x64_Store);</VC_LibraryPath_VC_x64>
    <VC_LibraryPath_VC_ARM Condition="'$(VC_LibraryPath_VC_ARM)' == ''">$(_VC_LibraryPath_VC_ARM_Store);</VC_LibraryPath_VC_ARM>
    <VC_LibraryPath_VC_ARM64 Condition="'$(VC_LibraryPath_VC_ARM64)' == ''">$(_VC_LibraryPath_VC_ARM64_Store);</VC_LibraryPath_VC_ARM64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VC_Target_Library_Platform)' == 'UWP'">
    <VC_LibraryPath_VC_x86 Condition="'$(VC_LibraryPath_VC_x86)' == ''">$(_VC_LibraryPath_VC_x86_UWP);</VC_LibraryPath_VC_x86>
    <VC_LibraryPath_VC_x64 Condition="'$(VC_LibraryPath_VC_x64)' == ''">$(_VC_LibraryPath_VC_x64_UWP);</VC_LibraryPath_VC_x64>
    <VC_LibraryPath_VC_ARM Condition="'$(VC_LibraryPath_VC_ARM)' == ''">$(_VC_LibraryPath_VC_ARM_UWP);</VC_LibraryPath_VC_ARM>
    <VC_LibraryPath_VC_ARM64 Condition="'$(VC_LibraryPath_VC_ARM64)' == ''">$(_VC_LibraryPath_VC_ARM64_UWP);</VC_LibraryPath_VC_ARM64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VC_Target_Library_Platform)' == 'OneCore'">
    <!-- OneCore that is not currently supported in the IDE.
         Setting _VC_Target_Library_Platform to OneCore in the build environment or command-line this can be enabled by the user-->
    <VC_LibraryPath_VC_x86 Condition="'$(VC_LibraryPath_VC_x86)' == ''">$(_VC_LibraryPath_VC_x86_OneCore);</VC_LibraryPath_VC_x86>
    <VC_LibraryPath_VC_x64 Condition="'$(VC_LibraryPath_VC_x64)' == ''">$(_VC_LibraryPath_VC_x64_OneCore);</VC_LibraryPath_VC_x64>
    <VC_LibraryPath_VC_ARM Condition="'$(VC_LibraryPath_VC_ARM)' == ''">$(_VC_LibraryPath_VC_ARM_OneCore);</VC_LibraryPath_VC_ARM>
    <VC_LibraryPath_VC_ARM64 Condition="'$(VC_LibraryPath_VC_ARM64)' == ''">$(_VC_LibraryPath_VC_ARM64_OneCore);</VC_LibraryPath_VC_ARM64>
  </PropertyGroup>
  <PropertyGroup>
    <VC_LibraryPath_x86>$(VC_LibraryPath_VC_x86);$(_VC_LibraryPath_ATL_x86);$(VC_VS_LibraryPath_VC_VS_x86);$(UniversalCRT_LibraryPath_x86);</VC_LibraryPath_x86>
    <VC_LibraryPath_x64>$(VC_LibraryPath_VC_x64);$(_VC_LibraryPath_ATL_x64);$(VC_VS_LibraryPath_VC_VS_x64);$(UniversalCRT_LibraryPath_x64);</VC_LibraryPath_x64>
    <VC_LibraryPath_ARM>$(VC_LibraryPath_VC_ARM);$(_VC_LibraryPath_ATL_ARM);$(VC_VS_LibraryPath_VC_VS_ARM);$(UniversalCRT_LibraryPath_ARM);</VC_LibraryPath_ARM>
    <VC_LibraryPath_ARM64>$(VC_LibraryPath_VC_ARM64);$(_VC_LibraryPath_ATL_ARM64);$(VC_VS_LibraryPath_VC_VS_ARM64);$(UniversalCRT_LibraryPath_ARM64);</VC_LibraryPath_ARM64>
  </PropertyGroup>
  <PropertyGroup>
    <VC_PGO_RunTime_Dir>$(VCToolsInstallDir)bin\Host$(PreferredToolArchitecture)\$(PlatformTarget)</VC_PGO_RunTime_Dir>
  </PropertyGroup>
  <!-- VC redist location, used in deploy for remote debugging -->
  <PropertyGroup>
    <VC_DebugCppRuntimeFilesPath_x86>$(VCToolsRedistInstallDir)Debug_NonRedist\x86</VC_DebugCppRuntimeFilesPath_x86>
    <VC_DebugCppRuntimeFilesPath_x64>$(VCToolsRedistInstallDir)Debug_NonRedist\x64</VC_DebugCppRuntimeFilesPath_x64>
    <VC_DebugCppRuntimeFilesPath_ARM>$(VCToolsRedistInstallDir)Debug_NonRedist\ARM</VC_DebugCppRuntimeFilesPath_ARM>
    <VC_DebugCppRuntimeFilesPath_ARM64>$(VCToolsRedistInstallDir)Debug_NonRedist\ARM64</VC_DebugCppRuntimeFilesPath_ARM64>
  </PropertyGroup>
  <PropertyGroup>
    <VC_CppRuntimeFilesPath_x86>$(VCToolsRedistInstallDir)x86</VC_CppRuntimeFilesPath_x86>
    <VC_CppRuntimeFilesPath_x64>$(VCToolsRedistInstallDir)x64</VC_CppRuntimeFilesPath_x64>
    <VC_CppRuntimeFilesPath_ARM>$(VCToolsRedistInstallDir)ARM</VC_CppRuntimeFilesPath_ARM>
    <VC_CppRuntimeFilesPath_ARM64>$(VCToolsRedistInstallDir)ARM64</VC_CppRuntimeFilesPath_ARM64>
  </PropertyGroup>
  <PropertyGroup>
    <UseStructuredOutput Condition="'$(UseStructuredOutput)' == '' and '$(_ClStructuredDiagnosticsPipeSupported)' == 'true'">true</UseStructuredOutput>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(PreferredToolArchitecture)' == 'x64' and '$(_VC_x64_ToolsInstalled)' == 'true'">
    <VCToolArchitecture>Native64Bit</VCToolArchitecture>
    <VC_ExecutablePath_x86>$(VC_ExecutablePath_x64_x86);$(VC_ExecutablePath_x64_x64)</VC_ExecutablePath_x86>
    <VC_ExecutablePath_x64>$(VC_ExecutablePath_x64_x64)</VC_ExecutablePath_x64>
    <VC_ExecutablePath_ARM>$(VC_ExecutablePath_x64_ARM);$(VC_ExecutablePath_x64_x64)</VC_ExecutablePath_ARM>
    <VC_ExecutablePath_ARM64>$(VC_ExecutablePath_x64_ARM64);$(VC_ExecutablePath_x64_x64)</VC_ExecutablePath_ARM64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(PreferredToolArchitecture)' == 'arm64' and '$(_VC_arm64_ToolsInstalled)' == 'true'">
    <VCToolArchitecture>NativeARM64</VCToolArchitecture>
    <VC_ExecutablePath_x86>$(VC_ExecutablePath_ARM64_x86);$(VC_ExecutablePath_ARM64_ARM64)</VC_ExecutablePath_x86>
    <VC_ExecutablePath_x64>$(VC_ExecutablePath_ARM64_x64);$(VC_ExecutablePath_ARM64_ARM64)</VC_ExecutablePath_x64>
    <VC_ExecutablePath_ARM>$(VC_ExecutablePath_ARM64_ARM);$(VC_ExecutablePath_ARM64_ARM64)</VC_ExecutablePath_ARM>
    <VC_ExecutablePath_ARM64>$(VC_ExecutablePath_ARM64_ARM64)</VC_ExecutablePath_ARM64>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VCToolArchitecture)' != 'Native64Bit' and '$(VCToolArchitecture)' != 'NativeARM64'">
    <VCToolArchitecture>Native32Bit</VCToolArchitecture>
    <VC_ExecutablePath_x86>$(VC_ExecutablePath_x86_x86)</VC_ExecutablePath_x86>
    <VC_ExecutablePath_x64>$(VC_ExecutablePath_x86_x64);$(VC_ExecutablePath_x86_x86)</VC_ExecutablePath_x64>
    <VC_ExecutablePath_ARM>$(VC_ExecutablePath_x86_ARM);$(VC_ExecutablePath_x86_x86)</VC_ExecutablePath_ARM>
    <VC_ExecutablePath_ARM64>$(VC_ExecutablePath_x86_ARM64);$(VC_ExecutablePath_x86_x86)</VC_ExecutablePath_ARM64>
  </PropertyGroup>
  <PropertyGroup>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x64_x86)' != ''">$(VC_ExecutablePath_x64_x86)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x64_x64)' != ''">$(VC_ExecutablePath_x64_x64)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x64_ARM)' != ''">$(VC_ExecutablePath_x64_ARM)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x64_ARM64)' != ''">$(VC_ExecutablePath_x64_ARM64)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x86_x86)' != ''">$(VC_ExecutablePath_x86_x86)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x86_x64)' != ''">$(VC_ExecutablePath_x86_x64)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_x86_ARM64)' != ''">$(VC_ExecutablePath_x86_ARM64)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_ARM64_x86)' != ''">$(VC_ExecutablePath_ARM64_x86)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_ARM64_x64)' != ''">$(VC_ExecutablePath_ARM64_x64)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_ARM64_ARM)' != ''">$(VC_ExecutablePath_ARM64_ARM)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
    <VC_ExecutablePath_Loc Condition="'$(VC_ExecutablePath_ARM64_ARM64)' != ''">$(VC_ExecutablePath_ARM64_ARM64)\$(LangID);$(VC_ExecutablePath_Loc);</VC_ExecutablePath_Loc>
  </PropertyGroup>
  <!-- WindowsSDK tools architecture needs to match VC tools -->
  <PropertyGroup>
    <WindowsSDKToolArchitecture>$(VCToolArchitecture)</WindowsSDKToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsSDKToolArchitecture)' == 'Native64Bit'">
    <WindowsSDK_ExecutablePath>$(WindowsSDK_ExecutablePath_x64);$(WindowsSDK_ExecutablePath_x86)</WindowsSDK_ExecutablePath>
    <WindowsSdk_71A_ExecutablePath Condition="'$(WindowsSdkDir_71A)' != ''">$(WindowsSdk_71A_ExecutablePath_x64)</WindowsSdk_71A_ExecutablePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsSDKToolArchitecture)' == 'NativeARM64'">
    <WindowsSDK_ExecutablePath>$(WindowsSDK_ExecutablePath_ARM64);$(WindowsSDK_ExecutablePath_x86)</WindowsSDK_ExecutablePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WindowsSDKToolArchitecture)' != 'Native64Bit' and '$(WindowsSDKToolArchitecture)' != 'NativeARM64'">
    <WindowsSDK_ExecutablePath>$(WindowsSDK_ExecutablePath_x86)</WindowsSDK_ExecutablePath>
    <WindowsSdk_71A_ExecutablePath Condition="'$(WindowsSdkDir_71A)' != ''">$(WindowsSdk_71A_ExecutablePath_x86)</WindowsSdk_71A_ExecutablePath>
  </PropertyGroup>
  <!-- Msbuild tools -->
  <PropertyGroup>
    <MSBuild_ExecutablePath>$(MSBuildToolsPath32);$(MSBuildFrameworkToolsPath32)</MSBuild_ExecutablePath>
    <MSBuild_ExecutablePath Condition="'$(VCToolArchitecture)' == 'Native64Bit'">$(MSBuildToolsPath);$(MSBuildFrameworkToolsPath64);$(MSBuildFrameworkToolsPath);$(MSBuild_ExecutablePath)</MSBuild_ExecutablePath>
  </PropertyGroup>
  <!-- VS tools -->
  <PropertyGroup>
    <VS_ExecutablePath>$(VSInstallDir)Common7\tools;$(VSInstallDir)Common7\ide;$(MSBuildProgramFiles32)\HTML Help Workshop;</VS_ExecutablePath>
  </PropertyGroup>
  <!-- Default debugger properties -->
  <PropertyGroup>
    <!-- Local Windows debugger -->
    <LocalDebuggerDebuggerType>Auto</LocalDebuggerDebuggerType>
    <!-- LocalDebuggerCommand is defined into an empty $(TargetPath) for the property page, it is later redefined to its proper value. -->
    <LocalDebuggerCommand Condition="'$(TargetPath)' != ''">$(TargetPath)</LocalDebuggerCommand>
    <LocalDebuggerWorkingDirectory>$(ProjectDir)</LocalDebuggerWorkingDirectory>
    <LocalDebuggerMergeEnvironment>true</LocalDebuggerMergeEnvironment>
    <LocalDebuggerAttach>False</LocalDebuggerAttach>
    <LocalDebuggerSQLDebugging>False</LocalDebuggerSQLDebugging>
    <!-- Remote Windows debugger -->
    <RemoteDebuggerDebuggerType>Auto</RemoteDebuggerDebuggerType>
    <RemoteDebuggerWorkingDirectory>$(ProjectDir)</RemoteDebuggerWorkingDirectory>
    <RemoteDebuggerServerName>$(COMPUTERNAME)</RemoteDebuggerServerName>
    <RemoteDebuggerConnection>RemoteWithAuthentication</RemoteDebuggerConnection>
    <RemoteDebuggerAttach>False</RemoteDebuggerAttach>
    <RemoteDebuggerSQLDebugging>False</RemoteDebuggerSQLDebugging>
    <RemoteDebuggerDeployDebugCppRuntime>false</RemoteDebuggerDeployDebugCppRuntime>
    <RemoteDebuggerDeployCppRuntime>false</RemoteDebuggerDeployCppRuntime>
    <RemoteDebuggerDeployDebugCppRuntime Condition="'$(UseDebugLibraries)' == 'true'">true</RemoteDebuggerDeployDebugCppRuntime>
    <RemoteDebuggerDeployCppRuntime Condition="'$(UseDebugLibraries)' != 'true'">true</RemoteDebuggerDeployCppRuntime>
    <!-- Web Browser debugger -->
    <WebBrowserDebuggerDebuggerType>Auto</WebBrowserDebuggerDebuggerType>
    <!-- Web Service debugger-->
    <WebServiceDebuggerDebuggerType>Auto</WebServiceDebuggerDebuggerType>
    <WebServiceDebuggerSQLDebugging>False</WebServiceDebuggerSQLDebugging>
    <!-- GPU debugger-->
    <LocalGPUDebuggerTargetType Condition="'$(GPUDebuggerTargetType)' == ''">{F4453496-1DB8-47F8-A7D5-31EBDDC2EC96}</LocalGPUDebuggerTargetType>
    <RemoteGPUDebuggerTargetType Condition="'$(GPUDebuggerTargetType)' == ''">{F4453496-1DB8-47F8-A7D5-31EBDDC2EC96}</RemoteGPUDebuggerTargetType>
    <GPURefDebuggerBreakOnAllThreads Condition="'$(GPURefDebuggerBreakOnAllThreads)' == ''">GPURefBreakOncePerWarp</GPURefDebuggerBreakOnAllThreads>
    <DebuggerLaunchApplication>true</DebuggerLaunchApplication>
    <AllowLocalNetworkLoopback>true</AllowLocalNetworkLoopback>
    <DebuggerType>NativeOnly</DebuggerType>
    <DebuggerRequireAuthentication>true</DebuggerRequireAuthentication>
  </PropertyGroup>
  <PropertyGroup>
    <Language>C++</Language>
    <DefaultLanguageSourceExtension>.cpp</DefaultLanguageSourceExtension>
    <AllProjectIncludesArePublic Condition="'$(AllProjectIncludesArePublic)' == ''">false</AllProjectIncludesArePublic>
    <AllProjectBMIsArePublic Condition="'$(AllProjectBMIsArePublic)' == '' and '$(ConfigurationType)' == 'StaticLibrary'">true</AllProjectBMIsArePublic>
    <AllProjectBMIsArePublic Condition="'$(AllProjectBMIsArePublic)' == '' and '$(ConfigurationType)' != 'StaticLibrary'">false</AllProjectBMIsArePublic>
  </PropertyGroup>
  <!-- Define defaults for all tools for property page-->
  <PropertyGroup>
    <TargetName Condition="'$(TargetName)' == ''">$(ProjectName)</TargetName>
    <ExtensionsToDeleteOnClean Condition="'$(ExtensionsToDeleteOnClean)' == ''">*.cdf;*.cache;*.obj;*.obj.enc;*.ilk;*.ipdb;*.iobj;*.resources;*.tlb;*.tli;*.tlh;*.tmp;*.rsp;*.pgc;*.pgd;*.meta;*.tlog;*.manifest;*.res;*.pch;*.exp;*.idb;*.rep;*.xdc;*.pdb;*_manifest.rc;*.bsc;*.sbr;*.xml;*.metagen;*.bi</ExtensionsToDeleteOnClean>
    <IncludeVersionInInteropName Condition="'$(IncludeVersionInInteropName)'==''">true</IncludeVersionInInteropName>
    <InteropOutputPath Condition="'$(InteropOutputPath)'==''">Interop\</InteropOutputPath>
    <EmbedManifest Condition="'$(EmbedManifest)'==''">true</EmbedManifest>
    <PreBuildEventUseInBuild Condition="'$(PreBuildEventUseInBuild)' == ''">true</PreBuildEventUseInBuild>
    <PreLinkEventUseInBuild Condition="'$(PreLinkEventUseInBuild)' == ''">true</PreLinkEventUseInBuild>
    <PostBuildEventUseInBuild Condition="'$(PostBuildEventUseInBuild)' == ''">true</PostBuildEventUseInBuild>
    <DocumentLibraryDependencies Condition="'$(DocumentLibraryDependencies)' == ''">true</DocumentLibraryDependencies>
    <!-- Set to enable using MSBuild Resource Manager -->
    <!--<UseMsbuildResourceManager Condition="'$(UseMsbuildResourceManager)' == ''">true</UseMsbuildResourceManager>-->
    <!--
    MultiToolTask is a helper Task that forgoes MSBuild batching and parallelizes execution itself.  This allows execution of tools with different command line in parallel.
    In addition, setting metadata MultiToolTaskDependency on an item will create a dependency on another item in the same input.
    Set property UseMultiToolTask to enable for all supported tools.
    Set property EnforceProcessCountAcrossBuilds to true to limiter max number of process across multiple msbuild instances.
    Set property MultiProcMaxCount or CL_MPCount to the max number of jobs.  CL_MPCount is set by the IDE.
    -->
    <UseMultiToolTask Condition="'$(UseMultiToolTask)' == ''">false</UseMultiToolTask>
    <EnforceProcessCountAcrossBuilds Condition="'$(EnforceProcessCountAcrossBuilds)' == ''">$(UseMsbuildResourceManager)</EnforceProcessCountAcrossBuilds>
    <MultiProcSchedulerName Condition="'$(MultiProcSchedulerName)' == '' and '$(UseMsbuildResourceManager)' == 'true'">Microsoft.Build.CPPTasks.MsbuildProcessCounter</MultiProcSchedulerName>
    <MultiProcMIDL Condition="'$(MultiProcMIDL)' == '' and '$(UseMultiToolTask)' == 'true'">true</MultiProcMIDL>
    <MultiProcMIDL Condition="'$(MultiProcMIDL)' == ''">false</MultiProcMIDL>
    <MultiProcFXC Condition="'$(MultiProcFXC)' == '' and '$(UseMultiToolTask)' == 'true'">true</MultiProcFXC>
    <MultiProcFXC Condition="'$(MultiProcFXC)' == ''">false</MultiProcFXC>
    <MultiProcCL Condition="'$(MultiProcCL)' == '' and '$(UseMultiToolTask)' == 'true'">true</MultiProcCL>
    <MultiProcCL Condition="'$(MultiProcCL)' == ''">false</MultiProcCL>
    <MultiProcMaxCount Condition="'$(MultiProcMaxCount)' == ''">$(CL_MPCount)</MultiProcMaxCount>
    <MultiProcMaxCount Condition="'$(MultiProcMaxCount)' == ''">0</MultiProcMaxCount>
    <!-- CLR enabled -->
    <EnableManagedIncrementalBuild Condition="$(EnableManagedIncrementalBuild)=='' and '$(CLRSupport)'!='' and '$(CLRSupport)'!='false' and '$(CLRSupport)'!='NetCore'">true</EnableManagedIncrementalBuild>
    <EnableManagedIncrementalBuild Condition="$(EnableManagedIncrementalBuild)==''">false</EnableManagedIncrementalBuild>
    <IgnoreImportLibrary Condition="$(IgnoreImportLibrary)=='' and '$(CLRSupport)'!='' and '$(CLRSupport)'!='false'">true</IgnoreImportLibrary>
    <IgnoreImportLibrary Condition="$(IgnoreImportLibrary)==''">false</IgnoreImportLibrary>
    <GenerateManifest Condition="$(GenerateManifest)==''">true</GenerateManifest>
    <!-- DelayImp.lib -->
    <DelayImplib Condition="'$(DelayImplib)' == ''">Delayimp.lib</DelayImplib>
    <!-- Copy Local is default false for native. -->
    <CopyLocalProjectReference Condition="'$(CopyLocalProjectReference)'==''">false</CopyLocalProjectReference>
    <CopyLocalDeploymentContent Condition="'$(CopyLocalDeploymentContent)'==''">false</CopyLocalDeploymentContent>
    <CopyLocalDebugSymbols Condition="'$(CopyLocalDebugSymbols)'==''">false</CopyLocalDebugSymbols>
    <CopyCppRuntimeToOutputDir Condition="'$(CopyCppRuntimeToOutputDir)'==''">false</CopyCppRuntimeToOutputDir>
    <!-- Generate Recipe Files for Desktop defaults to true. -->
    <GenerateDesktopDeployRecipeFile Condition="'$(GenerateDesktopDeployRecipeFile)' == '' and '$(ApplicationType)' == ''">true</GenerateDesktopDeployRecipeFile>
    <GenerateDesktopDeployRecipeFile Condition="'$(GenerateDesktopDeployRecipeFile)' == '' and '$(ApplicationType)' == 'Windows Store' and '$(DesktopCompatible)'== 'true'">true</GenerateDesktopDeployRecipeFile>
  </PropertyGroup>
  <!-- CRT SDK Reference - used by UWP and Centennial Desktop projects -->
  <PropertyGroup>
    <CrtSDKReferenceVersion Condition="'$(CrtSDKReferenceVersion)' == ''">14.0</CrtSDKReferenceVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DesktopCompatible)' == 'true'">
    <CrtSDKReferenceInclude Condition="'$(CrtSDKReferenceInclude)' == ''">Microsoft.VCLibs.Desktop, Version=$(CrtSDKReferenceVersion)</CrtSDKReferenceInclude>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DesktopCompatible)' != 'true' and '$(EnableAppLocalVCLibs)' != 'true'">
    <CrtSDKReferenceInclude Condition="'$(CrtSDKReferenceInclude)' == ''">Microsoft.VCLibs, Version=$(CrtSDKReferenceVersion)</CrtSDKReferenceInclude>
  </PropertyGroup>
  <!-- Applocal CRT SDK Reference, in case user wants it explicitly by setting 'UseAppLocalVcLibs'. There is no 'Desktop' applocal version of the package. -->
  <PropertyGroup Condition="'$(DesktopCompatible)' != 'true' and '$(EnableAppLocalVCLibs)' == 'true'">
    <CrtSDKReferenceInclude Condition="'$(CrtSDKReferenceInclude)' == ''">Microsoft.VCLibs.AppLocal, Version=$(CrtSDKReferenceVersion)</CrtSDKReferenceInclude>
  </PropertyGroup>
  <!-- Import CL and Link defaults-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cl.Common.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cl.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cl.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- *******************************************************************************************
        CLCompile
       ******************************************************************************************* -->
  <!-- Default cl options -->
  <PropertyGroup>
    <!-- check if older vc toolset which does not support /JMC is used -->
    <VCToolsetSupportsJustMyCode Condition="'$(VCToolsetSupportsJustMyCode)' == '' and&#xD;&#xA;                                            '$(VCToolsVersion)' != ''">true</VCToolsetSupportsJustMyCode>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(UseDebugLibraries)' == 'true'">
    <ClCompile>
      <RuntimeLibrary Condition="'%(ClCompile.RuntimeLibrary)'                == ''">MultiThreadedDebugDll</RuntimeLibrary>
      <BasicRuntimeChecks Condition="'%(ClCompile.BasicRuntimeChecks)' == '' and '$(UseDynamicDebugging)' != 'true'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'%(ClCompile.Optimization)'                  == ''">Disabled</Optimization>
      <SupportJustMyCode Condition="'%(ClCompile.SupportJustMyCode)' == '' and '$(VCToolsetSupportsJustMyCode)' == 'true'">true</SupportJustMyCode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AssemblerOutput Condition="'%(ClCompile.AssemblerOutput)'               == ''">NoListing</AssemblerOutput>
      <AssemblerListingLocation Condition="'%(ClCompile.AssemblerListingLocation)'      == ''">$(IntDir)</AssemblerListingLocation>
      <AcceptableNonZeroExitCodes Condition="'%(ClCompile.AcceptableNonZeroExitCodes)'    == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <UndefineAllPreprocessorDefinitions Condition="'%(ClCompile.UndefineAllPreprocessorDefinitions)' == ''">false</UndefineAllPreprocessorDefinitions>
      <BrowseInformation Condition="'%(ClCompile.BrowseInformation)'             == ''">false</BrowseInformation>
      <BrowseInformationFile Condition="'%(ClCompile.BrowseInformationFile)'         == ''">$(IntDir)</BrowseInformationFile>
      <BasicRuntimeChecks Condition="'%(ClCompile.BasicRuntimeChecks)'            == ''">Default</BasicRuntimeChecks>
      <CompileAs Condition="'%(ClCompile.CompileAs)'                     == ''">Default</CompileAs>
      <UseDynamicDebugging Condition="'%(ClCompile.UseDynamicDebugging)'           == '' and&#xD;&#xA;                                                   '$(UseDynamicDebugging)'                     != 'true'">false</UseDynamicDebugging>
      <ConformanceMode Condition="'%(ClCompile.ConformanceMode)'               == ''">Default</ConformanceMode>
      <DiagnosticsFormat Condition="'%(ClCompile.DiagnosticsFormat)'             == ''">Column</DiagnosticsFormat>
      <DisableLanguageExtensions Condition="'%(ClCompile.DisableLanguageExtensions)'     == ''">false</DisableLanguageExtensions>
      <ErrorReporting Condition="'%(ClCompile.ErrorReporting)'                == ''&#xD;&#xA;                                                   and '$(BuildingInsideVisualStudio)'          == 'true'">Prompt</ErrorReporting>
      <ErrorReporting Condition="'%(ClCompile.ErrorReporting)'                == ''">Queue</ErrorReporting>
      <ExpandAttributedSource Condition="'%(ClCompile.ExpandAttributedSource)'        == ''">false</ExpandAttributedSource>
      <ExceptionHandling Condition="'%(ClCompile.ExceptionHandling)'             == ''">Sync</ExceptionHandling>
      <EnableASAN Condition="'%(ClCompile.EnableASAN)'                    == ''">$(EnableASAN)</EnableASAN>
      <EnableFuzzer Condition="'%(ClCompile.EnableFuzzer)'                  == ''">$(EnableFuzzer)</EnableFuzzer>
      <EnableFiberSafeOptimizations Condition="'%(ClCompile.EnableFiberSafeOptimizations)'  == ''">false</EnableFiberSafeOptimizations>
      <EnableEnhancedInstructionSet Condition="'%(ClCompile.EnableEnhancedInstructionSet)'  == ''">NotSet</EnableEnhancedInstructionSet>
      <EnableVectorLength Condition="'%(ClCompile.EnableVectorLength)'            == ''">NotSet</EnableVectorLength>
      <FloatingPointModel Condition="'%(ClCompile.FloatingPointModel)'            == ''">Precise</FloatingPointModel>
      <ForceConformanceInForLoopScope Condition="'%(ClCompile.ForceConformanceInForLoopScope)'== ''">true</ForceConformanceInForLoopScope>
      <ForcedIncludeFiles Condition="'%(ClCompile.ForcedIncludeFiles)'            == ''" />
      <ForcedUsingFiles Condition="'%(ClCompile.ForcedUsingFiles)'              == ''" />
      <GenerateModuleDependencies Condition="'%(ClCompile.GenerateModuleDependencies)'    == ''">false</GenerateModuleDependencies>
      <GenerateSourceDependencies Condition="'%(ClCompile.GenerateSourceDependencies)'    == ''">false</GenerateSourceDependencies>
      <GenerateXMLDocumentationFiles Condition="'%(ClCompile.GenerateXMLDocumentationFiles)' == ''">false</GenerateXMLDocumentationFiles>
      <InlineFunctionExpansion Condition="'%(ClCompile.InlineFunctionExpansion)'       == ''">Default</InlineFunctionExpansion>
      <IntrinsicFunctions Condition="'%(ClCompile.IntrinsicFunctions)'            == ''">false</IntrinsicFunctions>
      <IgnoreStandardIncludePath Condition="'%(ClCompile.IgnoreStandardIncludePath)'     == ''">false</IgnoreStandardIncludePath>
      <LanguageStandard Condition="'%(ClCompile.LanguageStandard)'              == ''">Default</LanguageStandard>
      <LanguageStandard_C Condition="'%(ClCompile.LanguageStandard_C)'            == ''">Default</LanguageStandard_C>
      <MinimalRebuild Condition="'%(ClCompile.MinimalRebuild)'                == '' and&#xD;&#xA;                                                  ('$(CLRSupport)'                              == '' or&#xD;&#xA;                                                   '$(CLRSupport)'                              == 'false')">false</MinimalRebuild>
      <ModuleDependenciesFile Condition="'%(ClCompile.ModuleDependenciesFile)'        == ''">$(IntDir)</ModuleDependenciesFile>
      <ModuleOutputFile Condition="'%(ClCompile.ModuleOutputFile)'              == ''">$(IntDir)</ModuleOutputFile>
      <MultiProcessorCompilation Condition="'%(ClCompile.MultiProcessorCompilation)'     == '' and&#xD;&#xA;                                                   '$(CL_MP)'                                   == 'true'">true</MultiProcessorCompilation>
      <OmitDefaultLibName Condition="'%(ClCompile.OmitDefaultLibName)'            == ''">false</OmitDefaultLibName>
      <FavorSizeOrSpeed Condition="'%(ClCompile.FavorSizeOrSpeed)'              == ''">Neither</FavorSizeOrSpeed>
      <WholeProgramOptimization Condition="'%(ClCompile.WholeProgramOptimization)'      == ''">false</WholeProgramOptimization>
      <Optimization Condition="'%(ClCompile.Optimization)'                  == '' and&#xD;&#xA;                                                   ('%(ClCompile.BasicRuntimeChecks)'           == '' or&#xD;&#xA;                                                   '%(ClCompile.BasicRuntimeChecks)'            == 'Default')">MaxSpeed</Optimization>
      <ObjectFileName Condition="'%(ClCompile.ObjectFileName)'                == ''">$(IntDir)</ObjectFileName>
      <CallingConvention Condition="'%(ClCompile.CallingConvention)'             == '' and&#xD;&#xA;                                                  ('$(CLRSupport)'                              == '' or&#xD;&#xA;                                                   '$(CLRSupport)'                              == 'false')">Cdecl</CallingConvention>
      <ProgramDataBaseFileName Condition="'%(ClCompile.ProgramDataBaseFileName)'       == '' and&#xD;&#xA;                                                   '$(ConfigurationType)' == 'StaticLibrary'">$(OutDir)$(TargetName).pdb</ProgramDataBaseFileName>
      <ProgramDataBaseFileName Condition="'%(ClCompile.ProgramDataBaseFileName)'       == '' and&#xD;&#xA;                                                   '$(ConfigurationType)' != 'StaticLibrary'">$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <PrecompiledHeader Condition="'%(ClCompile.PrecompiledHeader)'             == ''">NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'%(ClCompile.PrecompiledHeaderFile)'         == ''">stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'%(ClCompile.PrecompiledHeaderOutputFile)'   == ''">$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <PreprocessToFile Condition="'%(ClCompile.PreprocessToFile)'              == ''">false</PreprocessToFile>
      <PreprocessKeepComments Condition="'%(ClCompile.PreprocessKeepComments)'        == ''">false</PreprocessKeepComments>
      <PreprocessSuppressLineNumbers Condition="'%(ClCompile.PreprocessSuppressLineNumbers)' == ''">false</PreprocessSuppressLineNumbers>
      <ProcessorNumber Condition="'$(CL_MPCount)'                              != ''">$(CL_MPCount)</ProcessorNumber>
      <RemoveUnreferencedCodeData Condition="'%(ClCompile.RemoveUnreferencedCodeData)'    == ''">true</RemoveUnreferencedCodeData>
      <RuntimeLibrary Condition="'%(ClCompile.RuntimeLibrary)'                == ''">MultiThreadedDll</RuntimeLibrary>
      <ScanSourceForModuleDependencies Condition="'%(ClCompile.ScanSourceForModuleDependencies)' == ''">false</ScanSourceForModuleDependencies>
      <ShowIncludes Condition="'%(ClCompile.ShowIncludes)'                  == ''">false</ShowIncludes>
      <SourceDependenciesFile Condition="'%(ClCompile.SourceDependenciesFile)'        == ''">$(IntDir)</SourceDependenciesFile>
      <SuppressStartupBanner Condition="'%(ClCompile.SuppressStartupBanner)'         == ''">true</SuppressStartupBanner>
      <BufferSecurityCheck Condition="'%(ClCompile.BufferSecurityCheck)'           == ''">true</BufferSecurityCheck>
      <SmallerTypeCheck Condition="'%(ClCompile.SmallerTypeCheck)'              == ''">false</SmallerTypeCheck>
      <SpectreMitigation Condition="'%(ClCompile.SpectreMitigation)'             == ''">$(SpectreMitigation)</SpectreMitigation>
      <StructMemberAlignment Condition="'%(ClCompile.StructMemberAlignment)'         == ''">Default</StructMemberAlignment>
      <SupportJustMyCode Condition="'%(ClCompile.SupportJustMyCode)'             == ''">false</SupportJustMyCode>
      <TrackerLogDirectory Condition="'%(ClCompile.TrackerLogDirectory)'           == ''">$(TLogLocation)</TrackerLogDirectory>
      <TranslateIncludes Condition="'%(ClCompile.TranslateIncludes)'             == ''">false</TranslateIncludes>
      <MinimalRebuildFromTracking Condition="'%(ClCompile.MinimalRebuildFromTracking)'    == ''">true</MinimalRebuildFromTracking>
      <TreatWarningAsError Condition="'%(ClCompile.TreatWarningAsError)'           == ''">false</TreatWarningAsError>
      <TreatWChar_tAsBuiltInType Condition="'%(ClCompile.TreatWChar_tAsBuiltInType)'     == ''">true</TreatWChar_tAsBuiltInType>
      <UseFullPaths Condition="'%(ClCompile.UseFullPaths)'                  == ''">true</UseFullPaths>
      <WarningLevel Condition="'%(ClCompile.WarningLevel)'                  == ''">Level1</WarningLevel>
      <XMLDocumentationFileName Condition="'%(ClCompile.XMLDocumentationFileName)'      == ''">$(IntDir)</XMLDocumentationFileName>
      <DebugInformationFormatDefined Condition="'%(ClCompile.DebugInformationFormat)'        != ''">true</DebugInformationFormatDefined>
      <DebugInformationFormat Condition="'%(ClCompile.DebugInformationFormat)'        == ''">ProgramDatabase</DebugInformationFormat>
      <IntelJCCErratum Condition="'%(ClCompile.IntelJCCErratum)'               == ''">false</IntelJCCErratum>
      <BuildStlModules Condition="'%(ClCompile.BuildStlModules)'               == ''">false</BuildStlModules>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(_ClExternalIncludesSupported)' == 'true'">
    <ClCompile>
      <TreatAngleIncludeAsExternal Condition="'%(ClCompile.TreatAngleIncludeAsExternal)' == ''">false</TreatAngleIncludeAsExternal>
      <ExternalWarningLevel Condition="'%(ClCompile.ExternalWarningLevel)' == ''">InheritWarningLevel</ExternalWarningLevel>
      <TreatExternalTemplatesAsInternal Condition="'%(ClCompile.TreatExternalTemplatesAsInternal)' == ''">true</TreatExternalTemplatesAsInternal>
      <DisableAnalyzeExternal Condition="'%(ClCompile.DisableAnalyzeExternal)' == ''">false</DisableAnalyzeExternal>
    </ClCompile>
  </ItemDefinitionGroup>
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.Unity.props" Condition="'$(EnableUnitySupport)' == 'true'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Link.Common.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Link.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Link.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- *******************************************************************************************
        Link
       ******************************************************************************************* -->
  <!-- Default link options -->
  <ItemDefinitionGroup>
    <Link>
      <AllowIsolation Condition="'%(Link.AllowIsolation)'              == ''">true</AllowIsolation>
      <SuppressStartupBanner Condition="'%(Link.SuppressStartupBanner)'       == ''">true</SuppressStartupBanner>
      <TrackerLogDirectory Condition="'%(Link.TrackerLogDirectory)'         == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(Link.MinimalRebuildFromTracking)'  == ''">true</MinimalRebuildFromTracking>
      <ImportLibrary Condition="'%(Link.ImportLibrary)'               == '' and&#xD;&#xA;                                              '$(IgnoreImportLibrary)'              != 'true' and&#xD;&#xA;                                             ('$(CLRSupport)'                       == 'false' or&#xD;&#xA;                                              '$(CLRSupport)'                       == '') and&#xD;&#xA;                                              '$(ConfigurationType)'                == 'DynamicLibrary'">$(OutDir)$(TargetName).lib</ImportLibrary>
      <OutputFile Condition="'%(Link.OutputFile)'                  == ''">$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <ManifestFile Condition="'%(Link.ManifestFile)'                == '' ">$(IntDir)$(TargetName)$(TargetExt).intermediate.manifest</ManifestFile>
      <ProgramDatabaseFile Condition="'%(Link.ProgramDatabaseFile)'         == ''">$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <Profile Condition="'%(Link.Profile)'                     == ''">false</Profile>
      <ProfileGuidedDatabase Condition="'%(Link.ProfileGuidedDatabase)'       == ''">$(OutDir)$(TargetName).pgd</ProfileGuidedDatabase>
      <EnableUAC Condition="'%(Link.EnableUAC)'                   == ''">true</EnableUAC>
      <UACExecutionLevel Condition="'%(Link.UACExecutionLevel)'           == ''">AsInvoker</UACExecutionLevel>
      <UACUIAccess Condition="'%(Link.UACUIAccess)'                 == ''">false</UACUIAccess>
      <LinkErrorReporting Condition="'%(Link.LinkErrorReporting)'          == '' and&#xD;&#xA;                                              '$(BuildingInsideVisualStudio)'       == 'true'">PromptImmediately</LinkErrorReporting>
      <LinkErrorReporting Condition="'%(Link.LinkErrorReporting)'          == ''">QueueForNextLogin</LinkErrorReporting>
      <AcceptableNonZeroExitCodes Condition="'%(Link.AcceptableNonZeroExitCodes)'  == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <RandomizedBaseAddress Condition="'%(Link.RandomizedBaseAddress)'       == ''">true</RandomizedBaseAddress>
      <DataExecutionPrevention Condition="'%(Link.DataExecutionPrevention)'     == ''">true</DataExecutionPrevention>
      <CLRImageType Condition="'%(Link.CLRImageType)'                == ''">Default</CLRImageType>
      <KeyFile Condition="'%(Link.KeyFile)'                     == ''" />
      <DelaySign Condition="'%(Link.DelaySign)'                   == ''" />
      <Driver Condition="'%(Link.Driver)'                      == ''">NotSet</Driver>
      <RegisterOutput Condition="'%(Link.RegisterOutput)'              == ''">false</RegisterOutput>
      <PerUserRedirection Condition="'%(Link.PerUserRedirection)'          == ''">false</PerUserRedirection>
      <TurnOffAssemblyGeneration Condition="'%(Link.TurnOffAssemblyGeneration)'   == ''">false</TurnOffAssemblyGeneration>
      <GenerateDebugInformation Condition="'%(Link.GenerateDebugInformation)'    == ''">DebugFull</GenerateDebugInformation>
      <GenerateMapFile Condition="'%(Link.GenerateMapFile)'             == ''">false</GenerateMapFile>
      <MapExports Condition="'%(Link.MapExports)'                  == ''">false</MapExports>
      <SwapRunFromCD Condition="'%(Link.SwapRunFromCD)'               == ''">false</SwapRunFromCD>
      <SwapRunFromNET Condition="'%(Link.SwapRunFromNET)'              == ''">false</SwapRunFromNET>
      <IgnoreEmbeddedIDL Condition="'%(Link.IgnoreEmbeddedIDL)'           == ''">false</IgnoreEmbeddedIDL>
      <TypeLibraryResourceID Condition="'%(Link.TypeLibraryResourceID)'       == ''">1</TypeLibraryResourceID>
      <NoEntryPoint Condition="'%(Link.NoEntryPoint)'                == ''">false</NoEntryPoint>
      <SetChecksum Condition="'%(Link.SetChecksum)'                 == ''">false</SetChecksum>
      <ShowProgress Condition="'%(Link.ShowProgress)'                == ''">NotSet</ShowProgress>
      <IncrementalLinkDatabaseFile Condition="'%(Link.IncrementalLinkDatabaseFile)' == '' and '$(_LinkILKSupported)' == 'true'">$(IntDir)$(TargetName).ilk</IncrementalLinkDatabaseFile>
      <LinkTimeCodeGenerationObjectFile Condition="'%(Link.LinkTimeCodeGenerationObjectFile)' == '' and '$(_LinkLTCGOUTSupported)' == 'true'">$(IntDir)$(TargetName).iobj</LinkTimeCodeGenerationObjectFile>
      <UseDynamicDebugging Condition="'%(Link.UseDynamicDebugging)'         == '' and&#xD;&#xA;                                              '$(UseDynamicDebugging)'              != 'true'">false</UseDynamicDebugging>
    </Link>
    <ImpLib>
      <LinkErrorReporting Condition="'%(ImpLib.LinkErrorReporting)'           == '' and&#xD;&#xA;                                              '$(BuildingInsideVisualStudio)'          == 'true'">PromptImmediately</LinkErrorReporting>
      <LinkErrorReporting Condition="'%(ImpLib.LinkErrorReporting)'           == ''">QueueForNextLogin</LinkErrorReporting>
      <TrackerLogDirectory Condition="'%(ImpLib.TrackerLogDirectory)'          == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(ImpLib.MinimalRebuildFromTracking)'   == ''">true</MinimalRebuildFromTracking>
      <SuppressStartupBanner Condition="'%(ImpLib.SuppressStartupBanner)'        == ''">true</SuppressStartupBanner>
      <AcceptableNonZeroExitCodes Condition="'%(ImpLib.AcceptableNonZeroExitCodes)'   == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
    </ImpLib>
  </ItemDefinitionGroup>
  <PropertyGroup>
    <LinkIncremental Condition="'$(UseDebugLibraries)' == 'true' and '$(LinkIncremental)'=='' and '$(UseDynamicDebugging)' != 'true'">true</LinkIncremental>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!-- Import Analysis defaults-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Analysis.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Analysis.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Analysis.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Override these to determine what analysis tools will be run and when -->
    <RunCodeAnalysis Condition="'$(RunCodeAnalysis)' == ''">false</RunCodeAnalysis>
    <EnableMicrosoftCodeAnalysis Condition="'$(EnableMicrosoftCodeAnalysis)' == ''">true</EnableMicrosoftCodeAnalysis>
    <EnableClangTidyCodeAnalysis Condition="'$(EnableClangTidyCodeAnalysis)' == ''">false</EnableClangTidyCodeAnalysis>
    <EnableMicrosoftCodeAnalysis Condition="'$(ApplicationType)' == 'Linux'">false</EnableMicrosoftCodeAnalysis>
    <!-- Default analysis tools to drive background analysis in the IDE -->
    <MsvcAnalysisToolsPath>$(VC_ExecutablePath_x64_x64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisPluginPath>$(VC_ExecutablePath_x64_x64)</MsvcAnalysisPluginPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VCToolArchitecture)'=='Native32Bit'">
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='x86'">$(VC_ExecutablePath_x86_x86)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='x64'">$(VC_ExecutablePath_x86_x64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='arm'">$(VC_ExecutablePath_X86_ARM)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='arm64'">$(VC_ExecutablePath_X86_ARM64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisPluginPath>$(MsvcAnalysisToolsPath)</MsvcAnalysisPluginPath>
    <MsvcAnalysisPluginPath Condition="'$(_CodeAnalysisExtensions)' != 'true'">$(VC_ExecutablePath_x86_x86)</MsvcAnalysisPluginPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VCToolArchitecture)'=='Native64Bit'">
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='x86'">$(VC_ExecutablePath_x64_x86)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='x64'">$(VC_ExecutablePath_X64_x64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='arm'">$(VC_ExecutablePath_X64_ARM)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='arm64'">$(VC_ExecutablePath_X64_ARM64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisPluginPath>$(MsvcAnalysisToolsPath)</MsvcAnalysisPluginPath>
    <MsvcAnalysisPluginPath Condition="'$(_CodeAnalysisExtensions)' != 'true'">$(VC_ExecutablePath_x64_x64)</MsvcAnalysisPluginPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VCToolArchitecture)'=='NativeARM64'">
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='x86'">$(VC_ExecutablePath_ARM64_x86)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='x64'">$(VC_ExecutablePath_ARM64_x64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='arm'">$(VC_ExecutablePath_ARM64_ARM)</MsvcAnalysisToolsPath>
    <MsvcAnalysisToolsPath Condition="'$(PlatformTarget)'=='arm64'">$(VC_ExecutablePath_ARM64_ARM64)</MsvcAnalysisToolsPath>
    <MsvcAnalysisPluginPath>$(MsvcAnalysisToolsPath)</MsvcAnalysisPluginPath>
    <MsvcAnalysisPluginPath Condition="'$(_CodeAnalysisExtensions)' != 'true'">$(VC_ExecutablePath_ARM64_ARM64)</MsvcAnalysisPluginPath>
  </PropertyGroup>
  <PropertyGroup>
    <ClCompilerPath Condition="'$(ClCompilerPath)' == ''">$(MsvcAnalysisPluginPath)\cl.exe</ClCompilerPath>
  </PropertyGroup>
  <!-- Experimental tooling diagnostics. -->
  <PropertyGroup>
    <EnableExperimentalDiagnostics Condition="'$(EnableExperimentalDiagnostics)' == ''">false</EnableExperimentalDiagnostics>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.CodeAnalysis.props" Condition="exists('$(VCTargetsPath)\Microsoft.CodeAnalysis.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CodeAnalysis.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CodeAnalysis.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition="'$(ConfigurationType)'!='Utility' and '$(ConfigurationType)'!='Makefile'">
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)\fxcop.xml" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.CodeAnalysis.Extensions.props" Condition="exists('$(VCTargetsPath)\Microsoft.CodeAnalysis.Extensions.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CodeAnalysis.Extensions.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CodeAnalysis.Extensions.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(ConfigurationType)'!='Utility' and '$(ConfigurationType)'!='Makefile'">
    <!-- Add the CppCoreCheck extension only if it wasn't explicitly set false in the project (allow project override) -->
    <!-- To disable CppCoreCheck, set property EnableCppCoreCheck=false in the project -->
    <EspXtensions Condition="'$(EnableCppCoreCheck)'!='false'">CppCoreCheck.dll;$(EspXtensions)</EspXtensions>
    <!-- Add the EnumIndex extension only if it wasn't explicitly set false in the project (allow project override) -->
    <!-- To disable EnumIndex, set property EnableEnumIndex=false in the project -->
    <EspXtensions Condition="'$(EnableEnumIndex)'!='false'">EnumIndex.dll;$(EspXtensions)</EspXtensions>
    <!-- Add the HResultCheck extension only if it wasn't explicitly set false in the project (allow project override) -->
    <!-- To disable HResultCheck, set property EnableHResultCheck=false in the project -->
    <EspXtensions Condition="'$(EnableHResultCheck)'!='false'">HResultCheck.dll;$(EspXtensions)</EspXtensions>
    <!-- Add the VariantClear extension only if it wasn't explicitly set false in the project (allow project override) -->
    <!-- To disable VariantClear, set property EnableVariantClear=false in the project -->
    <EspXtensions Condition="'$(EnableVariantClear)'!='false'">VariantClear.dll;$(EspXtensions)</EspXtensions>
    <!-- Add the ConcurrencyCheck extension  only if it wasn't explicitly set false in the project (allow project override) -->
    <!-- To disable ConcurrencyCheck, set property EnableConcurrencyCheck=false in the project -->
    <ConcurrencyCheckPath>$(VC_ExecutablePath_x86_x86)\ConcurrencyCheck.dll</ConcurrencyCheckPath>
    <ConcurrencyCheckPath Condition="'$(VCToolArchitecture)'=='Native64Bit'">$(VC_ExecutablePath_x64_x64)\ConcurrencyCheck.dll</ConcurrencyCheckPath>
    <ConcurrencyCheckPath Condition="'$(VCToolArchitecture)'=='NativeARM64'">$(VC_ExecutablePath_ARM64_ARM64)\ConcurrencyCheck.dll</ConcurrencyCheckPath>
    <ConcurrencyCheckPath Condition="'$(_CodeAnalysisExtensions)' == 'true' and '$(MsvcAnalysisPluginPath)' != ''">$(MsvcAnalysisPluginPath)\ConcurrencyCheck.dll</ConcurrencyCheckPath>
    <EspXtensions Condition="'$(EnableConcurrencyCheck)'!='false' and ('$(_CodeAnalysisExtensions)' == 'true' or Exists('$(ConcurrencyCheckPath)'))">ConcurrencyCheck.dll;$(EspXtensions)</EspXtensions>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.ClangTidy.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.ClangTidy.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.ClangTidy.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(LLVMInstallDir)' == ''">
    <ClangTidyLLVMInstallDir Condition="'$(PreferredToolArchitecture)' == 'arm64'">$(VsInstallRoot)\VC\Tools\Llvm\ARM64</ClangTidyLLVMInstallDir>
    <ClangTidyLLVMInstallDir Condition="'$(PreferredToolArchitecture)' == 'x64'">$(VsInstallRoot)\VC\Tools\Llvm\x64</ClangTidyLLVMInstallDir>
    <ClangTidyLLVMInstallDir Condition="'$(PreferredToolArchitecture)' != 'x64' AND '$(PreferredToolArchitecture)' != 'arm64'">$(VsInstallRoot)\VC\Tools\Llvm</ClangTidyLLVMInstallDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(LLVMInstallDir)' != ''">
    <ClangTidyLLVMInstallDir>$(LLVMInstallDir)</ClangTidyLLVMInstallDir>
  </PropertyGroup>
  <PropertyGroup>
    <ClangTidyToolExe Condition="'$(ClangTidyToolExe)'==''">clang-tidy.exe</ClangTidyToolExe>
    <!-- ClangTidyToolExeAdditionalOptions is added to the clang-tidy.exe commandline. -->
    <ClangTidyToolExeAdditionalOptions Condition="'$(ClangTidyToolExeAdditionalOptions)'==''" />
    <ClangTidyChecks Condition="'$(ClangTidyChecks)'==''" />
    <ClangTidyHeaderFilter Condition="'$(ClangTidyHeaderFilter)'==''" />
    <ClangTidyWarningsInSystemHeaders Condition="'$(ClangTidyWarningsInSystemHeaders)'==''">false</ClangTidyWarningsInSystemHeaders>
    <ClangTidyPlatformTargetSwitch Condition="'$(PlatformTarget)'=='x86'">--target=i686-pc-windows-msvc</ClangTidyPlatformTargetSwitch>
    <ClangTidyPlatformTargetSwitch Condition="'$(PlatformTarget)'=='x64'">--target=amd64-pc-windows-msvc</ClangTidyPlatformTargetSwitch>
    <ClangTidyPlatformTargetSwitch Condition="'$(PlatformTarget)'=='arm64'">--target=arm64-pc-windows-msvc</ClangTidyPlatformTargetSwitch>
    <!-- ClangTidyAdditionalOptions is added to the compile commands -->
    <ClangTidyAdditionalOptions>$(ClangTidyPlatformTargetSwitch) $(ClangTidyAdditionalOptions)</ClangTidyAdditionalOptions>
    <ClangTidyToolPath Condition="'$(ClangTidyToolPath)'==''">$(ClangTidyLLVMInstallDir)\bin</ClangTidyToolPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!-- Import headers and libs for Cpp UT projects -->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.UnitTest.props" Condition="exists('$(VCTargetsPath)\Microsoft.Cpp.UnitTest.props')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.UnitTest.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.UnitTest.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Include UnitTest headers & static libraries & copy debug cpp runtime to output directory by default -->
  <PropertyGroup Condition="'$(AppContainerApplication)' != 'true' and '$(ApplicationType)' == '' and ('$(ProjectSubType)' == 'NativeUnitTestProject' or '$(VCProjectVersion)' == '') and exists('$(VCInstallDir)Auxiliary\VS\UnitTest\lib')">
    <VC_IncludePath>$(VC_IncludePath);$(VCInstallDir)Auxiliary\VS\UnitTest\include</VC_IncludePath>
    <VC_LibraryPath_x86>$(VC_LibraryPath_x86);$(VCInstallDir)Auxiliary\VS\UnitTest\lib</VC_LibraryPath_x86>
    <VC_LibraryPath_x64>$(VC_LibraryPath_x64);$(VCInstallDir)Auxiliary\VS\UnitTest\lib</VC_LibraryPath_x64>
    <VC_LibraryPath_ARM>$(VC_LibraryPath_ARM);$(VCInstallDir)Auxiliary\VS\UnitTest\lib</VC_LibraryPath_ARM>
    <VC_LibraryPath_ARM64>$(VC_LibraryPath_ARM64);$(VCInstallDir)Auxiliary\VS\UnitTest\lib</VC_LibraryPath_ARM64>
    <CopyCppRuntimeToOutputDir Condition="'$(UseDebugLibraries)'=='true' and '$(BuildingInsideVisualStudio)'=='true' and Exists('$(SolutionDir)\testenvironments.json')">true</CopyCppRuntimeToOutputDir>
  </PropertyGroup>
  <!-- Include UnitTest headers & static libraries for UWP -->
  <PropertyGroup Condition="'$(AppContainerApplication)' == 'true' and ('$(ProjectSubType)' == 'NativeUnitTestProject' or '$(UnitTestPlatformVersion)' != '') and exists('$(VCInstallDir)Auxiliary\VS\UnitTest\lib')">
    <VC_IncludePath>$(VC_IncludePath);$(VCInstallDir)Auxiliary\VS\UnitTest\include\UWP</VC_IncludePath>
    <VC_LibraryPath_x86>$(VC_LibraryPath_x86);$(VCInstallDir)Auxiliary\VS\UnitTest\lib\UWP</VC_LibraryPath_x86>
    <VC_LibraryPath_x64>$(VC_LibraryPath_x64);$(VCInstallDir)Auxiliary\VS\UnitTest\lib\UWP</VC_LibraryPath_x64>
    <VC_LibraryPath_ARM>$(VC_LibraryPath_ARM);$(VCInstallDir)Auxiliary\VS\UnitTest\lib\UWP</VC_LibraryPath_ARM>
    <VC_LibraryPath_ARM64>$(VC_LibraryPath_ARM64);$(VCInstallDir)Auxiliary\VS\UnitTest\lib\UWP</VC_LibraryPath_ARM64>
    <UnitTestPlatformVersion Condition="'$(UnitTestPlatformVersion)' == '14.0'">15.0</UnitTestPlatformVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ProjectSubType)' == 'NativeUnitTestProject'">
    <CopyAsanBinariesToOutDir>true</CopyAsanBinariesToOutDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <PropertyGroup>
    <VCLibPackagePath Condition="'$(VCLibPackagePath)' == ''">$(LOCALAPPDATA)\vcpkg\vcpkg.user</VCLibPackagePath>
  </PropertyGroup>
  <!--<Import Project="$(VCLibPackagePath).props" Condition="'$(VCLibPackagePath)' != '' and Exists('$(VCLibPackagePath).props')" />-->
  <ItemDefinitionGroup>
    <CustomBuild>
      <Message Condition="'%(CustomBuild.Message)'                    == ''">Performing Custom Build Tools</Message>
      <LinkObjects Condition="'%(CustomBuild.LinkObjects)'                == ''">true</LinkObjects>
      <TreatOutputAsContent Condition="'%(CustomBuild.TreatOutputAsContent)'       == ''">false</TreatOutputAsContent>
      <TrackerLogDirectory Condition="'%(CustomBuild.TrackerLogDirectory)'        == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(CustomBuild.MinimalRebuildFromTracking)' == ''">true</MinimalRebuildFromTracking>
      <AcceptableNonZeroExitCodes Condition="'%(CustomBuild.AcceptableNonZeroExitCodes)' == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <BuildInParallel Condition="'%(CustomBuild.BuildInParallel)'            == ''">false</BuildInParallel>
      <MaxProcesses Condition="'%(CustomBuild.MaxProcesses)'               == ''">0</MaxProcesses>
      <MaxItemsInBatch Condition="'%(CustomBuild.MaxItemsInBatch)'            == ''">0</MaxItemsInBatch>
      <VerifyInputsAndOutputsExist Condition="'%(CustomBuild.VerifyInputsAndOutputsExist)' == ''">true</VerifyInputsAndOutputsExist>
    </CustomBuild>
    <CustomBuildStep>
      <Message Condition="'%(CustomBuildStep.Message)'=='' and '$(LangID)'=='1033'">Performing Custom Build Step</Message>
    </CustomBuildStep>
    <Lib>
      <TrackerLogDirectory Condition="'%(Lib.TrackerLogDirectory)'          == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(Lib.MinimalRebuildFromTracking)'   == ''">true</MinimalRebuildFromTracking>
      <OutputFile Condition="'%(Lib.OutputFile)'                   == ''">$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner Condition="'%(Lib.SuppressStartupBanner)'        == ''">true</SuppressStartupBanner>
      <AcceptableNonZeroExitCodes Condition="'%(Lib.AcceptableNonZeroExitCodes)'   == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
    </Lib>
    <Midl>
      <TypeLibraryName Condition="'%(Midl.TypeLibraryName)'                    == ''">$(IntDir)$(ProjectName).tlb</TypeLibraryName>
      <WarningLevel Condition="'%(Midl.WarningLevel)'                       == ''">1</WarningLevel>
      <DefaultCharType Condition="'%(Midl.DefaultCharType)'                    == ''">Signed</DefaultCharType>
      <SuppressStartupBanner Condition="'%(Midl.SuppressStartupBanner)'              == ''">true</SuppressStartupBanner>
      <TrackerLogDirectory Condition="'%(Midl.TrackerLogDirectory)'                == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(Midl.MinimalRebuildFromTracking)'         == ''">true</MinimalRebuildFromTracking>
      <AcceptableNonZeroExitCodes Condition="'%(Midl.AcceptableNonZeroExitCodes)'         == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <IgnoreStandardIncludePath Condition="'%(Midl.IgnoreStandardIncludePath)'          == ''">false</IgnoreStandardIncludePath>
      <WarnAsError Condition="'%(Midl.WarnAsError)'                        == ''">false</WarnAsError>
      <GenerateTypeLibrary Condition="'%(Midl.GenerateTypeLibrary)'                == ''">true</GenerateTypeLibrary>
      <ErrorCheckAllocations Condition="'%(Midl.ErrorCheckAllocations)'              == ''">false</ErrorCheckAllocations>
      <ErrorCheckBounds Condition="'%(Midl.ErrorCheckBounds)'                   == ''">false</ErrorCheckBounds>
      <ErrorCheckEnumRange Condition="'%(Midl.ErrorCheckEnumRange)'                == ''">false</ErrorCheckEnumRange>
      <ErrorCheckRefPointers Condition="'%(Midl.ErrorCheckRefPointers)'              == ''">false</ErrorCheckRefPointers>
      <ErrorCheckStubData Condition="'%(Midl.ErrorCheckStubData)'                 == ''">false</ErrorCheckStubData>
      <StructMemberAlignment Condition="'%(Midl.StructMemberAlignment)'              == ''">NotSet</StructMemberAlignment>
      <HeaderFileName Condition="'%(Midl.HeaderFileName)'                     == ''">%(Filename)_h.h</HeaderFileName>
      <UseResponseFile Condition="'%(Midl.UseResponseFile)'                    == ''">false</UseResponseFile>
      <MinimumTargetSystem Condition="'%(Midl.MinimumTargetSystem)'                == '' and '$(DefineWindowsSDK_71A)' != 'true'">NT60</MinimumTargetSystem>
    </Midl>
    <FxCompile>
      <ObjectFileOutput Condition="'%(FxCompile.ObjectFileOutput)'              == ''">$(OutDir)%(Filename).cso</ObjectFileOutput>
      <TrackerLogDirectory Condition="'%(FxCompile.TrackerLogDirectory)'           == ''">$(TLogLocation)</TrackerLogDirectory>
      <EntryPointName Condition="'%(FxCompile.EntryPointName)'                == ''">main</EntryPointName>
      <SuppressStartupBanner Condition="'%(FxCompile.SuppressStartupBanner)'         == ''">true</SuppressStartupBanner>
      <ShaderModel Condition="'%(FxCompile.ShaderModel)'                   == ''">4.0_level_9_3</ShaderModel>
      <MinimalRebuildFromTracking Condition="'%(FxCompile.MinimalRebuildFromTracking)'    == ''">true</MinimalRebuildFromTracking>
      <DisableOptimizations Condition="'$(UseDebugLibraries)' == 'true' and '%(FxCompile.ShaderModel)' != '2.0' and '%(FxCompile.ShaderModel)' != '3.0' and '%(FxCompile.ShaderModel)' != '4.0_level_9_1'">true</DisableOptimizations>
      <EnableDebuggingInformation Condition="'$(UseDebugLibraries)' == 'true' and '%(FxCompile.ShaderModel)' != '2.0' and '%(FxCompile.ShaderModel)' != '3.0' and '%(FxCompile.ShaderModel)' != '4.0_level_9_1'">true</EnableDebuggingInformation>
      <DisableOptimizations Condition="'$(UseDebugLibraries)'                       != 'true'">false</DisableOptimizations>
      <EnableDebuggingInformation Condition="'$(UseDebugLibraries)'                       != 'true'">false</EnableDebuggingInformation>
    </FxCompile>
    <ResourceCompile>
      <ResourceOutputFileName Condition="'%(ResourceCompile.ResourceOutputFileName)'        == ''">$(IntDir)%(Filename).res</ResourceOutputFileName>
      <Culture Condition="'%(ResourceCompile.Culture)'                       == ''">0x0409</Culture>
      <TrackerLogDirectory Condition="'%(ResourceCompile.TrackerLogDirectory)'           == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(ResourceCompile.MinimalRebuildFromTracking)'    == ''">true</MinimalRebuildFromTracking>
      <AcceptableNonZeroExitCodes Condition="'%(ResourceCompile.AcceptableNonZeroExitCodes)'    == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <UseResponseFile Condition="'%(ResourceCompile.UseResponseFile)'               == ''">false</UseResponseFile>
    </ResourceCompile>
    <Manifest>
      <TrackerLogDirectory Condition="'%(Manifest.TrackerLogDirectory)'            == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(Manifest.MinimalRebuildFromTracking)'     == ''">true</MinimalRebuildFromTracking>
      <SuppressStartupBanner Condition="'%(Manifest.SuppressStartupBanner)'          == ''">true</SuppressStartupBanner>
      <AcceptableNonZeroExitCodes Condition="'%(Manifest.AcceptableNonZeroExitCodes)'     == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <VerboseOutput Condition="'%(Manifest.VerboseOutput)'                  == ''">true</VerboseOutput>
      <GenerateCatalogFiles Condition="'%(Manifest.GenerateCatalogFiles)'           == ''">false</GenerateCatalogFiles>
      <UpdateFileHashes Condition="'%(Manifest.UpdateFileHashes)'               == ''">false</UpdateFileHashes>
      <OutputManifestFile Condition="'$(EmbedManifest)'                           == 'false'">$(TargetPath).manifest</OutputManifestFile>
      <!-- The manifest has been embedded via Link, but we might still need to run MT.  Place the output manifest into IntDir as it isn't part of the final outputs. -->
      <OutputManifestFile Condition="'$(EmbedManifest)'                           == 'true' AND '$(EmbedManifestBy)'=='LINK'">$(IntDir)$(TargetName)$(TargetExt).embed.manifest</OutputManifestFile>
    </Manifest>
    <ManifestResourceCompile>
      <ResourceOutputFileName Condition="'%(ManifestResourceCompile.ResourceOutputFileName)' == '' and '$(EmbedManifestBy)'=='LINK'">$(IntDir)$(TargetName)$(TargetExt).embed.manifest.res</ResourceOutputFileName>
    </ManifestResourceCompile>
    <XdcMake>
      <TrackerLogDirectory Condition="'%(XdcMake.TrackerLogDirectory)'            == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(XdcMake.MinimalRebuildFromTracking)'     == ''">true</MinimalRebuildFromTracking>
      <SuppressStartupBanner Condition="'%(XdcMake.SuppressStartupBanner)'          == ''">true</SuppressStartupBanner>
      <OutputFile Condition="'%(XdcMake.OutputFile)'                     == ''">$(OutDir)$(TargetName).xml</OutputFile>
      <AcceptableNonZeroExitCodes Condition="'%(XdcMake.AcceptableNonZeroExitCodes)'     == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
      <DocumentLibraryDependencies Condition="'%(XdcMake.DocumentLibraryDependencies)'    == ''">true</DocumentLibraryDependencies>
    </XdcMake>
    <BscMake>
      <TrackerLogDirectory Condition="'%(BscMake.TrackerLogDirectory)'            == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(BscMake.MinimalRebuildFromTracking)'     == ''">true</MinimalRebuildFromTracking>
      <SuppressStartupBanner Condition="'%(BscMake.SuppressStartupBanner)'          == ''">true</SuppressStartupBanner>
      <PreserveSBR Condition="'%(BscMake.PreserveSBR)'                    == ''">false</PreserveSBR>
      <OutputFile Condition="'%(BscMake.OutputFile)'                     == ''">$(OutDir)$(TargetName).bsc</OutputFile>
      <AcceptableNonZeroExitCodes Condition="'%(BscMake.AcceptableNonZeroExitCodes)'     == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
    </BscMake>
    <XSD>
      <TrackerLogDirectory Condition="'%(XSD.TrackerLogDirectory)'            == ''">$(TLogLocation)</TrackerLogDirectory>
      <MinimalRebuildFromTracking Condition="'%(XSD.MinimalRebuildFromTracking)'     == ''">true</MinimalRebuildFromTracking>
      <SuppressStartupBanner Condition="'%(XSD.SuppressStartupBanner)'          == ''">true</SuppressStartupBanner>
      <Language Condition="'%(XSD.Language)'                       == ''">cpp</Language>
      <Namespace Condition="'%(XSD.Namespace)'                      == ''">$(TargetName)</Namespace>
      <GenerateFromSchema Condition="'%(XSD.GenerateFromSchema)'             == ''">dataset</GenerateFromSchema>
      <AcceptableNonZeroExitCodes Condition="'%(XSD.AcceptableNonZeroExitCodes)'     == ''">$(AcceptableNonZeroExitCodes)</AcceptableNonZeroExitCodes>
    </XSD>
    <ProjectReference>
      <LinkLibraryDependencies Condition="'%(ProjectReference.LinkLibraryDependencies)' == '' and '$(ConfigurationType)' == 'StaticLibrary'">false</LinkLibraryDependencies>
      <LinkLibraryDependencies Condition="'%(ProjectReference.LinkLibraryDependencies)' == ''">true</LinkLibraryDependencies>
      <UseLibraryDependencyInputs Condition="'%(ProjectReference.UseLibraryDependencyInputs)' == ''">false</UseLibraryDependencyInputs>
      <ReferenceOutputAssembly Condition="'%(ProjectReference.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      <Private Condition="'%(ProjectReference.Private)' == ''">true</Private>
    </ProjectReference>
    <Reference>
      <ReferenceOutputAssembly>true</ReferenceOutputAssembly>
      <CopyLocalSatelliteAssemblies>true</CopyLocalSatelliteAssemblies>
    </Reference>
    <COMReference>
      <ReferenceOutputAssembly>true</ReferenceOutputAssembly>
      <CopyLocalSatelliteAssemblies>true</CopyLocalSatelliteAssemblies>
    </COMReference>
  </ItemDefinitionGroup>
  <ItemGroup>
    <!--  Unique items for the project-->
    <CustomBuildStep Include="$(ProjectName)" />
    <PreBuildEvent Include="$(ProjectName)" />
    <PreLinkEvent Include="$(ProjectName)" />
    <PostBuildEvent Include="$(ProjectName)" />
  </ItemGroup>
  <ItemDefinitionGroup>
    <ResourceCompile>
      <SuppressStartupBanner Condition="'%(ResourceCompile.SuppressStartupBanner)' == ''">true</SuppressStartupBanner>
    </ResourceCompile>
    <ManifestResourceCompile>
      <SuppressStartupBanner Condition="'%(ManifestResourceCompile.SuppressStartupBanner)'==''">true</SuppressStartupBanner>
    </ManifestResourceCompile>
    <Manifest>
      <EnableDPIAwareness Condition="'%(Manifest.EnableDPIAwareness)' == '' AND '$(UseOfMFC)' == 'static'">true</EnableDPIAwareness>
      <EnableDPIAwareness Condition="'%(Manifest.EnableDPIAwareness)' == '' AND '$(UseOfMFC)' == 'dynamic'">true</EnableDPIAwareness>
      <EnableDPIAwareness Condition="'%(Manifest.EnableDPIAwareness)' == '' AND '$(UseOfMFC)' != 'static' AND '$(UseOfMFC)' != 'dynamic'">false</EnableDPIAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <!-- Whole Program Optimization -->
  <PropertyGroup>
    <WholeProgramOptimizationAvailabilityTrue Condition="(exists('$(VCTargetsPath)\Microsoft.Cpp.WholeProgramOptimization.props'))">true</WholeProgramOptimizationAvailabilityTrue>
    <WholeProgramOptimizationAvailabilityInstrument Condition="(exists('$(VCTargetsPath)\Microsoft.Cpp.pginstrument.props'))">true</WholeProgramOptimizationAvailabilityInstrument>
    <WholeProgramOptimizationAvailabilityOptimize Condition="(exists('$(VCTargetsPath)\Microsoft.Cpp.pgoptimize.props'))">true</WholeProgramOptimizationAvailabilityOptimize>
    <WholeProgramOptimizationAvailabilityUpdate Condition="(exists('$(VCTargetsPath)\Microsoft.Cpp.pgupdate.props'))">true</WholeProgramOptimizationAvailabilityUpdate>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(ConfigurationType)' != 'Makefile'">-->
  <!-- Core Windows Libraries -->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.AppContainerApplication.props" Condition="'$(WindowsStoreApp)' == 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.AppContainerApplication.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.AppContainerApplication.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_PropertySheetDisplayName>Windows Store app</_PropertySheetDisplayName>
  </PropertyGroup>
  <ItemGroup>
    <CompatibilityIssues Include="Use of MFC" Condition="'$(_CompatibilityIssuesUseOfMFC)'!='false'">
      <Type>Warning</Type>
      <FirstName>UseOfMFC</FirstName>
      <FirstValue>$(_CompatibilityIssuesUseOfMFC)</FirstValue>
      <SecondName>WindowsAppContainer</SecondName>
      <SecondValue>true</SecondValue>
    </CompatibilityIssues>
    <CompatibilityIssues Include="Use of ATL" Condition="'$(_CompatibilityIssuesUseOfATLIssue)'!='false'">
      <Type>Warning</Type>
      <FirstName>UseOfATL</FirstName>
      <FirstValue>$(_CompatibilityIssuesUseOfATLIssue)</FirstValue>
      <SecondName>WindowsAppContainer</SecondName>
      <SecondValue>true</SecondValue>
    </CompatibilityIssues>
    <CompatibilityIssues Include="Use of Unicode" Condition="'$(_CompatibilityIssuesCharacterSetIssue)'!='Unicode' and '$(_CompatibilityIssuesCharacterSetIssue)'!='' and '$(_CompatibilityIssuesCharacterSetIssue)'!='NotSet'">
      <Type>Warning</Type>
      <FirstName>CharacterSet</FirstName>
      <FirstValue>$(_CompatibilityIssuesCharacterSetIssue)</FirstValue>
      <SecondName>WindowsAppContainer</SecondName>
      <SecondValue>true</SecondValue>
    </CompatibilityIssues>
  </ItemGroup>
  <PropertyGroup>
    <!-- Because we are disabling the MFC/ATL/CLR, we need to preserve the old values in order to warn the user. -->
    <_CompatibilityIssuesUseOfMFC>$(UseOfMFC)</_CompatibilityIssuesUseOfMFC>
    <_CompatibilityIssuesUseOfATLIssue>$(UseOfATL)</_CompatibilityIssuesUseOfATLIssue>
    <_CompatibilityIssuesCharacterSetIssue>$(CharacterSet)</_CompatibilityIssuesCharacterSetIssue>
    <GeneratedFilesDir Condition=" '$(GeneratedFilesDir)' == ''">Generated Files\</GeneratedFilesDir>
    <!-- Disable features not supported for Windows Store app projects -->
    <UseOfMFC>false</UseOfMFC>
    <UseOfATL>false</UseOfATL>
    <CharacterSet>Unicode</CharacterSet>
    <!-- else, OutDir needs to have project specific directory in order to handle files with unique names -->
    <OutDir Condition="'$(Platform)' == 'Win32' and '$(OutDirWasSpecified)' != 'true'">$(SolutionDir)$(Configuration)\$(MSBuildProjectName)\</OutDir>
    <OutDir Condition="'$(Platform)' != 'Win32' and '$(OutDirWasSpecified)' != 'true'">$(SolutionDir)$(Platform)\$(Configuration)\$(MSBuildProjectName)\</OutDir>
    <IgnoreImportLibrary Condition="'$(WindowsAppContainer)' == 'true'">true</IgnoreImportLibrary>
    <EmbedManifest Condition="'$(WindowsAppContainer)' == 'true'">false</EmbedManifest>
    <GenerateManifest Condition="'$(WindowsAppContainer)' == 'true'">false</GenerateManifest>
    <!-- Disable manage while building AppContainer -->
    <CLRSupport>false</CLRSupport>
    <EnableManagedIncrementalBuild>false</EnableManagedIncrementalBuild>
    <TargetRuntime>Native</TargetRuntime>
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == ''">UAP</TargetPlatformIdentifier>
    <TargetPlatformName Condition="'$(TargetPlatformName)' == ''">UAP</TargetPlatformName>
    <!-- Required bundle for Win10 projects -->
    <RequiredBundles>Microsoft.VisualStudio.ComponentGroup.UWP.VC;$(RequiredBundles)</RequiredBundles>
    <!-- Only 8.2 projects should be consuming these targets so we're only adding the 8.2 group for these -->
    <AddItemTemplateGuid Condition="'$(AddItemTemplateGuid)' == ''">{FE0B9DF8-A7C2-4687-A235-316C1ACA78D3}</AddItemTemplateGuid>
    <CanReferenceWinRT Condition="'$(CanReferenceWinRT)' == ''">true</CanReferenceWinRT>
    <!-- Windows Store app projects require a different library for delayload -->
    <DelayImplib>dloadhelper.lib</DelayImplib>
    <!-- Only uses Kernel32.lib -->
    <MinimalCoreWin Condition="'$(MinimalCoreWin)'==''">KernelOnly</MinimalCoreWin>
    <GPUDebuggerTargetType Condition="'$(GPUDebuggerTargetType)' == ''">{F4453496-1DB8-47F8-A7D5-31EBDDC2EC96}</GPUDebuggerTargetType>
    <GPURefDebuggerBreakOnAllThreads Condition="'$(GPURefDebuggerBreakOnAllThreads)' == ''">GPURefBreakOncePerWarp</GPURefDebuggerBreakOnAllThreads>
    <!-- Windows Store app exes needs packaging -->
    <AppxPackage Condition="'$(AppxPackage)'=='' and '$(WindowsAppContainer)' == 'true' and '$(ConfigurationType)' == 'Application'">True</AppxPackage>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == ''">$(SolutionDir)AppPackages\$(ProjectName)\</AppxPackageDir>
    <!-- Use different AppxPriInitialPath, because $(RootNamespace) matches name of the produced WINMD. -->
    <AppxPriInitialPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == '' and '$(WindowsPackageType)' != 'None'">$(RootNamespace)</AppxPriInitialPath>
    <CanBeStartupProject>$(AppxPackage)</CanBeStartupProject>
    <DebuggerFlavor Condition="'$(WindowsAppContainer)' == 'true'">AppHostLocalDebugger</DebuggerFlavor>
    <DebuggerFlavor Condition="'$(WindowsAppContainer)' != 'true'">WindowsLocalDebugger</DebuggerFlavor>
    <!-- By default, apps need XAML processing -->
    <_CppCommonExtensionTargets Condition="'$(_DefaultCppCommonExtensionTargets)' != 'false'">$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v$(VisualStudioVersion)\Microsoft.Windows.UI.Xaml.Cpp.targets</_CppCommonExtensionTargets>
    <!-- These properties are copied from Microsoft.cpp.currentversion.targets as these properties are used in Extension SDK props import and required before targets -->
    <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == '' and '$(DisableRegistryUse)' != 'true'">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
    <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
    <!-- Manifest driven extension SDK locations -->
    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(MSBuildProgramFiles32)\Windows Kits\10</SDKExtensionDirectoryRoot>
    <DesktopCompatible Condition="'$(DesktopCompatible)' == ''">false</DesktopCompatible>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(UseDebugLibraries)' == 'true'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <PreprocessorDefinitions Condition="'$(_NoWinAPIFamilyApp)' != 'true' AND '$(WindowsAppContainer)'=='true'">%(PreprocessorDefinitions);WINAPI_FAMILY=WINAPI_FAMILY_APP</PreprocessorDefinitions>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);__WRL_NO_DEFAULT_LIB__</PreprocessorDefinitions>
      <CompileAsWinRT Condition="'%(ClCompile.CompileAsWinRT)' == '' and '$(WindowsAppContainer)' == 'true'">true</CompileAsWinRT>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <WinRTNoStdLib Condition="'%(ClCompile.WinRTNoStdLib)' == ''">true</WinRTNoStdLib>
      <ExceptionHandling Condition="'%(ClCompile.ExceptionHandling)' == 'Async'">Sync</ExceptionHandling>
      <!-- /Gm is conflicting with /ZW, disable it -->
      <MinimalRebuild>false</MinimalRebuild>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <!-- The new templated project will have pch.h, while classic applications will have stdafx.h -->
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <!-- xaml compilation will produce .g.h in the intermediate dir-->
      <AdditionalIncludeDirectories>$(ProjectDir);$(GeneratedFilesDir);$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <ForcedUsingFiles>$(VCToolsInstallDir)lib\x86\store\references\platform.winmd;%(ForcedUsingFiles)</ForcedUsingFiles>
    </ClCompile>
    <Midl>
      <EnableWindowsRuntime Condition="'%(Midl.EnableWindowsRuntime)' == ''">true</EnableWindowsRuntime>
      <Enumclass Condition="'%(Midl.Enumclass)' == ''">true</Enumclass>
      <PrependWithABINamepsace Condition="'%(Midl.PrependWithABINamepsace)' == ''">true</PrependWithABINamepsace>
      <MetadataFileName Condition="'%(Midl.MetadataFileName)' == ''">$(OutDir)%(Filename).winmd</MetadataFileName>
      <AdditionalMetadataDirectories Condition="'$(WindowsSDK_MetadataFoundationPath)' != ''">$(WindowsSDK_MetadataFoundationPath);%(AdditionalMetadataDirectories)</AdditionalMetadataDirectories>
      <AdditionalMetadataDirectories Condition="'$(WindowsSDK_MetadataFoundationPath)' == ''">$(WindowsSDK_MetadataPath);%(AdditionalMetadataDirectories)</AdditionalMetadataDirectories>
    </Midl>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableUAC>false</EnableUAC>
      <UACExecutionLevel />
      <UACUIAccess>false</UACUIAccess>
      <GenerateDebugInformation Condition="'%(Link.GenerateDebugInformation)' == ''">true</GenerateDebugInformation>
      <GenerateWindowsMetadata Condition="'%(Link.GenerateWindowsMetadata)' == '' and '$(WindowsAppContainer)' == 'true'">true</GenerateWindowsMetadata>
      <WindowsMetadataFile Condition="'$(RootNamespace)' != '' and '%(Link.WindowsMetadataFile)' == ''">$(OutDir)$(RootNamespace).winmd</WindowsMetadataFile>
      <WindowsMetadataFile Condition="'%(Link.WindowsMetadataFile)' == ''">$(OutDir)$(TargetName).winmd</WindowsMetadataFile>
      <AppContainer Condition="'%(Link.AppContainer)' == ''">true</AppContainer>
    </Link>
    <Manifest>
      <OutputManifestFile Condition="'$(EmbedManifest)' == 'false'">$(OutDir)$(TargetName).manifest</OutputManifestFile>
    </Manifest>
    <Image>
      <DeploymentContent Condition="'%(Image.DeploymentContent)'==''">true</DeploymentContent>
    </Image>
    <Media>
      <DeploymentContent Condition="'%(Media.DeploymentContent)'==''">true</DeploymentContent>
    </Media>
    <Text>
      <DeploymentContent Condition="'%(Text.DeploymentContent)'==''">true</DeploymentContent>
    </Text>
    <Xml>
      <DeploymentContent Condition="'%(Xml.DeploymentContent)'==''">true</DeploymentContent>
    </Xml>
    <Xsd>
      <DeploymentContent Condition="'%(Xsd.DeploymentContent)'==''">true</DeploymentContent>
    </Xsd>
    <Font>
      <DeploymentContent Condition="'%(Font.DeploymentContent)'==''">true</DeploymentContent>
    </Font>
    <CopyFileToFolders>
      <TreatOutputAsContent Condition="'%(CopyFileToFolders.TreatOutputAsContent)'==''">true</TreatOutputAsContent>
      <RootFolder>$(OutDir)</RootFolder>
    </CopyFileToFolders>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(UseDebugLibraries)' != 'true'">
    <ClCompile>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <!-- Manifest metadata items.                       -->
  <!-- See Microsoft.AppxPackage.targets for details. -->
  <PropertyGroup>
    <!-- Ultimate Fallback will be x86 for both the host and target architectures -->
    <!-- Set the Host Architecture depending on the value of VCToolArchitecture as determined above. -->
    <AppxManifestMetadataClHostArchDir Condition="'$(AppxManifestMetadataClHostArchDir)' == '' and '$(VCToolArchitecture)' == 'Native64Bit'">HostX64</AppxManifestMetadataClHostArchDir>
    <AppxManifestMetadataClHostArchDir Condition="'$(AppxManifestMetadataClHostArchDir)' == '' and '$(VCToolArchitecture)' == 'NativeARM64'">HostArm64</AppxManifestMetadataClHostArchDir>
    <AppxManifestMetadataClHostArchDir Condition="'$(AppxManifestMetadataClHostArchDir)' == ''">HostX86</AppxManifestMetadataClHostArchDir>
    <!-- Since 'Platform' is not set when this props file is imported, we need to search for a valid executable from which the version info can be pulled. We're also assuming that all cl.exe instances within the same version directory will return the same result. -->
    <AppxManifestMetadataClTargetArchDir Condition="'$(AppxManifestMetadataClTargetArchDir)' == '' and Exists('$(VCToolsInstallDir)bin\$(AppxManifestMetadataClHostArchDir)\x86\cl.exe')">x86</AppxManifestMetadataClTargetArchDir>
    <AppxManifestMetadataClTargetArchDir Condition="'$(AppxManifestMetadataClTargetArchDir)' == '' and Exists('$(VCToolsInstallDir)bin\$(AppxManifestMetadataClHostArchDir)\x64\cl.exe')">x64</AppxManifestMetadataClTargetArchDir>
    <AppxManifestMetadataClTargetArchDir Condition="'$(AppxManifestMetadataClTargetArchDir)' == '' and Exists('$(VCToolsInstallDir)bin\$(AppxManifestMetadataClHostArchDir)\arm\cl.exe')">arm</AppxManifestMetadataClTargetArchDir>
    <AppxManifestMetadataClTargetArchDir Condition="'$(AppxManifestMetadataClTargetArchDir)' == '' and Exists('$(VCToolsInstallDir)bin\$(AppxManifestMetadataClHostArchDir)\arm64\cl.exe')">arm64</AppxManifestMetadataClTargetArchDir>
    <AppxManifestMetadataClTargetArchDir Condition="'$(AppxManifestMetadataClTargetArchDir)' == ''">x86</AppxManifestMetadataClTargetArchDir>
  </PropertyGroup>
  <ItemGroup Label="AppxManifestMetadata">
    <AppxManifestMetadata Include="$(VCToolsInstallDir)bin\$(AppxManifestMetadataClHostArchDir)\$(AppxManifestMetadataClTargetArchDir)\cl.exe" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.CoreWin.props" Condition="'$(NonCoreWin)' != 'true' and ( '$(UseOfMFC)' == 'false' OR '$(UseOfMFC)' == '')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.CoreWin.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.CoreWin.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_PropertySheetDisplayName>Core Windows Libraries</_PropertySheetDisplayName>
  </PropertyGroup>
  <PropertyGroup>
    <CoreLibraryDependencies Condition="'$(CoreLibraryDependencies)' == '' and '$(WindowsAppContainer)' == 'true'">WindowsApp.lib</CoreLibraryDependencies>
    <CoreLibraryDependencies Condition="'$(CoreLibraryDependencies)' == '' and '$(MinimalCoreWin)'=='KernelOnly'">kernel32.lib</CoreLibraryDependencies>
    <CoreLibraryDependencies Condition="'$(CoreLibraryDependencies)' == '' and '$(MinimalCoreWin)'=='true'">kernel32.lib;user32.lib</CoreLibraryDependencies>
    <CoreLibraryDependencies Condition="'$(CoreLibraryDependencies)' == ''">kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib</CoreLibraryDependencies>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!-- MFC -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.MFCStatic.props" Condition="'$(UseOfMFC)' == 'Static'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.MFCDynamic.props" Condition="'$(UseOfMFC)' == 'Dynamic'" />-->
  <!-- Character Set -->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.unicodesupport.props" Condition="'$(CharacterSet)' == 'Unicode'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.unicodesupport.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.unicodesupport.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_PropertySheetDisplayName>Unicode Support</_PropertySheetDisplayName>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <PreprocessorDefinitions>_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup>
    <ResourceCompile>
      <PreprocessorDefinitions>_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.MultiByteCharSupport.props" Condition="'$(CharacterSet)' == 'MultiByte'" />-->
  <!-- Configuration Type -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.WinDLL.props" Condition="'$(ConfigurationType)' == 'DynamicLibrary'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Application.props" Condition="'$(ConfigurationType)' == 'Application'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Application.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Application.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_PropertySheetDisplayName>Application</_PropertySheetDisplayName>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Common.props
============================================================================================================================================
-->
  <!-- Whole Program Optimization -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.WholeProgramOptimization.props" Condition="'$(WholeProgramOptimizationDelayImport)' != 'true' and '$(WholeProgramOptimization)' == 'true'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.WholeProgramOptimization.props" Condition="'$(WholeProgramOptimization)' == 'FASTLTCG'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.pginstrument.props" Condition="'$(WholeProgramOptimizationDelayImport)' != 'true' and '$(WholeProgramOptimization)' == 'PGInstrument'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.pgoptimize.props" Condition="'$(WholeProgramOptimizationDelayImport)' != 'true' and '$(WholeProgramOptimization)' == 'PGOptimize'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.pgupdate.props" Condition="'$(WholeProgramOptimizationDelayImport)' != 'true' and '$(WholeProgramOptimization)' == 'PGUpdate'" />-->
  <!-- C++ Dynamic Debugging -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.UseDynamicDebugging.props" Condition="'$(UseDynamicDebugging)' == 'true'" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup>-->
  <!-- Common Language Runtime Support  -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.ManagedExtensionsNetCore.props" Condition="'$(CLRSupport)' == 'NetCore'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.ManagedExtensions.props" Condition="'$(CLRSupport)' == 'true'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.ManagedExtensionsPure.props" Condition="'$(CLRSupport)' == 'Pure'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.ManagedExtensionsSafe.props" Condition="'$(CLRSupport)' == 'Safe'" />-->
  <!-- OldSyntax support has been removed. We're leaving this here so that the compiler errors out for projects that still have it set -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.ManagedExtensionsOldSyntax.props" Condition="'$(CLRSupport)' == 'OldSyntax'" />-->
  <!--</ImportGroup>-->
  <PropertyGroup>
    <CopyFileBeforeTargets>Midl</CopyFileBeforeTargets>
    <CopyFileAfterTargets>PreBuildEvent</CopyFileAfterTargets>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <CopyFileToFolders>
      <DestinationFolders>$(OutDir)</DestinationFolders>
      <DestinationFileName>%(Filename)%(Extension)</DestinationFileName>
    </CopyFileToFolders>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.MSVC.Toolset.Common.props
============================================================================================================================================
-->
  <!-- properties  common for all platforms -->
  <PropertyGroup>
    <IncludePath Condition="'$(IncludePath)' == ''">$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
    <ExternalIncludePath Condition="'$(ExternalIncludePath)' == ''">$(VC_IncludePath);$(WindowsSDK_IncludePath);</ExternalIncludePath>
    <LibraryWPath Condition="'$(LibraryWPath)' == ''">$(WindowsSDK_MetadataPath);</LibraryWPath>
    <SourcePath Condition="'$(SourcePath)' == ''">$(VC_SourcePath);</SourcePath>
    <CommonExecutablePath>$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(FxCopDir);$(PATH);</CommonExecutablePath>
    <CommonExcludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(VC_ExecutablePath_Loc);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(FxCopDir);$(MSBuildToolsPath);$(MSBuildFrameworkToolsPath);$(MSBuild_ExecutablePath);$(SystemRoot)</CommonExcludePath>
    <CheckMSVCComponents Condition="'$(CheckMSVCComponents)' == ''">true</CheckMSVCComponents>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.MSVC.Toolset.x64.props
============================================================================================================================================
-->
  <PropertyGroup>
    <ExecutablePath Condition="'$(ExecutablePath)' == ''">$(VC_ExecutablePath_x64);$(CommonExecutablePath)</ExecutablePath>
    <ReferencePath Condition="'$(ReferencePath)' == ''">$(VC_ReferencesPath_x64);</ReferencePath>
    <LibraryPath Condition="'$(LibraryPath)' == ''">$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <ExcludePath Condition="'$(ExcludePath)' == ''">$(CommonExcludePath);$(VC_ExecutablePath_x64);$(VC_LibraryPath_x64)</ExcludePath>
    <DebugCppRuntimeFilesPath>$(VC_DebugCppRuntimeFilesPath_x64);$(UniversalDebugCRT_ExecutablePath_x64)</DebugCppRuntimeFilesPath>
    <CppRuntimeFilesPath>$(VC_CppRuntimeFilesPath_x64);</CppRuntimeFilesPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\PlatformToolsets\v143\Toolset.props
============================================================================================================================================
-->
  <!-- Override the DebuggerRequireAuthentication value to Universal for UAP projects -->
  <PropertyGroup>
    <DebuggerRequireAuthentication>Universal</DebuggerRequireAuthentication>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportAfter\*.props" Condition="Exists('$(MSBuildThisFileDirectory)ImportAfter')" />-->
  <!-- This is intentionally added after ImportAfter. -->
  <!--
============================================================================================================================================
  <Import Project="$(_PlatformFolder)Platform.Common.props">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\Platform.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Platform.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- For older OSs local target is not supported, so set device as the default -->
    <DebuggerFlavor Condition="'$(TargetPlatformName)' == 'UAP' and '$(CurrentMajorVersionNumber)' != '10'">WindowsDeviceDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <EnablePREfast Condition="'%(ClCompile.EnablePREfast)' == ''">false</EnablePREfast>
      <OmitFramePointers Condition="'%(ClCompile.OmitFramePointers)' == ''">false</OmitFramePointers>
      <DebugInformationFormat Condition="'%(ClCompile.DebugInformationFormatDefined)' != 'true' and '$(UseDebugLibraries)' == 'true'  and '$(EnableASAN)' != 'true' and '$(UseDynamicDebugging)' != 'true'">EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine Condition="'%(Link.TargetMachine)' == ''">MachineX64</TargetMachine>
    </Link>
    <ImpLib>
      <TargetMachine Condition="'%(ImpLib.TargetMachine)' == ''">MachineX64</TargetMachine>
    </ImpLib>
    <Midl>
      <TargetEnvironment Condition="'%(Midl.TargetEnvironment)' == ''">X64</TargetEnvironment>
    </Midl>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\PlatformToolsets\v143\Toolset.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Platform.props
============================================================================================================================================
-->
  <!-- Import After -->
  <!--<Import Project="$(_PlatformFolder)ImportAfter\*.props" Condition="Exists('$(_PlatformFolder)ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\Platform.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.ToolsetLocation.props
============================================================================================================================================
-->
  <!-- In VS2010 most of the settings are located in the Microsoft.Cpp.props, so we have to import it. -->
  <!--<Import Project="$(VCTargetsPath10)\Microsoft.Cpp.props" Condition="'$(_VCTargetsPathForToolset)' == '$(VCTargetsPath10)'" />-->
  <!-- restore VCTargetsPath and VsInstallRoot to point to the current version -->
  <PropertyGroup>
    <VCTargetsPath>$(CurrentVCTargetsPath)</VCTargetsPath>
    <VsInstallRoot>$(CurrentVsInstallRoot)</VsInstallRoot>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.props
============================================================================================================================================
-->
  <!-- if we did not find the toolset in the current version, try older ones -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.Redirect.props" Condition="'$(_ToolsetFound)' != 'true'" />-->
  <PropertyGroup>
    <_ApplicationTypeAndRevisionFound Condition="'$(_ToolsetFound)' == 'true' or '$(ApplicationType)' == '' or '$(_ApplicationTypeRevisionDefaultPropsFound)' == 'true'">true</_ApplicationTypeAndRevisionFound>
  </PropertyGroup>
  <!-- If toolset still not found, try using default toolset. -->
  <PropertyGroup Condition="'$(_ToolsetFound)' != 'true' and '$(DefaultPlatformToolset)' != ''">
    <_DefaultPlatformProps>$(CurrentVCTargetsPath)$(_RelativePlatformFolder)Platform.props</_DefaultPlatformProps>
    <_DefaultPlatformTargets>$(CurrentVCTargetsPath)$(_RelativePlatformFolder)Platform.targets</_DefaultPlatformTargets>
    <_DefaultToolsetProps>$(CurrentVCTargetsPath)$(_RelativePlatformFolder)PlatformToolsets\$(DefaultPlatformToolset)\Toolset.props</_DefaultToolsetProps>
    <_DefaultToolsetTargets>$(CurrentVCTargetsPath)$(_RelativePlatformFolder)PlatformToolsets\$(DefaultPlatformToolset)\Toolset.targets</_DefaultToolsetTargets>
    <_UseDefaultToolset Condition="Exists($(_DefaultPlatformProps)) and Exists($(_DefaultPlatformTargets)) and Exists($(_DefaultToolsetProps)) and Exists($(_DefaultToolsetTargets))">true</_UseDefaultToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_UseDefaultToolset)' == 'true'">
    <_ToolsetPropsPath>$(_DefaultToolsetProps)</_ToolsetPropsPath>
    <_ToolsetTargetsPath>$(_DefaultToolsetTargets)</_ToolsetTargetsPath>
  </PropertyGroup>
  <PropertyGroup>
    <_ApplicationTypeAndRevisionFound Condition="'$(_ToolsetFound)' == 'true' or '$(ApplicationType)' == '' or '$(_ApplicationTypeRevisionDefaultPropsFound)' == 'true'">true</_ApplicationTypeAndRevisionFound>
  </PropertyGroup>
  <!--<Import Project="$(_DefaultPlatformProps)" Condition="'$(_UseDefaultToolset)' == 'true'" />-->
  <!-- Enable Address Sanitizer -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.EnableASAN.props" Condition="'$(EnableASAN)' == 'true'" />-->
  <!-- Import Makefile.props -->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Makefile.props" Condition="'$(ConfigurationType)' == 'Makefile'" />-->
  <!--<Import Project="Imports.props" Sdk="vcpkg:ManifestDirectory=$(VcpkgManifestDirectory);ImportFiles=$(ImportAfterCppProps)" Condition="'$(VcpkgManifestDirectory)' != '' and '$(ImportAfterCppProps)' != ''" />-->
  <!--<Import Project="$(ForceImportAfterCppProps)" Condition="Exists('$(ForceImportAfterCppProps)')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <!--<ImportGroup>-->
  <!--</ImportGroup>-->
  <!--<ImportGroup>-->
  <!--<Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="PropertySheet.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\PropertySheet.props
============================================================================================================================================
-->
  <!--<ImportGroup>-->
  <!--</ImportGroup>-->
  <PropertyGroup Label="UserMacros" />
  <!--
    To customize common C++/WinRT project properties:
    * right-click the project node
    * expand the Common Properties item
    * select the C++/WinRT property page

    For more advanced scenarios, and complete documentation, please see:
    https://github.com/Microsoft/xlang/tree/master/src/package/cppwinrt/nuget
    -->
  <PropertyGroup />
  <ItemDefinitionGroup />
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--<ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props" Condition="Exists('$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.props')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  This file will be consumed by ALL UWP C++ app projects (both inside
  and outside of this repo) that build on top of Microsoft.ReactNative.
  Do not make any changes here unless it applies to ALL such projects.
-->
  <!-- Keeping this at the top of the imports ensures we can use the autolinking 
       process to set properties without having to edit the project file -->
  <!--
============================================================================================================================================
  <Import Project="$(ProjectDir)\AutolinkedNativeModules.g.props" Condition="Exists('$(ProjectDir)\AutolinkedNativeModules.g.props')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\AutolinkedNativeModules.g.props
============================================================================================================================================
-->
  <!-- AutolinkedNativeModules.g.props contents generated by "react-native autolink-windows" -->
  <PropertyGroup>
    <!-- Set due to dependency on C# module(s): ReactNativeDocumentPicker -->
    <ConsumeCSharpModules Condition="'$(ConsumeCSharpModules)'==''">true</ConsumeCSharpModules>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.ReactNative.Uwp.Common.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.Common.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the MIT License.

  This file will be consumed by ALL UWP app and module projects (both inside
  and outside of this repo) that build on top of Microsoft.ReactNative.
  Do not make any changes here unless it applies to ALL such projects.
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.ReactNative.Common.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Common.props
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  This file will be consumed by ALL app and module projects (Desktop & UWP,
  both inside and outside of this repo) that build on top of
  Microsoft.ReactNative. Do not make any changes here unless it applies to
  ALL such projects.
-->
  <!--
    Projects internal to the `react-native-windows` package should resolve
    '$(ReactNativeWindowsDir)` via "Directory.Build.Props".

    External projects should resolve '$(ReactNativeWindowsDir)` using the
    node_modules resolution logic of the template project. Home-rolled projects
    may miss this logic, and instead import props directly by path.

    If this happens, set a valid $(ReactNativeWindowsDir) to allow our project
    to load, so we can load targets to show a later error via
    $(ReactNativeWindowsDirNotSet).
  -->
  <PropertyGroup Condition="'$(ReactNativeWindowsDir)' == ''">
    <ReactNativeWindowsDir>$([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)\..\..'))</ReactNativeWindowsDir>
    <ReactNativeWindowsDirNotSet>true</ReactNativeWindowsDirNotSet>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)PropertySheets\JSEngine.props" Condition="'$(JsEnginePropsDefined)' == ''">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\JSEngine.props
============================================================================================================================================
-->
  <Target Name="EnsureReactExperimentalFeaturesSetTarget" BeforeTargets="PrepareForBuild" Condition="Exists('$(SolutionDir)\ExperimentalFeatures.props') And '$(ReactExperimentalFeaturesSet)' != 'true'">
    <Warning Text="Property 'ReactExperimentalFeaturesSet' not set. Please specify &lt;ReactExperimentalFeaturesSet&gt;true&lt;/ReactExperimentalFeaturesSet&gt;&gt; in '$(SolutionDir)\ExperimentalFeatures.props' to prevent the MSB4011 warnings." />
  </Target>
  <!--<ImportGroup Condition="'$(ReactExperimentalFeaturesSet)' != 'true'">-->
  <!--
============================================================================================================================================
  <Import Project="$(SolutionDir)\ExperimentalFeatures.props" Condition="Exists('$(SolutionDir)\ExperimentalFeatures.props')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\ExperimentalFeatures.props
============================================================================================================================================
-->
  <!--
    This file contains some important settings that will apply globally for
    your app and *all* native modules your app consumes. These values were
    set when you created the app project, and in some cases cannot be
    simply changed here without recreating a new project.
  -->
  <PropertyGroup Label="Microsoft.ReactNative Experimental Features">
    <!--
      Enables default usage of Hermes.
      
      See https://microsoft.github.io/react-native-windows/docs/hermes
    -->
    <UseHermes>true</UseHermes>
    <!--
      Changes compilation to assume use of WinUI 3 instead of System XAML.
      Requires creation of new project.

      See https://microsoft.github.io/react-native-windows/docs/winui3
    -->
    <UseWinUI3>false</UseWinUI3>
    <!--
      Changes compilation to assume use of Microsoft.ReactNative NuGet packages
      instead of building the framework from source.
      Requires creation of new project.

      See https://microsoft.github.io/react-native-windows/docs/nuget
    -->
    <UseExperimentalNuget>false</UseExperimentalNuget>
    <ReactExperimentalFeaturesSet>true</ReactExperimentalFeaturesSet>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\JSEngine.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <PropertyGroup>
    <JsEnginePropsDefined>true</JsEnginePropsDefined>
    <!-- Enabling this will (1) Include hermes glues in the Microsoft.ReactNative binaries AND (2) Make hermes the default engine -->
    <UseHermes Condition="'$(UseHermes)' == ''">true</UseHermes>
    <!-- This will be true if (1) the client want to use hermes by setting UseHermes to true OR (2) We are building for UWP where dynamic switching is enabled -->
    <HermesVersion Condition="'$(HermesVersion)' == ''">0.1.27</HermesVersion>
    <HermesPackage Condition="'$(HermesPackage)' == '' And Exists('$(PkgMicrosoft_JavaScript_Hermes)')">$(PkgMicrosoft_JavaScript_Hermes)</HermesPackage>
    <HermesPackage Condition="'$(HermesPackage)' == ''">$(NuGetPackageRoot)\Microsoft.JavaScript.Hermes\$(HermesVersion)</HermesPackage>
    <EnableHermesInspectorInReleaseFlavor Condition="'$(EnableHermesInspectorInReleaseFlavor)' == ''">false</EnableHermesInspectorInReleaseFlavor>
    <!-- Disable linking Hermes into the output in cases where we need to fully rely on HermesShim -->
    <HermesNoLink Condition="'$(HermesNoLink)' == '' and '$(Configuration)' == 'Release' and '$(EnableHermesInspectorInReleaseFlavor)' != 'true'">true</HermesNoLink>
    <!-- Use Hermes bytecode bundles provided by metro hermes compiler when available -->
    <EnableDevServerHBCBundles Condition="'$(EnableDevServerHBCBundles)' == ''">false</EnableDevServerHBCBundles>
    <UseV8 Condition="'$(UseV8)' == ''">false</UseV8>
    <V8Version Condition="'$(V8Version)' == ''">0.71.18</V8Version>
    <V8PackageName>ReactNative.V8Jsi.Windows</V8PackageName>
    <V8PackageName Condition="'$(V8AppPlatform)' != 'win32'">$(V8PackageName).UWP</V8PackageName>
    <V8Package>$(NuGetPackageRoot)\$(V8PackageName).$(V8Version)</V8Package>
    <V8Platform Condition="'$(Platform)' == 'ARM64EC'">x64</V8Platform>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.ReactNative.Cpp.Dependencies.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Cpp.Dependencies.props
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  This file will be consumed by ALL app and module projects (Desktop & UWP,
  both inside and outside of this repo) that build on top of
  Microsoft.ReactNative. Do not make any changes here unless it applies to
  ALL such projects.
-->
  <PropertyGroup Label="CppWinRT">
    <CppWinRTVersion Condition="'$(CppWinRTVersion)' == '' Or $([MSBuild]::VersionLessThan('$(CppWinRTVersion)', '2.0.211028.7'))">2.0.211028.7</CppWinRTVersion>
  </PropertyGroup>
  <ItemDefinitionGroup Label="CppWinRT">
    <ClCompile>
      <PreprocessorDefinitions Condition="$([MSBuild]::VersionGreaterThanOrEquals('$(CppWinRTVersion)', '2.0.230524.3'))">
        CPPWINRT_USE_LOADLIBRARYEXW;
        %(PreprocessorDefinitions)
      </PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.ReactNative.CSharp.Dependencies.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.CSharp.Dependencies.props
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  This file will be consumed by ALL app and module projects (Desktop & UWP,
  both inside and outside of this repo) that build on top of
  Microsoft.ReactNative. Do not make any changes here unless it applies to
  ALL such projects.
-->
  <PropertyGroup Label="NetCoreUniversalWindowsPlatform">
    <NETCoreUWPVersion Condition="'$(NETCoreUWPVersion)' == '' Or $([MSBuild]::VersionLessThan('$(NETCoreUWPVersion)', '6.2.9'))">6.2.9</NETCoreUWPVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Common.props
============================================================================================================================================
-->
  <PropertyGroup>
    <ProjectDir Condition="'$(ProjectDir)' == ''">$(MSBuildProjectDirectory)\</ProjectDir>
    <UseExperimentalNuget Condition="'$(UseExperimentalNuget)' == ''">false</UseExperimentalNuget>
    <HermesNoDLLCopy Condition="'$(UseHermes)' != 'true'">true</HermesNoDLLCopy>
    <RestorePackagesWithLockFile Condition="'$(RestorePackagesWithLockFile)' == ''">true</RestorePackagesWithLockFile>
    <RestoreForceEvaluate Condition="'$(RestoreForceEvaluate)' == ''">false</RestoreForceEvaluate>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\NewAPIDeclarations.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\NewAPIDeclarations.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the MIT License.

  Defines properties/flags for customers to easily detect new APIS.
-->
  <PropertyGroup>
    <RnwReactTagAPI>true</RnwReactTagAPI>
  </PropertyGroup>
  <PropertyGroup>
    <DefineConstants>RNW_REACTTAG_API;$(DefineConstants)</DefineConstants>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <PreprocessorDefinitions>RNW_REACTTAG_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>RNW_REACTTAG_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Generated\PackageVersion.g.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Generated\PackageVersion.g.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  Generated by @rnw-scripts/stamp-version

  This file is stamped with the version of the published react-native-windows
  npm package.
-->
  <PropertyGroup>
    <ReactNativeWindowsVersion>0.73.22</ReactNativeWindowsVersion>
    <ReactNativeWindowsMajor>0</ReactNativeWindowsMajor>
    <ReactNativeWindowsMinor>73</ReactNativeWindowsMinor>
    <ReactNativeWindowsPatch>22</ReactNativeWindowsPatch>
    <ReactNativeWindowsCanary>false</ReactNativeWindowsCanary>
    <ReactNativeWindowsCommitId>ac3fb0736115294088207980c644ed32a5782607</ReactNativeWindowsCommitId>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Appx.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Appx.props
============================================================================================================================================
-->
  <PropertyGroup>
    <_NormalizedPlatform Condition="'$(Platform)' == 'Win32'">x86</_NormalizedPlatform>
    <_NormalizedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_NormalizedPlatform>
  </PropertyGroup>
  <!--
    AppX bundling logic has a bug causing it to rebuild the project as x64 when
    specifying x86 configuration. Only build the configuration we asked for in
    debug builds, but build everything by default in release builds.
  -->
  <PropertyGroup Condition="'$(AppxBundlePlatforms)' == ''">
    <AppxBundlePlatforms Condition="'$(Configuration)' == 'Debug'">$(_NormalizedPlatform)</AppxBundlePlatforms>
    <AppxBundlePlatforms Condition="'$(Configuration)' == 'Release'">x86|x64|arm64</AppxBundlePlatforms>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Autolink.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Autolink.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <PropertyGroup>
    <RunAutolinkCheck Condition="'$(RunAutolinkCheck)' == ''">true</RunAutolinkCheck>
    <AutolinkCommand Condition="'$(AutolinkCommand)' == ''">npx react-native autolink-windows</AutolinkCommand>
    <AutolinkCommandWorkingDir Condition="'$(AutolinkCommandWorkingDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(ProjectDir), 'package.json'))</AutolinkCommandWorkingDir>
    <AutolinkCommandArgs Condition="'$(AutolinkCommandArgs)' == '' And '$(SolutionPath)' != '' And '$(SolutionPath)' != '*Undefined*' And '$(ProjectPath)' != ''">--check --sln "$([MSBuild]::MakeRelative($(AutolinkCommandWorkingDir), $(SolutionPath)))" --proj "$([MSBuild]::MakeRelative($(AutolinkCommandWorkingDir), $(ProjectPath)))"</AutolinkCommandArgs>
    <AutolinkCommandArgs Condition="'$(AutolinkCommandArgs)' == ''">--check</AutolinkCommandArgs>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Codegen.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Codegen.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <PropertyGroup>
    <RunCodegenWindows Condition="'$(RunCodegenWindows)' == ''">true</RunCodegenWindows>
    <CodegenCommand Condition="'$(CodegenCommand)' == ''">npx react-native codegen-windows</CodegenCommand>
    <CodegenCommandWorkingDir Condition="'$(CodegenCommandWorkingDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(ProjectDir), 'package.json'))</CodegenCommandWorkingDir>
    <CodegenCommandArgs Condition="'$(CodegenCommandArgs)' == ''">--logging</CodegenCommandArgs>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\NuGet.Cpp.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\NuGet.Cpp.props
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the MIT License.

  Defines NuGet-related properties for C++ projects using PackageReference.
-->
  <PropertyGroup Label="NuGet">
    <!-- Should match entry in $(ReactNativeWindowsDir)vnext\Directory.Build.props -->
    <!-- See https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets#restore-target -->
    <!-- RestoreUseStaticGraphEvaluation broke in VS 17.6, see https://github.com/microsoft/react-native-windows/issues/11670 -->
    <RestoreUseStaticGraphEvaluation Condition="'$(BuildingInsideVisualStudio)' == 'true' AND $([MSBuild]::VersionLessThan('$(MSBuildVersion)', '17.6')) AND '$(DisableRestoreUseStaticGraphEvaluation)' != 'true'">true</RestoreUseStaticGraphEvaluation>
    <!-- Ensure PackageReference compatibility for any consuming projects/apps -->
    <ResolveNuGetPackages>false</ResolveNuGetPackages>
    <!-- https://github.com/NuGet/Home/issues/10511#issuecomment-778400668 -->
    <AssetTargetFallback>$(AssetTargetFallback);uap10.0.17763</AssetTargetFallback>
    <!--
      Avoid Visual Studio error message:
      "The project '$(MSBuildProjectName)' ran into a problem during the last operation: The value of the
      'TargetFrameworkMoniker' and 'NuGetTargetMoniker' properties in the '$(Configuration)|$(Platform)' configuration are both
      empty. This configuration will not contribute to NuGet restore, which may result in restore and build errors. You may
      need to reload the solution after fixing the problem."
    -->
    <TargetFrameworkMoniker>native,Version=v0.0</TargetFrameworkMoniker>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\WinUI.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\WinUI.props
============================================================================================================================================
-->
  <PropertyGroup Label="WinUI3 versioning">
    <!-- This value is also used by the CLI, see /packages/@react-native-windows/generate-windows -->
    <WinUI3Version Condition="'$(WinUI3Version)'==''">1.4.230913002</WinUI3Version>
  </PropertyGroup>
  <PropertyGroup Label="WinUI2x versioning">
    <!--This value is also used by the CLI, see /packages/@react-native-windows/generate-windows -->
    <WinUI2xVersion Condition="'$(WinUI2xVersion)'==''">2.8.0</WinUI2xVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseWinUI3)'=='true'">
    <WinUIPackageName>Microsoft.WindowsAppSDK</WinUIPackageName>
    <WinUIPackageVersion>$(WinUI3Version)</WinUIPackageVersion>
    <WinUIPackageProps />
    <!-- Enlighten C# code about WinUI3 -->
    <DefineConstants Condition="'$(UseWinUI3)'=='true'">USE_WINUI3;$(DefineConstants)</DefineConstants>
    <IsWinUIAlpha Condition="'$(IsWinUIAlpha)' == ''">true</IsWinUIAlpha>
    <WindowsKitsPath Condition="'$(IsWinUIAlpha)' == 'true'">WinUI-Alpha-Projects-Don-t-Use-SDK-Xaml-Tools</WindowsKitsPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseWinUI3)'!='true'">
    <WinUIPackageName>Microsoft.UI.Xaml</WinUIPackageName>
    <WinUIPackageVersion>$(WinUI2xVersion)</WinUIPackageVersion>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(UseWinUI3)'=='true'">
    <!-- Enlighten C++ code about WinUI3 -->
    <ClCompile>
      <PreprocessorDefinitions>USE_WINUI3;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <!-- Enlighten IDL interfaces about WinUI3 -->
    <Midl>
      <PreprocessorDefinitions>USE_WINUI3;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
  </ItemDefinitionGroup>
  <Target Name="PrintWinUIConfig" BeforeTargets="Midl;Build;ResolveSDKReferences">
    <Message Text="UseWinUI3 = $(UseWinUI3)" />
    <Message Text="WinUIPackage = $(WinUIPackageName).$(WinUIPackageVersion)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\CppAppConsumeCSharpModule.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <PropertyGroup>
    <ConsumeCSharpModules Condition="'$(ConsumeCSharpModules)' == ''">false</ConsumeCSharpModules>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ConsumeCSharpModules)' == 'true'">
    <!-- Start Custom .NET Native properties -->
    <UseDotNetNativeToolchain Condition="'$(Configuration)'=='Release'">true</UseDotNetNativeToolchain>
    <DotNetNativeVersion>DOTNET_NATIVE_VERSION_NOT_SET</DotNetNativeVersion>
    <DotNetNativeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.7-rel-27913-00\build\Microsoft.Net.Native.Compiler.props')">2.2.7-rel-27913-00</DotNetNativeVersion>
    <DotNetNativeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.8-rel-28605-00\build\Microsoft.Net.Native.Compiler.props')">2.2.8-rel-28605-00</DotNetNativeVersion>
    <DotNetNativeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.9-rel-29512-01\build\Microsoft.Net.Native.Compiler.props')">2.2.9-rel-29512-01</DotNetNativeVersion>
    <DotNetNativeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.10-rel-29722-00\build\Microsoft.Net.Native.Compiler.props')">2.2.10-rel-29722-00</DotNetNativeVersion>
    <DotNetNativeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.11-rel-30601-02\build\Microsoft.Net.Native.Compiler.props')">2.2.11-rel-30601-02</DotNetNativeVersion>
    <DotNetNativeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\Microsoft.Net.Native.Compiler.props')">2.2.12-rel-31116-00</DotNetNativeVersion>
    <DotNetNativeRuntimeVersion>DOTNET_NATIVE_RUNTIME_VERSION_NOT_SET</DotNetNativeRuntimeVersion>
    <DotNetNativeRuntimeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.7-rel-27913-00\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props')">2.2.7-rel-27913-00</DotNetNativeRuntimeVersion>
    <DotNetNativeRuntimeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.7-rel-28605-00\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props')">2.2.7-rel-28605-00</DotNetNativeRuntimeVersion>
    <DotNetNativeRuntimeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-29512-01\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props')">2.2.8-rel-29512-01</DotNetNativeRuntimeVersion>
    <DotNetNativeRuntimeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-29722-00\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props')">2.2.8-rel-29722-00</DotNetNativeRuntimeVersion>
    <DotNetNativeRuntimeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-30601-02\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props')">2.2.8-rel-30601-02</DotNetNativeRuntimeVersion>
    <DotNetNativeRuntimeVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props')">2.2.8-rel-31116-00</DotNetNativeRuntimeVersion>
    <!-- The name 'DotNetNativeVersion' is critical for restoring the right .NET framework libraries -->
    <UWPCoreRuntimeSdkVersion>UWP_CORE_RUNTIME_SDK_VERSION_NOT_SET</UWPCoreRuntimeSdkVersion>
    <UWPCoreRuntimeSdkVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.9\build\Microsoft.Net.UWPCoreRuntimeSdk.props')">2.2.9</UWPCoreRuntimeSdkVersion>
    <UWPCoreRuntimeSdkVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.10\build\Microsoft.Net.UWPCoreRuntimeSdk.props')">2.2.10</UWPCoreRuntimeSdkVersion>
    <UWPCoreRuntimeSdkVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.11\build\Microsoft.Net.UWPCoreRuntimeSdk.props')">2.2.11</UWPCoreRuntimeSdkVersion>
    <UWPCoreRuntimeSdkVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.12\build\Microsoft.Net.UWPCoreRuntimeSdk.props')">2.2.12</UWPCoreRuntimeSdkVersion>
    <UWPCoreRuntimeSdkVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.13\build\Microsoft.Net.UWPCoreRuntimeSdk.props')">2.2.13</UWPCoreRuntimeSdkVersion>
    <UWPCoreRuntimeSdkVersion Condition="Exists('$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\build\Microsoft.Net.UWPCoreRuntimeSdk.props')">2.2.14</UWPCoreRuntimeSdkVersion>
    <!-- End Custom .NET Native properties -->
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(ConsumeCSharpModules)' == 'true'">-->
  <!-- Start Custom .NET Native targets -->
  <!-- Import all of the .NET Native / CoreCLR props at the beginning of the project -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\$(UWPCoreRuntimeSdkVersion)\build\Microsoft.Net.UWPCoreRuntimeSdk.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\build\Microsoft.Net.UWPCoreRuntimeSdk.props
============================================================================================================================================
-->
  <PropertyGroup>
    <NetfxCoreRuntimeTargets>$(MSBuildThisFileDirectory)..\tools\CoreRuntime\Microsoft.Net.CoreRuntime.targets</NetfxCoreRuntimeTargets>
    <NetfxCoreRuntimeSettingsTargets>$(MSBuildThisFileDirectory)..\tools\CoreRuntime\Microsoft.Net.CoreRuntime.settings.targets</NetfxCoreRuntimeSettingsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk\$(UWPCoreRuntimeSdkVersion)\build\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\build\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk.props
============================================================================================================================================
-->
  <PropertyGroup>
    <CoreRuntimeSDKRootx86>$(MSBuildThisFileDirectory)..\tools</CoreRuntimeSDKRootx86>
    <CopyWin32Resourcesx86Path>$(MSBuildThisFileDirectory)..\tools\CoreRuntime\copywin32resources.exe</CopyWin32Resourcesx86Path>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk\$(UWPCoreRuntimeSdkVersion)\build\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\build\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk.props
============================================================================================================================================
-->
  <PropertyGroup>
    <CoreRuntimeSDKRootx64>$(MSBuildThisFileDirectory)..\tools</CoreRuntimeSDKRootx64>
    <CopyWin32Resourcesx64Path>$(MSBuildThisFileDirectory)..\tools\CoreRuntime\copywin32resources.exe</CopyWin32Resourcesx64Path>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\Microsoft.Net.Native.Compiler.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\Microsoft.Net.Native.Compiler.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.Native.Compiler.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ProjectNTargets>$(MSBuildThisFileDirectory)..\tools\Microsoft.NetNative.targets</ProjectNTargets>
    <ProjectNSettingsTargets>$(MSBuildThisFileDirectory)..\tools\Microsoft.NetNative.Settings.targets</ProjectNSettingsTargets>
    <UseNugetInstall>true</UseNugetInstall>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\runtime.win10-x86.Microsoft.Net.Native.Compiler.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\runtime.win10-x86.Microsoft.Net.Native.Compiler.props
============================================================================================================================================
-->
  <PropertyGroup>
    <IlcToolPathx86>$(MSBuildThisFileDirectory)..\tools\</IlcToolPathx86>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\runtime.win10-x64.Microsoft.Net.Native.Compiler.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\runtime.win10-x64.Microsoft.Net.Native.Compiler.props
============================================================================================================================================
-->
  <PropertyGroup>
    <IlcToolPathx64>$(MSBuildThisFileDirectory)..\tools\</IlcToolPathx64>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\runtime.win10-arm64.Microsoft.Net.Native.Compiler.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\runtime.win10-arm64.Microsoft.Net.Native.Compiler.props
============================================================================================================================================
-->
  <PropertyGroup>
    <IlcToolPatharm64>$(MSBuildThisFileDirectory)..\tools\</IlcToolPatharm64>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\$(DotNetNativeRuntimeVersion)\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.props
============================================================================================================================================
-->
  <PropertyGroup>
    <ILCSharedAssemblySDKRootx86>$(MSBuildThisFileDirectory)..\tools\SharedLibrary</ILCSharedAssemblySDKRootx86>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary\$(DotNetNativeRuntimeVersion)\build\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary.props
============================================================================================================================================
-->
  <PropertyGroup>
    <ILCSharedAssemblySDKRootx64>$(MSBuildThisFileDirectory)..\tools\SharedLibrary</ILCSharedAssemblySDKRootx64>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary\$(DotNetNativeRuntimeVersion)\build\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary.props">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary.props
============================================================================================================================================
-->
  <PropertyGroup>
    <ILCSharedAssemblySDKRootarm64>$(MSBuildThisFileDirectory)..\tools\SharedLibrary</ILCSharedAssemblySDKRootarm64>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.props
============================================================================================================================================
-->
  <!-- End Custom .NET Native targets -->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\PackageVersionDefinitions.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\PackageVersionDefinitions.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the MIT License.

  Assigns preprocessor definitions mirroring package version MSBuild props
  previously imported from "PackageVersion.g.props".
-->
  <ItemDefinitionGroup>
    <ClCompile>
      <PreprocessorDefinitions>
        RNW_VERSION=$(ReactNativeWindowsVersion);
        RNW_MAJOR=$(ReactNativeWindowsMajor);
        RNW_MINOR=$(ReactNativeWindowsMinor);
        RNW_PATCH=$(ReactNativeWindowsPatch);
        RNW_COMMITID=$(ReactNativeWindowsCommitId);
        %(PreprocessorDefinitions)
      </PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(ReactNativeWindowsCanary)' == 'true'">
        RNW_CANARY;
        %(PreprocessorDefinitions)
      </PreprocessorDefinitions>
    </ClCompile>
    <Midl>
      <PreprocessorDefinitions>
        RNW_VERSION=$(ReactNativeWindowsVersion);
        RNW_MAJOR=$(ReactNativeWindowsMajor);
        RNW_MINOR=$(ReactNativeWindowsMinor);
        RNW_PATCH=$(ReactNativeWindowsPatch);
        RNW_COMMITID=$(ReactNativeWindowsCommitId);
        %(PreprocessorDefinitions)
      </PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(ReactNativeWindowsCanary)' == 'true'">
        RNW_CANARY;
        %(PreprocessorDefinitions)
      </PreprocessorDefinitions>
    </Midl>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\external\Microsoft.ReactNative.Uwp.CppApp.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup>
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)pch.pch</PrecompiledHeaderOutputFile>
      <WarningLevel>Level4</WarningLevel>
      <AdditionalOptions>%(AdditionalOptions) /bigobj</AdditionalOptions>
      <DisableSpecificWarnings>4453;28204</DisableSpecificWarnings>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="MainPage.h">
      <DependentUpon>MainPage.xaml</DependentUpon>
      <SubType>Code</SubType>
    </ClInclude>
    <ClInclude Include="ReactPackageProvider.h" />
    <ClInclude Include="AutolinkedNativeModules.g.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="App.h">
      <DependentUpon>App.xaml</DependentUpon>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <SubType>Designer</SubType>
    </ApplicationDefinition>
  </ItemGroup>
  <ItemGroup>
    <AppxManifest Include="Package.appxmanifest">
      <SubType>Designer</SubType>
    </AppxManifest>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Assets\LockScreenLogo.scale-200.png" />
    <Image Include="Assets\SplashScreen.scale-200.png" />
    <Image Include="Assets\Square150x150Logo.scale-200.png" />
    <Image Include="Assets\Square44x44Logo.scale-200.png" />
    <Image Include="Assets\Square44x44Logo.targetsize-24_altform-unplated.png" />
    <Image Include="Assets\StoreLogo.png" />
    <Image Include="Assets\Wide310x150Logo.scale-200.png" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MainPage.cpp">
      <DependentUpon>MainPage.xaml</DependentUpon>
      <SubType>Code</SubType>
    </ClCompile>
    <ClCompile Include="ReactPackageProvider.cpp" />
    <ClCompile Include="AutolinkedNativeModules.g.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader>Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="App.cpp">
      <DependentUpon>App.xaml</DependentUpon>
    </ClCompile>
    <ClCompile Include="$(GeneratedFilesDir)module.g.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Midl Include="App.idl">
      <DependentUpon>App.xaml</DependentUpon>
    </Midl>
    <Midl Include="MainPage.idl">
      <DependentUpon>MainPage.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Midl>
  </ItemGroup>
  <ItemGroup>
    <None Include="PropertySheet.props" />
    <Text Include="readme.txt">
      <DeploymentContent>false</DeploymentContent>
    </Text>
  </ItemGroup>
  <ItemGroup>
    <Page Include="MainPage.xaml">
      <SubType>Designer</SubType>
    </Page>
  </ItemGroup>
  <ItemGroup />
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the properties required to build Visual C++ projects.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DesignTimeBuild)' == 'true'">
    <!-- Disable code analysis targets for designtime -->
    <CodeAnalysisTargets Condition="'$(CodeAnalysisTargets)'==''">CodeAnalysisTargets_disabled</CodeAnalysisTargets>
  </PropertyGroup>
  <!-- determine TargetRuntime to avoid msbuild common targets setting TargetFrameworkVersion for native projects -->
  <PropertyGroup Condition="'$(ManagedAssembly)' == ''">
    <ManagedAssembly>false</ManagedAssembly>
    <ManagedAssembly Condition="'$(CLRSupport)' != '' and '$(CLRSupport)' != 'false'">true</ManagedAssembly>
  </PropertyGroup>
  <!-- if a manged project does not define TargetFrameworkVersion set it to the current default -->
  <PropertyGroup>
    <TargetRuntime Condition="'$(TargetRuntime)' == '' and '$(ManagedAssembly)' == 'true'">Managed</TargetRuntime>
    <TargetRuntime Condition="'$(TargetRuntime)' == '' and '$(ManagedAssembly)' != 'true'">Native</TargetRuntime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed' and '$(CLRSupport)' != 'NetCore' and '$(TargetFrameworkVersion)' == ''">
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <TargetFrameworkVersionDefault>true</TargetFrameworkVersionDefault>
  </PropertyGroup>
  <!--<Import Project="Imports.props" Sdk="vcpkg:ManifestDirectory=$(VcpkgManifestDirectory);ImportFiles=$(ImportBeforeCppTargets)" Condition="'$(VcpkgManifestDirectory)' != '' and '$(ImportBeforeCppTargets)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Current.targets" Condition="'$(_Redirect)' != 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Current.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(ForceImportBeforeCppTargets)" Condition="Exists('$(ForceImportBeforeCppTargets)')" />-->
  <PropertyGroup>
    <SolutionExt>.sln</SolutionExt>
    <Language>C++</Language>
    <DefaultLanguageSourceExtension>.cpp</DefaultLanguageSourceExtension>
    <!-- List of optional installation bundles required -->
    <RequiredBundles Condition="'$(ApplicationType)' == 'Android'">$(RequiredBundles);Component.MDD.Android</RequiredBundles>
    <RequiredBundles Condition="'$(ApplicationType)' == 'iOS'">$(RequiredBundles);Component.MDD.IOS</RequiredBundles>
    <!-- Ensure that IntDir and OutDir will contain proper trailing slash.  Also set the flag to warn the user.  -->
    <IntDirTrailingSlashWarning Condition="'$(IntDir)' != '' and !HasTrailingSlash('$(IntDir)')">true</IntDirTrailingSlashWarning>
    <OutDirTrailingSlashWarning Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">true</OutDirTrailingSlashWarning>
    <IntDir Condition="'$(IntDir)' != '' and !HasTrailingSlash('$(IntDir)')">$(IntDir)\</IntDir>
    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
    <!-- Correct OutputPath as it may be out of sync with OutDir -->
    <OutputPath>$(OutDir)</OutputPath>
    <!-- Prevent error about OutputPath in Microsoft.Common.CurrentVersion.targets which happens before "Missing toolset" error -->
    <OutputPath Condition="'$(OutputPath)' == ''">Debug\</OutputPath>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Set Build Default Environment Variables
       ******************************************************************************************* -->
  <UsingTask TaskName="SetEnv" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <!-- Determine to use the 32 or 64 bit tools. -->
  <PropertyGroup>
    <_IsNativeEnvironment Condition="'$(PROCESSOR_ARCHITECTURE)' == 'AMD64' and '$(Platform)' == 'X64'">true</_IsNativeEnvironment>
    <_IsNativeEnvironment Condition="'$(PROCESSOR_ARCHITECTURE)' == 'IA64' and '$(Platform)' == 'Itanium'">true</_IsNativeEnvironment>
    <!-- VS2013 is not using DefaultToolArchitecture (it is using PreferredToolArchitecture instead), but need to keep it defined for older toolsets -->
    <DefaultToolArchitecture Condition="'$(DefaultToolArchitecture)' == '' and '$(_IsNativeEnvironment)' != 'true'">Native32Bit</DefaultToolArchitecture>
    <DefaultToolArchitecture Condition="'$(DefaultToolArchitecture)' == '' and '$(_IsNativeEnvironment)' == 'true'">Native64Bit</DefaultToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(LibraryWPath)' != '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' != '' and '$(TargetPlatformVersion)' != '7.0'">
    <ReferencePath>$(LibraryWPath);$(ReferencePath)</ReferencePath>
  </PropertyGroup>
  <PropertyGroup>
    <SetBuildDefaultEnvironmentVariablesDependsOn>
      AddExternalIncludDirectoriesToPaths;
      $(SetBuildDefaultEnvironmentVariablesDependsOn)
    </SetBuildDefaultEnvironmentVariablesDependsOn>
    <DetermineProjectTypeTargets>
      $(DetermineProjectTypeTargets);
      AddExternalIncludDirectoriesToPaths
    </DetermineProjectTypeTargets>
  </PropertyGroup>
  <Target Name="AddExternalIncludDirectoriesToPaths" DependsOnTargets="$(AddExternalIncludDirectoriesToPathsDependsOn)" Condition="'$(UseEnv)' != 'true'">
    <ItemGroup Condition="'$(ExternalIncludePath)' != ''">
      <_ExternalIncludePathToInclude Include="$(ExternalIncludePath)" />
      <_ExternalIncludePathToInclude Remove="$(IncludePath)" />
      <_ExternalIncludePathToExclude Include="$(ExternalIncludePath)" />
      <_ExternalIncludePathToExclude Remove="$(ExcludePath)" />
    </ItemGroup>
    <PropertyGroup>
      <IncludePath Condition="'@(_ExternalIncludePathToInclude)' != ''">$(IncludePath);@(_ExternalIncludePathToInclude)</IncludePath>
      <ExcludePath Condition="'@(_ExternalIncludePathToExclude)' != ''">$(ExcludePath);@(_ExternalIncludePathToExclude)</ExcludePath>
    </PropertyGroup>
    <ItemGroup>
      <_ExternalIncludePathToInclude Remove="@(_ExternalIncludePathToInclude)" />
      <_ExternalIncludePathToExclude Remove="@(_ExternalIncludePathToExclude)" />
    </ItemGroup>
  </Target>
  <Target Name="SetBuildDefaultEnvironmentVariables" DependsOnTargets="$(SetBuildDefaultEnvironmentVariablesDependsOn)" Condition="'$(UseEnv)' != 'true' and '$(DesignTimeBuild)' != 'true'">
    <!-- Vs2013 does not use NativeExecutablePath, but we have to keep this for older toolsets. -->
    <PropertyGroup>
      <ExecutablePath Condition="'$(_IsNativeEnvironment)' == 'true' and '$(NativeExecutablePath)' != ''">$(NativeExecutablePath)</ExecutablePath>
    </PropertyGroup>
    <SetEnv Name="PATH" Value="$(ExecutablePath)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="Path" />
    </SetEnv>
    <SetEnv Name="LIB" Value="$(LibraryPath)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="LIB" />
    </SetEnv>
    <SetEnv Name="LIBPATH" Value="$(ReferencePath)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="LIBPATH" />
    </SetEnv>
    <SetEnv Name="INCLUDE" Value="$(IncludePath)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="INCLUDE" />
    </SetEnv>
    <SetEnv Name="EXTERNAL_INCLUDE" Value="$(ExternalIncludePath)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="EXTERNAL_INCLUDE" />
    </SetEnv>
  </Target>
  <!-- *******************************************************************************************
    Set User Macro Environment Variables
     ******************************************************************************************* -->
  <Target Name="SetUserMacroEnvironmentVariables" Condition="'@(BuildMacro)' != '' and '$(DesignTimeBuild)' != 'true'">
    <SetEnv Condition="'%(BuildMacro.EnvironmentVariable)' == 'true'" Name="@(BuildMacro)" Value="%(BuildMacro.Value)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="%(BuildMacro.Identity)" />
    </SetEnv>
  </Target>
  <!-- *******************************************************************************************
       Import Platform targets or Makefile
       ******************************************************************************************* -->
  <!--<ImportGroup Condition="'$(ConfigurationType)' != 'Makefile'">-->
  <!--
============================================================================================================================================
  <Import Project="$(_PlatformTargets)" Condition="'$(_ToolsetFound)' == 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\Platform.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Platform.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps/targets required to build Visual C++ projects
specifically on x64 platforms.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- When UseNativeEnvironment or UseEnv on 64bit prompt, then try building with the 64bit native tools. -->
    <_IsNative64Available Condition="'$(_IsNative64Available)' == '' and Exists('$(VCToolsInstallDir)\bin\amd64') and ('$(PROCESSOR_ARCHITECTURE)' == 'AMD64' or '$(PROCESSOR_ARCHITEW6432)' == 'AMD64')">true</_IsNative64Available>
    <_IsNativeEnvironment Condition="'$(_IsNativeEnvironment)' == '' and (('$(PROCESSOR_ARCHITECTURE)' == 'AMD64' and '$(UseEnv)' == 'true') or ('$(UseNativeEnvironment)' != 'false' and '$(_IsNative64Available)' == 'true'))">true</_IsNativeEnvironment>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Platform.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Platform.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Platform.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps/targets required to build Visual C++ projects
specifically on x86 platforms.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Before -->
  <!--<Import Project="$(_PlatformFolder)ImportBefore\*.targets" Condition="Exists('$(_PlatformFolder)ImportBefore')" />-->
  <!-- Import platform toolset -->
  <!--
============================================================================================================================================
  <Import Project="$(_ToolsetTargetsPath)">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\PlatformToolsets\v143\Toolset.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Toolset.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <UseDefaultDebuggersPropertyPageSchemas>false</UseDefaultDebuggersPropertyPageSchemas>
  </PropertyGroup>
  <!-- Set of debuggers for Store apps targetting UAP SDK -->
  <!-- For UAP, debug targets are filtered by underlying OS(6.1 = Win7, 6.2 = win8, 6.3 = win8.1) -->
  <ItemGroup Condition="'$(TargetPlatformName)' == 'UAP'">
    <AppHostDebuggerPages Condition="'$(CurrentMajorVersionNumber)' == '10'" Include="$(VCTargetsPath)$(LangID)\AppHostDebugger_Local.xml" />
    <AppHostDebuggerPages Condition="'$(HostOsVersion)' &gt; '6.1'" Include="$(MSBuildExtensionsPath)\Microsoft\Universal\$(LangID)\WindowsAppEmulatorDebugger.xaml" />
    <AppHostDebuggerPages Include="$(VCTargetsPath)$(LangID)\AppHostDebugger_Remote.xml" />
    <AppHostDebuggerPages Include="$(MSBuildExtensionsPath)\Microsoft\Universal\$(LangID)\WindowsDeviceDebugger.xaml" />
  </ItemGroup>
  <ItemGroup>
    <DesktopDebuggerPages Include="$(VCTargetsPath)$(LangID)\debugger_local_windows.xml" />
    <DesktopDebuggerPages Include="$(VCTargetsPath)$(LangID)\debugger_remote_windows.xml" />
  </ItemGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportBefore\*.targets" Condition="Exists('$(MSBuildThisFileDirectory)ImportBefore')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.CppCommon.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CppCommon.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps/targets common to building Visual C++ projects.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Yield optimization properties -->
    <YieldDuringToolExecution Condition="'$(YieldDuringToolExecution)' == ''">true</YieldDuringToolExecution>
    <ClYieldDuringToolExecution Condition="'$(ClYieldDuringToolExecution)' == ''">$(YieldDuringToolExecution)</ClYieldDuringToolExecution>
    <MidlYieldDuringToolExecution Condition="'$(MidlYieldDuringToolExecution)' == ''">$(YieldDuringToolExecution)</MidlYieldDuringToolExecution>
  </PropertyGroup>
  <!-- Define the Target Macros-->
  <PropertyGroup>
    <!-- If OutDir was set outside of the project file, then we will append ProjectName -->
    <OutDir Condition="'$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
    <!-- Correct OutputPath as it may be out of sync with OutDir -->
    <OutputPath>$(OutDir)</OutputPath>
    <TargetPath Condition="'$(TargetPath)' == '' and '$(OutDirFullPath)'==''">$([MSBuild]::NormalizePath('$(ProjectDir)', '$(OutDir)$(TargetName)$(TargetExt)'))</TargetPath>
    <TargetPath Condition="'$(TargetPath)' == '' and '$(OutDirFullPath)'!=''">$(OutDirFullPath)$(TargetName)$(TargetExt)</TargetPath>
    <TargetFileName Condition=" '$(TargetFileName)'=='' ">$([System.IO.Path]::GetFileName('$(TargetPath)'))</TargetFileName>
    <!-- TargetDir is only used in msbuild common targets, but needs to be defined here (the same way as in Microsoft.Common.CurrentVersion.targets) for debugger properties working correctly -->
    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(OutDir)'))</TargetDir>
    <LocalDebuggerCommand Condition="'$(LocalDebuggerCommand)'==''">$(TargetPath)</LocalDebuggerCommand>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)'==''">$(IntDir)</IntermediateOutputPath>
    <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
    <ExtensionsToDeleteOnClean>$(ExtensionsToDeleteOnClean);$(TargetPath).manifest;$(OutDir)$(TargetName).tlb;$(OutDir)$(TargetName).pdb;$(TargetPath);$(OutDir)$(TargetName).bsc;$(OutDir)$(TargetName).ilk;$(TargetPath).intermediate.manifest;$(IntermediateOutputPath)$(CleanFile)</ExtensionsToDeleteOnClean>
    <!-- Set AppxPackageDir before OutDirWasSpecified is set false -->
    <AppxPackageDir Condition=" '$(OutDirWasSpecified)' == 'true' ">$(OutDir)AppPackages\</AppxPackageDir>
    <!-- After OutDir has been fixed, disable Microsoft.common.targets from fixing it again -->
    <OutDirWasSpecified>false</OutDirWasSpecified>
    <!-- Enable incremental build by enable file tracking in tasks-->
    <TrackFileAccess Condition="'$(TrackFileAccess)' == ''">true</TrackFileAccess>
    <!-- we cannot use structured logging with older compiler versions which don't support it yet -->
    <UseClStructuredOutput Condition="'$(UseStructuredOutput)' == 'true' and '$(_ClStructuredDiagnosticsPipeSupported)' == 'true'">true</UseClStructuredOutput>
  </PropertyGroup>
  <!--
  Link.exe can now embed manifest.  This helps the build avoid the double linking.  The build will pretend that it is embedding by MT, but instead
  of passing MT the embed command, it will pass it them to link.exe via /manifest:embed and /manifestinput.  MT will still run incase there are other utilities
  MT provides.

  To revert back to the old behavior set $(LegacyManifestEmbedding) to true.
  -->
  <!-- If we are compiling managed -->
  <PropertyGroup Condition="'$(GenerateManifest)' == 'true' AND '$(EmbedManifest)'=='true' AND '$(CLRSupport)'!='' AND '$(CLRSupport)'!='false' AND&#xD;&#xA;      ('$(ConfigurationType)'=='Application' OR '$(ConfigurationType)'=='DynamicLibrary' ) ">
    <EmbedManifestBy Condition="'$(LinkKeyFile)'=='' OR '$(LinkDelaySign)'=='true'">MT</EmbedManifestBy>
    <EmbedManifestBy Condition="'$(LinkKeyFile)'!='' AND '$(LinkDelaySign)'!='true'">LINK</EmbedManifestBy>
  </PropertyGroup>
  <!-- If we are compiling native -->
  <PropertyGroup Condition="'$(GenerateManifest)' == 'true' AND '$(EmbedManifest)'=='true' AND ('$(CLRSupport)'=='false' or '$(CLRSupport)'=='') AND&#xD;&#xA;      ('$(ConfigurationType)'=='Application' OR '$(ConfigurationType)'=='DynamicLibrary' ) ">
    <EmbedManifestBy Condition="'$(LinkIncremental)'=='true'">LINK</EmbedManifestBy>
    <EmbedManifestBy Condition="'$(LinkIncremental)'!='true'">MT</EmbedManifestBy>
  </PropertyGroup>
  <PropertyGroup>
    <MicrosoftNETSdkBeforeCommonTargets Condition="'$(MicrosoftNETSdkBeforeCommonTargets)' == ''">Sdk.BeforeCommon.targets</MicrosoftNETSdkBeforeCommonTargets>
    <MicrosoftNETSdkAfterCommonTargets Condition="'$(MicrosoftNETSdkAfterCommonTargets)' == ''">Sdk.AfterCommon.targets </MicrosoftNETSdkAfterCommonTargets>
    <EnableManagedIncrementalBuild Condition="'$(CLRSupport)' == 'NetCore'">false</EnableManagedIncrementalBuild>
    <!-- Turn off the PackageReference support for projects that do not target .NET (e.g., CLR .NET Framework projects) -->
    <EnableManagedPackageReferenceSupport Condition="'$(CLRSupport)' != 'NetCore'">false</EnableManagedPackageReferenceSupport>
    <SkipImportNuGetBuildTargets Condition="'$(EnableManagedPackageReferenceSupport)' == 'true'">true</SkipImportNuGetBuildTargets>
    <EnableVCProjectCache Condition="'$(EnableManagedPackageReferenceSupport)' == 'true'">false</EnableVCProjectCache>
    <_EnablePackageReferencesInVCProjects Condition="'$(EnableManagedPackageReferenceSupport)' == 'true'">true</_EnablePackageReferencesInVCProjects>
    <RestoreProjectStyle Condition="'$(EnableManagedPackageReferenceSupport)' == 'true'">PackageReference</RestoreProjectStyle>
  </PropertyGroup>
  <!--<Import Project="$(MicrosoftNETSdkBeforeCommonTargets)" Sdk="Microsoft.NET.Sdk" Condition="'$(CLRSupport)' == 'NetCore' and '$(ImportNETCoreSdkFromVCTargets)' != 'false'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.CppBuild.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppBuild.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CppBuild.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps/targets required to build Visual C++ projects.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="VCMessage" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="CheckVCToolsetVersion" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="GenerateDesktopDeployRecipe" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="GetOutputFileNameItems" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="CleanupStaleTlogItems" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <!-- *******************************************************************************************
        Tools usage for various config types
       ******************************************************************************************* -->
  <!-- Possible VC config types are:
         Unknown     (can be makefile, but not necessarily)
         Application (exe)
         DynamicLibrary (dll)
         StaticLibrary (lib)
         Generic (utility like copy, zip, etc.) -->
  <PropertyGroup>
    <IntDirFullPath>$([MSBuild]::NormalizePath('$(ProjectDir)', '$(IntDir)'))</IntDirFullPath>
    <OutDirFullPath>$([MSBuild]::NormalizePath('$(ProjectDir)', '$(OutDir)'))</OutDirFullPath>
    <DesktopDeployRecipeFile Condition="'$(GenerateDesktopDeployRecipeFile)'=='true' and '$(DesktopDeployRecipeFile)' == ''">$(IntDirFullPath)$(TargetName)$(TargetExt).recipe</DesktopDeployRecipeFile>
    <WinMDAssembly Condition="'$(WinMDAssembly)' == ''">false</WinMDAssembly>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.BuildSteps.Targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.BuildSteps.Targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.BuildSteps.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for C++ projects.  It
contains all the steps that are specific to building Visual C++ projects.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <GenerateTargetFrameworkAttribute Condition="'$(CLRSupport)' == '' or '$(CLRSupport)' == 'false'">false</GenerateTargetFrameworkAttribute>
    <AssemblyName Condition="'$(CLRSupport)' == 'netcore' and '$(TargetName)' != ''">$(TargetName)</AssemblyName>
    <!-- By default we do not want to build project to project references if they are disabled in the solution configuration -->
    <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration Condition="'$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)' == ''">true</OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>
    <_BuildActionType Condition="'$(_BuildActionType)' == ''">Build</_BuildActionType>
  </PropertyGroup>
  <!-- disable intermediate pdb copy to output dir by msbuild common targets, it should never be done for C++ build -->
  <PropertyGroup>
    <!-- avoid msbuild warning about not defined property -->
    <DebugType Condition="'$(DebugType)' == ''" />
    <_DebugTypeOld>$(DebugType)</_DebugTypeOld>
    <DebugType>none</DebugType>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.Targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="">
    <CommonTargetsPath>$(MSBuildToolsPath)\Microsoft.Common.CurrentVersion.targets</CommonTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CommonTargetsPath)">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(MicrosoftCommonPropsHasBeenImported)' != 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />-->
  <PropertyGroup xmlns="">
    <ImportByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonTargets>
    <ImportByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportBefore\Microsoft.Cpp.VCLibs120Universal.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.cpp.VCLibs120Universal.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
      created a backup copy.  Incorrect changes to this file will make it
      impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>$(_GenerateAppxManifestDependsOn);_FixVCLibs120References</_GenerateAppxManifestDependsOn>
  </PropertyGroup>
  <Target Name="_FixVCLibs120References" Condition="'$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP'">
    <!-- Check if VC libs 120 reference is found,  If found remove it-->
    <ItemGroup>
      <VCLibs120Ref Include="'%(PackagingOutputs.SDKName)'" Condition="'%(PackagingOutputs.SDKName)' == 'Microsoft.VCLibs, Version=12.0'" />
    </ItemGroup>
    <ItemGroup Condition="'@(VCLibs120Ref)' != ''">
      <PackagingOutputs Remove="@(PackagingOutputs)" Condition="'%(PackagingOutputs.SDKName)' == 'Microsoft.VCLibs, Version=12.0'" />
    </ItemGroup>
    <!-- Get the resolved SDK reference item for Microsoft.VCLibs.120, Version=14.0 and add that to the packaging output -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == '' and '@(VCLibs120Ref)' != ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <ResolveSDKReference SDKReferences="Microsoft.VCLibs.120, Version=14.0" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)" Condition="'@(VCLibs120Ref)' != ''">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="VCLibs12UniversalReference" />
    </ResolveSDKReference>
    <ItemGroup Condition="'@(VCLibs120Ref)' != '' and '@(VCLibs12UniversalReference)' != '' ">
      <PackagingOutputs Include="@(VCLibs12UniversalReference)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
      </PackagingOutputs>
    </ItemGroup>
  </Target>
  <!-- This target adds reference to the Microsoft.UniversalCRT.Debug Extension SDK for UWP apps that :
  reference the Microsoft.VCLibs.14.00.Debug framework package
  Needs to run after the GetPackagingOutputs so that it is not added if a UCRT Debug reference is already present in the parent or referenced projects. -->
  <Target Name="_AddVCLibs140UniversalCrtDebugReference" AfterTargets="GetPackagingOutputs" Condition="'$(DisableImplicitUCRTReference)' == '' and '$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP'">
    <!-- ******************************************************************************
           This item group queries the application project for the following traits:
           a. Microsoft.VCLibs, Version=14.0, Configuration=Debug is referenced by the project or its referenced projects
           b. This project or its referenced projects already reference Microsoft.UniversalCRT.Debug, Version=<Any>
           ******************************************************************************* -->
    <ItemGroup>
      <VCLibs140UCRTRef Include="'%(PackagingOutputs.SDKName)'" Condition="'%(PackagingOutputs.SDKName)' == 'Microsoft.VCLibs, Version=14.0' and ('%(PackagingOutputs.TargetedSDKConfiguration)' == 'Debug' or '$(Configuration)'=='Debug')" />
      <HasUCRTRef Include="'%(PackagingOutputs.SDKName)'" Condition="$([System.String]::new('%(PackagingOutputs.SDKName)').StartsWith('Microsoft.UniversalCRT.Debug, Version='))" />
    </ItemGroup>
    <!-- Add UCRT Debug reference if one is not already specified and the project (or referenced projects) have a reference to VCLibs140 framework package -->
    <PropertyGroup>
      <AddUCRTRef Condition="'@(HasUCRTRef)'=='' and '@(VCLibs140UCRTRef)'!=''">true</AddUCRTRef>
    </PropertyGroup>
    <!-- Get the resolved SDK reference item for Microsoft.UniversalCRT.Debug, Version=<TPV> and add that to the packaging output -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == '' and '$(AddUCRTRef)'=='true'">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <!-- Find the Microsoft.Ucrt.Debug ESDK, based upon TPV.  This package is installed by the Windows 10 SDK, so there should always be a matching
           ESDK for given TPV value -->
    <ResolveSDKReference Condition="'$(AddUCRTRef)'=='true'" SDKReferences="Microsoft.UniversalCRT.Debug, Version=$(TargetPlatformVersion)" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="UniversalCrtDebugReference" />
    </ResolveSDKReference>
    <!-- Add the resolved ucrtbased.dll to the packaging output -->
    <ItemGroup>
      <PackagingOutputs Condition="'$(AddUCRTRef)' == 'true'" Include="@(UniversalCrtDebugReference->'%(Identity)\redist\Debug\%(TargetedSDKArchitecture)\ucrtbased.dll')">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(MSBuildProjectName)</ProjectName>
        <TargetPath>ucrtbased.dll</TargetPath>
      </PackagingOutputs>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportBefore\Microsoft.Net.CoreRuntime.ImportBefore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.ImportBefore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NetfxCoreRuntimeSettingsTargets Condition="'$(NetfxCoreRuntimeSettingsTargets)'==''">$(MSBuildProgramFiles32)\MSBuild\15.0\.Net\CoreRuntime\Microsoft.Net.CoreRuntime.Settings.targets</NetfxCoreRuntimeSettingsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NetfxCoreRuntimeSettingsTargets)" Condition="'$(TargetPlatformIdentifier)' == 'UAP' and '$(AppxPackage)' == 'true' and exists('$(NetfxCoreRuntimeSettingsTargets)')">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\tools\CoreRuntime\Microsoft.Net.CoreRuntime.settings.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.Settings.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_CoreRuntimeVersion>2.2</_CoreRuntimeVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportBefore\Microsoft.Net.CoreRuntime.ImportBefore.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportBefore\Microsoft.NetNative.ImportBefore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.ImportBefore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_ProjectNPlatformSupported Condition="'$(TargetPlatformIdentifier)' == 'UAP'">true</_ProjectNPlatformSupported>
    <_ProjectNProjectSupported Condition="'$(AppxPackage)' == 'true'">true</_ProjectNProjectSupported>
    <!-- Denotes that Microsoft .Net Native is supported by this kind of project so corresponding UI elements should be visible -->
    <CanUseProjectN Condition="'$(_ProjectNPlatformSupported)' == 'true' and '$(_ProjectNProjectSupported)' == 'true'">true</CanUseProjectN>
    <UseDotNetNativeToolchain Condition="'$(UseDotNetNativeToolchain)' == ''">$(UseProjectNToolchain)</UseDotNetNativeToolchain>
    <ProjectNProfileEnabled Condition="'$(CanUseProjectN)'=='true'">true</ProjectNProfileEnabled>
    <ProjectNSettingsTargets Condition="'$(ProjectNSettingsTargets)'==''">$(MSBuildProgramFiles32)\MSBuild\15.0\.Net\.NetNative\15.0.24211\Microsoft.NetNative.Settings.targets</ProjectNSettingsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ProjectNSettingsTargets)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(ProjectNSettingsTargets)')">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\tools\Microsoft.NetNative.Settings.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.Settings.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Check platform and project for Microsoft .Net Native support -->
  <PropertyGroup>
    <DefineConstants Condition="'$(ProjectNProfileEnabled)'=='true'">$(DefineConstants);CODE_ANALYSIS</DefineConstants>
  </PropertyGroup>
  <!--
    Arm64 has no CoreCLR so must always use the .NET native toolchain
  -->
  <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(PlatformTarget)' == 'arm64'">
    <UseDotNetNativeToolchain>true</UseDotNetNativeToolchain>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportBefore\Microsoft.NetNative.ImportBefore.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportBefore\Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportBefore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportBefore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
    This .targets automatically sets 'UseUwpTools' for apps using 'UseUwp'. this property is used by the .NET 9 SDK, and it makes
    it reference the new WinRT projections for Windows.UI.Xaml.* types in the Windows SDK package for .NET projects. In the vast
    majority of cases, projects setting this property indent to actually be compiled as UWP (that is, importing all tooling for
    UWP apps, such as the XAML compiler). Because of this, and also to make the experience consistent with other UI frameworks
    such as WinForms, WPF and WinUI 3, which also use a single property to enable their associated tooling (ie. 'UseWinForms',
    'UseWpf' and 'UseWinUI' respectively), we automatically set 'UseUwpTools' for all projects setting 'UseUwp' by default.

    For advanced "mixed-mode" scenarios where projects are both referencing Windows.UI.Xaml.* projections and using WindowsAppSDK,
    and do not intend to compile as a UWP app, they can manually disable 'UseUwpTools', and we will respect their preference.

    Note that this property is set in an 'ImportBefore' .targets file, for two reasons:
      - We need to read properties set in the .csproj (or in any .props files), so we must be a .targets file.
      - We need to set this default option as soon as possible after the project is evaluated, such that the default option is
        visible not only to .targets imported by NuGet packages, but also by any Directory.Build.targets files, as well as any
        'CustomBeforeMicrosoftCommonTargets' files. MSBuild will import this file before all of them, as it will be picked up
        by 'Microsoft.Common.CurrentVersion.targets' before any 'CustomBeforeMicrosoftCommonTargets' file as well.
  -->
  <PropertyGroup>
    <UseUwpTools Condition="'$(UseUwp)' == 'true' AND '$(UseUwpTools)' == ''">true</UseUwpTools>
  </PropertyGroup>
  <!--
    We want to allow projects to skip defining 'TargetPlatformMinVersion', which should automatically match the target platform
    version specified in 'TargetFramework' in that case. For WinUI 3, this is handled automatically by the .NET SDK, which sets
    the value of 'TargetPlatformMinVersion' from 'Microsoft.NET.Windows.targets' to either sync with 'SupportedOSPlatformVersion',
    if that property is set, or to just match 'TargetPlatformVersion' otherwise. For UWP apps, we cannot rely on that same logic,
    because there are various checks in the APPX and XAML compiler .targets that assume this property should already be set by
    the time they are imported, which happens before that .targets from the .NET SDK. To work around this, we can check whether
    the current project didn't define 'TargetPlatformMinVersion', and automatically set it from here. This file is imported
    before any of the APPX or XAML .targets, so that ensures those will work correctly. The logic below matches the behavior
    of the .NET SDK, with the only difference being that it only sets 'TargetPlatformMinVersion' (not 'SupportedOSPlatformVersion').

    Note that this .targets file is imported well after 'Microsoft.NET.TargetFrameworkInference.targets', so we can rely on that
    setting the value of 'TargetPlatformVersion' used below, meaning that we don't have to parse 'TargetFramework' from here.
  -->
  <PropertyGroup Condition="'$(UseUwpTools)' == 'true'">
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)' == ''">$(SupportedOSPlatformVersion)</TargetPlatformMinVersion>
    <TargetPlatformMinVersion Condition="'$(TargetPlatformMinVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformMinVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />-->
  <!-- VS10 without SP1 and without VS11 will not have VisualStudioVersion set, so do that here -->
  <PropertyGroup xmlns="">
    <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
    <ReportingServicesTargets Condition="'$(ReportingServicesTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\ReportingServices\Microsoft.ReportingServices.targets</ReportingServicesTargets>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonTargets)" Condition="'$(CustomBeforeMicrosoftCommonTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonTargets)')" />-->
  <!-- By default, we are creating a managed app because .NET 2.0 projects did not have this property. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == ''" xmlns="">
    <TargetRuntime>Managed</TargetRuntime>
  </PropertyGroup>
  <!-- Because .NET 2.0 apps did not set TargetFrameworkIdentifier, we need to set it for them here by default.  If
       the runtime is set to Managed, we also need to set these.  Otherwise they should be blank (for instance Javascript or
       Native apps) because they do not target a .NET Framework. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed'" xmlns="">
    <TargetFrameworkIdentifier Condition="'$(TargetFrameworkIdentifier)' == ''">.NETFramework</TargetFrameworkIdentifier>
    <TargetFrameworkVersion Condition=" '$(TargetFrameworkVersion)' == '' ">v4.0</TargetFrameworkVersion>
  </PropertyGroup>
  <!-- AvailablePlatforms is the list of platform targets available. -->
  <PropertyGroup xmlns="">
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' == '10.0' or '$(VisualStudioVersion)' == ''">Any CPU,x86,x64,Itanium</AvailablePlatforms>
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0'">Any CPU,x86,x64</AvailablePlatforms>
  </PropertyGroup>
  <!-- Import depends on if it is .NETCore. Imports for .NETFramework is a superset of that for .NETCore-->
  <!--<Import Project="Microsoft.NETFramework.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight'" />-->
  <!--<Import Project="Microsoft.NET.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' or '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" />-->
  <PropertyGroup xmlns="">
    <!-- Generates full paths for the 'File' property in errors, warnings and messages in many targets -->
    <GenerateFullPaths Condition="'$(GenerateFullPaths)' == ''">true</GenerateFullPaths>
    <!-- Yield optimization properties -->
    <YieldDuringToolExecution Condition="'$(YieldDuringToolExecution)' == ''">true</YieldDuringToolExecution>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' != '' and '$(TargetFrameworkVersion)' != ''" xmlns="">
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == '' and '$([System.String]::IsNullOrWhitespace($(TargetFrameworkProfile)))' != 'true'">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion),Profile=$(TargetFrameworkProfile)</TargetFrameworkMoniker>
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
    <!-- When working off a packaged reference assemblies, do not go to machine-global locations. This property is target-framework-specific, so it cannot be overridden in msbuild.exe.config once and for all. -->
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And '$(FrameworkPathOverride)' == '' And Exists('$(TargetFrameworkRootPath)$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)')">$(TargetFrameworkRootPath)$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)</FrameworkPathOverride>
    <!-- The FrameworkPathOverride is required for the inproc visual basic compiler to initialize when targeting target frameworks less than 4.0. If .net 2.0 is not installed then the property value above will not provide the location
             of mscorlib. This is also true if the build author overrides this property to some other directory which does not contain mscorlib.dll. In the case we cannot find mscorlib.dll at the correct location
             we need to find a directory which does contain mscorlib to allow the inproc compiler to initialize and give us the chance to show certain dialogs in the IDE (which only happen after initialization).-->
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And '$(FrameworkPathOverride)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToStandardLibraries($(TargetFrameworkIdentifier), $(TargetFrameworkVersion), $(TargetFrameworkProfile), $(PlatformTarget), $(TargetFrameworkRootPath), $(TargetFrameworkFallbackSearchPaths)))</FrameworkPathOverride>
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And !Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">Windows</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">7.0</TargetPlatformVersion>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformSdkRootOverride)' != ''">$(TargetPlatformSdkRootOverride)\</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and $([MSBuild]::IsOSPlatform('Windows')) and '$(MSBuildRuntimeType)' != 'Core'">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKLocation($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformSdkPath>
    <TargetPlatformSdkMetadataLocation Condition="'$(TargetPlatformSdkMetadataLocation)' == '' and Exists('$(TargetPlatformSdkPath)')">$(TargetPlatformSdkPath)Windows Metadata</TargetPlatformSdkMetadataLocation>
    <TargetPlatformSdkMetadataLocation Condition="Exists('$(TargetPlatformSdkPath)') and ('$(TargetPlatformSdkMetadataLocation)' == '' or !Exists('$(TargetPlatformSdkMetadataLocation)'))">$(TargetPlatformSdkPath)References\CommonConfiguration\Neutral</TargetPlatformSdkMetadataLocation>
    <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == '' and Exists('$(TargetPlatformSdkMetadataLocation)')">$(TargetPlatformSdkMetadataLocation)</TargetPlatformWinMDLocation>
    <UseOSWinMdReferences Condition="'$(UseOSWinMdReferences)' == '' and ('$(TargetPlatformWinMDLocation)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &gt; '7.0')">true</UseOSWinMdReferences>
    <TargetPlatformWinMDLocation Condition="'$(UseOsWinMdReferences)' == 'true'">$(WinDir)\System32\WinMetadata</TargetPlatformWinMDLocation>
    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != '' and '$(TargetPlatformVersion)' != ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
    <TargetPlatformDisplayName Condition="'$(TargetPlatformDisplayName)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
  </PropertyGroup>
  <!--
    Several properties must be set in the main project file, before using this .TARGETS file.
    However, if the properties are not set, we pick some defaults.

    OutDir:
    Indicates the final output location for the project or solution. When building a solution,
    OutDir can be used to gather multiple project outputs in one location. In addition,
    OutDir is included in AssemblySearchPaths used for resolving references.

    BaseOutputPath:
    This is the top level folder where all configuration specific output folders will be created.
    Default value is bin\

    OutputPath:
    This is the full Output Path, and is derived from BaseOutputPath, if none specified
    (eg. bin\Debug). If this property is overridden, then setting BaseOutputPath has no effect.

    For Legacy projects using only Common targets, this property is usually specified in the project file
    and is used to initialize OutDir. Some SDKs including the .NET SDK derive this automatically.
    OutDir and OutputPath are distinguished for legacy reasons, and OutDir should be used if at all possible.

    BaseIntermediateOutputPath:
    This is the top level folder where all configuration specific intermediate output folders will be created.
    Default value is obj\

    IntermediateOutputPath:
    This is the full intermediate Output Path, and is derived from BaseIntermediateOutputPath, if none specified
    (eg. obj\Debug). If this property is overridden, then setting BaseIntermediateOutputPath has no effect.

    Ensure any and all path property has a trailing slash, so it can be concatenated.
    -->
  <PropertyGroup xmlns="">
    <!-- Example, AnyCPU -->
    <_OriginalPlatform>$(Platform)</_OriginalPlatform>
    <!-- Example, Debug -->
    <_OriginalConfiguration>$(Configuration)</_OriginalConfiguration>
    <!-- Check whether OutputPath was specified for valid Configuration/Platform combination -->
    <_OutputPathWasMissing Condition="'$(_OriginalPlatform)' != '' and '$(_OriginalConfiguration)' != '' and '$(OutputPath)' == ''">true</_OutputPathWasMissing>
    <!-- Check whether BaseOutputPath was specified -->
    <BaseOutputPathWasSpecified Condition="'$(BaseOutputPath)' != ''">true</BaseOutputPathWasSpecified>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <Platform Condition="'$(Platform)' == ''">AnyCPU</Platform>
    <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <ConfigurationName Condition="'$(ConfigurationName)' == ''">$(Configuration)</ConfigurationName>
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseOutputPath)$(Configuration)\</OutputPath>
    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseOutputPath)$(PlatformName)\$(Configuration)\</OutputPath>
    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!-- Determine OutputType property from the legacy TargetType property -->
    <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
    <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
    <OutputType Condition=" '$(OutputType)' == '' ">exe</OutputType>
    <DebugSymbols Condition=" '$(ConfigurationName)' == 'Debug' and '$(DebugSymbols)' == '' and '$(DebugType)'==''">true</DebugSymbols>
    <!-- Whether or not a .pdb file is produced. -->
    <_DebugSymbolsProduced>false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugSymbols)'=='true'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='none'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='pdbonly'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='portable'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='embedded'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(ProduceOnlyReferenceAssembly)'=='true'">false</_DebugSymbolsProduced>
    <!-- Whether or not a .xml file is produced. -->
    <_DocumentationFileProduced>true</_DocumentationFileProduced>
    <_DocumentationFileProduced Condition="'$(DocumentationFile)'==''">false</_DocumentationFileProduced>
    <!-- Whether or not a reference assembly is produced. -->
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == ''">false</ProduceReferenceAssembly>
  </PropertyGroup>
  <!--
    For Legacy projects that define properties per Configuration/Platform combination, the validity of an
    invalid combination is determined by the non-empty value of the 'OutputPath' property specified under
    the IDE generated Configuration/Platform specific 'PropertyGroup' section.

    If 'BaseOutputPath' is specified, we can skip the validation, since, we assume the 'OutputPath' property
    will be derived (e.g.: from the 'BaseOutputPath' property).
  -->
  <PropertyGroup Condition="'$(BaseOutputPathWasSpecified)' != 'true' and '$(_OutputPathWasMissing)' == 'true'" xmlns="">
    <!--
        When 'OutputPath' is missing or empty (along with non-existent 'BaseOutputPath') at this point means,
        we're in legacy mode and we shall assume the current Configuration/Platform combination as invalid.
        Whether this is considered an error or a warning depends on the value of $(SkipInvalidConfigurations).
    -->
    <_InvalidConfigurationMessageSeverity Condition=" '$(SkipInvalidConfigurations)' == 'true' ">Warning</_InvalidConfigurationMessageSeverity>
    <_InvalidConfigurationMessageSeverity Condition=" '$(SkipInvalidConfigurations)' != 'true' ">Error</_InvalidConfigurationMessageSeverity>
  </PropertyGroup>
  <!--
    IDE Macros available from both integrated builds and from command line builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps.
  -->
  <PropertyGroup xmlns="">
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='exe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='appcontainerexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='library'">.dll</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='module'">.netmodule</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winmdobj'">.winmdobj</TargetExt>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!-- Required for enabling Team Build for packaging app package-generating projects -->
    <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
    <!-- Example, bin\Debug\ -->
    <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
    <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
    <!-- Example, MyProject -->
    <!-- For projects that generate app packages or ones that want a per-project output directory, update OutDir to include the project name -->
    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
    <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
    <TargetName Condition="'$(TargetName)' == '' and '$(OutputType)' == 'winmdobj' and '$(RootNamespace)' != ''">$(RootNamespace)</TargetName>
    <TargetName Condition=" '$(TargetName)' == '' ">$(AssemblyName)</TargetName>
    <!-- Example, MyAssembly -->
    <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>
    <!-- Example, MyProject.csproj -->
    <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>
    <!-- Example, .csproj -->
    <WinMDExpOutputWindowsMetadataFilename Condition="'$(WinMDExpOutputWindowsMetadataFilename)' == '' and '$(OutputType)' == 'winmdobj'">$(TargetName).winmd</WinMDExpOutputWindowsMetadataFilename>
    <TargetFileName Condition=" '$(TargetFileName)' == '' and '$(OutputType)' == 'winmdobj'">$(WinMDExpOutputWindowsMetadataFilename)</TargetFileName>
    <TargetFileName Condition=" '$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>
    <!-- Example, MyAssembly.dll -->
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!--
        The PublishableProject property is used when invoking the publish target on a solution that
        contains multiple projects. The property determines which projects should be published, and
        which projects should be skipped in the publish target. By default any "Windows Application"
        or "Console Application" project type is publishable. However, a project that would otherwise
        be published can be skipped by defining the PublishableProject property in the project itself.
        -->
    <_DeploymentPublishableProjectDefault Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">true</_DeploymentPublishableProjectDefault>
    <PublishableProject Condition="'$(PublishableProject)'==''">$(_DeploymentPublishableProjectDefault)</PublishableProject>
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='library'">Native.$(AssemblyName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, Native.MyAssembly.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='winexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='exe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='appcontainerexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' != 'true'">$(AssemblyName).application</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.application -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.xbap -->
    <GenerateClickOnceManifests Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">$(GenerateManifests)</GenerateClickOnceManifests>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='library'">Native.$(AssemblyName)</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='winexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='exe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='appcontainerexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' != 'true'">$(AssemblyName).application</_DeploymentDeployManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</_DeploymentDeployManifestIdentity>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'=='true'">.deploy</_DeploymentFileMappingExtension>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'!='true'" />
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'=='true'">$(UpdateInterval)</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'=='true'">$(UpdateIntervalUnits)</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'!='true'">0</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true' and '$(Install)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>
    <_DeploymentLauncherBased Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_DeploymentLauncherBased>
    <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <!--
        By default, GenerateApplicationManifest puts all satellite assemblies to the manifest
        record by default by setting TargetCulture to *.
        -->
    <TargetCulture Condition="'$(TargetCulture)'==''">*</TargetCulture>
    <FallbackCulture Condition="'$(UICulture)'!='' and '$(FallbackCulture)'==''">$(UICulture)</FallbackCulture>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <!-- Not used any more-->
    <_OutputPathItem Include="$(OutDir)" />
    <_UnmanagedRegistrationCache Include="$(BaseIntermediateOutputPath)$(MSBuildProjectFile).UnmanagedRegistration.cache" />
    <_ResolveComReferenceCache Include="$(IntermediateOutputPath)$(MSBuildProjectFile).ResolveComReference.cache" />
  </ItemGroup>
  <PropertyGroup xmlns="">
    <!-- Example, C:\MyProjects\MyProject\bin\Debug\ -->
    <!--
        Condition intentionally omitted on this one, because it causes problems
        when we pick up the value of an environment variable named TargetDir
        -->
    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::Escape($([System.IO.Path]::GetFullPath(`$([System.IO.Path]::Combine(`$(MSBuildProjectDirectory)`, `$(OutDir)`))`))))</TargetDir>
    <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
    <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and '$(ProduceReferenceAssemblyInOutDir)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
    <!-- Example, C:\MyProjects\MyProject\ -->
    <ProjectDir Condition=" '$(ProjectDir)' == '' ">$([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))</ProjectDir>
    <!-- Example, C:\MyProjects\MyProject\MyProject.csproj -->
    <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <!-- This is not used here but remains for backwards compatibility -->
    <AppConfigFileDestination Include="$(OutDir)$(TargetFileName).config" />
  </ItemGroup>
  <!--
    IDE Macros available only from integrated builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps. However, they are not defined when directly building
    a project from the command line, only when building a solution.
    -->
  <PropertyGroup xmlns="">
    <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
    <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
    <!-- Example, MySolution -->
    <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
    <!-- Example, MySolution.sln -->
    <SolutionPath Condition="'$(SolutionPath)'==''">*Undefined*</SolutionPath>
    <!-- Example, f:\MySolutions\MySolution\MySolution.sln -->
    <SolutionDir Condition="'$(SolutionDir)'==''">*Undefined*</SolutionDir>
    <!-- Example, f:\MySolutions\MySolution\ -->
    <SolutionExt Condition="'$(SolutionExt)'==''">*Undefined*</SolutionExt>
    <!-- Example, .sln -->
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <GenerateBindingRedirectsOutputType Condition="'$(OutputType)'=='exe' or '$(OutputType)'=='winexe'">true</GenerateBindingRedirectsOutputType>
    <!-- It would be a breaking change to automatically turn on binding redirects for existing projects, so turn them on only when opting into a new framework. -->
    <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion.TrimStart(vV))' &gt;= '4.7.2'">true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AutoUnifyAssemblyReferences)' == ''" xmlns="">
    <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
    <AutoUnifyAssemblyReferences Condition="'$(GenerateBindingRedirectsOutputType)' == 'true' and '$(AutoGenerateBindingRedirects)' != 'true'">false</AutoUnifyAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
    <!-- During DesignTime Builds, skip project reference build as Design time is only queueing information.-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == '' and '$(DesignTimeBuild)' == 'true'">false</BuildProjectReferences>
    <!-- By default we will build (and if applicable, clean) all project references. But this can be used to disable that-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == ''">true</BuildProjectReferences>
    <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
    <_ResolveReferenceDependencies Condition="'$(_ResolveReferenceDependencies)' == ''">false</_ResolveReferenceDependencies>
    <_GetChildProjectCopyToOutputDirectoryItems Condition="'$(_GetChildProjectCopyToOutputDirectoryItems)' == ''">true</_GetChildProjectCopyToOutputDirectoryItems>
    <OverwriteReadOnlyFiles Condition="'$(OverwriteReadOnlyFiles)' == ''">false</OverwriteReadOnlyFiles>
    <ComReferenceNoClassMembers Condition="'$(ComReferenceNoClassMembers)' == ''">false</ComReferenceNoClassMembers>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''" xmlns="">
    <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 codepoints of the filename and a filename hash. -->
    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByAsciiChars($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
    <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" />
    <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')" />
    <CopyUpToDateMarker Include="$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildCopyMarkerName)'))" />
  </ItemGroup>
  <ItemGroup Condition="'$(ProduceReferenceAssembly)' == 'true'" xmlns="">
    <IntermediateRefAssembly Include="$(IntermediateOutputPath)refint\$(TargetName)$(TargetExt)" Condition="'@(IntermediateRefAssembly)' == ''" />
    <CreateDirectory Include="@(IntermediateRefAssembly->'%(RootDir)%(Directory)')" />
    <CreateDirectory Include="$(OutDir)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' == 'true'" />
    <CreateDirectory Include="$(IntermediateOutputPath)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' != 'true'" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true'" xmlns="">
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).compile.pdb" Condition="'$(OutputType)' == 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).pdb" Condition="'$(OutputType)' != 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsOutputPath Include="@(_DebugSymbolsIntermediatePath->'$(OutDir)%(Filename)%(Extension)')" />
  </ItemGroup>
  <PropertyGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(OutputType)' == 'winmdobj'" xmlns="">
    <WinMDExpOutputPdb Condition="'$(WinMDExpOutputPdb)' == ''">$(IntermediateOutputPath)$(TargetName).pdb</WinMDExpOutputPdb>
    <_WinMDDebugSymbolsOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))))</_WinMDDebugSymbolsOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OutputType)' == 'winmdobj' and '$(DocumentationFile)'!=''" xmlns="">
    <WinMDOutputDocumentationFile Condition="'$(WinMDOutputDocumentationFile)' == ''">$(IntermediateOutputPath)$(TargetName).xml</WinMDOutputDocumentationFile>
    <_WinMDDocFileOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))))</_WinMDDocFileOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WinMDExpOutputWindowsMetadataFilename)' != ''" xmlns="">
    <_IntermediateWindowsMetadataPath>$(IntermediateOutputPath)$(WinMDExpOutputWindowsMetadataFilename)</_IntermediateWindowsMetadataPath>
    <_WindowsMetadataOutputPath>$(OutDir)$(WinMDExpOutputWindowsMetadataFilename)</_WindowsMetadataOutputPath>
  </PropertyGroup>
  <!-- ARM64-related properties -->
  <PropertyGroup xmlns="">
    <_SupportedArchitectures>amd64 arm64</_SupportedArchitectures>
  </PropertyGroup>
  <ItemGroup xmlns="">
    <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
    <_DeploymentManifestEntryPoint Include="@(IntermediateAssembly)">
      <TargetPath>$(TargetFileName)</TargetPath>
    </_DeploymentManifestEntryPoint>
    <!-- Create an item for the application icon if one exists in the project (Example: app.ico) -->
    <!-- NOTE: The item Include and the Exists function are operating relative to the PROJECT (.csproj, .vbproj etc.) directory in this case -->
    <_DeploymentManifestIconFile Include="$(ApplicationIcon)" Condition="Exists('$(ApplicationIcon)')">
      <TargetPath>$(ApplicationIcon)</TargetPath>
    </_DeploymentManifestIconFile>
    <!-- Create an item for the output application manifest (Example: WindowsApplication1.exe.manifeset) -->
    <ApplicationManifest Include="$(IntermediateOutputPath)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </ApplicationManifest>
    <!-- Create an item for the final application manifest (Example: WindowsApplication1.exe.manifeset)
             This item represents the final output application manifest used for project-to-project
             references and for copying to the publish output location. -->
    <_ApplicationManifestFinal Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </_ApplicationManifestFinal>
    <!-- Create an item for the output deploy manifest (Example: WindowsApplication1.application) -->
    <DeployManifest Include="$(IntermediateOutputPath)$(TargetDeployManifestFileName)">
      <TargetPath>$(TargetDeployManifestFileName)</TargetPath>
    </DeployManifest>
    <!-- Create an item for the intermediate trust info file -->
    <_DeploymentIntermediateTrustInfoFile Include="$(IntermediateOutputPath)$(TargetName).TrustInfo.xml" Condition="'$(TargetZone)'!=''" />
  </ItemGroup>
  <!--
    Determine the <deploymentProvider> (_DeploymentUrl) for the ClickOnce deployment manifest.
    Prefer the UpdateUrl, falling back to InstallUrl or PublishUrl if not specified.
    If the UpdateUrl is specified then _DeploymentUrl is always set to the UpdateUrl.
    Otherwise, only set the _DeploymentUrl if it's an installed app and updates are enabled.
    -->
  <PropertyGroup xmlns="">
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(UpdateUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(InstallUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(PublishUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="!('$(UpdateUrl)'=='') and '$(Install)'=='false'" />
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'!=''">$(_DeploymentUrl)$(TargetDeployManifestFileName)</_DeploymentUrl>
    <!--
        Need to explicitly blank out the _DeploymentUrl when it's not used. Otherwise an
        inappropriate value may be used. For example a local path from the PublishUrl
        is something we never want to see in the manifest because it means you could
        only install the app from that machine.
        -->
    <_DeploymentUrl Condition="'$(UpdateUrl)'=='' and !('$(Install)'=='true' and '$(UpdateEnabled)'=='true')" />
    <_DeploymentUrl Condition="'$(ExcludeDeploymentUrl)'=='true'" />
  </PropertyGroup>
  <!-- Determine the URLs for the bootstrapper. -->
  <PropertyGroup xmlns="">
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true'">$(InstallUrl)</_DeploymentApplicationUrl>
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true' and '$(InstallUrl)'==''">$(PublishUrl)</_DeploymentApplicationUrl>
    <_DeploymentComponentsUrl Condition="'$(BootstrapperComponentsLocation)'=='Absolute'">$(BootstrapperComponentsUrl)</_DeploymentComponentsUrl>
  </PropertyGroup>
  <!-- Output location for publish target. -->
  <PropertyGroup xmlns="">
    <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    <PublishDir Condition="'$(PublishDir)'==''">$([MSBuild]::EnsureTrailingSlash('$(OutputPath)'))app.publish\</PublishDir>
  </PropertyGroup>
  <!--
    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except
    for a trailing slash. PublishDir when specified as a global property on the command line cannot be changed to add a trailing slash.
  -->
  <PropertyGroup xmlns="">
    <ClickOncePublishDir>$(PublishDir)</ClickOncePublishDir>
    <ClickOncePublishDir Condition="!HasTrailingSlash('$(ClickOncePublishDir)')">$(ClickOncePublishDir)\</ClickOncePublishDir>
  </PropertyGroup>
  <!--
    ProcessorArchitecture is the target processor architecture.
    -->
  <PropertyGroup Condition="'$(ProcessorArchitecture)'==''" xmlns="">
    <!--
        If ProcessorArchitecture is not set, set it to PlatformTarget
        Note: if $(PlatformTarget) is also blank resolve assembly reference defaults to msil which is the
        desired behavior in this case
        -->
    <ProcessorArchitecture>$(PlatformTarget)</ProcessorArchitecture>
    <!--
        If Processor architecture is not set and PlatformTarget is a known target translate the
        PlatformTarget into something ResolveAssemblyReference knows about
        -->
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'AnyCpu' ">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x64' ">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x86' ">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'ARM' ">arm</ProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <ConsiderPlatformAsProcessorArchitecture Condition="'$(ConsiderPlatformAsProcessorArchitecture)' == ''">true</ConsiderPlatformAsProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ProcessorArchitecture)' == '' and '$(ConsiderPlatformAsProcessorArchitecture)' == 'true'" xmlns="">
    <!-- We need to do this here because if we were to just compare against platform visual would parse them out as available platforms which may not be the case -->
    <ProcessorArchitectureAsPlatform>$(Platform)</ProcessorArchitectureAsPlatform>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'AnyCpu' or '$(ProcessorArchitectureAsPlatform)' == 'Any Cpu'">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x64' or '$(ProcessorArchitectureAsPlatform)' == 'amd64'">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x86' or '$(ProcessorArchitectureAsPlatform)' == 'win32'">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'ARM' ">arm</ProcessorArchitecture>
    <!--For compatibility with the 4.0 behavior, if not set above, default to the environment. To override this, set ProcessorArchitecture explicitly. We also need to disable the warning since we do not know if what the environment is set to is correct-->
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ProcessorArchitecture)'==''">None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
    <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">$(PROCESSOR_ARCHITECTURE)</ProcessorArchitecture>
  </PropertyGroup>
  <!-- Sensible defaults for the most-commonly-desired MSBuildRuntime and MSBuildArchitecture values. The Core runtime does not currently support specifying task architecture or runtime.
       If support for out-of-proc task execution is added on other runtimes, make sure each task's logic is checked against the current state of support. -->
  <PropertyGroup Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Full'" xmlns="">
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">CLR2</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v4.0' or '$(TargetFrameworkVersion)' == 'v4.5'">CLR4</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkAsMSBuildRuntime)' == ''">CurrentRuntime</TargetFrameworkAsMSBuildRuntime>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' != ''">true</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">false</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'x86' or ('$(PlatformTarget)' == 'x64' and '$(MSBuildExtensionsPath64)' != '')">$(PlatformTarget)</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'arm'">x86</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="('$(PlatformTarget)' == 'ia64' and '$(MSBuildExtensionsPath64)' != '')">x64</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">CurrentArchitecture</PlatformTargetAsMSBuildArchitecture>
  </PropertyGroup>
  <!-- Flavor is the project flavor. For example, Client, Smart Devices, SQL Server, etc. -->
  <PropertyGroup xmlns="">
    <ProjectFlavor Condition="'$(ProjectFlavor)'==''">Client</ProjectFlavor>
  </PropertyGroup>
  <!--
    The default for compilers is to not delay-sign. If $(DelaySign) is false, let the compiler
    use its default rather than forcing a no-delay-sign flag to be passed in. This is so that
    attributes in the source code can override this decision.
    -->
  <PropertyGroup xmlns="">
    <DelaySign Condition="'$(SignAssembly)' != 'true'">false</DelaySign>
    <DelaySign Condition="'$(DelaySign)'!='true'" />
  </PropertyGroup>
  <!-- These properties control web reference proxy generation. -->
  <PropertyGroup xmlns="">
    <WebReference_EnableProperties Condition=" '$(WebReference_EnableProperties)' == '' ">true</WebReference_EnableProperties>
    <WebReference_EnableSQLTypes Condition=" '$(WebReference_EnableSQLTypes)' == '' ">true</WebReference_EnableSQLTypes>
    <WebReference_EnableLegacyEventingModel Condition=" '$(WebReference_EnableLegacyEventingModel)' == '' ">false</WebReference_EnableLegacyEventingModel>
  </PropertyGroup>
  <!--
    These parameters control where to look in the registry for directories to search for
    assemblies in the assembly resolution tasks.
    -->
  <PropertyGroup xmlns="">
    <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
    <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\$(TargetFrameworkIdentifier)</FrameworkRegistryBase>
    <TargetPlatformRegistryBase Condition="'$(TargetPlatformRegistryBase)' == ''">Software\Microsoft\Microsoft SDKs\$(TargetPlatformIdentifier)</TargetPlatformRegistryBase>
    <AssemblyFoldersConfigFile Condition="'$(AssemblyFoldersConfigFile)' == ''">$([MSBuild]::GetToolsDirectory32())\AssemblyFolders.config</AssemblyFoldersConfigFile>
    <AssemblyFoldersConfigFileSearchPath Condition="Exists('$(AssemblyFoldersConfigFile)')">{AssemblyFoldersFromConfig:$(AssemblyFoldersConfigFile),$(TargetFrameworkVersion)};</AssemblyFoldersConfigFileSearchPath>
    <!--
        These are the extensions that assembly reference resolution will consider for resolution.
        Add new extensions here if you want to add new file types to consider (for example, .metadata_dll).
        Put the most likely extensions first for reference resolution speed.
        -->
    <AllowedReferenceAssemblyFileExtensions Condition=" '$(AllowedReferenceAssemblyFileExtensions)' == '' ">
      .winmd;
      .dll;
      .exe
    </AllowedReferenceAssemblyFileExtensions>
    <!--
        These are the extensions that reference resolution will consider when looking for files related
        to resolved references.  Add new extensions here if you want to add new file types to consider.
        -->
    <AllowedReferenceRelatedFileExtensions Condition=" '$(AllowedReferenceRelatedFileExtensions)' == '' ">
      .pdb;
      .xml;
      .pri;
      .dll.config;
      .exe.config
    </AllowedReferenceRelatedFileExtensions>
    <!--
        These names are used when determining which TargetFramework subset to use. If the any of the FullReferenceAssemblyNames
        are seen in the list of client subsets, RAR will assume that no client subset is being used. The list is semicolon seperated
        For example :   Full;Complete;AllThere
        -->
    <FullReferenceAssemblyNames Condition="'$(FullReferenceAssemblyNames)' == ''">Full</FullReferenceAssemblyNames>
  </PropertyGroup>
  <PropertyGroup Condition="$(AssemblySearchPaths) == ''" xmlns="">
    <!--
        The SearchPaths property is set to find assemblies in the following order:

            (1) Files from current project - indicated by {CandidateAssemblyFiles}
            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
            (5) Assembly folders from AssemblyFolders.config file (provided by Visual Studio Dev15+).
            (6) Registered assembly folders, indicated by {Registry:*,*,*}
            (7) Legacy registered assembly folders, indicated by {AssemblyFolders}
            (8) Resolve to the GAC.
            (9) Treat the reference's Include as if it were a real file name.
            (10) Look in the application's output folder (like bin\debug)
        -->
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseCandidateAssemblyFiles)' != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseReferencePath)' != 'false'">$(AssemblySearchPaths);$(ReferencePath)</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseHintPathFromItem)' != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseTargetFrameworkDirectory)' != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath)' != 'false'">$(AssemblySearchPaths);$(AssemblyFoldersConfigFileSearchPath)</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRegistry)' != 'false'">$(AssemblySearchPaths);{Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFolders)' != 'false'">$(AssemblySearchPaths);{AssemblyFolders}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseGAC)' != 'false'">$(AssemblySearchPaths);{GAC}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRawFileName)' != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseOutDir)' != 'false'">$(AssemblySearchPaths);$(OutDir)</AssemblySearchPaths>
  </PropertyGroup>
  <!-- ContinueOnError takes 3 values:  WarnAndContinue (true), ErrorAndStop (false), and ErrorAndContinue.
         Default to ErrorAndStop, since that matches the behaviour in previous versions, and what users
         typically expect -->
  <PropertyGroup xmlns="">
    <ContinueOnError Condition="'$(ContinueOnError)' == ''">false</ContinueOnError>
  </PropertyGroup>
  <!-- Users familiar with how some other repos work try to use NoWarn with MSBuild in place of MSBuildWarningsAsMessages. -->
  <PropertyGroup xmlns="">
    <MSBuildWarningsAsMessages Condition="'$(MSBuildWarningsAsMessages)'==''">$(NoWarn)</MSBuildWarningsAsMessages>
    <MSBuildWarningsAsErrors Condition="'$(MSBuildWarningsAsErrors)'==''">$(WarningsAsErrors)</MSBuildWarningsAsErrors>
    <MSBuildWarningsNotAsErrors Condition="'$(MSBuildWarningsNotAsErrors)'==''">$(WarningsNotAsErrors)</MSBuildWarningsNotAsErrors>
  </PropertyGroup>
  <!-- Common Project System support -->
  <PropertyGroup xmlns="">
    <CommonXamlResourcesDirectory Condition=" '$(CommonXamlResourcesDirectory)' == '' ">$(MSBuildThisFileDirectory)$(LangName)\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <!-- We need to fallback to en-US in case the xaml rules are not localized (possibly happen on community languages).  -->
  <PropertyGroup Condition="!Exists('$(CommonXamlResourcesDirectory)')" xmlns="">
    <CommonXamlResourcesDirectory>$(MSBuildThisFileDirectory)en-US\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonItemSchemas)' == 'true' " xmlns="">
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectItemsSchema.xaml" />
    <PropertyPageSchema Include="&#xD;&#xA;                        $(CommonXamlResourcesDirectory)General.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Debugger_General.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General.BrowseObject.xaml">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General_File.xaml">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SCC.xaml">
      <Context>Invisible</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Folder.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)None.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)Content.xaml;&#xD;&#xA;                        $(CommonXamlResourcesDirectory)EmbeddedResource.xaml;&#xD;&#xA;                        ">
      <Context>File;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SpecialFolder.xaml;">
      <Context>File;ProjectSubscriptionService</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <PropertyGroup xmlns="">
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">$(DefineCommonItemSchemas)</DefineCommonReferenceSchemas>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonReferenceSchemas)' == 'true' " xmlns="">
    <!-- Assembly references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)assemblyreference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedAssemblyReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- COM references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)COMReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedCOMReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- Project references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedProjectReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' " xmlns="">
    <ProjectCapability Include="&#xD;&#xA;                          AssemblyReferences;&#xD;&#xA;                          COMReferences;&#xD;&#xA;                          ProjectReferences;&#xD;&#xA;                          SharedProjectReferences;&#xD;&#xA;                          OutputGroups;&#xD;&#xA;                          AllTargetOutputGroups;&#xD;&#xA;                          VisualStudioWellKnownOutputGroups;&#xD;&#xA;                          SingleFileGenerators;&#xD;&#xA;                          DeclaredSourceItems;&#xD;&#xA;                          UserSourceItems;&#xD;&#xA;                           " />
    <ProjectCapability Condition=" '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &lt; 8.0 " Include="BuildWindowsDesktopTarget" />
  </ItemGroup>
  <ItemDefinitionGroup Condition=" '$(DefineExplicitDefaults)' == 'true' " xmlns="">
    <None>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </None>
    <Content>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
    <Compile>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Compile>
    <EmbeddedResource>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
  </ItemDefinitionGroup>
  <!--
    Target that allows targets consuming source control confirmation to establish a dependency on targets producing this information.

    Any target that reads SourceRevisionId, PrivateRepositoryUrl, SourceRoot, and other source control properties and items
    should depend on this target and be conditioned on '$(SourceControlInformationFeatureSupported)' == 'true'.

    SourceRevisionId property uniquely identifies the source control revision of the repository the project belongs to.
    For Git repositories this id is a commit hash, for TFVC repositories it's the changeset number, etc.

    PrivateRepositoryUrl property stores the URL of the repository supplied by the CI server or retrieved from source control manager.
    Targets consuming this property shall not publish its value implicitly as it might inadvertently reveal an internal URL.
    Instead, they shall only do so if the project sets PublishRepositoryUrl property to true. For example, the NuGet Pack target
    may include the repository URL in the nuspec file generated for NuGet package produced by the project if PublishRepositoryUrl is true.

    SourceRoot item group lists all source roots that the project source files reside under and their mapping to source control server URLs,
    if available. This includes both source files under source control as well as source files in source packages. SourceRoot items are
    used by compilers to determine path map in deterministic build and by SourceLink provider, which maps local paths to URLs of source files
    stored on the source control server.

    Source control information provider that sets these properties and items shall execute before this target (by including
    InitializeSourceControlInformation in its BeforeTargets) and set source control properties and items that haven't been initialized yet.
  -->
  <Target Name="InitializeSourceControlInformation" xmlns="" />
  <PropertyGroup xmlns="">
    <SourceControlInformationFeatureSupported>true</SourceControlInformationFeatureSupported>
  </PropertyGroup>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Build Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <Target Name="_AddOutputPathToGlobalPropertiesToRemove" xmlns="">
    <PropertyGroup>
      <_GlobalPropertiesToRemoveFromProjectReferences Condition="'$(PassOutputPathToReferencedProjects)'=='false'">$(_GlobalPropertiesToRemoveFromProjectReferences);OutputPath</_GlobalPropertiesToRemoveFromProjectReferences>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _CheckForInvalidConfigurationAndPlatform

    This target checks for errors in statically defined properties.  By setting BeforeTargets, we try
    to ensure that the target runs before any build related targets.
    If your target requires this check and is running as a BeforeTargets of one of the first targets
    of $(BuildDependsOn), $(RebuildDependsOn), or $(CleanDependsOn) you will need to set your DependsOn
    to this target.
    ============================================================
    -->
  <Target Name="_CheckForInvalidConfigurationAndPlatform" BeforeTargets="$(BuildDependsOn);Build;$(RebuildDependsOn);Rebuild;$(CleanDependsOn);Clean" xmlns="">
    <PropertyGroup>
      <_InvalidConfigurationMessageResourceName Condition=" '$(BuildingInsideVisualStudio)' == 'true' ">CommonSdk.InvalidConfigurationTextWhenBuildingInsideVisualStudio</_InvalidConfigurationMessageResourceName>
      <_InvalidConfigurationMessageResourceName Condition=" '$(BuildingInsideVisualStudio)' != 'true' ">CommonSdk.InvalidConfigurationTextWhenBuildingOutsideVisualStudio</_InvalidConfigurationMessageResourceName>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'$(_InvalidConfigurationMessageSeverity)' != ''" ResourceName="$(_InvalidConfigurationMessageResourceName)" Severity="$(_InvalidConfigurationMessageSeverity)" FormatArguments="$(MSBuildProjectFile);$(_OriginalConfiguration);$(_OriginalPlatform)" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Configuration=$(Configuration)" Importance="Low" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Platform=$(Platform)" Importance="Low" />
    <!-- Although we try to ensure a trailing slash, it's possible to circumvent this if the property is set on the command line -->
    <MSBuildInternalMessage Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="OutDir" />
    <MSBuildInternalMessage Condition="'$(IntermediateOutputPath)' != '' and !HasTrailingSlash('$(IntermediateOutputPath)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="IntermediateOutputPath" />
    <MSBuildInternalMessage Condition="'$(BaseIntermediateOutputPath)' != '' and !HasTrailingSlash('$(BaseIntermediateOutputPath)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="BaseIntermediateOutputPath" />
    <!-- Also update the value of PlatformTargetAsMSBuildArchitecture per the value of Prefer32Bit.  We are doing
         this here because Prefer32Bit may be set anywhere in the targets, so we can't depend on it having the
         correct value when we're trying to figure out PlatformTargetAsMSBuildArchitecture -->
    <PropertyGroup Condition="'$(Prefer32Bit)' == 'true' and ('$(PlatformTarget)' == 'AnyCPU' or '$(PlatformTarget)' == '') and '$(PlatformTargetAsMSBuildArchitectureExplicitlySet)' != 'true'">
      <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>
    </PropertyGroup>
    <MSBuildInternalMessage Condition=" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonSdk.Prefer32BitAndPreferNativeArm64Enabled" Severity="Error" />
    <MSBuildInternalMessage Condition=" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonSdk.NoWin32ManifestAndPreferNativeArm64Enabled" Severity="Error" />
    <MSBuildInternalMessage Condition=" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' " ResourceName="CommonSdk.PlatformIsAnyCPUAndPreferNativeArm64Enabled" Severity="Warning" FormatArguments="$(Platform)" />
    <!--
      Log an error MSB3540 if the user set MSBuildProjectExtensionsPath in the body of a project. In an SDK style project
      if you set a value in the body, the value is not used by the top implicit import but is used by the bottom.
      This can lead to confusing behavior and builds can fail for obscure reasons.
    -->
    <MSBuildInternalMessage Condition=" '$(_InitialMSBuildProjectExtensionsPath)' != '' And '$(MSBuildProjectExtensionsPath)' != '$(_InitialMSBuildProjectExtensionsPath)' " ResourceName="CommonSdk.MSBuildProjectExtensionsPathModifiedAfterUse" Severity="Error" />
    <!--
      Log a warning MSB3539 if:
        1. $(EnableBaseIntermediateOutputPathMismatchWarning) is 'true'
        2. $(BaseIntermediateOutputPath) was set in the body of a project after its default value was set in Microsoft.Common.props
        3. $(BaseIntermediateOutputPath) is not the same as $(MSBuildProjectExtensionsPath)

      Similar to the error above, there are cases when users set $(BaseIntermediateOutputPath) in the body of their project and things build but only by coincidence.
      MSBuild does not know if $(BaseIntermediateOutputPath) changing would cause problems so tools like NuGet must set $(EnableBaseIntermediateOutputPathMismatchWarning)
      to 'true'.
    -->
    <MSBuildInternalMessage Condition=" '$(EnableBaseIntermediateOutputPathMismatchWarning)' == 'true' And '$(_InitialBaseIntermediateOutputPath)' != '$(BaseIntermediateOutputPath)' And '$(BaseIntermediateOutputPath)' != '$(MSBuildProjectExtensionsPath)' " ResourceName="CommonSdk.BaseIntermediateOutputPathMismatchWarning" Severity="Warning" />
  </Target>
  <!--
    ============================================================
                                        Build

    The main build entry point.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildDependsOn>
      BeforeBuild;
      CoreBuild;
      AfterBuild
    </BuildDependsOn>
  </PropertyGroup>
  <Target Name="Build" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(BuildDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" xmlns="" />
  <!--
    ============================================================
                                        BeforeBuild

    Redefine this target in your project in order to run tasks just before Build
    ============================================================
    -->
  <Target Name="BeforeBuild" xmlns="" />
  <!--
    ============================================================
                                        AfterBuild

    Redefine this target in your project in order to run tasks just after Build
    ============================================================
    -->
  <Target Name="AfterBuild" xmlns="" />
  <!--
    ============================================================
                                        CoreBuild

    The core build step calls each of the build targets.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CoreBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      PreBuildEvent;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      Compile;
      ExportWindowsMDFile;
      UnmanagedUnregistration;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
      GenerateManifests;
      GetTargetPath;
      PrepareForRun;
      UnmanagedRegistration;
      IncrementalClean;
      PostBuildEvent
    </CoreBuildDependsOn>
  </PropertyGroup>
  <Target Name="CoreBuild" DependsOnTargets="$(CoreBuildDependsOn)" xmlns="">
    <OnError ExecuteTargets="_TimeStampAfterCompile;PostBuildEvent" Condition="'$(RunPostBuildEvent)'=='Always' or '$(RunPostBuildEvent)'=='OnOutputUpdated'" />
    <OnError ExecuteTargets="_CleanRecordFileWrites" />
  </Target>
  <!--
    ============================================================
                                        Rebuild

    Delete all intermediate and final build outputs, and then build the project from scratch.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>
    <RebuildDependsOn>
      BeforeRebuild;
      Clean;
      $(_ProjectDefaultTargets);
      AfterRebuild;
    </RebuildDependsOn>
    <RebuildDependsOn Condition=" '$(MSBuildProjectDefaultTargets)' == 'Rebuild' ">
      BeforeRebuild;
      Clean;
      Build;
      AfterRebuild;
    </RebuildDependsOn>
  </PropertyGroup>
  <Target Name="Rebuild" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(RebuildDependsOn)" Returns="$(TargetPath)" xmlns="" />
  <!--
    ============================================================
                                        BeforeRebuild

    Redefine this target in your project in order to run tasks just before Rebuild
    ============================================================
    -->
  <Target Name="BeforeRebuild" xmlns="" />
  <!--
    ============================================================
                                        AfterRebuild

    Redefine this target in your project in order to run tasks just after Rebuild
    ============================================================
    -->
  <Target Name="AfterRebuild" xmlns="" />
  <!--
    ============================================================
                                        BuildGenerateSources

    Redefine this target in your project in order to run tasks for BuildGenerateSources

    Set BuildPassReferences to enable P2P builds
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildGenerateSourcesAction>Build</BuildGenerateSourcesAction>
  </PropertyGroup>
  <Target Name="BuildGenerateSources" DependsOnTargets="BuildGenerateSourcesTraverse;$(BuildGenerateSourcesAction)" xmlns="" />
  <Target Name="BuildGenerateSourcesTraverse" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildGenerateSources" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework);" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="BuildGenerateSources" Targets="BuildGenerateSources" />
  </ItemGroup>
  <!--
    ============================================================
                                        BuildCompile

    Redefine this target in your project in order to run tasks for BuildCompile
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildCompileAction>Build</BuildCompileAction>
  </PropertyGroup>
  <Target Name="BuildCompile" DependsOnTargets="BuildCompileTraverse;$(BuildCompileAction)" xmlns="" />
  <Target Name="BuildCompileTraverse" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildCompile" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="BuildCompile" Targets="BuildCompile" />
  </ItemGroup>
  <!--
    ============================================================
                                        BuildLink

    Redefine this target in your project in order to run tasks for BuildLink
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildLinkAction>Build</BuildLinkAction>
  </PropertyGroup>
  <Target Name="BuildLink" DependsOnTargets="BuildLinkTraverse;$(BuildLinkAction)" xmlns="" />
  <Target Name="BuildLinkTraverse" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildLink" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="BuildLink" Targets="BuildLink" />
  </ItemGroup>
  <!--
    ============================================================
                                        CopyRunEnvironmentFiles

    Copy environment files necessary to run the user's app to the final directory.
    This is a public target that can be invoked by an IDE.

    This may be used by an IDE to make the app.config file available for running
    the target app.
    ============================================================
    -->
  <Target Name="CopyRunEnvironmentFiles" DependsOnTargets="PrepareForBuild;SetWin32ManifestProperties;_CopyAppConfigFile;_CleanRecordFileWrites" xmlns="" />
  <!--
    ============================================================
                                        Run

    Run the final build output if it is a .EXE
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <RunDependsOn />
  </PropertyGroup>
  <Target Name="Run" DependsOnTargets="$(RunDependsOn)" xmlns="">
    <MSBuildInternalMessage Condition="'$(TargetExt)'!='.exe'" ResourceName="CommonSdk.RunTargetDependsOnMessage" Severity="Error" FormatArguments="$(TargetPath)" />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(OutDir)" Condition=" '$(StartWorkingDirectory)' == '' " />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(StartWorkingDirectory)" Condition=" '$(StartWorkingDirectory)' != '' " />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                BuildOnlySettings Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        BuildOnlySettings

    This target is called only when doing a real build.  It is specifically not called during project load.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuildingProject>false</BuildingProject>
  </PropertyGroup>
  <Target Name="BuildOnlySettings" xmlns="">
    <PropertyGroup>
      <BuildingProject>true</BuildingProject>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForBuild Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareForBuild

    Prepare the prerequisites for building.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);GetFrameworkPaths;GetReferenceAssemblyPaths;AssignLinkMetadata</PrepareForBuildDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForBuild" DependsOnTargets="$(PrepareForBuildDependsOn)" xmlns="">
    <ItemGroup>
      <AppConfigWithTargetPath Include="$(AppConfig)" Condition="'$(AppConfig)'!=''">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
    <FindAppConfigFile PrimaryList="@(None)" SecondaryList="@(Content)" TargetPath="$(TargetFileName).config" Condition="'$(AppConfig)'==''">
      <Output TaskParameter="AppConfigFile" ItemName="AppConfigWithTargetPath" />
      <Output TaskParameter="AppConfigFile" PropertyName="AppConfig" />
    </FindAppConfigFile>
    <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
    <!-- We are going to continue on error here so that if the tree is read only we will still get intellisense -->
    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="true" />
  </Target>
  <!--
    ============================================================
                                        GetFrameworkPaths

    Get the paths for the .NET Framework installation directory

    These paths are not used directly by this .targets file but are available for pre and
    post build steps.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <Framework40Dir>@(_TargetFramework40DirectoryItem)</Framework40Dir>
    <Framework35Dir>@(_TargetFramework35DirectoryItem)</Framework35Dir>
    <Framework30Dir>@(_TargetFramework30DirectoryItem)</Framework30Dir>
    <Framework20Dir>@(_TargetFramework20DirectoryItem)</Framework20Dir>
    <!-- Note we need to make the 4.0 FrameworkDir point to the 2.0 location by default since we shipped msbuild 4.0 that way and to change it would be a breaking change.-->
    <FrameworkDir Condition="'$(FrameworkDir)' == '' and ('$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0')">@(_TargetFramework20DirectoryItem)</FrameworkDir>
    <FrameworkDir Condition="'$(FrameworkDir)' == ''">@(_TargetFramework40DirectoryItem)</FrameworkDir>
    <TargetedFrameworkDir Condition="'$(TargetedFrameworkDir)' == ''">@(_TargetedFrameworkDirectoryItem)</TargetedFrameworkDir>
    <FrameworkSDKDir Condition="'$(FrameworkSDKDir)' == ''">@(_TargetFrameworkSDKDirectoryItem)</FrameworkSDKDir>
    <GetFrameworkPathsDependsOn />
  </PropertyGroup>
  <!-- This is a generally overriden target, for example it is overriden in the Microsoft.NETFramework.targets file -->
  <Target Name="GetFrameworkPaths" xmlns="" />
  <!--
    ============================================================
                                        GetReferenceAssemblyPaths

    Get the paths for the Reference Assemblies for the known versions of the
    .NET Framework.

    These paths are used by the build process in order to resolve the correct
    assemblies from the various directories, and to support multi-targeting
    ============================================================
    -->
  <Target Name="GetReferenceAssemblyPaths" DependsOnTargets="$(GetReferenceAssemblyPathsDependsOn);GetFrameworkPaths" xmlns="">
    <!-- if TargetFrameworkDirectory doesn't have a custom value, clear it out; that way we can get reference paths and target framework directories all in the right order -->
    <PropertyGroup>
      <TargetFrameworkDirectory Condition="'@(_CombinedTargetFrameworkDirectoriesItem)' == '$(TargetFrameworkDirectory)'" />
    </PropertyGroup>
    <!-- By default if there is no root path set then the task will assume it is Program Files\Reference Assemblies\Microsoft\Framework-->
    <GetReferenceAssemblyPaths Condition="'$(TargetFrameworkMoniker)' != '' and ('$(_TargetFrameworkDirectories)' == '' or '$(_FullFrameworkReferenceAssemblyPaths)' == '')" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)" BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories" />
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths" />
      <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''" />
    </GetReferenceAssemblyPaths>
    <PropertyGroup>
      <TargetFrameworkDirectory>$(_TargetFrameworkDirectories);$(TargetFrameworkDirectory);$(WinFXAssemblyDirectory)</TargetFrameworkDirectory>
      <TargetFrameworkDirectory Condition="'$(TargetPlatformWinMDLocation)' != '' and Exists('$(TargetPlatformWinMDLocation)')">$(TargetFrameworkDirectory);$(TargetPlatformWinMDLocation)</TargetFrameworkDirectory>
    </PropertyGroup>
    <!-- Remove the AssemblyFolders if no target framework directories could be found. This is to prevent us from
             resolving from the assemblyfolders global location if we are not acutally targeting a framework-->
    <PropertyGroup>
      <RemoveAssemblyFoldersIfNoTargetFramework Condition="'$(RemoveAssemblyFoldersIfNoTargetFramework)' == ''">true</RemoveAssemblyFoldersIfNoTargetFramework>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == '' and '$(AssemblySearchPaths)' != '' and '$(RemoveAssemblyFoldersIfNoTargetFramework)' == 'true'">
      <AssemblySearchPaths>$(AssemblySearchPaths.Replace('{AssemblyFolders}', '').Split(';'))</AssemblySearchPaths>
    </PropertyGroup>
    <ItemGroup Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'">
      <DesignTimeFacadeDirectoryRoots Include="$(TargetFrameworkDirectory)" />
      <DesignTimeFacadeDirectories Include="%(DesignTimeFacadeDirectoryRoots.Identity)Facades\" Condition="Exists('%(DesignTimeFacadeDirectoryRoots.Identity)Facades\')" />
    </ItemGroup>
    <PropertyGroup Condition="'@(DesignTimeFacadeDirectories)' != ''">
      <TargetFrameworkDirectory>$(TargetFrameworkDirectory);@(DesignTimeFacadeDirectories)</TargetFrameworkDirectory>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == ''">
      <TargetFrameworkProfile />
    </PropertyGroup>
  </Target>
  <!-- Returns target framework moniker. E.g. ".NETFramework,Version=v4.0.1" -->
  <Target Name="GetTargetFrameworkMoniker" Returns="$(TargetFrameworkMoniker)" xmlns="" />
  <!-- Returns target framework moniker display name. E.g. ".NET Framework 4 Platform Update 1 (KB2478063)" -->
  <Target Name="GetTargetFrameworkMonikerDisplayName" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkMonikerDisplayName)" xmlns="" />
  <!-- Returns semicolon separated list of target framework directories.
  E.g "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0.1\;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\" -->
  <Target Name="GetTargetFrameworkDirectories" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkDirectory)" xmlns="" />
  <!--
    ============================================================
                                        AssignLinkMetadata

       For items of a certain set of allowlisted types, make sure that
       if they are defined in a file other than the project file, that
       they have "Link" metadata set to an appropriate default.
    ============================================================
    -->
  <Target Name="AssignLinkMetadata" Condition=" '$(SynthesizeLinkMetadata)' == 'true' " xmlns="">
    <!-- NONE ITEMS -->
    <AssignLinkMetadata Items="@(None)" Condition="'@(None)' != '' and '%(None.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <None Remove="@(_Temp)" />
      <None Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- CONTENT ITEMS -->
    <AssignLinkMetadata Items="@(Content)" Condition="'@(Content)' != '' and '%(Content.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Content Remove="@(_Temp)" />
      <Content Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- PAGE ITEMS -->
    <AssignLinkMetadata Items="@(Page)" Condition="'@(Page)' != '' and '%(Page.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Page Remove="@(_Temp)" />
      <Page Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- APPLICATIONDEFINITION ITEMS -->
    <AssignLinkMetadata Items="@(ApplicationDefinition)" Condition="'@(ApplicationDefinition)' != '' and '%(ApplicationDefinition.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <ApplicationDefinition Remove="@(_Temp)" />
      <ApplicationDefinition Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- EMBEDDEDRESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(EmbeddedResource)" Condition="'@(EmbeddedResource)' != '' and '%(EmbeddedResource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temp)" />
      <EmbeddedResource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- RESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(Resource)" Condition="'@(Resource)' != '' and '%(Resource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)' and $([MSBuild]::AreFeaturesEnabled('17.10'))">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup Condition="$([MSBuild]::AreFeaturesEnabled('17.10'))">
      <Resource Remove="@(_Temp)" />
      <Resource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PreBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PreBuildEvent

    Run the pre-build event if there is one.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PreBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PreBuildEvent" Condition="'$(PreBuildEvent)'!=''" DependsOnTargets="$(PreBuildEventDependsOn)" xmlns="">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedUnregistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedUnregistration

    If the main assembly had previously been registered for COM interop, unregister it now.
    We will re-register the new version after it has been built.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <UnmanagedUnregistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedUnregistration" Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or&#xD;&#xA;                    ('$(_AssemblyTimestampBeforeCompile)' == '')) and&#xD;&#xA;                   Exists('@(_UnmanagedRegistrationCache)')" DependsOnTargets="$(UnmanagedUnregistrationDependsOn)" xmlns="">
    <PropertyGroup>
      <UnregisterAssemblyMSBuildArchitecture Condition="'$(UnregisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</UnregisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(UnregisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the
           corresponding comment in GenerateResource. -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == '' and&#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(UnregisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</UnregisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</UnregisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)" MSBuildArchitecture="$(UnregisterAssemblyMSBuildArchitecture)" MSBuildRuntime="$(UnregisterAssemblyMSBuildRuntime)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveReferences Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                     GetTargetFrameworkVersion

    This stand-alone target returns the target framework version (i.e. v3.5, v4.0, etc.)
    that would be used if we built this project.

    ============================================================
    -->
  <Target Name="GetTargetFrameworkVersion" Returns="$(TargetFrameworkVersion)" xmlns="" />
  <!--
    ============================================================
                                        ResolveReferences
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ResolveReferencesDependsOn>
      BeforeResolveReferences;
      AssignProjectConfiguration;
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      ResolveNativeReferences;
      ResolveAssemblyReferences;
      GenerateBindingRedirects;
      GenerateBindingRedirectsUpdateAppConfig;
      ResolveComReferences;
      AfterResolveReferences
    </ResolveReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveReferencesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforeResolveReferences

    Redefine this target in your project in order to run tasks just before ResolveReferences
    ============================================================
    -->
  <Target Name="BeforeResolveReferences" xmlns="" />
  <!--
    ============================================================
                                        AfterResolveReferences

    Redefine this target in your project in order to run tasks just after ResolveReferences
    ============================================================
    -->
  <Target Name="AfterResolveReferences" xmlns="" />
  <!--
    ============================================================
                                        IgnoreJavaScriptOutputAssembly

    esproj are JavaScript or TypeScript Projects that never produce an assembly.
    Set ReferenceOutputAssembly to false in any reference to an esproj.
    ============================================================
    -->
  <Target Name="IgnoreJavaScriptOutputAssembly" BeforeTargets="AssignProjectConfiguration" xmlns="">
    <ItemGroup>
      <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
        <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
      </ProjectReference>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        AssignProjectConfiguration

    Assigns the appropriate configuration to each project in the list of project references passed in.
    Adds to the project references passed in any project references implied by dependencies expressed in the solution file, if any.

        [IN]
        @(ProjectReference) - the list of all project references

        [OUT]
        @(ProjectReferenceWithConfiguration) - the list of project references (MSBuild and potentially VSIP projects)
                                               with metadata values FullConfiguration, Configuration, Platform,
                                               SetConfiguration, and SetPlatform
    ============================================================
    -->
  <Target Name="AssignProjectConfiguration" Condition="'$(CurrentSolutionConfigurationContents)' != '' or '@(ProjectReference)'!=''" xmlns="">
    <PropertyGroup>
      <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration Condition="'$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)' == ''">true</OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildingSolutionFile)' == 'true')">true</ShouldUnsetParentConfigurationAndPlatform>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == ''">false</ShouldUnsetParentConfigurationAndPlatform>
      <!-- Web Application projects can "secretly" reference Silverlight projects, which can take project dependencies on that same Web Application.  If the project
           dependencies are promoted to project references, this ends up creating a situation where we have a circular reference between the two projects.  We don't
           want this to happen, so just turn off synthetic project reference generation for Silverlight projects. -->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(TargetFrameworkIdentifier)' == 'Silverlight'">false</AddSyntheticProjectReferencesForSolutionDependencies>
      <!-- Inside VS, we do not need to add synthetic references, as VS already organizes the build per any solution-level dependencies; we only do this on the command line-->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</AddSyntheticProjectReferencesForSolutionDependencies>
    </PropertyGroup>
    <!-- Assign a project configuration to each project reference if we're building a solution file. -->
    <AssignProjectConfiguration ProjectReferences="@(ProjectReference)" CurrentProject="$(MSBuildProjectFullPath)" CurrentProjectConfiguration="$(Configuration)" CurrentProjectPlatform="$(Platform)" DefaultToVcxPlatformMapping="$(DefaultToVcxPlatformMapping)" VcxToDefaultPlatformMapping="$(VcxToDefaultPlatformMapping)" OutputType="$(OutputType)" ResolveConfigurationPlatformUsingMappings="false" SolutionConfigurationContents="$(CurrentSolutionConfigurationContents)" AddSyntheticProjectReferencesForSolutionDependencies="$(AddSyntheticProjectReferencesForSolutionDependencies)" OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration="$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)" ShouldUnsetParentConfigurationAndPlatform="$(ShouldUnsetParentConfigurationAndPlatform)">
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME PROJECTREFERENCEWITHCONFIGURATION INSTEAD -->
      <Output TaskParameter="AssignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="AssignedProjects" ItemName="ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="ProjectReferenceWithConfiguration" />
    </AssignProjectConfiguration>
    <ItemGroup>
      <_ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(_ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(_ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </_ProjectReferenceWithConfiguration>
      <ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </ProjectReferenceWithConfiguration>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SplitProjectReferencesByFileExistence

    Split referenced projects into two lists: those that exist on
    disk and those that don't.
    ============================================================
    -->
  <Target Name="_SplitProjectReferencesByFileExistence" xmlns="">
    <!--
        Use this task for matching projects with pre-resolved project outputs set by the IDE
        if building inside the IDE.  The IDE only includes non-MSBuild projects in the output list.  We'll
        use MSBuild to resolve MSBuild projects.
        This task will resolve VSIP (3rd party) project references and create a new item list with only project references
        to projects in the MSBuild format.
        -->
    <ResolveNonMSBuildProjectOutput ProjectReferences="@(ProjectReferenceWithConfiguration)" PreresolvedProjectOutputs="$(VSIDEResolvedNonMSBuildProjectOutputs)" Condition="'$(BuildingInsideVisualStudio)'=='true' and '@(ProjectReferenceWithConfiguration)'!=''">
      <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedProjectReferencePaths" />
      <Output TaskParameter="UnresolvedProjectReferences" ItemName="_MSBuildProjectReference" />
    </ResolveNonMSBuildProjectOutput>
    <!--
       If building from the command line, simply copy the ProjectReferenceWithConfiguration item list to _MSBuildProjectReference,
       since we have to assume all projects are in the MSBuild format. We have no way of building
       VSIP (3rd party) projects from the command line.
       -->
    <ItemGroup>
      <_MSBuildProjectReference Include="@(ProjectReferenceWithConfiguration)" Condition="'$(BuildingInsideVisualStudio)'!='true' and '@(ProjectReferenceWithConfiguration)'!=''" />
    </ItemGroup>
    <!-- Break the project list into two lists: those that exist on disk and those that don't. -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Include="@(_MSBuildProjectReference)" Condition="Exists('%(Identity)')" />
      <_MSBuildProjectReferenceNonexistent Include="@(_MSBuildProjectReference)" Condition="!Exists('%(Identity)')" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================
                                        _GetProjectReferencePlatformProperties

    If a project is opted in via $(EnableDynamicPlatformResolution), this target calls the
    GetCompatiblePlatform task on all ProjectReference items to determine the most compatible
    platform for each project. It then sets SetPlatform metadata on each ProjectReference.
    This prevents overbuilding a project when 'AnyCPU' is available.

    ======================================================================================
  -->
  <PropertyGroup xmlns="">
    <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
  </PropertyGroup>
  <!-- This target skips sln-based builds because they already supply Platform and
       Configuration information. See AssignProjectConfiguration -->
  <Target Name="_GetProjectReferencePlatformProperties" Condition="'$(EnableDynamicPlatformResolution)' == 'true'&#xD;&#xA;                     and '@(_MSBuildProjectReferenceExistent)' != ''" xmlns="">
    <!-- Allow preset SetPlatform to override this operation -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''">
        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <ItemGroup>
      <_ProjectReferencePlatformPossibilities Include="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'" />
    </ItemGroup>
    <!-- Assign default PlatformLookupTables when doing Managed <-> Unmanaged hops -->
    <ItemGroup>
      <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->
      <_ProjectReferencePlatformPossibilities Condition="'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'">
        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->
        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">x86=Win32</PlatformLookupTable>
      </_ProjectReferencePlatformPossibilities>
      <!-- If we're looking at a managed project from a cpp project, map native to managed platforms. -->
      <_ProjectReferencePlatformPossibilities Condition="('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj') and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' != 'true'">
        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">Win32=x86</PlatformLookupTable>
      </_ProjectReferencePlatformPossibilities>
    </ItemGroup>
    <GetCompatiblePlatform AnnotatedProjects="@(_ProjectReferencePlatformPossibilities)" CurrentProjectPlatform="$(Platform)" PlatformLookupTable="$(PlatformLookupTable)" Condition="'@(_ProjectReferencePlatformPossibilities)' != ''">
      <Output ItemName="_ProjectsWithPlatformAssignment" TaskParameter="AssignedProjectsWithPlatform" />
    </GetCompatiblePlatform>
    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.
         Don't do anything in this case. Ex: A project references many projects
         that can't multiplatform.  -->
    <ItemGroup Condition="'@(_ProjectsWithPlatformAssignment)' != ''">
      <ProjectsWithNearestPlatform Include="@(_ProjectsWithPlatformAssignment)" />
      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''">
        <SetPlatform>Platform=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
      </ProjectsWithNearestPlatform>
      <!-- When GetCompatiblePlatform fails to assign NearestPlatform (or determines it's identical to default for the referenced project), undefine Platform and let that project build "on its own" -->
      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' == ''">
        <UndefineProperties>%(ProjectsWithNearestPlatform.UndefineProperties);Platform</UndefineProperties>
      </ProjectsWithNearestPlatform>
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'" />
      <_MSBuildProjectReferenceExistent Include="@(ProjectsWithNearestPlatform)" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================
                                        _GetProjectReferenceTargetFrameworkProperties

    Builds the GetTargetFrameworks target of all existent project references to get a list
    of all supported TargetFrameworks of the referenced projects. Calls the
    GetReferenceNearestTargetFrameworkTask to determine the closest match for each project.
    This allows a cross-targeting project to select how it should be configured to build
    against the most appropriate target for the referring target framework.

    ======================================================================================
  -->
  <Target Name="_GetProjectReferenceTargetFrameworkProperties" DependsOnTargets="_AddOutputPathToGlobalPropertiesToRemove" xmlns="">
    <!--
      Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over
      TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and
      has floating NTM=UAP,Version=vX.Y.Z. However, in other cases (classic PCLs), NTM contains multiple values and that will cause the MSBuild
      invocation below to fail by passing invalid properties. Therefore we do not use the NTM if it contains a semicolon.
    -->
    <PropertyGroup Condition="'$(ReferringTargetFrameworkForProjectReferences)' == ''">
      <ReferringTargetFrameworkForProjectReferences Condition="'$(NuGetTargetMoniker)' != '' and !$(NuGetTargetMoniker.Contains(';'))">$(NuGetTargetMoniker)</ReferringTargetFrameworkForProjectReferences>
      <ReferringTargetFrameworkForProjectReferences Condition="'$(NuGetTargetMoniker)' == ''">$(TargetFrameworkMoniker)</ReferringTargetFrameworkForProjectReferences>
    </PropertyGroup>
    <!--
      Honor SkipGetTargetFrameworkProperties=true metadata on project references
      to mean that the project reference is known not to target multiple frameworks
      and the mechanism here for selecting the best one can be skipped as an optimization.

      We give this treatment to .vcxproj by default since no .vcxproj can target more
      than one framework currently. The user must specify exactly one TargetFramework.

      vcxproj files compile down to OS-specific binaries, either native or .NET. In the
      _GetProjectReferenceTargetFrameworkProperties target of Microsoft.Common.CurrentVersion.targets,
      SkipTargetFrameworkProperties is set to true for vcxproj to account for that.

      This means we do not fill the Item _ProjectReferenceTargetFrameworkPossibilities or, by extension,
      the AnnotatedProjects Item.

      For single-targeted projects, we normally decorate the AnnotatedProjects Item with
      UndefineProperties metadata specifying that TargetFramework should be undefined. Because it
      isn't defined properly at that stage, however, this does not happen, and TargetFramework is
      defined at this point in addition to having been defined globally. Currently, this is always
      true for vcxproj.

      MSBuild permits building the same project twice as long as it has different sets of global properties.
      Because the TargetFramework global property is not being removed as expected by the multitargeting
      part of MSBuild, the engine recognizes that there are differences and builds it twice. This can
      become more noticeable if the projects build in parallel, since they could try to access the same
      resources and conflict, failing the build. Note, however, that building the same project twice in
      this way is always wrong even if it seems minor because they do not conflict, and the second build is
      relatively fast.
   -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and ('%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj')">
        <!--
          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
          Don't skip when opted into the feature.
        -->
        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
        <UndefineProperties>%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework</UndefineProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <!--
       Allow project references to specify which target framework properties to set and their values
       without consulting the referenced project. This has two use cases:

       1. A caller may wish to pick a compatible but sub-optimal target framework. For example,
          to unit test the .NETStandard implementation using a .NETFramework caller even though
          there is also a .NETFramework implementation.

       2. As an escape hatch for cases where the compatibility check performed by
          GetTargetFrameworkProperties is faulty.
    -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetTargetFramework)' != ''">
        <!--
          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
          Don't skip when opted into the feature.
        -->
        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <!--
       Get reference target framework lists.
       Note: A future optimization could cache the closest match and set the target framework on
       this MSBuild task invocation. This would (optimistically) save an evaluation of the referenced
       project when the answer is the same.
    -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetFrameworks" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' != 'true'" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
    </MSBuild>
    <!--
       SetPlatform negotiation requires the 'GetTargetFrameworks' MSBuild call to NOT pass global properties. This is to verify
       whether or not the referenced project would build as the same platform as the current project by default. The above
       MSBuild call is kept for legacy scenarios that may depend on passing %(SetConfiguration) and %(SetPlatform).
    -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetFrameworks" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration;$(_GlobalPropertiesToRemoveFromProjectReferences)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' == 'true'" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
    </MSBuild>
    <ItemGroup>
      <!--
        Preserve the ItemSpec value on the _ProjectReferenceTargetFrameworkPossibilities. Because relative paths in another project
        context would be incorrect, the MSBuild task invocation needs expands the project reference paths in the MSBuild task above.
        This is generally OK, but if the list is copied the OriginalItemSpec can become the expanded value and cause issues correlating
        a project reference back to an Item instance.
      -->
      <_ProjectReferenceTargetFrameworkPossibilitiesOriginalItemSpec Include="@(_ProjectReferenceTargetFrameworkPossibilities->'%(OriginalItemSpec)')" />
      <_ProjectReferenceTargetFrameworkPossibilities Remove="@(_ProjectReferenceTargetFrameworkPossibilities)" />
      <_ProjectReferenceTargetFrameworkPossibilities Include="@(_ProjectReferenceTargetFrameworkPossibilitiesOriginalItemSpec)" />
    </ItemGroup>
    <!-- For each reference, get closest match -->
    <!-- Pass the CurrentProjectTargetPlatform parameter to the task only if GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter is true.  This means
         that we are using a version of NuGet which supports that parameter on this task. -->
    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)" CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)" CurrentProjectTargetPlatform="$(TargetPlatformMoniker)" CurrentProjectName="$(MSBuildProjectName)" FallbackTargetFrameworks="$(AssetTargetFallback)" Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''&#xD;&#xA;                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
    </GetReferenceNearestTargetFrameworkTask>
    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)" CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)" CurrentProjectName="$(MSBuildProjectName)" FallbackTargetFrameworks="$(AssetTargetFallback)" Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''&#xD;&#xA;                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
    </GetReferenceNearestTargetFrameworkTask>
    <ItemGroup>
      <!--
         If the task was skipped or the current TargetFramework is empty, AnnotatedProjects will be empty.
         In this case, copy _ProjectReferenceTargetFrameworkPossibilities as is. See:
            https://github.com/dotnet/sdk/issues/416

        Furthermore, if we're referencing a .vcxproj or .nativeproj, those items won't be populated into `AnnotatedProjects`
        by `GetReferenceNearestTargetFrameworkTask`, so let them flow when `EnableDynamicPlatformResolution` is set.
      -->
      <AnnotatedProjects Include="@(_ProjectReferenceTargetFrameworkPossibilities)" Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or&#xD;&#xA;                                    ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
    </ItemGroup>
    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.
         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects
         the IsRidAgnostic value for the NearestTargetFramework for the project. -->
    <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
      <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
    </SetRidAgnosticValueForProjects>
    <ItemGroup>
      <AnnotatedProjects Remove="@(AnnotatedProjects)" />
      <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
      <UpdatedAnnotatedProjects Remove="@(UpdatedAnnotatedProjects)" />
      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
        <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
      </AnnotatedProjects>
      <!--
         If the NearestTargetFramework property was not set or the project has a single TargetFramework, we need to Undefine
         TargetFramework to avoid another project evaluation.
      -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and ('%(AnnotatedProjects.NearestTargetFramework)' == '' or '%(AnnotatedProjects.HasSingleTargetFramework)' == 'true')">
        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>
      </AnnotatedProjects>
      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,
           unless the project is expecting those properties to flow. -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'">
        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier;SelfContained</UndefineProperties>
      </AnnotatedProjects>
      <!--
         Remove the items we've touched from _MSBuildProjectReferenceExistent. This will leave all projects where
         SkipGetTargetFrameworkProperties was set. Then add all AnnotatedProjects back.
      -->
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'" />
      <_MSBuildProjectReferenceExistent Include="@(AnnotatedProjects)" />
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworks" DependsOnTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework" Returns="@(_ThisProjectBuildMetadata)" xmlns="">
    <MSBuildInternalMessage Condition="'$(IsCrossTargetingBuild)' == 'true'" ResourceName="CommonSdk.CrossTargetingGetTargetFrameworks" Severity="Error" />
    <CombineXmlElements RootElementName="AdditionalProjectProperties" XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
      <Output TaskParameter="Result" PropertyName="_AdditionalPropertiesFromProject" />
    </CombineXmlElements>
    <ItemGroup>
      <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
        <HasSingleTargetFramework>true</HasSingleTargetFramework>
        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
        <!-- Extract necessary information for SetPlatform negotiation -->
        <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
        <Platform>$(Platform)</Platform>
        <Platforms>$(Platforms)</Platforms>
        <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
             Build the `Platforms` property from that. -->
        <Platforms Condition="'$(UsePlatformFromProjectConfiguration)' != 'false' and '@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration-&gt;'%(Platform)'-&gt;Distinct())</Platforms>
      </_ThisProjectBuildMetadata>
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework" Returns="@(_TargetFrameworkInfo)" xmlns="">
    <ItemGroup>
      <_AdditionalTargetFrameworkInfoPropertyWithValue Include="@(AdditionalTargetFrameworkInfoProperty)">
        <Value>$(%(AdditionalTargetFrameworkInfoProperty.Identity))</Value>
      </_AdditionalTargetFrameworkInfoPropertyWithValue>
    </ItemGroup>
    <PropertyGroup>
      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
    </PropertyGroup>
    <CombineTargetFrameworkInfoProperties RootElementName="$(TargetFramework)" PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)" UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
      <Output TaskParameter="Result" PropertyName="_AdditionalTargetFrameworkInfoProperties" />
    </CombineTargetFrameworkInfoProperties>
    <ItemGroup>
      <_TargetFrameworkInfo Include="$(TargetFramework)">
        <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
        <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
        <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
        <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
        <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
        <!-- Determine whether a project is "RID agnostic" for each TargetFramework.  "RID agnostic" means that global properties such as
             SelfContained and RuntimeIdentifier should not flow across project references.  The IsRidAgnostic metadata value is consumed in the
             _GetProjectReferenceTargetFrameworkProperties target, where those properties are added to a project's UndefineProperties if
             IsRidAgnostic is set.

             Generally we set the IsRidAgnostic metadata based on the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the
             fallback logic here will be that the project is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
        <IsRidAgnostic Condition=" '%(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
        <IsRidAgnostic Condition=" '%(IsRidAgnostic)' == ''">false</IsRidAgnostic>
      </_TargetFrameworkInfo>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                    GetTargetFrameworkProperties

    OBSOLETE: present only for theoretical backward compatibility.
  -->
  <Target Name="GetTargetFrameworkProperties" xmlns="" />
  <!--
    ============================================================
                                        PrepareProjectReferences

    Prepares project references for consumption by other targets.

        [IN]
        @(ProjectReference) - The list of project references.

        [OUT]
        @(ProjectReferenceWithConfiguration)   - Project references with apporpriate metadata
        @(_MSBuildProjectReferenceExistent)    - Subset of @(ProjectReferenceWithConfiguration) that exist
                                                 with added SetTargetFramework metadata for cross-targeting
        @(_MSBuildProjectReferenceNonExistent) - Subset of  @(ProjectReferenceWithConfiguration) that do not exist
    ============================================================
  -->
  <PropertyGroup xmlns="">
    <PrepareProjectReferencesDependsOn>
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      _GetProjectReferenceTargetFrameworkProperties;
      _GetProjectReferencePlatformProperties
    </PrepareProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareProjectReferences" DependsOnTargets="$(PrepareProjectReferencesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        ResolveProjectReferences

    Build referenced projects:

        [IN]
        @(ProjectReferenceWithConfiguration) - The list of project references.

        [OUT]
        @(_ResolvedNativeProjectReferencePaths) - Paths to referenced native projects.
        @(_ResolvedProjectReferencePaths) - Paths to referenced managed projects.
    ============================================================
    -->
  <!-- By default, the outputs of project references are passed to the compiler -->
  <ItemDefinitionGroup xmlns="">
    <ProjectReference>
      <!-- Target to build in the project reference; by default, this property is blank, indicating the default targets-->
      <Targets>$(ProjectReferenceBuildTargets)</Targets>
      <!-- Extra item type to emit outputs of the destination into. Defaults to blank. To emit only into this list, set the ReferenceOutputAssembly metadata to false as well. -->
      <OutputItemType />
      <ReferenceSourceTarget>ProjectReference</ReferenceSourceTarget>
    </ProjectReference>
  </ItemDefinitionGroup>
  <Target Name="ResolveProjectReferences" DependsOnTargets="PrepareProjectReferences" Returns="@(_ResolvedNativeProjectReferencePaths);@(_ResolvedProjectReferencePaths)" xmlns="">
    <!--
        When building this project from the IDE, just gather the referenced build outputs.
        The IDE will already have built the project, so there's no need to do it again here.

        The ContinueOnError setting is here so that, during project load, as
        much information as possible will be passed to the compilers.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetPath" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' != '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Build referenced projects when building from the command line.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="%(_MSBuildProjectReferenceExistent.Targets)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform);  %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true' or '$(DesignTimeBuild)' == 'true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Get manifest items from the (non-exe) built project references (to feed them into ResolveNativeReference).
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetNativeManifest" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingProject)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" SkipNonexistentTargets="true" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="NativeReference" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)' == 'true'" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.ResolveableAssembly)' == 'false'" />
      <!--
          Copy OriginalItemSpec to OriginalProjectReferenceItemSpec, so that when ResolveAssemblyReferences
          takes these items and resolves them to ReferencePath, we can still recover the _real_ OriginalItemSpec
          for the unresolved reference items.
          -->
      <_ResolvedProjectReferencePaths>
        <OriginalProjectReferenceItemSpec>%(_ResolvedProjectReferencePaths.OriginalItemSpec)</OriginalProjectReferenceItemSpec>
      </_ResolvedProjectReferencePaths>
    </ItemGroup>
    <!-- Issue a warning or error MSB9008 for each non-existent project. -->
    <PropertyGroup>
      <_NonExistentProjectReferenceSeverity Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' != 'True'">Warning</_NonExistentProjectReferenceSeverity>
      <_NonExistentProjectReferenceSeverity Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' == 'True'">Error</_NonExistentProjectReferenceSeverity>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'$(_NonExistentProjectReferenceSeverity)' != ''" ResourceName="CommonSdk.NonExistentProjectReference" Severity="$(_NonExistentProjectReferenceSeverity)" FormatArguments="@(_MSBuildProjectReferenceNonexistent->'%(Identity)')" />
  </Target>
  <Target Name="ResolveProjectReferencesDesignTime" Returns="@(_ProjectReferencesFromRAR);@(_ResolvedNativeProjectReferencePaths)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences" xmlns="">
    <!-- We need to do this here because we only want project references which have passed through rar and have not been unresolved due to violating some MT rule
        which means we need to pull the project references out of the referencepath item because they will only exist there if they were correctly resolved.
    -->
    <ItemGroup>
      <_ProjectReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))">
        <OriginalItemSpec>%(ReferencePath.ProjectReferenceOriginalItemSpec)</OriginalItemSpec>
      </_ProjectReferencesFromRAR>
    </ItemGroup>
  </Target>
  <Target Name="ExpandSDKReferencesDesignTime" Returns="@(ReferencesFromSDK)" DependsOnTargets="ExpandSDKReferences" xmlns="" />
  <!--
    ============================================================
                                        GetTargetPath

    This target returns an item containing the build product (i.e. EXE, DLL)
    that would be produced if we built this project, with some relevant
    metadata.
    ============================================================
    -->
  <Target Name="GetTargetPath" DependsOnTargets="$(GetTargetPathDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" xmlns="" />
  <!--
    ============================================================
                                        GetTargetPathWithTargetPlatformMoniker

    This stand-alone target returns the name and version of the target platform for this project.

    NOTE: The ProjectReference protocol uses only GetTargetPath. Computing the item
    in this target allows projects to override GetTargetPath without having to reimplement
    the details of the metadata computation.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <GetTargetPathWithTargetPlatformMonikerDependsOn>$(GetTargetPathDependsOn)</GetTargetPathWithTargetPlatformMonikerDependsOn>
  </PropertyGroup>
  <!--NOTE: since an overridden GetTargetPath might not include a DependsOn
      for this target, it's safer to establish the dependency here with a
      BeforeTargets. -->
  <Target Name="GetTargetPathWithTargetPlatformMoniker" BeforeTargets="GetTargetPath" DependsOnTargets="$(GetTargetPathWithTargetPlatformMonikerDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" xmlns="">
    <ItemGroup>
      <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion.TrimStart('vV'))</TargetFrameworkVersion>
        <ReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == 'true'">$(TargetRefPath)</ReferenceAssembly>
        <CopyUpToDateMarker>@(CopyUpToDateMarker)</CopyUpToDateMarker>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetNativeManifest

    Compute the manifest item for this project.

        [IN]
        $(_DeploymentApplicationManifestIdentity) - the manifest identity
        @(ApplicationManifest)         - the original application manifest item

        [OUT]
        @(ComputedApplicationManifest) - application manifest item with full hint path, if generated
    ============================================================
    -->
  <Target Name="GetNativeManifest" Returns="@(ComputedApplicationManifest)" xmlns="">
    <ItemGroup>
      <ComputedApplicationManifest Include="$(_DeploymentApplicationManifestIdentity)" Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe' and Exists('%(_ApplicationManifestFinal.FullPath)')">
        <HintPath>%(_ApplicationManifestFinal.FullPath)</HintPath>
      </ComputedApplicationManifest>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveNativeReferences

    Resolve native references

        [IN]
        @(NativeReference) - The manifest reference (or list of manifest references)

        [OUT]
        @(NativeReferenceFile)  - List of manifest files referenced.
        @(_DeploymentNativePrerequisite)   - List of native assembly prerequisites contained in the manifest.
        @(ComClassReference)    - List of COM components contained in the manifest.
        @(COMReferenceFromNative) List of type libraries contained in the manifest.
        @(COMFileReference)     - List of loose files contained in the manifest.
        @(_DeploymentLooseManifestFile)    - List of extra files that should be published.
    ============================================================
    -->
  <Target Name="ResolveNativeReferences" Condition="'@(NativeReference)'!=''" DependsOnTargets="ResolveProjectReferences" xmlns="">
    <ResolveNativeReference NativeReferences="@(NativeReference)" AdditionalSearchPaths="$(ReferencePath);$(OutDir)">
      <Output TaskParameter="ContainingReferenceFiles" ItemName="NativeReferenceFile" />
      <Output TaskParameter="ContainedPrerequisiteAssemblies" ItemName="_DeploymentNativePrerequisite" />
      <Output TaskParameter="ContainedComComponents" ItemName="ComClassReference" />
      <Output TaskParameter="ContainedTypeLibraries" ItemName="COMReferenceFromNative" />
      <Output TaskParameter="ContainedLooseTlbFiles" ItemName="COMFileReference" />
      <Output TaskParameter="ContainedLooseEtcFiles" ItemName="_DeploymentLooseManifestFile" />
    </ResolveNativeReference>
  </Target>
  <!--
    ============================================================

                                        ResolveAssemblyReferences

    Given the list of assemblies, find the closure of all assemblies that they depend on. These are
    what we need to copy to the output directory.

        [IN]
        @(Reference) - List of assembly references as fusion names.
        @(_ResolvedProjectReferencePaths) - List of project references produced by projects that this project depends on.

            The 'Private' attribute on the reference corresponds to the Copy Local flag in IDE.
            The 'Private' flag can have three possible values:
                - 'True' means the reference should be Copied Local
                - 'False' means the reference should not be Copied Local
                - [Missing] means this task will decide whether to treat this reference as CopyLocal or not.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.
        @(ReferenceDependencyPaths) - Paths to resolved dependency files.
        @(_ReferenceRelatedPaths) - Paths to .xmls and .pdbs.
        @(ReferenceSatellitePaths) - Paths to satellites.
        @(_ReferenceSerializationAssemblyPaths) - Paths to XML serialization assemblies created by sgen.
        @(_ReferenceScatterPaths) - Paths to scatter files.
        @(ReferenceCopyLocalPaths) - Paths to files that should be copied to the local directory.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ResolveAssemblyReferencesDependsOn>
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      PrepareForBuild;
      ResolveSDKReferences;
      ExpandSDKReferences;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveAssemblyReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)" xmlns="">
    <ItemGroup>
      <_ReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
      <_ReferenceInstalledAssemblySubsets Include="$(TargetFrameworkSubset)" />
    </ItemGroup>
    <!--
        Only read and write cache file at build time, skip it for load time because its more
        expensive to write the newly created cache file.
        -->
    <PropertyGroup>
      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <!-- Make an App.Config item that exists when AutoUnify is false. -->
    <ItemGroup>
      <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Default in task is true -->
      <_FindDependencies Condition="'$(BuildingProject)' != 'true' and '$(_ResolveReferenceDependencies)' != 'true'">false</_FindDependencies>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == '' and '$(TraceDesignTime)' != 'true' and '$(BuildingProject)' == 'false'">true</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == ''">false</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)' == ''">Warning</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
      <ResolveAssemblyReferencesFindRelatedSatellites Condition="'$(ResolveAssemblyReferencesFindRelatedSatellites)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedSatellites>
      <ResolveAssemblyReferencesFindSerializationAssemblies Condition="'$(ResolveAssemblyReferencesFindSerializationAssemblies)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindSerializationAssemblies>
      <ResolveAssemblyReferencesFindRelatedFiles Condition="'$(ResolveAssemblyReferencesFindRelatedFiles)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedFiles>
      <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">false</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
    </PropertyGroup>
    <ItemGroup>
      <!-- Remove any references which we have added as explicit reference so that we do not get duplicates. We need to make sure we do not have duplicates
             because this confuses the IDE  when it tries to compare the list of references passed in to the list of resolved references. If it does not match then the
             ide will show one of the references as not resolved, this will not break the build but is a display issue -->
      <Reference Remove="$(AdditionalExplicitAssemblyReferences)" />
      <Reference Include="$(AdditionalExplicitAssemblyReferences)">
        <Implicit>true</Implicit>
      </Reference>
    </ItemGroup>
    <!--Converts string property NonCultureResourceDirectories to array if present. NonCultureResourceDirectories defines exclusions for the custom cultures.  -->
    <ItemGroup Condition="'$(NonCultureResourceDirectories)' != ''">
      <NonCultureResourceDirectory Include="$(NonCultureResourceDirectories)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(EnableCustomCulture)' == ''">
      <EnableCustomCulture>false</EnableCustomCulture>
    </PropertyGroup>
    <!--
      Normally, as an optimization, finding dependencies of references marked with ExternallyResolved=true metadata is skipped.
      However, skipping that step breaks binding redirect generation when there are conflicting versions within the externally
      resolved graph.
    -->
    <PropertyGroup Condition="'$(FindDependenciesOfExternallyResolvedReferences)' == ''">
      <FindDependenciesOfExternallyResolvedReferences>false</FindDependenciesOfExternallyResolvedReferences>
      <FindDependenciesOfExternallyResolvedReferences Condition="'$(AutoGenerateBindingRedirects)' == 'true'">true</FindDependenciesOfExternallyResolvedReferences>
    </PropertyGroup>
    <ResolveAssemblyReference Assemblies="@(Reference)" AssemblyFiles="@(_ResolvedProjectReferencePaths);@(_ExplicitReference)" TargetFrameworkDirectories="@(_ReferenceInstalledAssemblyDirectory)" InstalledAssemblyTables="@(InstalledAssemblyTables);@(RedistList)" IgnoreDefaultInstalledAssemblyTables="$(IgnoreDefaultInstalledAssemblyTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" CandidateAssemblyFiles="@(Content);@(None)" SearchPaths="$(AssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" AppConfigFile="@(_ResolveAssemblyReferencesApplicationConfigFileForExes)" AutoUnify="$(AutoUnifyAssemblyReferences)" SupportsBindingRedirectGeneration="$(GenerateBindingRedirectsOutputType)" IgnoreVersionForFrameworkReferences="$(IgnoreVersionForFrameworkReferences)" FindDependencies="$(_FindDependencies)" FindSatellites="$(ResolveAssemblyReferencesFindRelatedSatellites)" FindSerializationAssemblies="$(ResolveAssemblyReferencesFindSerializationAssemblies)" FindRelatedFiles="$(ResolveAssemblyReferencesFindRelatedFiles)" Silent="$(ResolveAssemblyReferencesSilent)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(ResolveAssemblyReferencesStateFile)" AssemblyInformationCachePaths="$(AssemblyInformationCachePaths)" AssemblyInformationCacheOutputPath="$(AssemblyInformationCacheOutputPath)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" LatestTargetFrameworkDirectories="@(LatestTargetFrameworkDirectories)" CopyLocalDependenciesWhenParentReferenceInGac="$(CopyLocalDependenciesWhenParentReferenceInGac)" DoNotCopyLocalIfInGac="$(DoNotCopyLocalIfInGac)" ResolvedSDKReferences="@(ResolvedSDKReference)" WarnOrErrorOnTargetArchitectureMismatch="$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)" IgnoreTargetFrameworkAttributeVersionMismatch="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)" FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)" ContinueOnError="$(ContinueOnError)" OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)" NonCultureResourceDirectories="@(NonCultureResourceDirectory)" EnableCustomCulture="$(EnableCustomCulture)" Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths" />
      <Output TaskParameter="RelatedFiles" ItemName="_ReferenceRelatedPaths" />
      <Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths" />
      <Output TaskParameter="SerializationAssemblyFiles" ItemName="_ReferenceSerializationAssemblyPaths" />
      <Output TaskParameter="ScatterFiles" ItemName="_ReferenceScatterPaths" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="SuggestedRedirects" ItemName="SuggestedBindingRedirects" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="DependsOnSystemRuntime" PropertyName="DependsOnSystemRuntime" />
      <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard" />
      <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================

                                        FindReferenceAssembliesForReferences

    Given the list of references, create a list of assemblies to pass to the compiler that
    includes reference assemblies rather than implementation assemblies where possible.

        [IN]
        @(ReferencePath) - List of assembly references as resolved paths with ReferenceAssembly metadata

        [OUT]
        @(ReferencePathWithRefAssemblies) - Paths to resolved reference (or implementation) assemblies.
    ============================================================
    -->
  <Target Name="FindReferenceAssembliesForReferences" DependsOnTargets="ResolveReferences" xmlns="">
    <ItemGroup>
      <!-- Reference assemblies are not produced in all cases, but it's easier to consume them
           if this metadatum is always populated. Ensure that it points to the implementation
           assembly unless already specified. -->
      <ReferencePath Condition="'%(ReferencePath.ReferenceAssembly)' == ''">
        <ReferenceAssembly>%(FullPath)</ReferenceAssembly>
      </ReferencePath>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath->'%(ReferenceAssembly)')" Condition="'$(CompileUsingReferenceAssemblies)' != 'false'">
        <OriginalPath Condition="'%(ReferencePath.Identity)' != '@(ReferencePath->'%(ReferenceAssembly)')'">%(ReferencePath.Identity)</OriginalPath>
      </ReferencePathWithRefAssemblies>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath)" Condition="'$(CompileUsingReferenceAssemblies)' == 'false'" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirects
    Inject the binding redirects into the app config file based on suggested redirects as output from
    ResolveAssemblyReferences.

        [IN]
        @(AppConfigWithTargetPath) - Path to the source app config file. This can be null if the project
                                     doesn't contain an app config file.
        $(TargetFileName) -          The file name of the build target.

        [OUT]
        @(OutputAppConfigFile) -     Path to the output app config file in the intermediate directory.

    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirects" Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(SuggestedBindingRedirectsCacheFile)" Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="_GenerateSuggestedBindingRedirectsCache" xmlns="">
    <GenerateBindingRedirects AppConfigFile="@(AppConfigWithTargetPath)" TargetName="$(TargetFileName).config" OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)" SuggestedRedirects="@(SuggestedBindingRedirects)" />
    <ItemGroup>
      <FileWrites Include="$(_GenerateBindingRedirectsIntermediateAppConfig)" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirectsUpdateAppConfig
    Updates the project to use the generated app.config content.  This needs to run regardless of
    inputs/outputs so it is seperate from GenerateBindingRedirects.
    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirectsUpdateAppConfig" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'" xmlns="">
    <PropertyGroup>
      <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
      <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
    </PropertyGroup>
    <PropertyGroup>
      <ConfigFileExists Condition="Exists('@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')')">true</ConfigFileExists>
      <HasNoBindingRedirects Condition="'@(SuggestedBindingRedirects)' == ''">true</HasNoBindingRedirects>
    </PropertyGroup>
    <!-- Overwrites .config file with a App.config content if RAR returned empty @(SuggestedBindingRedirects). -->
    <Copy SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')" DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)" SkipUnchangedFiles="true" Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>
    <Touch Files="$(_GenerateBindingRedirectsIntermediateAppConfig)" AlwaysCreate="true" Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'" />
    <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
      <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
      <AppConfigWithTargetPath Include="$(AppConfig)">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ===========================================================================================
                                        GetInstalledSDKs

    Gets the list of SDKs installed in the SDKDirectoryRoot and SDKRegistryRoot locations

    These paths are used by the ResolveSDKReference task and the ResolveAssemblyReference task.
    ===========================================================================================
  -->
  <PropertyGroup xmlns="">
    <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == ''">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
    <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
    <!-- Manifest driven extension SDK locations -->
    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(WindowsKitsRoot)</SDKExtensionDirectoryRoot>
    <!-- UAP projects by default should support Windows 8.1 SDKs -->
    <SupportWindows81SDKs Condition="'$(SupportWindows81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">true</SupportWindows81SDKs>
    <TargetPlatformIdentifierWindows81 Condition="'$(TargetPlatformIdentifierWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">Windows</TargetPlatformIdentifierWindows81>
    <TargetPlatformVersionWindows81 Condition="'$(TargetPlatformVersionWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">8.1</TargetPlatformVersionWindows81>
    <!-- Desktop and phone SDKs often have the exact same identifiers, don't enable phone by default -->
    <SupportWindowsPhone81SDKs Condition="'$(SupportWindowsPhone81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">false</SupportWindowsPhone81SDKs>
    <TargetPlatformIdentifierWindowsPhone81 Condition="'$(TargetPlatformIdentifierWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">WindowsPhoneApp</TargetPlatformIdentifierWindowsPhone81>
    <TargetPlatformVersionWindowsPhone81 Condition="'$(TargetPlatformVersionWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">8.1</TargetPlatformVersionWindowsPhone81>
  </PropertyGroup>
  <Target Name="GetInstalledSDKLocations" Condition="'@(SDKReference)' != ''" DependsOnTargets="$(GetInstalledSDKLocationsDependsOn)" Returns="@(InstalledSDKLocations)" xmlns="">
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <!-- Also lookup 8.1 SDKs if requested -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindows81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindows81)" Condition="'$(SupportWindows81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindows81)' != '' and '$(TargetPlatformVersionWindows81)' != ''" WarnWhenNoSDKsFound="false">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindowsPhone81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindowsPhone81)" Condition="'$(SupportWindowsPhone81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindowsPhone81)' != '' and '$(TargetPlatformVersionWindowsPhone81)' != ''" WarnWhenNoSDKsFound="false">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
  </Target>
  <!--
    ============================================================

                                        ResolveSDKReferences

    Given a list of SDKReference items and a list of resolved winmd files which may contain metadata as to which sdk they came from
    we need to find the sdk root folders on disk and populate a ResolvedSDKReference item which has the full path to the SDK ROOT
    and the sdk identity as a piece of metadata.

        [IN]
        @(SDKReference) - List of sdk references (the identity in the sdk manifest file).
        @(ReferencePath) -List of resolved assemblies, we are interested in the ones which have IsWinMDFile set to true.

        [OUT]
        @(ResolvedSDKReference) - Full path to the root of the SDK
    ============================================================
  -->
  <PropertyGroup xmlns="">
    <ResolveSDKReferencesDependsOn>
      GetInstalledSDKLocations
    </ResolveSDKReferencesDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Debug'">Debug</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Release'">Retail</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == ''">Retail</TargetedSDKConfiguration>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">$(ProcessorArchitecture)</TargetedSDKArchitecture>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">Neutral</TargetedSDKArchitecture>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <ShouldMarkCertainSDKReferencesAsRuntimeOnly Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == ''">true</ShouldMarkCertainSDKReferencesAsRuntimeOnly>
  </PropertyGroup>
  <ItemGroup Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == 'true'" xmlns="">
    <!-- Dependencies that are specified as runtime-only dependencies. Therefore the associated files are not used to build Appx package.  -->
    <!-- TODO: Do we need to do anything like this for the new SDK? -->
    <RuntimeReferenceOnlySDKDependencies Condition="'$(TargetPlatformVersion)' == '8.1'" Include="Microsoft.VCLibs, Version=11.0" />
  </ItemGroup>
  <Target Name="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" DependsOnTargets="$(ResolveSDKReferencesDependsOn)" xmlns="">
    <ResolveSDKReference SDKReferences="@(SDKReference)" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)" Condition="'@(SDKReference)'!=''">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedSDKReference" />
    </ResolveSDKReference>
  </Target>
  <Target Name="ResolveSDKReferencesDesignTime" Returns="@(ResolvedSDKReference)" DependsOnTargets="ResolveSDKReferences" xmlns="" />
  <!--
    ============================================================

                                        FindInvalidProjectReferences

    Find project to project references with target platform version higher than the one used by the current project and
    creates a list of invalid references to be unresolved. It issues a warning for each invalid reference.

        [IN]
        $(TargetPlatformVersion) - Project's target platform version
        @(_ProjectReferenceTargetPlatformMonikers) - List of monikers of all referenced projects gathered by the helper
                                                     target GetTargetPlatformMonikers.

        [OUT]
    @(InvalidProjectReferences) - List of invalid project references

    ============================================================
    -->
  <PropertyGroup xmlns="">
    <FindInvalidProjectReferencesDependsOn>
      GetReferenceTargetPlatformMonikers
    </FindInvalidProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="FindInvalidProjectReferences" Condition="'$(FindInvalidProjectReferences)' == 'true'" DependsOnTargets="$(FindInvalidProjectReferencesDependsOn)" xmlns="">
    <FindInvalidProjectReferences TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" ProjectReferences="@(_ProjectReferenceTargetPlatformMonikers)">
      <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
    </FindInvalidProjectReferences>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(InvalidProjectReferences)" />
    </ItemGroup>
  </Target>
  <Target Name="GetReferenceTargetPlatformMonikers" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Targets="GetTargetPathWithTargetPlatformMoniker" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetPlatformMonikers" />
    </MSBuild>
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(FindInvalidProjectReferences)' == 'true'" xmlns="">
    <ProjectReferenceTargets Include="Build" Targets="GetTargetPathWithTargetPlatformMoniker" />
  </ItemGroup>
  <!--
    ============================================================

                       ExpandSDKReferences

        After we have resolved the sdk refrence we need to make sure that we automatically include the references which are part of the SDK (both winmd and dll)
        as part of the assemblies passed to the compiler.

        Project systems or project which do not want to reference all dlls or winmd files should override this target to do nothing.
   ============================================================
    -->
  <PropertyGroup xmlns="">
    <ExpandSDKReferencesDependsOn>
      ResolveSDKReferences
    </ExpandSDKReferencesDependsOn>
    <ExpandSDKAllowedReferenceExtensions Condition="'$(ExpandSDKAllowedReferenceExtensions)' == ''">
      .winmd;
      .dll
    </ExpandSDKAllowedReferenceExtensions>
  </PropertyGroup>
  <Target Name="ExpandSDKReferences" Returns="@(ReferencesFromSDK)" DependsOnTargets="$(ExpandSDKReferencesDependsOn)" xmlns="">
    <GetSDKReferenceFiles ResolvedSDKReferences="@(ResolvedSDKReference)" ReferenceExtensions="$(ExpandSDKAllowedReferenceExtensions)" TargetSDKIdentifier="$(SDKIdentifier)" TargetSDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" LogRedistFilesList="$(GetSDKReferenceFilesLogRedistFilesList)" LogRedistConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogRedistConflictsWithinSDKAsWarning)" LogRedistConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogRedistConflictsBetweenSDKsAsWarning)" LogReferencesList="$(GetSDKReferenceFilesLogReferencesList)" LogReferenceConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsWithinSDKAsWarning)" LogReferenceConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsBetweenSDKsAsWarning)" CacheFileFolderPath="$(GetSDKReferenceFilesCacheFolder)" LogCacheFileExceptions="$(GetSDKReferenceFilesLogCacheFileExceptions)" Condition="'@(ResolvedSDKReference)'!=''">
      <Output TaskParameter="References" ItemName="ReferencePath" />
      <Output TaskParameter="References" ItemName="ReferencesFromSDK" />
      <Output TaskParameter="References" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="RedistFiles" ItemName="ResolvedRedistFiles" />
    </GetSDKReferenceFiles>
  </Target>
  <!--
    ============================================================

                                        ExportWindowsMDFile

    When a project is generating a a winmd file through c# or vb, ect the compiler will create a WinMDModule file. This file needs to be run
    through the winmdexp tool in order to generate the resulting WinMD file.

    ===========================================================
    -->
  <Target Name="ExportWindowsMDFile" DependsOnTargets="Compile" Condition="'$(ExportWinMDFile)' == 'true'" Inputs="@(IntermediateAssembly);@(DocFileItem);@(_DebugSymbolsIntermediatePath);@(ReferencePathWithRefAssemblies);$(MSBuildAllProjects)" Outputs="$(_IntermediateWindowsMetadataPath);$(WinMDExpOutputPdb);$(WinMDOutputDocumentationFile)" xmlns="">
    <PropertyGroup>
      <!-- Will be copied by the "copy WinMD artifacts" step instead -->
      <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>
      <CopyDocumentationFileToOutputDirectory>false</CopyDocumentationFileToOutputDirectory>
      <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</WinMdExpToolPath>
      <WinMdExpUTF8Ouput Condition="'$(WinMdExpUTF8Ouput)' == ''">true</WinMdExpUTF8Ouput>
    </PropertyGroup>
    <WinMDExp WinMDModule="@(IntermediateAssembly)" References="@(ReferencePathWithRefAssemblies)" DisabledWarnings="$(WinMdExpNoWarn)" InputDocumentationFile="@(DocFileItem)" OutputDocumentationFile="$(WinMDOutputDocumentationFile)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" InputPDBFile="@(_DebugSymbolsIntermediatePath)" OutputPDBFile="$(WinMDExpOutputPdb)" OutputWindowsMetadataFile="$(_IntermediateWindowsMetadataPath)" EnvironmentVariables="$(WinMDExpEnvironment)" UTF8Output="$(WinMdExpUTF8Ouput)" SdkToolsPath="$(WinMdExpToolPath)" AssemblyUnificationPolicy="$(WinMDExpAssemblyUnificationPolicy)">
      <Output TaskParameter="OutputWindowsMetadataFile" ItemName="FileWrites" />
    </WinMDExp>
    <ItemGroup>
      <WinMDExpArtifacts Include="$(_IntermediateWindowsMetadataPath)" />
      <WinMDExpArtifacts Include="$(WinMDOutputDocumentationFile)" />
      <WinMDExpArtifacts Include="$(WinMDExpOutputPdb)" />
      <FileWrites Include="$(WinMDOutputDocumentationFile);$(WinMDExpOutputPdb)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveAssemblyReferencesDesignTime" Returns="@(_ReferencesFromRAR)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences" xmlns="">
    <!-- We need to do this here because we only want references which have been passed into rar but are not project to project references. -->
    <ItemGroup>
      <_ReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ResolveAssemblyReference'))" />
    </ItemGroup>
  </Target>
  <PropertyGroup xmlns="">
    <ProjectDesignTimeAssemblyResolutionSearchPaths Condition=" '$(ProjectDesignTimeAssemblyResolutionSearchPaths)' == '' ">
      {CandidateAssemblyFiles};
      $(ReferencePath);
      {HintPathFromItem};
      {TargetFrameworkDirectory};
      {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
      {RawFileName};
      $(TargetDir)
    </ProjectDesignTimeAssemblyResolutionSearchPaths>
  </PropertyGroup>
  <!--
    ==============================================================

                                       DesignTimeResolveAssemblyReferences

    Given the list of assemblies, resolve their reference paths.
    This target is called by Visual Studio at run time in order to filter references
    according to the targeted framework.

        [IN]
        @(DesignTimeReference) - List of assembly references as simple/fusion names.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.

    ==============================================================
    -->
  <PropertyGroup xmlns="">
    <DesignTimeResolveAssemblyReferencesDependsOn>
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      ResolveReferences
    </DesignTimeResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="DesignTimeResolveAssemblyReferences" Condition="'$(DesignTimeReference)'!=''" DependsOnTargets="$(DesignTimeResolveAssemblyReferencesDependsOn)" xmlns="">
    <ItemGroup>
      <_DesignTimeReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
    </ItemGroup>
    <PropertyGroup>
      <DesignTimeResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true'">$(IntermediateOutputPath)$(MSBuildProjectFile)DesignTimeResolveAssemblyReferences.cache</DesignTimeResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeAssemblySearchPaths Condition=" '$(DesignTimeAssemblySearchPaths)' == '' ">
        {CandidateAssemblyFiles};
        $(ReferencePath);
        {HintPathFromItem};
        {TargetFrameworkDirectory};
        {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
        {RawFileName};
        $(OutDir)
      </DesignTimeAssemblySearchPaths>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeFindDependencies Condition=" '$(DesignTimeFindDependencies)' == '' ">false</DesignTimeFindDependencies>
      <DesignTimeIgnoreVersionForFrameworkReferences Condition=" '$(DesignTimeIgnoreVersionForFrameworkReferences)' == '' ">false</DesignTimeIgnoreVersionForFrameworkReferences>
      <DesignTimeFindSatellites Condition=" '$(DesignTimeFindSatellites)' == '' ">false</DesignTimeFindSatellites>
      <DesignTimeFindSerializationAssemblies Condition=" '$(DesignTimeFindSerializationAssemblies)' == '' ">false</DesignTimeFindSerializationAssemblies>
      <DesignTimeFindRelatedFiles Condition=" '$(DesignTimeFindRelatedFiles)' == '' ">false</DesignTimeFindRelatedFiles>
      <DesignTimeSilentResolution Condition=" '$(DesignTimeSilentResolution)' == '' and '$(TraceDesignTime)' != 'true'">true</DesignTimeSilentResolution>
      <DesignTimeAutoUnify Condition="'$(DesignTimeAutoUnify)' == ''">false</DesignTimeAutoUnify>
    </PropertyGroup>
    <ItemGroup>
      <_DesignTimeReferenceAssemblies Include="$(DesignTimeReference)" />
    </ItemGroup>
    <ItemGroup>
      <_RARResolvedReferencePath Include="@(ReferencePath)" />
      <ReferencePath Remove="@(ReferencePath)" />
    </ItemGroup>
    <ResolveAssemblyReference Assemblies="@(_DesignTimeReferenceAssemblies)" TargetFrameworkDirectories="@(_DesignTimeReferenceInstalledAssemblyDirectory)" SearchPaths="$(DesignTimeAssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" CandidateAssemblyFiles="@(Content);@(None);@(_RARResolvedReferencePath)" FindDependencies="$(DesignTimeFindDependencies)" AutoUnify="$(DesignTimeAutoUnify)" IgnoreVersionForFrameworkReferences="$(DesignTimeIgnoreVersionForFrameworkReferences)" FindSatellites="$(DesignTimeFindSatellites)" FindSerializationAssemblies="$(DesignTimeFindSerializationAssemblies)" FindRelatedFiles="$(DesignTimeFindRelatedFiles)" Silent="$(DesignTimeSilentResolution)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(DesignTimeResolveAssemblyReferencesStateFile)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" ResolvedSDKReferences="@(ResolvedSDKReference)" IgnoreTargetFrameworkAttributeVersionMismatch="$(DesignTimeIgnoreTargetFrameworkAttributeVersionMismatch)">
      <Output TaskParameter="ResolvedFiles" ItemName="DesignTimeReferencePath" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================
                                        ResolveComReferences

    Resolve COM references

        [IN]
        @(COMReference) - The list of COM references
        $(InteropOutputPath) - The output directory in which to generate wrapper assemblies
                               When $(InteropOutputPath) is not set, then it defaults to $(IntermediateOutputPath).

        [OUT]
        @(ReferencePath) - Paths to referenced wrappers.

        If ResolveComReferences is invoked from the IDE, PrepareForBuild may need to run to create directories.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ComReferenceExecuteAsTool Condition="'$(ComReferenceExecuteAsTool)'==''">false</ComReferenceExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResolveComReferences" Condition="'@(COMReference)'!='' or '@(COMFileReference)'!=''" Returns="@(ReferencePath)" DependsOnTargets="PrepareForBuild;ResolveKeySource;ResolveAssemblyReferences" xmlns="">
    <PropertyGroup Condition=" '$(InteropOutputPath)' == '' ">
      <InteropOutputPath>$(IntermediateOutputPath)</InteropOutputPath>
    </PropertyGroup>
    <MakeDir Directories="$(InteropOutputPath)" />
    <!--
        Note: This task should not be batched, since it relies on having all the COM references fed into it at once.
        -->
    <PropertyGroup>
      <ResolveComReferenceMSBuildArchitecture Condition="'$(ResolveComReferenceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</ResolveComReferenceMSBuildArchitecture>
      <ResolveComReferenceToolPath Condition="'$(ResolveComReferenceToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResolveComReferenceToolPath>
      <ResolveComReferenceSilent Condition="'$(ResolveComReferenceSilent)' == ''">false</ResolveComReferenceSilent>
    </PropertyGroup>
    <ResolveComReference TypeLibNames="@(COMReference)" TypeLibFiles="@(COMFileReference)" ResolvedAssemblyReferences="@(ReferencePath)" WrapperOutputDirectory="$(InteropOutputPath)" IncludeVersionInInteropName="$(IncludeVersionInInteropName)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" StateFile="@(_ResolveComReferenceCache)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetProcessorArchitecture="$(ProcessorArchitecture)" NoClassMembers="$(ComReferenceNoClassMembers)" Silent="$(ResolveComReferenceSilent)" EnvironmentVariables="$(ResolveComReferenceEnvironment)" SdkToolsPath="$(ResolveComReferenceToolPath)" ExecuteAsTool="$(ComReferenceExecuteAsTool)" MSBuildArchitecture="$(ResolveComReferenceMSBuildArchitecture)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="ComReferenceWrappers" />
      <Output TaskParameter="ResolvedFiles" ItemName="FileWrites" />
      <!-- This output list only includes items with Isolated attribute set to True.  It's done by the task itself. -->
      <Output TaskParameter="ResolvedModules" ItemName="ResolvedIsolatedComModules" />
    </ResolveComReference>
    <ItemGroup>
      <FileWrites Include="@(_ResolveComReferenceCache)" />
      <ReferenceComWrappersToCopyLocal Include="@(ComReferenceWrappers)" Condition="'%(ComReferenceWrappers.CopyLocal)'!='false'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _GetAssembliesMetadata

    Resolve Assembly attributes for assemblies
    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,
    but this target handles all the assembly references from ResolveAssemblyReferences
    This target is needed by the Visual Studio legacy project system during design time build only

        [IN]
        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.

        [OUT]
        @(AssembliesMetadata) - Resolved assemblies attributes.
    ============================================================
    -->
  <Target Name="_GetAssembliesMetadata" Condition="'@(ReferencePath)'!=''and '$(DesignTimeBuild)' == 'true' " Returns="@(_AssembliesMetadata)" DependsOnTargets="ResolveComReferences" xmlns="">
    <GetAssembliesMetadata AssemblyPaths="@(ReferencePath)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="AssembliesMetadata" ItemName="_AssembliesMetadata" />
    </GetAssembliesMetadata>
  </Target>
  <Target Name="ResolveComReferencesDesignTime" Returns="@(ComReferenceWrappers)" DependsOnTargets="ResolveComReferences" xmlns="" />
  <!--
    ============================================================
                                      ResolveFrameworkReferences

    Overrridden by Microsoft.NET.Sdk to return
    ResolvedFrameworkReference items in order to populate the
    Frameworks node of the Solution Explorer in the IDE.
  -->
  <Target Name="ResolveFrameworkReferences" xmlns="" />
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareResources Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareResources

    Prepare resources for the Compile step.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareResourcesDependsOn>
      $(PrepareResourcesDependsOn);
      PrepareResourceNames;
      ResGen;
      CompileLicxFiles
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResources" DependsOnTargets="$(PrepareResourcesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        PrepareResourceNames

    Prepare the names of resource files.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareResourceNamesDependsOn>
      AssignTargetPaths;
      SplitResourcesByCulture;
      CreateManifestResourceNames;
      CreateCustomManifestResourceNames
    </PrepareResourceNamesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResourceNames" DependsOnTargets="$(PrepareResourceNamesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        AssignTargetPaths

    This target creates <TargetPath> tags for items. <TargetPath> is a relative folder plus filename
    for the destination of this item.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <AssignTargetPathsDependsOn />
  </PropertyGroup>
  <Target Name="AssignTargetPaths" DependsOnTargets="$(AssignTargetPathsDependsOn)" xmlns="">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- AssignTargetPath generates TargetPath metadata that is consumed by CreateManifestResourceNames target for manifest name generation -->
    <AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
      <EmbeddedResource Remove="@(_Temporary)" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_NoneWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(BaseApplicationManifest)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)" Condition="'@(_DeploymentBaseManifestWithTargetPath)'=='' and '%(None.Extension)'=='.manifest'">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
  </Target>
  <!--
    ============================================================
                                        GetItemTargetPaths

    This target returns all items that have TargetPath metadata assigned by the AssignTargetPaths target.
    ============================================================
    -->
  <Target Name="GetItemTargetPaths" DependsOnTargets="AssignTargetPaths" Returns="&#xD;&#xA;      @(EmbeddedResource);&#xD;&#xA;      @(ContentWithTargetPath);&#xD;&#xA;      @(_NoneWithTargetPath);&#xD;&#xA;      @(_DeploymentBaseManifestWithTargetPath);&#xD;&#xA;      " xmlns="" />
  <!--
    ============================================================
                                        SplitResourcesByCulture

    Split EmbeddedResource items into five lists based on whether
    they are resx files, licx files or other resources and whether they should be localized. Also adds Type and Culture
    metadata. Type indicates whether the resource is "Resx" or "Non-Resx".

        [IN]/[OUT]
        @(EmbeddedResource) - The raw list of resources.

        [OUT]
        @(_LicxFile) - The EmbeddedResource items with extension equal to '.licx'.
    ============================================================
    -->
  <Target Name="SplitResourcesByCulture" DependsOnTargets="AssignTargetPaths" xmlns="">
    <PropertyGroup>
      <RespectAlreadyAssignedItemCulture Condition="'$(RespectAlreadyAssignedItemCulture)' == ''">false</RespectAlreadyAssignedItemCulture>
      <WarnOnCultureOverwritten Condition="'$(WarnOnCultureOverwritten)' == ''">false</WarnOnCultureOverwritten>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'@(ResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9000;ResxWithNoCulture" />
    <MSBuildInternalMessage Condition="'@(ResxWithCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9001;ResxWithCulture" />
    <MSBuildInternalMessage Condition="'@(NonResxWithCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9002;NonResxWithCulture" />
    <MSBuildInternalMessage Condition="'@(NonResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9003;NonResxWithNoCulture" />
    <ItemGroup>
      <_LicxFile Include="@(EmbeddedResource)" Condition="'%(Extension)'=='.licx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <EmbeddedResource Include="@(ResxWithNoCulture);@(ResxWithCulture)">
        <Type>Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(NonResxWithCulture);@(NonResxWithNoCulture)">
        <Type>Non-Resx</Type>
      </EmbeddedResource>
    </ItemGroup>
    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'" RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)" WarnOnCultureOverwritten="$(WarnOnCultureOverwritten)">
      <!-- Create the list of culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture" />
      <!-- Create the list of non-culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="_MixedResourceWithNoCulture" />
    </AssignCulture>
    <ItemGroup>
      <!-- Remove EmbeddedResource items that we have processed already
                 i.e. either Licx, or resources that don't have culture info -->
      <EmbeddedResource Remove="@(_MixedResourceWithCulture)" />
      <EmbeddedResource Remove="@(_MixedResourceWithNoCulture)" />
      <EmbeddedResource Remove="@(_LicxFile)" />
      <!-- Add back everything except Licx, so that we have culture info -->
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'=='.resx' or '%(Extension)'=='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'!='.resx' and '%(Extension)'!='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Non-Resx</Type>
      </EmbeddedResource>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ResxWithNoCulture Remove="@(ResxWithNoCulture)" />
      <NonResxWithNoCulture Remove="@(NonResxWithNoCulture)" />
      <ResxWithCulture Remove="@(ResxWithCulture)" />
      <NonResxWithCulture Remove="@(NonResxWithCulture)" />
      <ResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <ResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <!-- Clean up temporary lists -->
      <_MixedResourceWithNoCulture Remove="@(_MixedResourceWithNoCulture)" />
      <_MixedResourceWithCulture Remove="@(_MixedResourceWithCulture)" />
    </ItemGroup>
  </Target>
  <!--
    =======================================================================
                                        CreateCustomManifestResourceNames

    Allows custom manifest resource name generation tasks to plug
    into the build process
    =======================================================================
    -->
  <PropertyGroup xmlns="">
    <CreateCustomManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateCustomManifestResourceNames" DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        ResGen

    Run GenerateResource on the given resx files.

    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ResGenDependsOn>ResolveAssemblyReferences;SplitResourcesByCulture;BeforeResGen;CoreResGen;AfterResGen</ResGenDependsOn>
    <CoreResGenDependsOn>FindReferenceAssembliesForReferences</CoreResGenDependsOn>
    <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
    <ResGenExecuteAsTool Condition="'$(ResGenExecuteAsTool)'==''">false</ResGenExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResGen" DependsOnTargets="$(ResGenDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforeResGen

    Redefine this target in your project in order to run tasks just before Resgen.
    ============================================================
    -->
  <Target Name="BeforeResGen" xmlns="" />
  <!--
    ============================================================
                                        AfterResGen

    Redefine this target in your project in order to run tasks just after Resgen.
    ============================================================
    -->
  <Target Name="AfterResGen" xmlns="" />
  <!--
    ============================================================
                                        CoreResGen
    ============================================================
    -->
  <Target Name="CoreResGen" DependsOnTargets="$(CoreResGenDependsOn)" xmlns="">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <PropertyGroup>
      <GenerateResourceMSBuildArchitecture Condition="'$(GenerateResourceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</GenerateResourceMSBuildArchitecture>
      <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(GenerateResourceMSBuildArchitecture)' != ''">
      <!-- In the general case, we want to fail to run the task if the task host it's requesting doesn't exist, because we'd rather let the
           user know there's something wrong than just silently generate something that's probably not quite right. However, in a few
           circumstances, there are tasks that are already aware of runtime / bitness concerns, in which case even if we go ahead and run
           the more recent version of the task, it should be able to generate something correct.  GenerateResource is one such task, so
           we check for the existence of the targeted task host so that we can use it preferentially, but if it can't be found, we'll fall
           back to the current task since it's still mostly correct.

           In particular, we need to do this because otherwise people with Dev10 on a machine that they upgrade to Win8 will be broken:
           they'll have ResGen from the 7.0A SDK installed, so launching ResGen will still work, but the CLR2 task host is only installed by
           the 8.0A SDK, which they won't have installed, and thus without this fallback mechanism, their projects targeting v3.5 will
           suddenly start failing to build.-->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == '' and&#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(GenerateResourceMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</GenerateResourceMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == ''">CurrentRuntime</GenerateResourceMSBuildRuntime>
    </PropertyGroup>
    <!-- 4.0 task has some new parameters that we want to make use of if we're targeting 4.0 -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePathWithRefAssemblies)" UsePreserializedResources="$(GenerateResourceUsePreserializedResources)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' != 'CLR2'" SdkToolsPath="$(ResgenToolPath)" ExecuteAsTool="$(ResGenExecuteAsTool)" EnvironmentVariables="$(ResGenEnvironment)" WarnOnBinaryFormatterUse="$(GenerateResourceWarnOnBinaryFormatterUse)" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <!-- But we can't use those parameters if we're targeting 3.5, since we're using the 3.5 task -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' == 'CLR2'">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temporary)" />
      <!-- Add back the Sources list (with OutputResource metadata) that we output from GenerateResource into EmbeddedResource -->
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithNoCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithNoCulture>
      <ManifestNonResxWithNoCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithNoCultureOnDisk>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithCulture>
      <ManifestNonResxWithCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithCultureOnDisk>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        CompileLicxFiles

    Compile .licx files (containing information about licensed controls used by the application) into .licenses files.

        [IN]
        @(_LicxFile) - The list of .licx files in the project (usually there will be just one)

        [OUT]
        @(CompiledLicenseFile) - The list of compiled .licenses files (there will be just one)
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CompileLicxFilesDependsOn />
  </PropertyGroup>
  <Target Name="CompileLicxFiles" Condition="'@(_LicxFile)'!=''" DependsOnTargets="$(CompileLicxFilesDependsOn)" Inputs="$(MSBuildAllProjects);@(_LicxFile);@(ReferencePathWithRefAssemblies);@(ReferenceDependencyPaths)" Outputs="$(IntermediateOutputPath)$(TargetFileName).licenses" xmlns="">
    <PropertyGroup>
      <LCMSBuildArchitecture Condition="'$(LCMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</LCMSBuildArchitecture>
    </PropertyGroup>
    <LC Sources="@(_LicxFile)" LicenseTarget="$(TargetFileName)" OutputDirectory="$(IntermediateOutputPath)" OutputLicense="$(IntermediateOutputPath)$(TargetFileName).licenses" ReferencedAssemblies="@(ReferencePathWithRefAssemblies);@(ReferenceDependencyPaths)" NoLogo="$(NoLogo)" ToolPath="$(LCToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(LCEnvironment)" MSBuildArchitecture="$(LCMSBuildArchitecture)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputLicense" ItemName="CompiledLicenseFile" />
      <Output TaskParameter="OutputLicense" ItemName="FileWrites" />
    </LC>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveKeySource Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        ResolveKeySource

    Resolve the strong name key used to sign the assembly as well as the certificate used to
    sign the ClickOnce manifests.

        [IN]
        $(AssemblyOriginatorKeyFile)     - The file used to sign the assembly (.snk or .pfx)
        $(ManifestCertificateThumbprint) - The thumbprint used to locate the certificate in the
                                           user's certificate store.
        $(ManifestKeyFile)               - The key file that contains the certificate in case the
                                           certificate is not in the user's store.

        [OUT]
        $(ResolvedAssemblyKeyFile)        - Key used to sign the assembly
        $(_DeploymentResolvedManifestCertificateThumbprint) - Certificate used to sign the manifests
    ============================================================
    -->
  <Target Name="ResolveKeySource" Condition="$(SignManifests) == 'true' or $(SignAssembly) == 'true'" xmlns="">
    <ResolveKeySource KeyFile="$(AssemblyOriginatorKeyFile)" CertificateThumbprint="$(ManifestCertificateThumbprint)" CertificateFile="$(ManifestKeyFile)" SuppressAutoClosePasswordPrompt="$(BuildingInsideVisualStudio)" ShowImportDialogDespitePreviousFailures="$(BuildingProject)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ResolvedKeyFile" PropertyName="KeyOriginatorFile" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedKeyContainer" PropertyName="KeyContainerName" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedThumbprint" PropertyName="_DeploymentResolvedManifestCertificateThumbprint" Condition=" '$(SignManifests)' == 'true' " />
    </ResolveKeySource>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Compile Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Compile
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CompileDependsOn>
      ResolveReferences;
      ResolveKeySource;
      SetWin32ManifestProperties;
      _SetPreferNativeArm64Win32ManifestProperties;
      FindReferenceAssembliesForReferences;
      _GenerateCompileInputs;
      BeforeCompile;
      _TimeStampBeforeCompile;
      _GenerateCompileDependencyCache;
      CoreCompile;
      _TimeStampAfterCompile;
      AfterCompile;
    </CompileDependsOn>
  </PropertyGroup>
  <Target Name="Compile" DependsOnTargets="$(CompileDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _GenerateCompileInputs

    Create the _CoreCompileResourceInputs list of inputs to the CoreCompile target.
    ============================================================
    -->
  <Target Name="_GenerateCompileInputs" xmlns="">
    <MSBuildInternalMessage Condition="'@(ManifestResourceWithNoCulture)'!='' and '%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9004;ManifestResourceWithNoCulture;false;Resx" />
    <MSBuildInternalMessage Condition="'@(ManifestNonResxWithNoCultureOnDisk)'!='' and '%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9005;ManifestNonResxWithNoCultureOnDisk;false;Non-Resx" />
    <ItemGroup>
      <!-- _CoreCompileResourceInputs is the list of TLDA inputs that should trigger CoreCompile, and are listed as inputs to that target -->
      <_CoreCompileResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_CoreCompileResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Non-Resx' " />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_CoreCompileResourceInputs Include="@(ManifestResourceWithNoCulture)" Condition="'%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
      <_CoreCompileResourceInputs Include="@(ManifestNonResxWithNoCultureOnDisk)" Condition="'%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateTargetFrameworkMonikerAttribute

    Emit the target framework moniker attribute as  a code fragment into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''" xmlns="">
    <!-- Do not clean if we are going to default the path to the temp directory -->
    <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$(IntermediateOutputPath)','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
  </PropertyGroup>
  <PropertyGroup xmlns="">
    <GenerateTargetFrameworkAttribute Condition="'$(GenerateTargetFrameworkAttribute)' == '' and '$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">true</GenerateTargetFrameworkAttribute>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == 'true'" xmlns="">
    <Clean Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
  </ItemGroup>
  <Target Name="GenerateTargetFrameworkMonikerAttribute" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets" Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)" Condition="'@(Compile)' != '' and '$(GenerateTargetFrameworkAttribute)' == 'true'" xmlns="">
    <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
             and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
    <WriteLinesToFile File="$(TargetFrameworkMonikerAssemblyAttributesPath)" Lines="$(TargetFrameworkMonikerAssemblyAttributeText)" Overwrite="true" ContinueOnError="true" Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''" />
    <ItemGroup Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''">
      <Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
      <!-- Do not put in FileWrites: this is a file shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateAdditionalSources

    Emit any specified code fragments into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(AssemblyAttributesPath)' != ''" xmlns="">
    <GenerateAdditionalSources Condition="'$(GenerateAdditionalSources)' == ''">true</GenerateAdditionalSources>
  </PropertyGroup>
  <ItemGroup Condition="'$(AssemblyAttributesPath)' != ''" xmlns="">
    <Clean Include="$(AssemblyAttributesPath)" Condition="'$(AssemblyAttributesFileClean)' != 'false'" />
  </ItemGroup>
  <Target Name="GenerateAdditionalSources" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildAllProjects)" Outputs="$(AssemblyAttributesPath)" Condition="'@(AssemblyAttributes)' != '' and '$(GenerateAdditionalSources)' == 'true'" xmlns="">
    <WriteCodeFragment AssemblyAttributes="@(AssemblyAttributes)" OutputFile="$(AssemblyAttributesPath)" Language="$(Language)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
    ============================================================
                                        BeforeCompile

    Redefine this target in your project in order to run tasks just before Compile.
    ============================================================
    -->
  <Target Name="BeforeCompile" xmlns="" />
  <!--
    ============================================================
                                        AfterCompile

    Redefine this target in your project in order to run tasks just after Compile.
    ============================================================
    -->
  <Target Name="AfterCompile" xmlns="" />
  <!--
    ============================================================
                                        _TimeStampBeforeCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampBeforeCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')" xmlns="">
    <PropertyGroup>
      <_AssemblyTimestampBeforeCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampBeforeCompile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _GenerateSuggestedBindingRedirectsCache
    Generate a file used to track whether suggested binding redirects changed between builds.
    @(SuggestedBindingRedirects) never contains a file on disk, so create a file
    that contains a hash of the items to prevent `GenerateBindingRedirects`
    from running every build.

    See https://github.com/dotnet/msbuild/issues/5943 for details.
    ============================================================
    -->
  <Target Name="_GenerateSuggestedBindingRedirectsCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences" xmlns="">
    <PropertyGroup>
      <SuggestedBindingRedirectsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectFile).SuggestedBindingRedirects.cache</SuggestedBindingRedirectsCacheFile>
    </PropertyGroup>
    <Hash ItemsToHash="@(SuggestedBindingRedirects)">
      <Output TaskParameter="HashResult" PropertyName="SuggestedBindingRedirectsHash" />
    </Hash>
    <WriteLinesToFile Lines="$(SuggestedBindingRedirectsHash)" File="$(SuggestedBindingRedirectsCacheFile)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(SuggestedBindingRedirectsCacheFile)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _GenerateCompileDependencyCache

    Generate a file used to track compiler dependencies between incremental build
    executions. This handles cases where items are added or removed from a glob (e.g.
    <Compile Include="**\*.cs" />) and can't otherwise be detected with timestamp
    comparisons. The file contains a hash of compiler inputs that are known to
    contribute to incremental build inconsistencies.
    ============================================================
    -->
  <Target Name="_GenerateCompileDependencyCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences;_GenerateCompileInputs" xmlns="">
    <ItemGroup>
      <CustomAdditionalCompileInputs Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
      <CoreCompileCache Include="@(Compile)" />
      <CoreCompileCache Include="@(ReferencePath)" />
      <CoreCompileCache Include="$(DefineConstants)" />
      <CoreCompileCache Include="$(LangVersion)" />
      <CoreCompileCache Include="$(Deterministic)" />
      <CoreCompileCache Include="$(PathMap)" />
      <CoreCompileCache Include="@(_CoreCompileResourceInputs)" />
    </ItemGroup>
    <Hash ItemsToHash="@(CoreCompileCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CoreCompileCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CoreCompileDependencyHash" />
    </Hash>
    <WriteLinesToFile Lines="$(CoreCompileDependencyHash)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _TimeStampAfterCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampAfterCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')" xmlns="">
    <PropertyGroup>
      <_AssemblyTimestampAfterCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampAfterCompile>
    </PropertyGroup>
  </Target>
  <!--
    ================================================================
                                        _ComputeNonExistentFileProperty

    There are certain situations in which we want to always run the CoreCompile target (and
    thus the Csc task), even if the timestamps of the outputs appear to be up-to-date on disk.
    If we're inside the IDE during design-time, then the Csc/Vbc/Vjc task is simply being used to
    initialize the host compiler, so we always want to run it.  Also, if we're inside the IDE, and
    the host compiler is responsible for doing the compilation during an actual build, we want to let
    the host compiler determine whether the output is up-to-date, because there may be source files
    in the IDE's in-memory buffers that we don't know about.

    So, we always run the CoreCompile target if we're in the IDE, and either we're in design-time or
    we're delegating to the host compiler for the actual build.

    We compare against BuildOutOfProcess != true because we cannot assume that the build process will
    have set BuildOutOfProcess to true or false. Therefore the default behavior should be to do the
    legacy behavior seen before BuildingOutOfProcess was introduced if the property is not set.
    ================================================================
    -->
  <Target Name="_ComputeNonExistentFileProperty" Condition="('$(BuildingInsideVisualStudio)' == 'true') and ('$(BuildingOutOfProcess)' != 'true') and (('$(BuildingProject)' == 'false') or ('$(UseHostCompilerIfAvailable)' == 'true'))" xmlns="">
    <PropertyGroup>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateSerializationAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <_SGenDllName>$(TargetName).XmlSerializers.dll</_SGenDllName>
    <_SGenDllCreated>false</_SGenDllCreated>
    <_SGenGenerateSerializationAssembliesConfig>$(GenerateSerializationAssemblies)</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(GenerateSerializationAssemblies)' == ''">Auto</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(ConfigurationName)'=='Debug' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto'">Off</_SGenGenerateSerializationAssembliesConfig>
    <SGenUseProxyTypes Condition="'$(SGenUseProxyTypes)' == ''">true</SGenUseProxyTypes>
    <SGenUseKeep Condition="'$(SGenUseKeep)'==''">false</SGenUseKeep>
    <SGenShouldGenerateSerializer Condition="'$(SGenShouldGenerateSerializer)' == ''">true</SGenShouldGenerateSerializer>
  </PropertyGroup>
  <!--
    ============================================================
                                        GenerateSerializationAssemblies

    Run GenerateSerializationAssemblies on the assembly produced by this build.

        [IN]
        @(BuildAssemblyName) - The assembly generated by this build.
        @(BuildAssemblyPath) - The path where the assembly resides.
        @(ReferencePath) - The list of references used by this assembly.

        [OUT]
        @(SerializationAssembly) - The path to the serialization assembly.  Maybe we'll just append to an existing list.
    ============================================================
    -->
  <Target Name="GenerateSerializationAssemblies" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" DependsOnTargets="AssignTargetPaths;Compile;ResolveKeySource" Inputs="$(MSBuildAllProjects);@(IntermediateAssembly)" Outputs="$(IntermediateOutputPath)$(_SGenDllName)" xmlns="">
    <PropertyGroup>
      <SGenMSBuildArchitecture Condition="'$(SGenMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</SGenMSBuildArchitecture>
    </PropertyGroup>
    <SGen BuildAssemblyName="$(TargetFileName)" BuildAssemblyPath="$(IntermediateOutputPath)" References="@(ReferencePath)" ShouldGenerateSerializer="$(SGenShouldGenerateSerializer)" UseProxyTypes="$(SGenUseProxyTypes)" UseKeep="$(SGenUseKeep)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" ToolPath="$(SGenToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(SGenEnvironment)" MSBuildArchitecture="$(SGenMSBuildArchitecture)" SerializationAssembly="$(IntermediateOutputPath)$(_SGenDllName)" Platform="$(SGenPlatformTarget)" Types="$(SGenSerializationTypes)">
      <Output TaskParameter="SerializationAssembly" ItemName="SerializationAssembly" />
    </SGen>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                CreateSatelliteAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CreateSatelliteAssemblies

    Create one satellite assembly for every unique culture in the resources.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CreateSatelliteAssembliesDependsOn>
      $(CreateSatelliteAssembliesDependsOn);
      _GenerateSatelliteAssemblyInputs;
      ComputeIntermediateSatelliteAssemblies;
      GenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="CreateSatelliteAssemblies" DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _GenerateSatelliteAssemblyInputs

    Create the _SatelliteAssemblyResourceInputs list of inputs to the CreateSatelliteAssemblies target.
    ============================================================
    -->
  <Target Name="_GenerateSatelliteAssemblyInputs" xmlns="">
    <MSBuildInternalMessage Condition="'@(ManifestResourceWithCulture)'!='' and '%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9006;ManifestResourceWithCulture;true;Resx" />
    <MSBuildInternalMessage Condition="'@(ManifestNonResxWithCultureOnDisk)'!='' and '%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9007;ManifestNonResxWithCultureOnDisk;true;Non-Resx" />
    <ItemGroup>
      <!-- _SatelliteAssemblyResourceInputs is the list of TLDA inputs that should trigger CreateSatelliteAssemblies, so listed as inputs to that target -->
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_SatelliteAssemblyResourceInputs Include="@(ManifestResourceWithCulture)" Condition="'%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
      <_SatelliteAssemblyResourceInputs Include="@(ManifestNonResxWithCultureOnDisk)" Condition="'%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSatelliteAssemblies

    Actually run al.exe to create the satellite assemblies.
    ============================================================
    -->
  <Target Name="GenerateSatelliteAssemblies" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != '' and '$(GenerateSatelliteAssembliesForCore)' != 'true'" xmlns="">
    <PropertyGroup>
      <_ALExeToolPath Condition="'$(_ALExeToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</_ALExeToolPath>
    </PropertyGroup>
    <MakeDir Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />
    <AL AlgorithmId="$(Satellite_AlgorithmId)" BaseAddress="$(Satellite_BaseAddress)" CompanyName="$(Satellite_CompanyName)" Configuration="$(Satellite_Configuration)" Copyright="$(Satellite_Copyright)" Culture="%(Culture)" DelaySign="$(DelaySign)" Description="$(Satellite_Description)" EmbedResources="@(_SatelliteAssemblyResourceInputs)" EnvironmentVariables="$(AlEnvironment)" EvidenceFile="$(Satellite_EvidenceFile)" FileVersion="$(Satellite_FileVersion)" Flags="$(Satellite_Flags)" GenerateFullPaths="$(Satellite_GenerateFullPaths)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LinkResources="@(Satellite_LinkResource)" MainEntryPoint="$(Satellite_MainEntryPoint)" OutputAssembly="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Platform="$(PlatformTarget)" ProductName="$(Satellite_ProductName)" ProductVersion="$(Satellite_ProductVersion)" ResponseFiles="@(AlResponseFile)" SourceModules="@(Satellite_SourceModule)" TargetType="$(Satellite_TargetType)" TemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Title="$(Satellite_Title)" ToolPath="$(AlToolPath)" ToolExe="$(AlToolExe)" SdkToolsPath="$(_ALExeToolPath)" Trademark="$(Satellite_Trademark)" Version="$(Satellite_Version)" Win32Icon="$(Satellite_Win32Icon)" Win32Resource="$(Satellite_Win32Resource)">
      <Output TaskParameter="OutputAssembly" ItemName="FileWrites" />
    </AL>
  </Target>
  <!--
    ============================================================
                                        ComputeIntermediateSatelliteAssemblies

    Compute the paths to the intermediate satellite assemblies,
    with culture attributes so we can copy them to the right place.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ComputeIntermediateSatelliteAssembliesDependsOn>
      CreateManifestResourceNames
    </ComputeIntermediateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="ComputeIntermediateSatelliteAssemblies" Condition="@(EmbeddedResource->'%(WithCulture)') != ''" DependsOnTargets="$(ComputeIntermediateSatelliteAssembliesDependsOn)" xmlns="">
    <ItemGroup>
      <IntermediateSatelliteAssembliesWithTargetPath Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.Culture)' != ''">
        <Culture>%(EmbeddedResource.Culture)</Culture>
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
      </IntermediateSatelliteAssembliesWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                SetWin32ManifestProperties Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <EmbeddedWin32Manifest>$(Win32Manifest)</EmbeddedWin32Manifest>
  </PropertyGroup>
  <!--
    ============================================================
                                        SetWin32ManifestProperties

    Set Win32Manifest and EmbeddedManifest properties to be used later in the build.
    ============================================================
    -->
  <Target Name="SetWin32ManifestProperties" Condition="'$(Win32Manifest)'==''" DependsOnTargets="ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetEmbeddedWin32ManifestProperties" xmlns="" />
  <Target Name="_SetExternalWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!=''" xmlns="">
    <PropertyGroup>
      <!-- set _DeploymentBaseManifest property to the value of $(ApplicationManifest) if the property is set,
                 but use _DeploymentBaseManifestWithTargetPath item-group if the property is not set to support backwards
                 compat with earlier MSBuild versions when manifest files were determined by the item-group. If the newer
                 property is set though, prefer that one be used to specify the manifest. -->
      <_DeploymentBaseManifest>$(ApplicationManifest)</_DeploymentBaseManifest>
      <_DeploymentBaseManifest Condition="'$(_DeploymentBaseManifest)'==''">@(_DeploymentBaseManifestWithTargetPath)</_DeploymentBaseManifest>
      <!-- when using external manifests, always set the NoWin32Manifest property to
                 true if there is no value set in the incoming project file so the
                 compilers that support manifest embedding know not to add
                 a manifest to their built assemblies -->
      <NoWin32Manifest Condition="'$(NoWin32Manifest)'==''">true</NoWin32Manifest>
    </PropertyGroup>
  </Target>
  <Target Name="_SetEmbeddedWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'!='true' and '@(NativeReference)'=='' and '@(ResolvedIsolatedComModules)'==''" xmlns="">
    <PropertyGroup>
      <EmbeddedWin32Manifest>$(ApplicationManifest)</EmbeddedWin32Manifest>
      <Win32Manifest>$(ApplicationManifest)</Win32Manifest>
    </PropertyGroup>
    <!-- If PreferNativeArm64 is enabled, it searches for the same default.win32manifest  -->
    <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true'">
      <Output TaskParameter="FrameworkVersion40Path" PropertyName="_FrameworkVersion40Path" />
    </GetFrameworkPath>
    <PropertyGroup>
      <EmbeddedWin32Manifest Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true' and Exists('$(_FrameworkVersion40Path)\default.win32manifest')">$(_FrameworkVersion40Path)\default.win32manifest</EmbeddedWin32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _SetPreferNativeArm64Win32ManifestProperties

    Populates Manifest with SupportedArchitectures and updates Win32Manifest property to be used later in the build.
    ============================================================
    -->
  <Target Name="_SetPreferNativeArm64Win32ManifestProperties" Condition=" '$(PreferNativeArm64)'=='true' and '$(NoWin32Manifest)'!='true'" DependsOnTargets="SetWin32ManifestProperties" xmlns="">
    <AddToWin32Manifest ApplicationManifest="$(Win32Manifest)" OutputDirectory="$(IntermediateOutputPath)" SupportedArchitectures="$(_SupportedArchitectures)">
      <Output TaskParameter="ManifestPath" PropertyName="_Win32Manifest" />
    </AddToWin32Manifest>
    <PropertyGroup>
      <Win32Manifest Condition="'$(_Win32Manifest)' != ''">$(_Win32Manifest)</Win32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateManifests Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        GenerateManifests

    Generates ClickOnce application and deployment manifests or a native manifest.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <GenerateManifestsDependsOn>
      SetWin32ManifestProperties;
      GenerateApplicationManifest;
      GenerateDeploymentManifest
    </GenerateManifestsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                  _GenerateResolvedDeploymentManifestEntryPoint

    Use the ResolveManifestFiles to generate the GenerateResolvedDeploymentManifestEntryPoint

    ============================================================
    -->
  <Target Name="_GenerateResolvedDeploymentManifestEntryPoint" xmlns="">
    <ItemGroup>
      <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'" />
    </ItemGroup>
    <ResolveManifestFiles TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" SigningManifests="$(SignManifests)" DeploymentManifestEntryPoint="@(ApplicationManifest)" PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
      <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint" />
    </ResolveManifestFiles>
  </Target>
  <Target Name="GenerateManifests" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!='' or '$(GenerateAppxManifest)' == 'true'" DependsOnTargets="$(GenerateManifestsDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        GenerateApplicationManifest

    Generates a ClickOnce or native application manifest.
    An application manifest specifies declarative application identity, dependency and security information.

        [IN]
        $(_DeploymentBaseManifest) - The base app.manifest from project.
        @(ResolvedIsolatedComModules) - The list of COM references to be isolated as reg-free COM dependencies for native assembly loader.
        @(_DeploymentManifestFiles) - The list of loose files (content, pdb, xml, etc.) for ClickOnce.
        @(_DeploymentManifestDependencies) - The list of application dependencies (typically this is the set of assembly dependencies in bin\) for ClickOnce.
        @(AppConfigWithTargetPath) - App config file, if present.
        $(_DeploymentManifestType) - Type of manifest to be generated, either "Native" or "ClickOnce".

        [OUT]
        @(ApplicationManifest) - Generated native or ClickOnce application manifest, i.e. WindowsApplication1.exe.manifest
    ============================================================
    -->
  <Target Name="GenerateApplicationManifest" DependsOnTargets="&#xD;&#xA;            _DeploymentSetClickOnceVersions;&#xD;&#xA;            _DeploymentGenerateLauncher;&#xD;&#xA;            _DeploymentComputeNativeManifestInfo;&#xD;&#xA;            _DeploymentComputeClickOnceManifestInfo;&#xD;&#xA;            ResolveComReferences;&#xD;&#xA;            ResolveNativeReferences;&#xD;&#xA;            _GenerateResolvedDeploymentManifestEntryPoint" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            @(AppConfigWithTargetPath);&#xD;&#xA;            $(_DeploymentBaseManifest);&#xD;&#xA;            @(ResolvedIsolatedComModules);&#xD;&#xA;            @(_DeploymentManifestDependencies);&#xD;&#xA;            @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;            @(_DeploymentManifestFiles)" Outputs="@(ApplicationManifest)" xmlns="">
    <RequiresFramework35SP1Assembly ReferencedAssemblies="@(Reference)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" TargetFrameworkVersion="$(TargetFrameworkVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" SigningManifests="$(SignManifests)" Assemblies="@(_DeploymentManifestDependencies)" DeploymentManifestEntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" Files="@(_DeploymentManifestFiles)" SuiteName="$(SuiteName)">
      <Output TaskParameter="RequiresMinimumFramework35SP1" PropertyName="_DeploymentRequiresMinimumFramework35SP1" />
    </RequiresFramework35SP1Assembly>
    <GenerateApplicationManifest AssemblyName="$(_DeploymentApplicationManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" ConfigFile="@(AppConfigWithTargetPath)" ClrVersion="$(ClrVersion)" Dependencies="@(_DeploymentManifestDependencies)" Description="$(Description)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" FileAssociations="@(FileAssociation)" Files="@(_DeploymentManifestFiles)" HostInBrowser="$(HostInBrowser)" IconFile="@(_DeploymentManifestIconFile)" InputManifest="$(_DeploymentBaseManifest)" IsolatedComReferences="@(ResolvedIsolatedComModules)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" ManifestType="$(_DeploymentManifestType)" MaxTargetPath="$(MaxTargetPath)" OutputManifest="@(ApplicationManifest)" OSVersion="$(OSVersion)" Platform="$(_DeploymentPlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkSubset="$(TargetFrameworkSubset)" TargetFrameworkProfile="$(TargetFrameworkProfile)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)" UseApplicationTrust="$(UseApplicationTrust)">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateApplicationManifest>
    <AddToWin32Manifest Condition="'$(PreferNativeArm64)'=='true'" ApplicationManifest="@(ApplicationManifest)" OutputDirectory="$(IntermediateOutputPath)" SupportedArchitectures="$(_SupportedArchitectures)" />
    <PropertyGroup>
      <_DeploymentCopyApplicationManifest>true</_DeploymentCopyApplicationManifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentSetClickOnceVersions

    Sets ClickOnce versions
    ============================================================
    -->
  <Target Name="_DeploymentSetClickOnceVersions" Condition="'$(GenerateClickOnceManifests)'=='true'" xmlns="">
    <PropertyGroup>
      <_DeploymentManifestTargetFrameworkMoniker>$(TargetFrameworkMoniker)</_DeploymentManifestTargetFrameworkMoniker>
      <_DeploymentManifestTargetFrameworkVersion>$(TargetFrameworkVersion)</_DeploymentManifestTargetFrameworkVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateLauncher

    Generates Launcher if needed
    ============================================================
    -->
  <Target Name="_DeploymentGenerateLauncher" Condition="'$(GenerateClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true'" xmlns="">
    <!--
      If apphost based built EXE is found, use that as the Launcher.exe's entry point otherwise
      use the built DLL as the entry point
    -->
    <ItemGroup Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')">
      <EntryPointForLauncher Include="$(AppHostIntermediatePath)" TargetPath="$(AssemblyName).exe" />
      <ContentWithTargetPath Include="@(EntryPointForLauncher)" />
    </ItemGroup>
    <ItemGroup Condition="'$(EntryPointForLauncher)'==''">
      <EntryPointForLauncher Include="$(_DeploymentManifestEntryPoint)" />
    </ItemGroup>
    <!-- Generates Launcher and obtains its Framework version and moniker -->
    <GenerateLauncher AssemblyName="$(_DeploymentApplicationManifestIdentity)" EntryPoint="@(EntryPointForLauncher)" OutputPath="$(IntermediateOutputPath)" VisualStudioVersion="$(VisualStudioVersion)">
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentManifestLauncherEntryPoint" />
    </GenerateLauncher>
    <!--
      .NET Core ClickOnce deployments use Launcher, which targets .NET FX 4.5 as the minimum
      supported ClickOnce runtime version on target user's machine.

      TargetFramework Verion and Moniker properties are used in Deployment manifest generation
      task to set compatibleFrameworks element, which needs to match Launcher's target version.

      Version can be overriden with DeploymentManifestTargetFrameworkVersionOverride property.
    -->
    <PropertyGroup>
      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' == ''">v4.5</_DeploymentManifestTargetFrameworkVersion>
      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' != ''">$(DeploymentManifestTargetFrameworkVersionOverride)</_DeploymentManifestTargetFrameworkVersion>
      <_DeploymentManifestTargetFrameworkMoniker>.NETFramework,Version=$(_DeploymentManifestTargetFrameworkVersion)</_DeploymentManifestTargetFrameworkMoniker>
    </PropertyGroup>
    <!-- Sign Launcher EXE -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentManifestLauncherEntryPoint)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Sign the original ClickOnce entrypoint -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentManifestEntryPoint)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Sign apphost.exe if it's the entrypoint for the Launcher.exe. This is the case in loose file publish -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(AppHostIntermediatePath)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(UseAppHost)' == 'true' and '$(PublishSingleFile)' != 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')" />
    <!--
      Replace entry-point with Launcher and move original project's entry-point to content group.
    -->
    <ItemGroup>
      <ContentWithTargetPath Include="@(_DeploymentManifestEntryPoint)" />
      <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)" />
      <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeNativeManifestInfo

    Compute info for native manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeNativeManifestInfo" Condition="'$(GenerateClickOnceManifests)'!='true'" xmlns="">
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies" />
    </ResolveManifestFiles>
    <PropertyGroup>
      <_DeploymentManifestType>Native</_DeploymentManifestType>
    </PropertyGroup>
    <!-- Obtain manifest version from the built assembly -->
    <GetAssemblyIdentity AssemblyFiles="@(IntermediateAssembly)">
      <Output TaskParameter="Assemblies" ItemName="_IntermediateAssemblyIdentity" />
    </GetAssemblyIdentity>
    <PropertyGroup>
      <_DeploymentManifestVersion>@(_IntermediateAssemblyIdentity->'%(Version)')</_DeploymentManifestVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeClickOnceManifestInfo

    Compute info for  ClickOnce manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeClickOnceManifestInfo" Condition="'$(GenerateClickOnceManifests)'=='true'" DependsOnTargets="$(DeploymentComputeClickOnceManifestInfoDependsOn)" xmlns="">
    <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
    <ItemGroup>
      <_SGenDllsRelatedToCurrentDll Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
      <_SGenDllsRelatedToCurrentDll Include="@(SerializationAssembly->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <ItemGroup Condition="!exists('$(ProjectLockFile)')">
      <_CopyLocalFalseRefPaths Include="@(ReferencePath)" Condition="'%(CopyLocal)' == 'false'" />
      <_CopyLocalFalseRefPathsWithExclusion Include="@(_CopyLocalFalseRefPaths)" Exclude="@(ReferenceCopyLocalPaths);@(_NETStandardLibraryNETFrameworkLib)" />
    </ItemGroup>
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <_ClickOnceSatelliteAssemblies Include="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" />
    </ItemGroup>
    <!-- Flag primary dependencies-certain warnings emitted during application manifest generation apply only to them. -->
    <ItemGroup>
      <_DeploymentReferencePaths Include="@(ReferenceCopyLocalPaths)" Condition="('%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md') and ('%(ReferenceCopyLocalPaths.CopyToPublishDirectory)' != 'false')">
        <IsPrimary>true</IsPrimary>
      </_DeploymentReferencePaths>
      <_DeploymentReferencePaths Include="@(_CopyLocalFalseRefPathsWithExclusion)" />
    </ItemGroup>
    <!-- Include managed references in clickonce manifest only if single file publish is false -->
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <_ManifestManagedReferences Include="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly);@(ReferenceCOMWrappersToCopyLocal)" Exclude="@(_ClickOnceSatelliteAssemblies);@(_ReferenceScatterPaths);@(_ExcludedAssembliesFromManifestGeneration)" />
    </ItemGroup>
    <!-- Include the following files in clickonce manifest only if single file publish is false -->
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <!--
      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in
      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems
      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the
      ResolvePackageAssets target in dotnet/sdk
      -->
      <_ClickOnceRuntimeCopyLocalItems Include="@(RuntimeTargetsCopyLocalItems)" Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
      <!--
        For .NET>=5, we need to check if we need to publish any content items from transitive project references. For such items to be published, they
        either have the .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
      -->
      <_ClickOnceTransitiveContentItemsTemp Include="@(_TransitiveItemsToCopyToOutputDirectory-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never')-&gt;'%(TargetPath)')" Condition="'$(PublishProtocol)' == 'ClickOnce'">
        <SavedIdentity>%(Identity)</SavedIdentity>
      </_ClickOnceTransitiveContentItemsTemp>
      <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
      <!--
        ClickOnce content items is union of transitive content items and content items from this project.
        We also exclude content items from this project that have set CopyToPublishDirectory to Never.
      -->
      <_ClickOnceContentItems Include="@(ContentWithTargetPath-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never'))" />
      <_ClickOnceContentItems Include="@(_ClickOnceTransitiveContentItems)" />
      <!--
        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either
        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
      -->
      <!-- Include items from None group for publishing -->
      <_ClickOnceNoneItemsTemp Include="@(_NoneWithTargetPath-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never')-&gt;'%(TargetPath)')" Condition="'$(PublishProtocol)'=='Clickonce' And ('%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent')">
        <SavedIdentity>%(Identity)</SavedIdentity>
      </_ClickOnceNoneItemsTemp>
      <_ClickOnceNoneItems Include="@(_ClickOnceNoneItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
      <_ClickOnceFiles Include="@(_ClickOnceContentItems);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems)" />
      <!-- clear temporary item groups to free memory -->
      <_ClickOnceNoneItemsTemp Remove="@(_ClickOnceNoneItemsTemp)" />
      <_ClickOnceNoneItems Remove="@(_ClickOnceNoneItems)" />
      <_ClickOnceTransitiveContentItemsTemp Remove="@(_ClickOnceTransitiveContentItemsTemp)" />
      <_ClickOnceTransitiveContentItems Remove="@(_ClickOnceTransitiveContentItems)" />
      <_ClickOnceContentItems Remove="@(_ClickOnceContentItems)" />
      <_ClickOnceRuntimeCopyLocalItems Remove="@(_ClickOnceRuntimeCopyLocalItems)" />
    </ItemGroup>
    <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
      <_ClickOnceFiles Include="$(PublishedSingleFilePath);@(_DeploymentManifestIconFile)" />
      <_ClickOnceFiles Include="@(_FilesExcludedFromBundle)" />
      <!-- Include file association icons from Content as loose files -->
      <_FileAssociationIcons Include="%(FileAssociation.DefaultIcon)" />
      <_ClickOnceFiles Include="@(ContentWithTargetPath)" Condition="'%(Identity)'=='@(_FileAssociationIcons)'" />
    </ItemGroup>
    <!-- For single file publish in .net core app, sign the SF EXE if signing is enabled -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(PublishedSingleFilePath)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true' and '$(PublishSingleFile)' == 'true'" />
    <!--
    If ReadyToRun is enabled in loose files scenario, we need to remove entries of the IL images that have gone through R2R
    compiler and replace them with the entries for their R2R images. The R2R application image also needs to be signed if necessary.
    -->
    <ItemGroup Condition="'$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'">
      <_ManifestManagedReferences Remove="@(_ReadyToRunCompileList)" />
      <_ClickOnceFiles Remove="@(_ReadyToRunCompileList)" />
      <_ClickOnceFiles Include="@(_ReadyToRunFilesToPublish)" />
      <_ClickOnceTargetFile Include="@(_ReadyToRunFilesToPublish)" Condition="'%(Filename)%(Extension)' == '$(TargetFileName)'" />
    </ItemGroup>
    <!-- Sign application image created by R2R -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_ClickOnceTargetFile)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)' == 'true' and '$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'" />
    <!-- Copy the application executable from Obj folder to app.publish folder.
    This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
    <Copy SourceFiles="@(_DeploymentManifestEntryPoint)" DestinationFolder="$(ClickOncePublishDir)">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentClickOnceApplicationExecutable" />
    </Copy>
    <!-- Sign the application executable located in app.publish folder.  Signing this file is done to comply with SmartScreen. -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentClickOnceApplicationExecutable)" Condition="'$(_DeploymentResolvedManifestCertificateThumbprint)'!='' and '$(_DeploymentSignClickOnceManifests)'=='true' and '$(TargetExt)' == '.exe'" />
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles AssemblyName="$(_DeploymentApplicationManifestIdentity)" EntryPoint="@(_DeploymentClickOnceApplicationExecutable)" ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)" Files="@(_ClickOnceFiles)" IsSelfContainedPublish="$(SelfContained)" IsSingleFilePublish="$(PublishSingleFile)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" ManagedAssemblies="@(_ManifestManagedReferences)" NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)" PublishFiles="@(PublishFile)" RuntimePackAssets="@(RuntimePackAsset)" SatelliteAssemblies="@(_ClickOnceSatelliteAssemblies)" SigningManifests="$(SignManifests)" TargetCulture="$(TargetCulture)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependenciesUnfiltered" />
      <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles" />
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentResolvedManifestEntryPoint" />
    </ResolveManifestFiles>
    <!-- We have to filter items out of the dependencies that have neither CopyLocal set to true, -->
    <!-- nor the dependency type manually set to 'Install'.                                       -->
    <ItemGroup>
      <_DeploymentManifestDependencies Include="@(_DeploymentManifestDependenciesUnfiltered)" Condition="!('%(_DeploymentManifestDependenciesUnfiltered.CopyLocal)' == 'false' And '%(_DeploymentManifestDependenciesUnfiltered.DependencyType)' != 'Install')" />
    </ItemGroup>
    <PropertyGroup>
      <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
    </PropertyGroup>
    <!--
      Manifest platform should always be MSIL for Launcher-based deployments, as the Launcher is MSIL.
      Do not set _DeploymentPlatformTarget property in Launcher case - this is interpreted as MSIL,
      by GenerateApplicationManifest and GenerateDeploymentManifest tasks.
      Otherwise, set it to PlatformTarget.
    -->
    <PropertyGroup>
      <_DeploymentPlatformTarget Condition="'$(_DeploymentLauncherBased)' != 'true'">$(PlatformTarget)</_DeploymentPlatformTarget>
    </PropertyGroup>
    <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion" />
    </FormatVersion>
    <FormatUrl InputUrl="$(_DeploymentUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedDeploymentUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(SupportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedSupportUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(ErrorReportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedErrorReportUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateTrustInfo

    Generates the application permission set for inclusion in the generated ClickOnce application manifest.
    ============================================================
    -->
  <Target Name="_DeploymentGenerateTrustInfo" Condition="'$(TargetZone)'!=''" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            $(_DeploymentBaseManifest);&#xD;&#xA;            " Outputs="@(_DeploymentIntermediateTrustInfoFile)" xmlns="">
    <GenerateTrustInfo BaseManifest="$(_DeploymentBaseManifest)" ApplicationDependencies="@(ReferencePath);@(ReferenceDependencyPaths)" ExcludedPermissions="$(ExcludedPermissions)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetZone="$(TargetZone)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)">
      <Output TaskParameter="TrustInfoFile" ItemName="FileWrites" />
    </GenerateTrustInfo>
  </Target>
  <!--
    ============================================================
                                        GenerateDeploymentManifest

    Generates a ClickOnce deployment manifest.
    An deployment manifest specifies declarative application identity and application update information.
    ============================================================
    -->
  <Target Name="GenerateDeploymentManifest" DependsOnTargets="GenerateApplicationManifest" Inputs="&#xD;&#xA;            $(MSBuildAllProjects);&#xD;&#xA;            @(ApplicationManifest)&#xD;&#xA;            " Outputs="@(DeployManifest)" xmlns="">
    <GenerateDeploymentManifest AssemblyName="$(_DeploymentDeployManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" DeploymentUrl="$(_DeploymentFormattedDeploymentUrl)" Description="$(Description)" DisallowUrlActivation="$(DisallowUrlActivation)" EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" Install="$(Install)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" MapFileExtensions="$(MapFileExtensions)" MaxTargetPath="$(MaxTargetPath)" MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)" OutputManifest="@(DeployManifest)" Platform="$(_DeploymentPlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" TargetFrameworkMoniker="$(_DeploymentManifestTargetFrameworkMoniker)" TrustUrlParameters="$(TrustUrlParameters)" UpdateEnabled="$(UpdateEnabled)" UpdateInterval="$(_DeploymentBuiltUpdateInterval)" UpdateMode="$(UpdateMode)" UpdateUnit="$(_DeploymentBuiltUpdateIntervalUnits)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateDeploymentManifest>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForRun Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <SkipCopyUnchangedFiles Condition="'$(SkipCopyUnchangedFiles)' == ''">true</SkipCopyUnchangedFiles>
    <UseCommonOutputDirectory Condition="'$(UseCommonOutputDirectory)' == ''">false</UseCommonOutputDirectory>
  </PropertyGroup>
  <!--
    ============================================================
                                        PrepareForRun

    Copy the build outputs to the final directory if they have changed.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PrepareForRunDependsOn>
      CopyFilesToOutputDirectory
    </PrepareForRunDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForRun" DependsOnTargets="$(PrepareForRunDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        CopyFilesToOutputDirectory

    Copy all build outputs, satellites and other necessary files to the final directory.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <!-- By default we're not using Hard or Symbolic Links to copy to the output directory, and never when building in VS -->
    <CreateHardLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateHardLinksForCopyAdditionalFilesIfPossible>
    <CreateSymbolicLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateSymbolicLinksForCopyAdditionalFilesIfPossible>
  </PropertyGroup>
  <Target Name="CopyFilesToOutputDirectory" DependsOnTargets="&#xD;&#xA;            ComputeIntermediateSatelliteAssemblies;&#xD;&#xA;            _CopyFilesMarkedCopyLocal;&#xD;&#xA;            _CopySourceItemsToOutputDirectory;&#xD;&#xA;            _CopyAppConfigFile;&#xD;&#xA;            _CopyManifestFiles;&#xD;&#xA;            _CheckForCompileOutputs;&#xD;&#xA;            _SGenCheckForOutputs" xmlns="">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
      <CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible>
      <ErrorIfLinkFailsForCopyFilesToOutputDirectory Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)' == ''">false</ErrorIfLinkFailsForCopyFilesToOutputDirectory>
    </PropertyGroup>
    <PropertyGroup>
      <CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)'==''">true</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)'==''">true</CopyOutputSymbolsToOutputDirectory>
      <CopyDocumentationFileToOutputDirectory Condition="'$(CopyDocumentationFileToOutputDirectory)'==''">true</CopyDocumentationFileToOutputDirectory>
    </PropertyGroup>
    <!-- Copy the build product (.dll or .exe). -->
    <Copy SourceFiles="@(IntermediateAssembly)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="MainAssembly" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the reference assembly build product (.dll or .exe). -->
    <CopyRefAssembly SourcePath="@(IntermediateRefAssembly)" DestinationPath="$(TargetRefPath)" Condition="'$(ProduceReferenceAssembly)' == 'true' and '$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationPath" ItemName="ReferenceAssembly" />
      <Output TaskParameter="DestinationPath" ItemName="FileWrites" />
    </CopyRefAssembly>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(MainAssembly->'%(FullPath)')" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)'!='true'" />
    <!-- Copy the additional modules. -->
    <Copy SourceFiles="@(AddModules)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)" Condition="'@(AddModules)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the serialization assembly if it exists. -->
    <Copy SourceFiles="$(IntermediateOutputPath)$(_SGenDllName)" DestinationFiles="$(OutDir)$(_SGenDllName)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_SGenDllCreated)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the debug information file (.pdb), if any -->
    <Copy SourceFiles="@(_DebugSymbolsIntermediatePath)" DestinationFiles="@(_DebugSymbolsOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true' and '$(CopyOutputSymbolsToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the resulting XML documentation file, if any. -->
    <Copy SourceFiles="@(DocFileItem)" DestinationFiles="@(FinalDocFile)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_DocumentationFileProduced)'=='true' and '$(CopyDocumentationFileToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy satellite assemblies. -->
    <Copy SourceFiles="@(IntermediateSatelliteAssembliesWithTargetPath)" DestinationFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(OutDir)%(Culture)\$(TargetName).resources.dll')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'@(IntermediateSatelliteAssembliesWithTargetPath)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!--
        Copy COM reference wrappers, isolated COM references, COM references included by
        native (manifest) references, native (manifest) reference files themselves.
        -->
    <Copy SourceFiles="@(ReferenceComWrappersToCopyLocal); @(ResolvedIsolatedComModules); @(_DeploymentLooseManifestFile); @(NativeReferenceFile)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)" Condition="'@(ReferenceComWrappersToCopyLocal)' != '' or '@(ResolvedIsolatedComModules)' != '' or '@(_DeploymentLooseManifestFile)' != '' or '@(NativeReferenceFile)' != '' ">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
    </Copy>
    <!-- Copy the build product of WinMDExp. -->
    <Copy SourceFiles="@(WinMDExpArtifacts)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '@(WinMDExpArtifacts)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
      <Output TaskParameter="DestinationFiles" ItemName="FinalWinmdExpArtifacts" />
    </Copy>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
  </Target>
  <!--
    ============================================================
                                        _CopyFilesMarkedCopyLocal

    Copy references that are marked as "CopyLocal" and their dependencies, including .pdbs, .xmls and satellites.
    ============================================================
    -->
  <Target Name="_CopyFilesMarkedCopyLocal" Condition="'@(ReferenceCopyLocalPaths)' != ''" xmlns="">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyLocalIfPossible)' == ''">false</CreateHardLinksForCopyLocalIfPossible>
      <CreateSymbolicLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyLocalIfPossible)' == ''">false</CreateSymbolicLinksForCopyLocalIfPossible>
    </PropertyGroup>
    <Copy SourceFiles="@(ReferenceCopyLocalPaths)" DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyLocalIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyLocalIfPossible)" Condition="'$(UseCommonOutputDirectory)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
      <Output TaskParameter="CopiedFiles" ItemName="ReferencesCopiedInThisBuild" />
      <Output TaskParameter="WroteAtLeastOneFile" PropertyName="WroteAtLeastOneFile" />
    </Copy>
    <!-- If this project produces reference assemblies *and* copied (possibly transitive)
         references on this build, subsequent builds of projects that depend on it must
         not be considered up to date, so touch this marker file that is considered an
         input to projects that reference this one. -->
    <Touch Files="@(CopyUpToDateMarker)" AlwaysCreate="true" Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'" />
    <ItemGroup>
      <FileWrites Include="@(CopyUpToDateMarker)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopySourceItemsToOutputDirectory
    ============================================================
    -->
  <Target Name="_CopySourceItemsToOutputDirectory" DependsOnTargets="&#xD;&#xA;            GetCopyToOutputDirectoryItems;&#xD;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectory;&#xD;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectoryAlways;&#xD;&#xA;            _CopyDifferingSourceItemsToOutputDirectory" xmlns="" />
  <!--
    ============================================================
                                        GetCopyToOutputDirectoryItems

    Get all project items that may need to be transferred to the output directory.
    This includes baggage items from transitively referenced projects.

    As of 17.0, content items are copied transitively by default.
    Set `MSBuildCopyContentTransitively` to false to opt out.
    See https://github.com/dotnet/msbuild/pull/6622 for more info.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <_TargetsThatPrepareProjectReferences>_SplitProjectReferencesByFileExistence</_TargetsThatPrepareProjectReferences>
    <!--
      GetCopyToOutputDirectoryItems depends on an unspecified dependency _SplitProjectReferencesByFileExistence -> AssignProjectConfiguration (https://github.com/dotnet/msbuild/issues/4677).
      When the unspecified dependency does not happen by accident, content copying is only 1 level deep instead of transitive.
      This target enforces the dependency.
    -->
    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
    <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </_TargetsThatPrepareProjectReferences>
    <GetCopyToOutputDirectoryItemsDependsOn>
      AssignTargetPaths;
      $(_TargetsThatPrepareProjectReferences);
      _GetProjectReferenceTargetFrameworkProperties;
      _PopulateCommonStateForGetCopyToOutputDirectoryItems
    </GetCopyToOutputDirectoryItemsDependsOn>
    <!--
      Mitigation for https://github.com/dotnet/msbuild/issues/4677
      When MSBuildCopyContentTransitively == true, all content copying is transitive.
      When MSBuildCopyContentTransitively == false, content copying is 1 level deep.
      When MSBuildCopyContentTransitively != {true, false}, the legacy behaviour in https://github.com/dotnet/msbuild/issues/4677 manifests.
     -->
    <_RecursiveTargetForContentCopying>GetCopyToOutputDirectoryItems</_RecursiveTargetForContentCopying>
    <!-- Enforce 1 level deep content copying by replacing the recursive content target with the target that retrieves the content for the current project only. -->
    <_RecursiveTargetForContentCopying Condition=" '$(MSBuildCopyContentTransitively)' == 'false' ">_GetCopyToOutputDirectoryItemsFromThisProject</_RecursiveTargetForContentCopying>
  </PropertyGroup>
  <Target Name="_PopulateCommonStateForGetCopyToOutputDirectoryItems" xmlns="">
    <!-- In the general case, clients need very little of the metadata which is generated by invoking this target on this project and its children.  For those
         cases, we can immediately discard the unwanted metadata, reducing memory usage, particularly in very large and interconnected systems of projects.
         However, if some client does require the original functionality, it is sufficient to set MSBuildDisableGetCopyToOutputDirectoryItemsOptimization to
         a non-empty value and the original behavior will be restored. -->
    <PropertyGroup Condition=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' ">
      <_GCTODIKeepDuplicates>false</_GCTODIKeepDuplicates>
      <_GCTODIKeepMetadata>CopyToOutputDirectory;TargetPath</_GCTODIKeepMetadata>
    </PropertyGroup>
  </Target>
  <Target Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences" DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove" Returns="@(_CopyToOutputDirectoryTransitiveItems)" xmlns="">
    <!-- Get items from child projects first. -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="$(_RecursiveTargetForContentCopying)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false' and '$(UseCommonOutputDirectory)' != 'true'" ContinueOnError="$(ContinueOnError)" SkipNonexistentTargets="true" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectItemsWithTargetPath" />
    </MSBuild>
    <!-- Target outputs must be full paths because they will be consumed by a different project. -->
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Remove="@(_AllChildProjectItemsWithTargetPath)" />
    </ItemGroup>
    <!-- Copy paste _GetCopyToOutputDirectoryItemsFromThisProject but keep the items that came from other projects via ProjectReference's OutputItemType metadata -->
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='IfDifferent' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="('%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest' or '%(Compile.CopyToOutputDirectory)'=='IfDifferent') AND '%(Compile.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
  </Target>
  <Target Name="_GetCopyToOutputDirectoryItemsFromThisProject" DependsOnTargets="AssignTargetPaths;_PopulateCommonStateForGetCopyToOutputDirectoryItems" Returns="@(_ThisProjectItemsToCopyToOutputDirectory)" xmlns="">
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='IfDifferent' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="('%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest' or '%(Compile.CopyToOutputDirectory)'=='IfDifferent') AND '%(Compile.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
  </Target>
  <Target Name="GetCopyToOutputDirectoryItems" Returns="@(AllItemsFullPathWithTargetPath)" KeepDuplicateOutputs=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' " DependsOnTargets="$(GetCopyToOutputDirectoryItemsDependsOn)" xmlns="">
    <!-- Compose the content items as the union between transitive content items and content items from this project. -->
    <!-- Use CallTarget to avoid breaking targets that hook right before GetCopyToOutputDirectoryItems but expect to run after _GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences and _GetCopyToOutputDirectoryItemsFromThisProject -->
    <CallTarget Targets="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences">
      <Output TaskParameter="TargetOutputs" ItemName="_TransitiveItemsToCopyToOutputDirectory" />
    </CallTarget>
    <CallTarget Targets="_GetCopyToOutputDirectoryItemsFromThisProject">
      <Output TaskParameter="TargetOutputs" ItemName="_ThisProjectItemsToCopyToOutputDirectory" />
    </CallTarget>
    <ItemGroup Condition="'$(CopyConflictingTransitiveContent)' == 'false'">
      <_TransitiveItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" MatchOnMetadata="TargetPath" MatchOnMetadataOptions="PathLike" />
    </ItemGroup>
    <ItemGroup>
      <_TransitiveItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'" />
      <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_TransitiveItemsToCopyToOutputDirectoryIfDifferent KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='IfDifferent'" />
      <_ThisProjectItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'" />
      <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_ThisProjectItemsToCopyToOutputDirectoryIfDifferent KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='IfDifferent'" />
      <!-- Append the items from this project last so that they will be copied last. -->
      <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_TransitiveItemsToCopyToOutputDirectoryAlways);@(_ThisProjectItemsToCopyToOutputDirectoryAlways)" />
      <_SourceItemsToCopyToOutputDirectory Include="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest);@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_SourceItemsToCopyToOutputDirectoryIfDifferent Include="@(_TransitiveItemsToCopyToOutputDirectoryIfDifferent);@(_ThisProjectItemsToCopyToOutputDirectoryIfDifferent)" />
      <AllItemsFullPathWithTargetPath Include="@(_SourceItemsToCopyToOutputDirectoryAlways->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectory->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectoryIfDifferent->'%(FullPath)')" />
      <!-- Empty intermediate items to release memory -->
      <_TransitiveItemsToCopyToOutputDirectoryAlways Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)" />
      <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_TransitiveItemsToCopyToOutputDirectoryIfDifferent Remove="@(_TransitiveItemsToCopyToOutputDirectoryIfDifferent)" />
      <_ThisProjectItemsToCopyToOutputDirectoryAlways Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)" />
      <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_ThisProjectItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" />
      <_ThisProjectItemsToCopyToOutputDirectoryIfDifferent Remove="@(_ThisProjectItemsToCopyToOutputDirectoryIfDifferent)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetCopyToPublishDirectoryItems

    Default implementation of GetCopyToPublishDirectoryItems for projects that do not
    use Microsoft.NET.Sdk. It simply returns whatever GetCopyToOutputDirectoryItems
    does with CopyToPublishDirectory implied  by CopyToOutputDirectory, which is the
    same as Microsoft.NET.Sdk default when its CopyToPublishDirectory is not used.

    Microsoft.NET.Sdk projects  will override this to allow the publish output to be
    customized independently from the build output.

    Having a default implementation here allows the Microsoft.NET.Sdk Publish target
    to work when a Microsoft.NET.Sdk-based project references a non-Microsoft.NET.Sdk-based
    project.
    ============================================================
    -->
  <Target Name="GetCopyToPublishDirectoryItems" DependsOnTargets="GetCopyToOutputDirectoryItems" Returns="@(AllPublishItemsFullPathWithTargetPath)" xmlns="">
    <ItemGroup>
      <AllPublishItemsFullPathWithTargetPath Include="@(AllItemsFullPathWithTargetPath)">
        <CopyToPublishDirectory>%(CopyToOutputDirectory)</CopyToPublishDirectory>
      </AllPublishItemsFullPathWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'PreserveNewest'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectory)' != '' " Inputs="@(_SourceItemsToCopyToOutputDirectory)" Outputs="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')" xmlns="">
    <!--
        Not using SkipUnchangedFiles="true" because the items we pass in are already only those that have newer timestampts in the source (determined by _GetCopyToOutputDirectoryItemsFromThisProject).
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectory)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectoryAlways

    Copy files that have the CopyToOutputDirectory attribute set to 'Always'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectoryAlways" Condition=" '@(_SourceItemsToCopyToOutputDirectoryAlways)' != '' " xmlns="">
    <!--
        Not using SkipUnchangedFiles="true" by default for backwards compatibility.
        -->
    <PropertyGroup>
      <SkipUnchangedFilesOnCopyAlways Condition="'$(SkipUnchangedFilesOnCopyAlways)' == ''">false</SkipUnchangedFilesOnCopyAlways>
    </PropertyGroup>
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryAlways)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')" SkipUnchangedFiles="$(SkipUnchangedFilesOnCopyAlways)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyDifferingSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'IfDifferent'.
    ============================================================
    -->
  <Target Name="_CopyDifferingSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectoryIfDifferent)' != '' " xmlns="">
    <!--
        Using SkipUnchangedFiles="true" because we want only differing files.
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryIfDifferent)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryIfDifferent->'$(OutDir)%(TargetPath)')" SkipUnchangedFiles="true" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyAppConfigFile

    Copy the application config file.
    ============================================================
    -->
  <Target Name="_CopyAppConfigFile" Condition=" '@(AppConfigWithTargetPath)' != '' " Inputs="@(AppConfigWithTargetPath)" Outputs="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')" xmlns="">
    <!--
        Copy the application's .config file, if any.
        Not using SkipUnchangedFiles="true" because the application may want to change
        the app.config and not have an incremental build replace it.
        -->
    <Copy SourceFiles="@(AppConfigWithTargetPath)" DestinationFiles="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ================================================================
                                         _CopyManifestFiles
    ================================================================

    Copy the built manifests (.exe.manifest, .application/.xbap) to the final directory.
    -->
  <Target Name="_CopyManifestFiles" Condition=" '$(_DeploymentCopyApplicationManifest)'=='true' or '$(GenerateClickOnceManifests)'=='true' " DependsOnTargets="PrepareForBuild" xmlns="">
    <Copy SourceFiles="@(ApplicationManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true' or '$(_DeploymentCopyApplicationManifest)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainApplicationManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(_DeploymentCopyApplicationManifest)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainApplicationManifest->'%(FullPath)')" />
    <Copy SourceFiles="@(DeployManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainDeployManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(GenerateClickOnceManifests)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainDeployManifest->'%(FullPath)')" />
  </Target>
  <!--
    ================================================================
                                         _CheckForCompileOutputs

    Checks each file output from the main "Compile" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_CheckForCompileOutputs" xmlns="">
    <!--Record the main compile outputs.-->
    <ItemGroup>
      <FileWrites Include="@(IntermediateAssembly)" Condition="Exists('@(IntermediateAssembly)')" />
      <FileWrites Include="@(IntermediateRefAssembly)" Condition="'$(ProduceReferenceAssembly)' == 'true' and Exists('@(IntermediateRefAssembly)')" />
    </ItemGroup>
    <!-- Record the .xml if one was produced. -->
    <PropertyGroup>
      <_DocumentationFileProduced Condition="!Exists('@(DocFileItem)')">false</_DocumentationFileProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(DocFileItem)" Condition="'$(_DocumentationFileProduced)'=='true'" />
    </ItemGroup>
    <!-- Record the .pdb if one was produced. -->
    <PropertyGroup>
      <_DebugSymbolsProduced Condition="!Exists('@(_DebugSymbolsIntermediatePath)')">false</_DebugSymbolsProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SGenCheckForOutputs

    Checks each file output from the "GenerateSerializationAssemblies" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_SGenCheckForOutputs" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" xmlns="">
    <!-- Record the serializer .dll if one was produced.-->
    <PropertyGroup>
      <_SGenDllCreated Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')">true</_SGenDllCreated>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(_SGenDllName)" Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedRegistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedRegistration

    Registers the main assembly for COM interop.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <UnmanagedRegistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedRegistration" Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'" DependsOnTargets="$(UnmanagedRegistrationDependsOn)" xmlns="">
    <PropertyGroup>
      <RegisterAssemblyMSBuildArchitecture Condition="'$(RegisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</RegisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(RegisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the
           corresponding comment in GenerateResource. -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == '' and&#xD;&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(RegisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</RegisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</RegisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <RegisterAssembly Assemblies="@(_OutputPathItem->'%(FullPath)$(TargetFileName)')" TypeLibFiles="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" AssemblyListFile="@(_UnmanagedRegistrationCache)" CreateCodeBase="true" MSBuildRuntime="$(RegisterAssemblyMSBuildRuntime)" MSBuildArchitecture="$(RegisterAssemblyMSBuildArchitecture)" Condition="!Exists('@(_UnmanagedRegistrationCache)')" />
    <ItemGroup>
      <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                IncrementalClean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        IncrementalClean

    Remove files that were produced in a prior build but weren't produced in the current build.
    The reason is that if, for example, the name of the .exe has changed we want to delete the
    old copy.

    Leave the Clean cache file containing only the files produced in the current build.
    ============================================================
    -->
  <Target Name="IncrementalClean" DependsOnTargets="$(IncrementalCleanDependsOn);_CleanGetCurrentAndPriorFileWrites" xmlns="">
    <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
    <ItemGroup>
      <_CleanOrphanFileWrites Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanCurrentFileWrites)" />
    </ItemGroup>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete the orphaned files. -->
    <Delete Files="@(_CleanOrphanFileWritesInIntermediate);@(_CleanOrphanFileWritesInOutput)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanOrphanFilesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted or was outside
             the current final output and intermediate output directories. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterIncrementalClean Include="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)" Exclude="@(_CleanOrphanFilesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterIncrementalClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWritesAfterIncrementalClean" />
    </RemoveDuplicates>
    <!-- Write new list of current files back to disk, replacing the existing list.-->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)" Condition="'@(_CleanUnfilteredPriorFileWrites)'!='@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)'" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanGetCurrentAndPriorFileWrites

    Get the list of files built in the current build and in prior builds.
    ============================================================
    -->
  <Target Name="_CleanGetCurrentAndPriorFileWrites" DependsOnTargets="_CheckForCompileOutputs;_SGenCheckForOutputs" xmlns="">
    <!-- Read the list of files produced by a prior builds from disk. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanUnfilteredPriorFileWrites" />
    </ReadLinesFromFile>
    <!--
        Convert the list of references to the absolute paths so we can make valid comparisons
        across two lists
         -->
    <ConvertToAbsolutePath Paths="@(_ResolveAssemblyReferenceResolvedFiles)">
      <Output TaskParameter="AbsolutePaths" ItemName="_ResolveAssemblyReferenceResolvedFilesAbsolute" />
    </ConvertToAbsolutePath>
    <!--
        Subtract any resolved assembly files from *prior* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.
         -->
    <ItemGroup>
      <_CleanPriorFileWrites Include="@(_CleanUnfilteredPriorFileWrites)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!--
        Of shareable files, keep only those that are in the project's directory.
        We never clean shareable files outside of the project directory because
        the build may be to a common output directory and other projects may need
        them.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
        -->
    <FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="FileWrites" />
    </FindUnderPath>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInIntermediate" />
    </FindUnderPath>
    <!--
        Subtract any resolved assembly files from *current* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
         -->
    <ItemGroup>
      <_CleanCurrentFileWritesWithNoReferences Include="@(_CleanCurrentFileWritesInOutput);@(_CleanCurrentFileWritesInIntermediate)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!-- Remove duplicates from files produced in this build. -->
    <RemoveDuplicates Inputs="@(_CleanCurrentFileWritesWithNoReferences)">
      <Output TaskParameter="Filtered" ItemName="_CleanCurrentFileWrites" />
    </RemoveDuplicates>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Clean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Clean

    Delete all intermediate and final build outputs.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CleanDependsOn>
      BeforeClean;
      UnmanagedUnregistration;
      CoreClean;
      CleanReferencedProjects;
      CleanPublishFolder;
      AfterClean
    </CleanDependsOn>
  </PropertyGroup>
  <Target Name="Clean" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(CleanDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforeClean

    Redefine this target in your project in order to run tasks just before Clean.
    ============================================================
    -->
  <Target Name="BeforeClean" xmlns="" />
  <!--
    ============================================================
                                        AfterClean

    Redefine this target in your project in order to run tasks just after Clean.
    ============================================================
    -->
  <Target Name="AfterClean" xmlns="" />
  <!--
    ============================================================
                                        CleanReferencedProjects

    Call Clean target on all Referenced Projects.
    ============================================================
    -->
  <Target Name="CleanReferencedProjects" DependsOnTargets="PrepareProjectReferences" xmlns="">
    <!--
        When building the project directly from the command-line, clean those referenced projects
        that exist on disk.  For IDE builds and command-line .SLN builds, the solution build manager
        takes care of this.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="Clean" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" BuildInParallel="$(BuildInParallel)" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <!--
    ============================================================
                                        CoreClean
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CoreCleanDependsOn />
  </PropertyGroup>
  <Target Name="CoreClean" DependsOnTargets="$(CoreCleanDependsOn)" xmlns="">
    <!-- First clean any explicitly specified cleanable files.
             Declare items of this type if you want Clean to delete them. -->
    <Delete Files="@(Clean)" TreatErrorsAsWarnings="true" />
    <!-- Read in list of files that were written to disk in past builds. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanPriorFileWrites" />
    </ReadLinesFromFile>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete those files. -->
    <Delete Files="@(_CleanPriorFileWritesInOutput);@(_CleanPriorFileWritesInIntermediate)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterClean Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanPriorFileWritesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write new list of current files back to disk. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" WriteOnlyWhenDifferent="true" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanRecordFileWrites

    Save the list of all files written to disk so that it can be used for "Clean" later.

    Files written in prior builds are not removed from Clean cache.
    ============================================================
    -->
  <Target Name="_CleanRecordFileWrites" DependsOnTargets="_CleanGetCurrentAndPriorFileWrites" xmlns="">
    <!--
        Merge list of files from prior builds with the current build and then
        remove duplicates.
        -->
    <RemoveDuplicates Inputs="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write merged file list back to disk, replacing existing contents. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueFileWrites)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <!--
    ============================================================
                                        CleanPublishFolder
    ============================================================
    -->
  <Target Name="CleanPublishFolder" xmlns="">
    <RemoveDir Directories="$(ClickOncePublishDir)" Condition="'$(ClickOncePublishDir)'=='$(OutputPath)app.publish\' and Exists('$(ClickOncePublishDir)')" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PostBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PostBuildEvent

    Run the post-build event. This step is driven by two parameters:

    (1) The $(RunPostBuildEvent) property is set by the user through the IDE and can be one of four values.

        - OnBuildSuccess: In this case, every step of the build must succeed for the post-build step to run.
        - <Blank>: This is the same as OnBuildSuccess.
        - OnOutputUpdated: In this case, the post-build step will run only if the main output assembly was
        actually updated.
        - Always: The post-build step is always run.

    (2) The $(_AssemblyTimestampBeforeCompile) and $(_AssemblyTimestampAfterCompile) values are
        set by the _TimeStampBeforeCompile and _TimeStampAfterCompile targets.  If the assembly was actually
        rebuilt during this build, then the two values will be different.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PostBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PostBuildEvent" Condition="'$(PostBuildEvent)' != '' and ('$(RunPostBuildEvent)' != 'OnOutputUpdated' or '$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)')" DependsOnTargets="$(PostBuildEventDependsOn)" xmlns="">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Publish Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup xmlns="">
    <DeploymentComputeClickOnceManifestInfoDependsOn>
      CleanPublishFolder;
      $(_RecursiveTargetForContentCopying);
      _DeploymentGenerateTrustInfo;
      $(DeploymentComputeClickOnceManifestInfoDependsOn)
    </DeploymentComputeClickOnceManifestInfoDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        Publish

    This target is only called when doing ClickOnce publishing outside the IDE, which implicitly builds before publishing.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PublishDependsOn Condition="'$(PublishableProject)'=='true'">
      SetGenerateManifests;
      Build;
      PublishOnly
    </PublishDependsOn>
    <PublishDependsOn Condition="'$(PublishableProject)'!='true'">
      _DeploymentUnpublishable
    </PublishDependsOn>
  </PropertyGroup>
  <Target Name="Publish" DependsOnTargets="$(PublishDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _DeploymentUnpublishable

    This target is used to block an attempt to ClickOnce publish a non-publishable project, such as a ClassLibrary, when building outside the IDE.
    ============================================================
    -->
  <Target Name="_DeploymentUnpublishable" xmlns="">
    <MSBuildInternalMessage ResourceName="CommonSdk.DeploymentUnpublishable" Severity="Message" />
  </Target>
  <!--
    ============================================================
                                        SetGenerateManifests

    This target simply assures the GenerateClickOnceManifests property is set whenever the publish target is invoked.
    ============================================================
    -->
  <Target Name="SetGenerateManifests" xmlns="">
    <MSBuildInternalMessage Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe'" ResourceName="CommonSdk.GenerateManifestsOnlyForExe" Severity="Error" />
    <MSBuildInternalMessage Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(ManifestCertificateThumbprint)'=='' and '$(ManifestKeyFile)'==''" ResourceName="CommonSdk.SigningKeyRequired" Severity="Error" />
    <PropertyGroup>
      <GenerateClickOnceManifests>true</GenerateClickOnceManifests>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        PublishOnly

    The "PublishOnly" target is intended for ClickOnce publishing inside the IDE, where the build has already been done
    by the BuildManager.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PublishOnlyDependsOn>
      SetGenerateManifests;
      PublishBuild;
      BeforePublish;
      GenerateManifests;
      CopyFilesToOutputDirectory;
      _CopyFilesToPublishFolder;
      _DeploymentGenerateBootstrapper;
      ResolveKeySource;
      _DeploymentSignClickOnceDeployment;
      AfterPublish
    </PublishOnlyDependsOn>
  </PropertyGroup>
  <Target Name="PublishOnly" DependsOnTargets="$(PublishOnlyDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        BeforePublish

    Redefine this target in your project in order to run tasks just before Publish.
    ============================================================
    -->
  <Target Name="BeforePublish" xmlns="" />
  <!--
    ============================================================
                                        AfterPublish

    Redefine this target in your project in order to run tasks just after Publish.
    ============================================================
    -->
  <Target Name="AfterPublish" xmlns="" />
  <!--
    ============================================================
                                        PublishBuild

    Defines the set of targets that publishing is directly dependent on.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <PublishBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
    </PublishBuildDependsOn>
  </PropertyGroup>
  <Target Name="PublishBuild" DependsOnTargets="$(PublishBuildDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        _CopyFilesToPublishFolder
    ============================================================
    -->
  <Target Name="_CopyFilesToPublishFolder" xmlns="">
    <!-- Compute name of application folder, which includes the assembly name plus formatted application version.
             The application version is formatted to use "_" in place of "." chars (i.e. "1_0_0_0" instead of "1.0.0.0").
             This is done because some servers misinterpret "." as a file extension. -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)" FormatType="Path">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentApplicationVersionFragment" />
    </FormatVersion>
    <PropertyGroup>
      <_DeploymentApplicationFolderName>Application Files\$(AssemblyName)_$(_DeploymentApplicationVersionFragment)</_DeploymentApplicationFolderName>
      <_DeploymentApplicationDir>$(ClickOncePublishDir)$(_DeploymentApplicationFolderName)\</_DeploymentApplicationDir>
    </PropertyGroup>
    <PropertyGroup>
      <!-- By default we're not using Hard or Symbolic Links to copy to the publish directory, and never when building in VS -->
      <CreateHardLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForPublishFilesIfPossible)' == ''">false</CreateHardLinksForPublishFilesIfPossible>
      <CreateSymbolicLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForPublishFilesIfPossible)' == ''">false</CreateSymbolicLinksForPublishFilesIfPossible>
    </PropertyGroup>
    <!-- Copy files to publish folder -->
    <Copy Condition="'$(PublishSingleFile)' != 'true'" SourceFiles="@(_ApplicationManifestFinal);&#xD;&#xA;                @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;                @(_DeploymentManifestFiles);&#xD;&#xA;                @(ReferenceComWrappersToCopyLocal);&#xD;&#xA;                @(ResolvedIsolatedComModules);&#xD;&#xA;                @(_DeploymentLooseManifestFile)" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xD;&#xA;                @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(_DeploymentManifestFiles->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(ReferenceComWrappersToCopyLocal->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(ResolvedIsolatedComModules->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                @(_DeploymentLooseManifestFile->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <Copy SourceFiles="@(_DeploymentManifestDependencies)" DestinationFiles="@(_DeploymentManifestDependencies->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" Condition="'$(PublishSingleFile)' != 'true' and '%(_DeploymentManifestDependencies.DependencyType)'=='Install'" />
    <Copy Condition="'$(PublishSingleFile)' != 'true'" SourceFiles="@(_ReferenceScatterPaths)" DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" />
    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
      <PublishedSingleFileToBeCopied Include="@(_DeploymentManifestFiles)" />
    </ItemGroup>
    <!-- For single-file publish case, we need to only copy the clickonce manifest, manifest entry point (launcher) and the SF EXE -->
    <Copy Condition="'$(PublishSingleFile)' == 'true'" SourceFiles="@(_ApplicationManifestFinal);&#xD;&#xA;                 @(_DeploymentResolvedManifestEntryPoint);&#xD;&#xA;                 @(PublishedSingleFileToBeCopied);" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xD;&#xA;                 @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xD;&#xA;                 @(PublishedSingleFileToBeCopied->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(_DeploymentComponentsUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedComponentsUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateBootstrapper
    ============================================================
    -->
  <Target Name="_DeploymentGenerateBootstrapper" xmlns="">
    <!-- Build setup.exe bootstrapper and copy referenced packages -->
    <GenerateBootstrapper ApplicationFile="$(TargetDeployManifestFileName)" ApplicationName="$(AssemblyName)" ApplicationUrl="$(_DeploymentFormattedApplicationUrl)" BootstrapperItems="@(BootstrapperPackage)" ComponentsLocation="$(BootstrapperComponentsLocation)" ComponentsUrl="$(_DeploymentFormattedComponentsUrl)" Culture="$(TargetCulture)" FallbackCulture="$(FallbackCulture)" OutputPath="$(ClickOncePublishDir)" SupportUrl="$(_DeploymentFormattedSupportUrl)" Path="$(GenerateBootstrapperSdkPath)" VisualStudioVersion="$(VisualStudioVersion)" Condition="'$(BootstrapperEnabled)'=='true'" />
  </Target>
  <!--
    ============================================================
                                        _DeploymentSignClickOnceDeployment
    ============================================================
    -->
  <Target Name="_DeploymentSignClickOnceDeployment" xmlns="">
    <!-- Sign manifests and the bootstrapper -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" DisallowMansignTimestampFallback="$(DisallowMansignTimestampFallback)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Update entry point path in deploy manifest -->
    <UpdateManifest ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" InputManifest="$(OutDir)$(TargetDeployManifestFileName)" OutputManifest="$(ClickOncePublishDir)$(TargetDeployManifestFileName)">
      <Output TaskParameter="OutputManifest" ItemName="PublishedDeployManifest" />
    </UpdateManifest>
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(ClickOncePublishDir)$(TargetDeployManifestFileName)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" DisallowMansignTimestampFallback="$(DisallowMansignTimestampFallback)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(ClickOncePublishDir)setup.exe" Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroups Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        AllProjectOutputGroups

    The targets below drive output groups, which provide generic information about a
    project's inputs (e.g., content files, compilation sources, etc.) and built outputs
    (e.g., built EXE/DLL, PDB, XML documentation files, etc.)

    Each target may produce two kinds of items:  outputs and dependencies.  Outputs are
    items from the current project; dependencies are items that are brought into the
    current project as a result of referencing other projects or components.

    For both outputs and dependencies, the Include attribute
    specifies the location of the output/dependency; it must be a full path.  Any number
    of additional attributes may be placed on an output/dependency item.
    ============================================================
    -->
  <Target Name="AllProjectOutputGroups" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroup;&#xD;&#xA;            DebugSymbolsProjectOutputGroup;&#xD;&#xA;            DocumentationProjectOutputGroup;&#xD;&#xA;            SatelliteDllsProjectOutputGroup;&#xD;&#xA;            SourceFilesProjectOutputGroup;&#xD;&#xA;            ContentFilesProjectOutputGroup;&#xD;&#xA;            SGenFilesOutputGroup" xmlns="" />
  <!--
    This is the key output for the BuiltProjectOutputGroup and is meant to be read directly from the IDE.
    Reading an item is faster than invoking a target.
    -->
  <ItemGroup Condition=" '$(OutputType)' != 'winmdobj' " xmlns="">
    <BuiltProjectOutputGroupKeyOutput Include="@(IntermediateAssembly->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
      <COM2REG Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'">true</COM2REG>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <ItemGroup Condition=" '$(OutputType)' == 'winmdobj' " xmlns="">
    <WinMDExpOutputWindowsMetadataFileItem Include="$(_IntermediateWindowsMetadataPath)" Condition="'$(_IntermediateWindowsMetadataPath)' != ''" />
    <BuiltProjectOutputGroupKeyOutput Include="@(WinMDExpOutputWindowsMetadataFileItem->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <!--
    ============================================================
                                        BuiltProjectOutputGroup
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
    <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library' and '$(OutputType)'!='winmdobj')">true</AddAppConfigToBuildOutputs>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroup" Returns="@(BuiltProjectOutputGroupOutput)" DependsOnTargets="$(BuiltProjectOutputGroupDependsOn)" xmlns="">
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="@(BuiltProjectOutputGroupKeyOutput)" />
    </ItemGroup>
    <!-- This item represents the app.config file -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(AppConfig)" Condition="'$(AddAppConfigToBuildOutputs)'=='true'">
        <FinalOutputPath>$(TargetDir)$(TargetFileName).config</FinalOutputPath>
        <TargetPath>$(TargetFileName).config</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(AppConfig)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <ItemGroup>
      <_IsolatedComReference Include="@(COMReference)" Condition=" '%(COMReference.Isolated)' == 'true' " />
      <_IsolatedComReference Include="@(COMFileReference)" Condition=" '%(COMFileReference.Isolated)' == 'true' " />
    </ItemGroup>
    <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="('@(NativeReference)'!='' or '@(_IsolatedComReference)'!='') And Exists('$(OutDir)$(_DeploymentTargetApplicationManifestFileName)')">
        <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="@(_BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec Condition="'%(_BuiltProjectOutputGroupOutputIntermediate.OriginalItemSpec)' == ''">%(_BuiltProjectOutputGroupOutputIntermediate.FullPath)</OriginalItemSpec>
      </BuiltProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroup

    This target performs population of the Debug Symbols project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DebugSymbolsProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' != 'winmdobj'" xmlns="">
    <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
      <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' == 'winmdobj'" xmlns="">
    <WinMDExpOutputPdbItem Include="$(WinMDExpOutputPdb)" Condition="'$(WinMDExpOutputPdb)' != ''" />
    <WinMDExpFinalOutputPdbItem Include="$(_WinMDDebugSymbolsOutputPath)" Condition="'$(_WinMDDebugSymbolsOutputPath)' != ''" />
    <DebugSymbolsProjectOutputGroupOutput Include="@(WinMDExpOutputPdbItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputPdbItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDExpOutputPdbItem->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DebugSymbolsProjectOutputGroup" Returns="@(DebugSymbolsProjectOutputGroupOutput)" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        DocumentationProjectOutputGroup

    This target performs population of the Documentation project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DocumentationProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(DocumentationFile)'!='' and '$(OutputType)' != 'winmdobj'" xmlns="">
    <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
      <FinalOutputPath>@(FinalDocFile->'%(FullPath)')</FinalOutputPath>
      <IsKeyOutput>true</IsKeyOutput>
      <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(DocumentationFile)' != '' and '$(OutputType)' == 'winmdobj'" xmlns="">
    <WinMDOutputDocumentationFileItem Include="$(WinMDOutputDocumentationFile)" Condition="'$(WinMDOutputDocumentationFile)' != ''" />
    <WinMDExpFinalOutputDocItem Include="$(_WinMDDocFileOutputPath)" Condition="'$(_WinMDDocFileOutputPath)' != ''" />
    <DocumentationProjectOutputGroupOutput Include="@(WinMDOutputDocumentationFileItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputDocItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDOutputDocumentationFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DocumentationProjectOutputGroup" Returns="@(DocumentationProjectOutputGroupOutput)" DependsOnTargets="$(DocumentationProjectOutputGroupDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroup

    This target performs population of the Satellite Files project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SatelliteDllsProjectOutputGroupDependsOn>$(SatelliteDllsProjectOutputGroupDependsOn);PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroup" Returns="@(SatelliteDllsProjectOutputGroupOutput)" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependsOn)" xmlns="">
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutputIntermediate Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.WithCulture)' == 'true'">
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
        <Culture>%(EmbeddedResource.Culture)</Culture>
      </SatelliteDllsProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <FinalOutputPath Condition=" '%(SatelliteDllsProjectOutputGroupOutputIntermediate.FinalOutputPath)' == '' ">$(TargetDir)%(SatelliteDllsProjectOutputGroupOutputIntermediate.TargetPath)</FinalOutputPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>%(SatelliteDllsProjectOutputGroupOutputIntermediate.Identity)</OriginalItemSpec>
      </SatelliteDllsProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SourceFilesProjectOutputGroup

    This target performs population of the Source Files project output group.
    Source files are items in the project whose type is "Compile" and "EmbeddedResource".
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SourceFilesProjectOutputGroup" Returns="@(SourceFilesProjectOutputGroupOutput)" DependsOnTargets="$(SourceFilesProjectOutputGroupDependsOn)" xmlns="">
    <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
      <SourceFilesProjectOutputGroupOutput Include="@(_CompileWithTargetPath->'%(FullPath)');@(EmbeddedResource->'%(FullPath)');@(_LicxFile->'%(FullPath)');@(AppConfigWithTargetPath->'%(FullPath)')" />
      <!-- Include the project file -->
      <SourceFilesProjectOutputGroupOutput Include="$(MSBuildProjectFullPath)">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(MSBuildProjectFullPath)</OriginalItemSpec>
        <TargetPath>$(ProjectFileName)</TargetPath>
      </SourceFilesProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- Get just the compile items -->
  <Target Name="GetCompile" Returns="@(Compile)" xmlns="" />
  <!--
    ============================================================
                                        ContentFilesProjectOutputGroup

    This target performs population of the Content Files project output group.
    Content files are items in the project whose type is "Content".
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ContentFilesProjectOutputGroup" Returns="@(ContentFilesProjectOutputGroupOutput)" DependsOnTargets="$(ContentFilesProjectOutputGroupDependsOn)" xmlns="">
    <!-- Convert items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <ContentFilesProjectOutputGroupOutput Include="@(ContentWithTargetPath->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroup

    This target performs population of the GenerateSerializationAssemblies Files project output group.
    GenerateSerializationAssemblies files are those generated by the GenerateSerializationAssemblies target and task.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SGenFilesOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" xmlns="">
    <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
      <FinalOutputPath>@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')</FinalOutputPath>
      <TargetPath>$(_SGenDllName)</TargetPath>
    </SGenFilesOutputGroupOutput>
  </ItemGroup>
  <Target Name="SGenFilesOutputGroup" Returns="@(SGenFilesOutputGroupOutput)" DependsOnTargets="$(SGenFilesOutputGroupDependsOn)" xmlns="" />
  <!--
    ============================================================
                                        SDKRelated Output groups

    These targets are to gather information from the SDKs.
    ============================================================
   -->
  <!-- Get the resolved SDK reference items -->
  <Target Name="GetResolvedSDKReferences" DependsOnTargets="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" xmlns="" />
  <!-- Target will return no results by default but will be populated by other targets elsewhere.
       Needed for certain build environments that import partial sets of targets. -->
  <Target Name="CollectReferencedNuGetPackages" Returns="@(ReferencedNuGetPackages)" xmlns="" />
  <!-- Get the TargetFrameworks that are supported for the Visual Studio TargetFramework drop down -->
  <Target Name="GenerateSupportedTargetFrameworkAlias" Returns="@(SupportedTargetFrameworkAlias)" xmlns="" />
  <!--
    ============================================================
                                        PriFilesOutputGroup

    This target performs population of the pri files output group
    ============================================================
    -->
  <Target Name="PriFilesOutputGroup" Condition="'@(_ReferenceRelatedPaths)' != ''" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(PriFilesOutputGroupOutput)" xmlns="">
    <!-- This item represents dependent pri file's -->
    <ItemGroup>
      <PriFilesOutputGroupOutput Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" />
    </ItemGroup>
  </Target>
  <PropertyGroup xmlns="">
    <SDKRedistOutputGroupDependsOn>ResolveSDKReferences;ExpandSDKReferences</SDKRedistOutputGroupDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        SDKRedistOutputGroup

    This target gathers the Redist folders from the SDKs which have been resolved.
    ============================================================
  -->
  <Target Name="SDKRedistOutputGroup" Returns="@(SDKRedistOutputGroupOutput)" DependsOnTargets="$(SDKRedistOutputGroupDependsOn)" xmlns="">
    <!-- This list starts with the least specific files to the most specific so that later files can overwrite earlier files-->
    <ItemGroup>
      <SDKRedistOutputGroupOutput Include="@(ResolvedRedistFiles)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroupsDependencies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CommonOutputGroupsDependsOn

    Dependencies common to many of the *OutputGroupDependencies targets.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <CommonOutputGroupsDependsOn>
      $(CommonOutputGroupsDependsOn);
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </CommonOutputGroupsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        AllProjectOutputGroupsDependencies
    ============================================================
    -->
  <Target Name="AllProjectOutputGroupsDependencies" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroupDependencies;&#xD;&#xA;            DebugSymbolsProjectOutputGroupDependencies;&#xD;&#xA;            SatelliteDllsProjectOutputGroupDependencies;&#xD;&#xA;            DocumentationProjectOutputGroupDependencies;&#xD;&#xA;            SGenFilesOutputGroupDependencies" xmlns="" />
  <!--
    ============================================================
                                        BuiltProjectOutputGroupDependencies

    This target performs population of the Built project output group dependencies.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <BuiltProjectOutputGroupDependenciesDependsOn>
      $(BuiltProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </BuiltProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroupDependencies" DependsOnTargets="$(BuiltProjectOutputGroupDependenciesDependsOn)" Returns="@(BuiltProjectOutputGroupDependency)" xmlns="">
    <ItemGroup>
      <BuiltProjectOutputGroupDependency Include="@(ReferencePath->'%(FullPath)');&#xD;&#xA;                                                         @(ReferenceDependencyPaths->'%(FullPath)');&#xD;&#xA;                                                         @(NativeReferenceFile->'%(FullPath)');&#xD;&#xA;                                                         @(_DeploymentLooseManifestFile->'%(FullPath)');&#xD;&#xA;                                                         @(ResolvedIsolatedComModules->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroupDependencies

    This target performs population of the dependencies for the debug symbols project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DebugSymbolsProjectOutputGroupDependenciesDependsOn>
      $(DebugSymbolsProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DebugSymbolsProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="DebugSymbolsProjectOutputGroupDependencies" Condition="'$(DebugSymbols)'!='false'" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependenciesDependsOn)" Returns="@(DebugSymbolsProjectOutputGroupDependency)" xmlns="">
    <!-- This item represents dependent PDB's -->
    <ItemGroup>
      <DebugSymbolsProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroupDependencies

    This target performs population of the dependencies for the satellite files project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SatelliteDllsProjectOutputGroupDependenciesDependsOn>
      $(SatelliteDllsProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </SatelliteDllsProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroupDependencies" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependenciesDependsOn)" Returns="@(SatelliteDllsProjectOutputGroupDependency)" xmlns="">
    <!-- This item represents dependent satellites -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupDependency Include="@(ReferenceSatellitePaths->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DocumentationProjectOutputGroupDependencies

    This target performs population of the dependencies for the documentation project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DocumentationProjectOutputGroupDependenciesDependsOn>
      $(DocumentationProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DocumentationProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="DocumentationProjectOutputGroupDependencies" Condition="'$(DocumentationFile)'!=''" DependsOnTargets="$(DocumentationProjectOutputGroupDependenciesDependsOn)" Returns="@(DocumentationProjectOutputGroupDependency)" xmlns="">
    <!-- This item represents dependent XMLs -->
    <ItemGroup>
      <DocumentationProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.xml'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroupDependencies

    This target performs population of the dependencies for the GenerateSerializationAssemblies project output group.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <SGenFilesOutputGroupDependenciesDependsOn>
      $(SGenFilesOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </SGenFilesOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="SGenFilesOutputGroupDependencies" DependsOnTargets="$(SGenFilesOutputGroupDependenciesDependsOn)" Returns="@(SGenFilesOutputGroupDependency)" xmlns="">
    <!-- This item represents sgen xml serializer dll's -->
    <ItemGroup>
      <SGenFilesOutputGroupDependency Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ReferenceCopyLocalPathsOutputGroup

    Exposes the set of items that should be copied locally based on the project's references.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <ReferenceCopyLocalPathsOutputGroupDependsOn>
      $(ReferenceCopyLocalPathsOutputGroupDependsOn);
      $(CommonOutputGroupsDependsOn)
    </ReferenceCopyLocalPathsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ReferenceCopyLocalPathsOutputGroup" DependsOnTargets="$(ReferenceCopyLocalPathsOutputGroupDependsOn)" Returns="@(ReferenceCopyLocalPathsOutputGroupOutput)" xmlns="">
    <ItemGroup>
      <ReferenceCopyLocalPathsOutputGroupOutput Include="@(ReferenceCopyLocalPaths)">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </ReferenceCopyLocalPathsOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
         DesignerRuntimeImplementationProjectOutputGroup

    Exposes build items to be used by designer. The default is empty, but
    SDKs can override it as appropriate. The empty stub is required so that
    the project system can always rely on calling it even if it is not
    overridden.
    ============================================================
    -->
  <PropertyGroup xmlns="">
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(DesignerRuntimeImplementationProjectOutputGroupDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesignerRuntimeImplementationProjectOutputGroup" DependsOnTargets="$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)" Returns="@(DesignerRuntimeImplementationProjectOutputGroupOutput)" xmlns="" />
  <!--
    ============================================================
                       .editorconfig support
    ============================================================
  -->
  <!-- Expose the set of potential .editorconfig files so the project system can
       retrieve them. -->
  <Target Name="GetPotentialEditorConfigFiles" Returns="@(PotentialEditorConfigFiles)" xmlns="" />
  <PropertyGroup xmlns="">
    <CodeAnalysisTargets Condition="'$(CodeAnalysisTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeAnalysis\Microsoft.CodeAnalysis.targets</CodeAnalysisTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CodeAnalysisTargets)" Condition="Exists('$(CodeAnalysisTargets)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.CodeAnalysis.targets
============================================================================================================================================
-->
  <UsingTask TaskName="SetEnvironmentVariable" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <EnvKey ParameterType="System.String" Required="true" />
      <EnvValue ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Code Type="Fragment" Language="cs"><![CDATA[
            try {
                Environment.SetEnvironmentVariable(EnvKey, EnvValue, System.EnvironmentVariableTarget.Process);
            }
            catch  {
            }
        ]]></Code>
    </Task>
  </UsingTask>
  <!-- Global properties for all analyzers -->
  <PropertyGroup>
    <CodeAnalysisStaticAnalysisDirectory Condition="'$(CodeAnalysisStaticAnalysisDirectory)'=='' and Exists('$(VsInstallRoot)\Team Tools\Static Analysis Tools\')">$(VsInstallRoot)\Team Tools\Static Analysis Tools\</CodeAnalysisStaticAnalysisDirectory>
    <!-- Default rule set search paths -->
    <CodeAnalysisRuleSetDirectories Condition="'$(CodeAnalysisIgnoreBuiltInRuleSets)'!='true' and&#xD;&#xA;             '$(CodeAnalysisStaticAnalysisDirectory)'!=''">$(CodeAnalysisRuleSetDirectories);$(CodeAnalysisStaticAnalysisDirectory)\Rule Sets</CodeAnalysisRuleSetDirectories>
    <!--
         In scenario where we run CA from command-line , we don't get "CodeAnalysisVSSku" variable passed by the IDE, so in case of Express-only installation
         we attempt to load rule sets that are only present on Pro and above - and fail. Let's assume we're in "Express" mode if the Pro+ rule set doesn't exist.
      -->
    <CodeAnalysisVSSku Condition="'$(CodeAnalysisVSSku)'=='' and !Exists('$(CodeAnalysisStaticAnalysisDirectory)\Rule Sets\NativeRecommendedRules.ruleset')">Express</CodeAnalysisVSSku>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RunCodeAnalysis)'=='true' or '$(RunCodeAnalysisOnce)'=='true'">
    <!--
         - Checking whether we should run Code Analysis only on specific project in the solution
         - Combine all variables into one "master" control variable to simplify conditions further below
      -->
    <RunCodeAnalysisOnThisProject>true</RunCodeAnalysisOnThisProject>
    <RunCodeAnalysisOnThisProject Condition="'$(CodeAnalysisProjectFullPath)'!='' and '$(MSBuildProjectFullPath)'!='' and '$(MSBuildProjectFullPath)'!='$(CodeAnalysisProjectFullPath)'">false</RunCodeAnalysisOnThisProject>
  </PropertyGroup>
  <PropertyGroup>
    <IsCSharpOrVbProject Condition="'$(Language)'=='C#' or '$(Language)'=='VB'">true</IsCSharpOrVbProject>
    <IsLegacyCodeAnalysis Condition="'$(IsCSharpOrVbProject)'=='true'">true</IsLegacyCodeAnalysis>
    <SuppressLegacyCodeAnalysisDeprecatedWarning Condition="'$(SuppressLegacyCodeAnalysisDeprecatedWarning)'!='true'">false</SuppressLegacyCodeAnalysisDeprecatedWarning>
    <RunAnalyzersDuringLiveAnalysis Condition="'$(RunAnalyzers)' != ''">$(RunAnalyzers)</RunAnalyzersDuringLiveAnalysis>
    <RunAnalyzersDuringLiveAnalysis Condition="'$(RunAnalyzersDuringLiveAnalysis)' == ''">$(IsCSharpOrVbProject)</RunAnalyzersDuringLiveAnalysis>
    <RunAnalyzersDuringBuild Condition="'$(RunAnalyzers)' != ''">$(RunAnalyzers)</RunAnalyzersDuringBuild>
    <RunAnalyzersDuringBuild Condition="'$(RunAnalyzersDuringBuild)' == ''">$(IsCSharpOrVbProject)</RunAnalyzersDuringBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RunCodeAnalysisOnThisProject)'=='true'">
    <!-- Define the CODE_ANALYSIS constant -->
    <DefineConstants Condition="'$(Language)'=='C#' ">CODE_ANALYSIS;$(DefineConstants)</DefineConstants>
    <FinalDefineConstants Condition="'$(Language)'=='VB' ">CODE_ANALYSIS=-1,$(FinalDefineConstants)</FinalDefineConstants>
  </PropertyGroup>
  <PropertyGroup>
    <!-- We do this check all over the place, consolidate -->
    <RunCppAnalysis>false</RunCppAnalysis>
    <RunCppAnalysis Condition="'$(Language)'=='C++' and '$(RunCodeAnalysisOnThisProject)'=='true' and '$(ApplicationType)' != 'Linux'">true</RunCppAnalysis>
    <RunMsvcAnalysis>$(RunCppAnalysis)</RunMsvcAnalysis>
    <RunMsvcAnalysis Condition="'$(EnableMicrosoftCodeAnalysis)'=='false' or '$(UseClangCl)'=='true'">false</RunMsvcAnalysis>
  </PropertyGroup>
  <!-- Global properties for all analyzers -->
  <!-- FxCop analyzer properties -->
  <PropertyGroup>
    <!-- FxCopDir must be considered for backwards compatibility with the Visual Studio 2005 task, except within the context of a Team Build build. -->
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'=='' and '$(FxCopDir)'!='' and '$(TeamBuildConstants)'==''">$(FxCopDir)</CodeAnalysisPath>
    <CodeAnalysisPath Condition="'$(CodeAnalysisPath)'=='' and Exists('$(VsInstallRoot)\Team Tools\Static Analysis Tools\FxCop\')">$(VsInstallRoot)\Team Tools\Static Analysis Tools\FxCop\</CodeAnalysisPath>
    <!-- Default FxCop settings -->
    <CodeAnalysisApplyLogFileXsl Condition="'$(CodeAnalysisApplyLogFileXsl)'==''">false</CodeAnalysisApplyLogFileXsl>
    <CodeAnalysisFailOnMissingRules Condition="'$(CodeAnalysisFailOnMissingRules)'==''">false</CodeAnalysisFailOnMissingRules>
    <CodeAnalysisForceOutput Condition="'$(CodeAnalysisForceOutput)'==''">true</CodeAnalysisForceOutput>
    <CodeAnalysisGenerateSuccessFile Condition="'$(CodeAnalysisGenerateSuccessFile)'==''">true</CodeAnalysisGenerateSuccessFile>
    <CodeAnalysisIgnoreGeneratedCode Condition="'$(CodeAnalysisIgnoreGeneratedCode)'==''">true</CodeAnalysisIgnoreGeneratedCode>
    <CodeAnalysisIgnoreInvalidTargets Condition="'$(CodeAnalysisIgnoreInvalidTargets)'==''">true</CodeAnalysisIgnoreInvalidTargets>
    <CodeAnalysisIgnoreMissingIndirectReferences Condition="'$(CodeAnalysisIgnoreMissingIndirectReferences)'==''">false</CodeAnalysisIgnoreMissingIndirectReferences>
    <CodeAnalysisInputAssembly Condition="'$(CodeAnalysisInputAssembly)'==''">$(OutDir)$(TargetFileName)</CodeAnalysisInputAssembly>
    <CodeAnalysisLogFile Condition="'$(CodeAnalysisLogFile)'==''">$(CodeAnalysisInputAssembly).CodeAnalysisLog.xml</CodeAnalysisLogFile>
    <CodeAnalysisModuleSuppressionsFile Condition="'$(CodeAnalysisModuleSuppressionsFile)'==''">GlobalSuppressions$(DefaultLanguageSourceExtension)</CodeAnalysisModuleSuppressionsFile>
    <CodeAnalysisOverrideRuleVisibilities Condition="'$(CodeAnalysisOverrideRuleVisibilities)'==''">false</CodeAnalysisOverrideRuleVisibilities>
    <CodeAnalysisOutputToConsole Condition="'$(CodeAnalysisOutputToConsole)'==''">false</CodeAnalysisOutputToConsole>
    <CodeAnalysisQuiet Condition="'$(CodeAnalysisQuiet)'==''">false</CodeAnalysisQuiet>
    <!--
         Do not add the built-in rule directories in any of the following conditions:
         1. CodeAnalysisRuleAssemblies is not empty, CodeAnalysisRuleDirectories is empty, and CodeAnalysisRuleSet is empty. (This is the case when CodeAnalysisRuleAssemblies will be used.)
         2. CodeAnalysisIgnoreBuiltInRules is true.
         3. CodeAnalysisPath is empty.
         4. CodeAnalysisProject is not empty (i.e., an FxCop project file is used).

         The condition below checks ensures none of these four are true.
      -->
    <CodeAnalysisRuleDirectories Condition="('$(CodeAnalysisRuleAssemblies)'=='' or '$(CodeAnalysisRuleDirectories)'!='' or '$(CodeAnalysisRuleSet)'!='') and &#xD;&#xA;            '$(CodeAnalysisIgnoreBuiltInRules)'!='true' and &#xD;&#xA;            '$(CodeAnalysisPath)'!='' and &#xD;&#xA;            '$(CodeAnalysisProject)'==''">$(CodeAnalysisRuleDirectories);$(CodeAnalysisPath)\Rules</CodeAnalysisRuleDirectories>
    <!-- We emit active and suppressed messages in the output log when running code analysis within Visual Studio.
         Delete the below line if you do not want to see suppressed messages within Visual Studio. -->
    <CodeAnalysisSaveMessagesToReport Condition="'$(CodeAnalysisSaveMessagesToReport)'=='' and '$(RunCodeAnalysisOnce)'=='true'">Active,Excluded</CodeAnalysisSaveMessagesToReport>
    <!-- We only emit active messages in the output log when running code analysis from the command line. -->
    <CodeAnalysisSaveMessagesToReport Condition="'$(CodeAnalysisSaveMessagesToReport)'==''">Active</CodeAnalysisSaveMessagesToReport>
    <CodeAnalysisSearchGlobalAssemblyCache Condition="'$(CodeAnalysisSearchGlobalAssemblyCache)'==''">true</CodeAnalysisSearchGlobalAssemblyCache>
    <CodeAnalysisSucceededFile Condition="'$(CodeAnalysisSucceededFile)'==''">$(CodeAnalysisInputAssembly).lastcodeanalysissucceeded</CodeAnalysisSucceededFile>
    <CodeAnalysisSummary Condition="'$(CodeAnalysisSummary)'==''">false</CodeAnalysisSummary>
    <CodeAnalysisTimeout Condition="'$(CodeAnalysisTimeout)'==''">120</CodeAnalysisTimeout>
    <!-- Use a separate property '_CodeAnalysisTreatWarningsAsErrors' to avoid overwriting user specified value for 'CodeAnalysisTreatWarningsAsErrors', which is used outside this targets file. -->
    <_CodeAnalysisTreatWarningsAsErrors>$(CodeAnalysisTreatWarningsAsErrors)</_CodeAnalysisTreatWarningsAsErrors>
    <_CodeAnalysisTreatWarningsAsErrors Condition="'$(_CodeAnalysisTreatWarningsAsErrors)'==''">false</_CodeAnalysisTreatWarningsAsErrors>
    <CodeAnalysisUpdateProject Condition="'$(CodeAnalysisUpdateProject)'==''">false</CodeAnalysisUpdateProject>
    <CodeAnalysisUseTypeNameInSuppression Condition="'$(CodeAnalysisUseTypeNameInSuppression)'==''">true</CodeAnalysisUseTypeNameInSuppression>
    <CodeAnalysisVerbose Condition="'$(CodeAnalysisVerbose)'==''">false</CodeAnalysisVerbose>
  </PropertyGroup>
  <!-- Select appropriate default rule set depending on project type and VS Sku-->
  <Choose>
    <When Condition="!Exists('$(CodeAnalysisRuleSet)') and ('$(CodeAnalysisVSSku)'=='Express' or ('$(CodeAnalysisRules)'=='' and '$(CodeAnalysisRuleAssemblies)'=='' and '$(CodeAnalysisRuleSet)'==''))">
      <Choose>
        <When Condition="'$(Language)'=='C++' and '$(CLRSupport)'=='true' and '$(CodeAnalysisVSSku)'=='Express'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>MixedMinimumRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)'=='C++' and '$(CLRSupport)'=='true'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>MixedRecommendedRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)'=='C++' and '$(CodeAnalysisVSSku)'=='Express'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>NativeMinimumRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)'=='C++'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
        <When Condition="'$(CodeAnalysisVSSku)'=='Express'">
          <PropertyGroup>
            <CodeAnalysisRuleSet>ManagedMinimumRules.ruleset</CodeAnalysisRuleSet>
          </PropertyGroup>
        </When>
      </Choose>
    </When>
  </Choose>
  <!-- C#/VB specific properties -->
  <PropertyGroup Condition="'$(Language)'=='C#' or '$(Language)'=='VB'">
    <!-- Run Code Analysis after the build, but before running the application-->
    <PrepareForRunDependsOn>$(PrepareForRunDependsOn);RunCodeAnalysis</PrepareForRunDependsOn>
    <RunCodeAnalysisDependsOn>$(RunCodeAnalysisDependsOn);Compile</RunCodeAnalysisDependsOn>
  </PropertyGroup>
  <!-- C++ specific properties -->
  <PropertyGroup Condition="'$(RunMsvcAnalysis)'=='true'">
    <!-- Turn off /analyze:only for now since the perf gain doesn't justify the breaks -->
    <VCAnalyzeOnlyAllowed Condition="'$(VCAnalyzeOnlyAllowed)'==''">false</VCAnalyzeOnlyAllowed>
    <!-- CLR and WinRT projects don't support /analyze:only because they require metadata to be built -->
    <VCAnalyzeOnlyAllowed Condition="'$(VCAnalyzeOnlyAllowed)'=='' and ('$(WindowsAppContainer)'=='true' or '$(WinMDAssembly)'=='true' or '$(ManagedAssembly)'=='true')">false</VCAnalyzeOnlyAllowed>
    <!-- Keep track if we are doing an analyze-only build (toolset 14.0 and higher) -->
    <VCAnalyzeOnly>false</VCAnalyzeOnly>
    <VCAnalyzeOnly Condition="'$(RunCodeAnalysisOnce)'=='true' and '$(VCAnalyzeOnlyAllowed)'=='true' and '$(PlatformToolsetVersion)'&gt;='140'">true</VCAnalyzeOnly>
    <!-- Use the specified ruleset path if found otherwise try to determine the full path to the ruleset -->
    <VCAnalyzeRulesetPath Condition="Exists('$(CodeAnalysisRuleSet)')">$(CodeAnalysisRuleSet)</VCAnalyzeRulesetPath>
    <VCAnalyzeRulesetPath Condition="'$(VCAnalyzeRulesetPath)'==''">$(CodeAnalysisStaticAnalysisDirectory)Rule Sets\$(CodeAnalysisRuleSet)</VCAnalyzeRulesetPath>
    <!-- Set up localEspc plugin path -->
    <!-- use 32-bit version by default -->
    <LocalEspcPath>$(VC_ExecutablePath_x86_x86)\localespc.dll</LocalEspcPath>
    <!-- use 64-bit version if 64-bit cl.exe is used -->
    <LocalEspcPath Condition="'$(VCToolArchitecture)'=='Native64Bit'">$(VC_ExecutablePath_x64_x64)\localespc.dll</LocalEspcPath>
    <!-- use Arm64 version if Arm64 cl.exe is used -->
    <LocalEspcPath Condition="'$(VCToolArchitecture)'=='NativeARM64'">$(VC_ExecutablePath_ARM64_ARM64)\localespc.dll</LocalEspcPath>
    <RunMergeNativeCodeAnalysisDependsOn>ClCompile</RunMergeNativeCodeAnalysisDependsOn>
    <RunMergeNativeCodeAnalysisDependsOn Condition="'$(RunCodeAnalysisDependsOn)'!=''">$(RunCodeAnalysisDependsOn);$(RunMergeNativeCodeAnalysisDependsOn)</RunMergeNativeCodeAnalysisDependsOn>
    <RunCodeAnalysisDependsOn>$(RunCodeAnalysisDependsOn);ClCompile;RunMergeNativeCodeAnalysis</RunCodeAnalysisDependsOn>
    <ExtensionsToDeleteOnClean>$(ExtensionsToDeleteOnClean);$(CodeAnalysisLogFile);$(CodeAnalysisSucceededFile)</ExtensionsToDeleteOnClean>
    <CodeAnalysisTLogFile>$(IntDir)CodeAnalysis.read.1.tlog</CodeAnalysisTLogFile>
    <NativeCodeAnalysisTLogFile>$(IntDir)NativeCodeAnalysis.read.1.tlog</NativeCodeAnalysisTLogFile>
  </PropertyGroup>
  <!-- Analyze-only build, don't run any post-compile build steps -->
  <PropertyGroup Condition="'$(RunMsvcAnalysis)'=='true' and '$(VCAnalyzeOnly)'=='true'">
    <!--
          See Microsoft.BuildSteps.targets
          PrepareForBuild before ResolveReferences limits P2P rebuild
      -->
    <BuildSteps>
          PrepareForBuild;
          ResolveReferences;
          InitializeBuildStatus;
          BuildGenerateSources;
          BeforeClCompile;
          RunNativeCodeAnalysis
      </BuildSteps>
    <!-- In analyze-only, we don't generate assemblies so we can't run FxCop -->
  </PropertyGroup>
  <!-- Build with analyze, we run analysis after the assembly is linked -->
  <PropertyGroup Condition="'$(RunMsvcAnalysis)'=='true' and '$(VCAnalyzeOnly)'!='true'">
    <AfterBuildLinkTargets>$(AfterBuildLinkTargets);RunMergeNativeCodeAnalysis;RunNativeCodeAnalysis</AfterBuildLinkTargets>
    <AfterBuildLinkTargets Condition="'$(CLRSupport)'=='true'">$(AfterBuildLinkTargets);RunCodeAnalysis</AfterBuildLinkTargets>
  </PropertyGroup>
  <!-- NOTE: Back-compat support for EnablePREFast item property.
      It's possible to set manually set EnablePREFast in an item definition group
      in project, without setting RunCodeAnalysis. In this case, we want to set
      up CAExcludePath so headers are clean, but don't want to enable any other
      C++ CA features like the result ingestion tasks or /analyze:quiet. -->
  <PropertyGroup Condition="'$(Language)'=='C++' or '$(RunMsvcAnalysis)'=='true'">
    <!-- Set up CAExcludePath for known include paths -->
    <CAExcludePath Condition="'$(Console_SdkIncludeRoot)'!=''">$(Console_SdkIncludeRoot);$(CAExcludePath)</CAExcludePath>
    <CAExcludePath Condition="'$(WindowsSDK_IncludePath)'!=''">$(WindowsSDK_IncludePath);$(CAExcludePath)</CAExcludePath>
    <CAExcludePath Condition="'$(UniversalCRT_IncludePath)'!=''">$(UniversalCRT_IncludePath);$(CAExcludePath)</CAExcludePath>
    <CAExcludePath Condition="Exists('$(VCToolsInstallDir)include')">$(VCToolsInstallDir)include;$(CAExcludePath)</CAExcludePath>
    <CAExcludePath Condition="Exists('$(VCToolsInstallDir)atlmfc\include')">$(VCToolsInstallDir)atlmfc\include;$(CAExcludePath)</CAExcludePath>
    <!-- Make sure the target that sets CAExcludePath is run -->
    <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);SetCABuildNativeEnvironmentVariables</PrepareForBuildDependsOn>
  </PropertyGroup>
  <!-- Actually set CAExcludePath -->
  <Target Name="SetCABuildNativeEnvironmentVariables">
    <!-- SetEnv is defined in Microsoft.Cpp.CurrentVersion.targets and is much faster -->
    <SetEnv Condition="'$(CAExcludePath)'!=''" Value="$(CAExcludePath)" Name="CAExcludePath" Prefix="false" />
    <SetEnv Condition="'$(RunMsvcAnalysis)'=='true' and '$(VCCodeAnalysisUX)'=='true'" Value="1" Name="CAEmitSarifLog" Prefix="false" />
  </Target>
  <!-- Set up the additional cl.exe command line for each compilation unit -->
  <ItemDefinitionGroup Condition="'$(RunMsvcAnalysis)'=='true'">
    <ClCompile>
      <EnablePREFast>true</EnablePREFast>
      <PreprocessorDefinitions>CODE_ANALYSIS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PREfastLog Condition="'$(PlatformToolsetVersion)'&lt;'120'">$(IntDir)%(FileName)%(Extension).nativecodeanalysis.xml</PREfastLog>
      <PREfastLogFile Condition="'$(PlatformToolsetVersion)'&gt;='120'">%(ObjectFileName)%(FileName).nativecodeanalysis.xml</PREfastLogFile>
      <!-- Add the localEspc plugin only if ConcurrencyCheck is not installed -->
      <PREfastAdditionalPlugins Condition="('$(ConcurrencyCheckPath)' == '' or !Exists('$(ConcurrencyCheckPath)')) and Exists('$(LocalEspcPath)')">$(LocalEspcPath);%(ClCompile.PREfastAdditionalPlugins)</PREfastAdditionalPlugins>
      <!-- After Dev11 pass /analyze:quiet because warnings are added to the error list by a post-build task. -->
      <PREfastAdditionalOptions Condition="'$(PlatformToolsetVersion)'&gt;='110'">quiet;%(ClCompile.PREfastAdditionalOptions)</PREfastAdditionalOptions>
      <!-- Disable code-gen for analyze-only build -->
      <AdditionalOptions Condition="'$(VCAnalyzeOnly)'=='true'">%(ClCompile.AdditionalOptions) /c</AdditionalOptions>
      <PREfastAdditionalOptions Condition="'$(VCAnalyzeOnly)'=='true'">only;%(ClCompile.PREfastAdditionalOptions)</PREfastAdditionalOptions>
      <!-- In Dev15 we added ruleset handling in PREFast, add the ruleset file path if it exists -->
      <PREfastAdditionalOptions Condition="'$(PlatformToolsetVersion)'&gt;='140' and '$(PlatformToolsetVersion)'&lt;'142' and Exists('$(VCAnalyzeRulesetPath)')">%(ClCompile.PREfastAdditionalOptions);ruleset$(VCAnalyzeRulesetPath)</PREfastAdditionalOptions>
      <!-- In v142 ClCompile supports new arguments so other tools can filter them out (clang-cl)-->
      <PREfastRulesetFile Condition="'$(PlatformToolsetVersion)'&gt;='142' and Exists('$(VCAnalyzeRulesetPath)')">$(VCAnalyzeRulesetPath)</PREfastRulesetFile>
      <PREfastProjectDirectory Condition="'$(PlatformToolsetVersion)'&gt;='142' and Exists('$(MSBuildProjectDirectory)')">$(MSBuildProjectDirectory)</PREfastProjectDirectory>
      <PREfastRulesetDirectories Condition="'$(PlatformToolsetVersion)'&gt;='142' and '$(CodeAnalysisRuleSetDirectories)'!=''">$(CodeAnalysisRuleSetDirectories);%(ClCompile.PREfastRulesetDirectories)</PREfastRulesetDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Make AdditionalFiles and CodeAnalysisDictionary available as a Build Action in Visual Studio -->
  <ItemGroup>
    <AvailableItemName Include="AdditionalFiles" />
    <AvailableItemName Include="CodeAnalysisDictionary" />
  </ItemGroup>
  <!-- FxCop analyzer properties -->
  <!-- Managed analyzer targets -->
  <PropertyGroup>
    <RunCodeAnalysisInputs>$(CodeAnalysisInputAssembly)</RunCodeAnalysisInputs>
    <RunCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and Exists('$(CodeAnalysisRuleSet)')">$(RunCodeAnalysisInputs);$(CodeAnalysisRuleSet)</RunCodeAnalysisInputs>
    <RunCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and !Exists('$(CodeAnalysisRuleSet)') and Exists('$(ProjectDir)$(CodeAnalysisRuleSet)')">$(RunCodeAnalysisInputs);$(ProjectDir)$(CodeAnalysisRuleSet)</RunCodeAnalysisInputs>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.Build.Tasks.CodeAnalysis" AssemblyFile=".\FxCopTask.dll" />
  <Target Name="RunCodeAnalysis" Condition="'$(RunCodeAnalysisOnThisProject)'=='true'" Inputs="$(RunCodeAnalysisInputs)" Outputs="$(CodeAnalysisLogFile);$(CodeAnalysisSucceededFile)" DependsOnTargets="$(RunCodeAnalysisDependsOn)">
    <!-- Build CodeAnalysisReferencePath inside of the RunCodeAnalysis target to ensure that ReferencePath -->
    <!-- has already been populated by the ResolveReferences target prior to using it. -->
    <ItemGroup>
      <CodeAnalysisReferencePath Include="@(ReferencePath)" />
      <CodeAnalysisReferencePath Condition="'$(Language)'=='VB' and '$(VBRuntimePath)'!=''" Include="$(VBRuntimePath)" />
    </ItemGroup>
    <!-- Add AdditionalUsingDirectories as reference assembly paths for C++ projects -->
    <ItemGroup>
      <CodeAnalysisDependentAssemblyPaths Condition="'$(Language)'=='C++'" Include="%(ClCompile.AdditionalUsingDirectories)" />
    </ItemGroup>
    <!-- If it is winmd file than we want to analyze winmdobj instead of winmd file -->
    <PropertyGroup>
      <CodeAnalysisInputAssembly Condition="'$(OutputType)'=='winmdobj'">@(IntermediateAssembly)</CodeAnalysisInputAssembly>
      <CodeAnalysisInputAssembly Condition="'$(OutputType)'=='winmdobj' and '$(Language)'=='VB'">$(IntermediateOutputPath)\TempCA\$(TargetName)$(TargetExt)</CodeAnalysisInputAssembly>
    </PropertyGroup>
    <!-- VBCompiler issue: fix the name of PDB file for winmdobj assembly -->
    <Copy Condition="'$(OutputType)'=='winmdobj' and '$(Language)'=='VB'" DestinationFiles="$(IntermediateOutputPath)\TempCA\$(TargetName).pdb" SourceFiles="$(PdbFile)" OverwriteReadOnlyFiles="True" />
    <Copy Condition="'$(OutputType)'=='winmdobj' and '$(Language)'=='VB'" DestinationFolder="$(IntermediateOutputPath)\TempCA\" SourceFiles="@(IntermediateAssembly)" OverwriteReadOnlyFiles="True" />
    <CodeAnalysis Condition="'$(RunCodeAnalysisOnThisProject)'=='true'" AdditionalOptions="$(CodeAnalysisAdditionalOptions)" AlternativeToolName="$(CodeAnalysisAlternativeToolName)" AnalysisTimeout="$(CodeAnalysisTimeout)" ApplyLogFileXsl="$(CodeAnalysisApplyLogFileXsl)" Assemblies="$(CodeAnalysisInputAssembly)" ConsoleXsl="$(CodeAnalysisConsoleXsl)" Culture="$(CodeAnalysisCulture)" DependentAssemblyPaths="@(CodeAnalysisDependentAssemblyPaths)" Dictionaries="@(CodeAnalysisDictionary)" DisableReferenceSwitchGeneration="$(CodeAnalysisDisableReferenceSwitchGeneration)" FailOnMissingRules="$(CodeAnalysisFailOnMissingRules)" FilesWritten="$(CodeAnalysisLogFile);$(CodeAnalysisSucceededFile)" ForceOutput="$(CodeAnalysisForceOutput)" GenerateSuccessFile="$(CodeAnalysisGenerateSuccessFile)" IsLegacyCodeAnalysis="$(IsLegacyCodeAnalysis)" SuppressLegacyCodeAnalysisDeprecatedWarning="$(SuppressLegacyCodeAnalysisDeprecatedWarning)" IgnoreBuildTaskWarnings="$(CodeAnalysisIgnoreBuildTaskWarnings)" IgnoreGeneratedCode="$(CodeAnalysisIgnoreGeneratedCode)" IgnoreInvalidTargets="$(CodeAnalysisIgnoreInvalidTargets)" IgnoreMissingIndirectReferences="$(CodeAnalysisIgnoreMissingIndirectReferences)" Imports="@(CodeAnalysisImport)" LogFile="$(CodeAnalysisLogFile)" LogFileXsl="$(CodeAnalysisLogFileXsl)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" OutputToConsole="$(CodeAnalysisOutputToConsole)" OverrideRuleVisibilities="$(CodeAnalysisOverrideRuleVisibilities)" NeverReportRuleErrors="$(CodeAnalysisNeverReportRuleErrors)" PlatformPath="$(CodeAnalysisPlatformPath)" Project="$(CodeAnalysisProject)" Quiet="$(CodeAnalysisQuiet)" References="@(CodeAnalysisReferencePath)" RuleAssemblies="$(CodeAnalysisRuleAssemblies)" RuleDirectories="$(CodeAnalysisRuleDirectories)" Rules="$(CodeAnalysisRules)" RuleSet="$(CodeAnalysisRuleSet)" RuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" RuleSetOverrides="$(CodeAnalysisRuleSetOverrides)" SaveMessagesToReport="$(CodeAnalysisSaveMessagesToReport)" SearchGlobalAssemblyCache="$(CodeAnalysisSearchGlobalAssemblyCache)" SuccessFile="$(CodeAnalysisSucceededFile)" Summary="$(CodeAnalysisSummary)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TLogFile="$(CodeAnalysisTLogFile)" ToolPath="$(CodeAnalysisPath)" TreatWarningsAsErrors="$(_CodeAnalysisTreatWarningsAsErrors)" UpdateProject="$(CodeAnalysisUpdateProject)" Verbose="$(CodeAnalysisVerbose)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </CodeAnalysis>
  </Target>
  <!-- Managed analyzer targets -->
  <!-- Native analyzer targets -->
  <PropertyGroup Condition="'$(RunMsvcAnalysis)'=='true'">
    <RunNativeCodeAnalysisInputs>$(OutputFile)</RunNativeCodeAnalysisInputs>
    <RunNativeCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and Exists('$(CodeAnalysisRuleSet)')">$(RunNativeCodeAnalysisInputs);$(CodeAnalysisRuleSet)</RunNativeCodeAnalysisInputs>
    <RunNativeCodeAnalysisInputs Condition="'$(CodeAnalysisRuleSet)'!='' and !Exists('$(CodeAnalysisRuleSet)') and Exists('$(ProjectDir)$(CodeAnalysisRuleSet)')">$(RunNativeCodeAnalysisInputs);$(ProjectDir)$(CodeAnalysisRuleSet)</RunNativeCodeAnalysisInputs>
    <MergedOutputCodeAnalysisFile>$(IntDir)vc.nativecodeanalysis.all.xml</MergedOutputCodeAnalysisFile>
  </PropertyGroup>
  <Choose>
    <When Condition="'$(RunMsvcAnalysis)'=='true'">
      <Choose>
        <When Condition="'$(PlatformToolsetVersion)'&lt;'120'">
          <PropertyGroup>
            <MergeInputCodeAnalysisFiles>@(ClCompile->'%(PREfastLog)')</MergeInputCodeAnalysisFiles>
          </PropertyGroup>
        </When>
        <Otherwise>
          <PropertyGroup>
            <MergeInputCodeAnalysisFiles>@(ClCompile->'%(PREfastLogFile)')</MergeInputCodeAnalysisFiles>
          </PropertyGroup>
        </Otherwise>
      </Choose>
    </When>
  </Choose>
  <UsingTask TaskName="Microsoft.Build.Tasks.NativeCodeAnalysis" AssemblyFile=".\FxCopTask.dll" />
  <!-- Normal case that runs analysis for a full build -->
  <Target Name="RunNativeCodeAnalysis" Condition="'$(RunMsvcAnalysis)'=='true'" Inputs="$(RunCodeAnalysisInputs);$(MergedOutputCodeAnalysisFile)" Outputs="$(CodeAnalysisSucceededFile);$(NativeCodeAnalysisTLogFile)" DependsOnTargets="$(RunCodeAnalysisDependsOn)">
    <NativeCodeAnalysis IgnoreBuildTaskWarnings="$(CodeAnalysisIgnoreBuildTaskWarnings)" NativeCodeAnalysisLogFiles="$(MergedOutputCodeAnalysisFile)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" NeverReportRuleErrors="$(CodeAnalysisNeverReportRuleErrors)" RuleSet="$(CodeAnalysisRuleSet)" RuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" StaticAnalysisDirectory="$(CodeAnalysisStaticAnalysisDirectory)" TLogFile="$(NativeCodeAnalysisTLogFile)" TreatWarningsAsErrors="$(_CodeAnalysisTreatWarningsAsErrors)" VisualStudioSku="$(CodeAnalysisVSSku)" CodeAnalysisSucceededFile="$(CodeAnalysisSucceededFile)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </NativeCodeAnalysis>
  </Target>
  <!-- Special case that runs analysis for selected file compile -->
  <Target Name="RunSelectedFileNativeCodeAnalysis" Condition="'$(RunMsvcAnalysis)'=='true' and '$(SelectedFiles)'!=''" DependsOnTargets="RunMergeNativeCodeAnalysis;RunNativeCodeAnalysis" AfterTargets="ClCompile">
    <Message Text="Running code analysis targets for selected files $(SelectedFiles)" />
    <!-- Show a warning that results may not be complete if /Gm is enabled during selective compile -->
    <Warning Condition="'%(ClCompile.MinimalRebuild)'!='false' and '$(VCAnalyzeOnly)'=='false'" Text="Minimal rebuild (/Gm) was passed to the compiler, analysis results may be stale." />
  </Target>
  <!-- Native analyzer targets -->
  <!-- Merge native results targets -->
  <UsingTask TaskName="Microsoft.Build.Tasks.MergeNativeCodeAnalysis" AssemblyFile=".\FxCopTask.dll" />
  <Target Name="RunMergeNativeCodeAnalysis" Condition="'$(RunMsvcAnalysis)'=='true'" Inputs="$(RunCodeAnalysisInputs);$(MergeInputCodeAnalysisFiles)" Outputs="$(CodeAnalysisSucceededFile);$(NativeCodeAnalysisTLogFile);$(MergedOutputCodeAnalysisFile)" DependsOnTargets="$(RunMergeNativeCodeAnalysisDependsOn)">
    <MergeNativeCodeAnalysis InputNativeResultFiles="$(MergeInputCodeAnalysisFiles)" OutputCodeAnalysisFile="$(MergedOutputCodeAnalysisFile)" />
  </Target>
  <!-- Merge native results targets -->
  <ItemGroup>
    <Clean Include="$(IntermediateOutputPath)\TempCA\$(TargetName).pdb" />
    <Clean Include="$(IntermediateOutputPath)\TempCA\$(TargetName)$(TargetExt)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(ReportingServicesTargets)" Condition="Exists('$(ReportingServicesTargets)')" />-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.NETFramework.targets" Condition="('$(TargetFrameworkIdentifier)' == ''  or '$(TargetFrameworkIdentifier)' == '.NETFramework') and ('$(TargetRuntime)' == 'Managed')" />-->
  <PropertyGroup xmlns="">
    <ImportXamlTargets Condition="'$(ImportXamlTargets)'=='' and ('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.Xaml.targets')">true</ImportXamlTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Xaml.targets" Condition="('$(ImportXamlTargets)' == 'true')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Xaml.targets
============================================================================================================================================
-->
  <!--
      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
      outside of the .NET Framework.  As a result of this, there were several targets files, of which
      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.

      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
      consumers of them are not broken, but since the targets files themselves are still part of .NET,
      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
  -->
  <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer
      the .NET Framework directory and thus will no longer be the right answer. Override it to point
      to the correct .NET Framework location. -->
  <PropertyGroup xmlns="">
    <XamlBuildTaskPath Condition="'$(XamlBuildTaskPath)' == ''">$(MSBuildToolsPath64)</XamlBuildTaskPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets')">

C:\Windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Xaml.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Xaml.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <LoadTimeSensitiveTargets>
      $(LoadTimeSensitiveTargets);
      XamlMarkupCompilePass1;
    </LoadTimeSensitiveTargets>
    <LoadTimeSensitiveProperties>
      $(LoadTimeSensitiveProperties);
    </LoadTimeSensitiveProperties>
    <TaskVersion>4.0.0.0</TaskVersion>
    <TaskKeyToken>31bf3856ad364e35</TaskKeyToken>
    <XamlBuildTaskAssemblyName Condition="'$(XamlBuildTaskAssemblyName)'==''">XamlBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</XamlBuildTaskAssemblyName>
    <XamlRequiresCompilationPass2 Condition="'$(XamlRequiresCompilationPass2)'==''">false</XamlRequiresCompilationPass2>
    <XamlTemporaryAssemblyName Condition="'$(XamlTemporaryAssemblyName)'==''">$(AssemblyName)</XamlTemporaryAssemblyName>
    <CompileTargetNameForTemporaryAssembly Condition="'$(CompileTargetNameForTemporaryAssembly)' == ''">CompileTemporaryAssembly</CompileTargetNameForTemporaryAssembly>
    <!-- Microsoft.Xaml.targets needs to be included after Microsoft.Fx.targets and Microsoft.DevDiv.targets
       to have a chance to add these tasks to the PrepareResources target's dependencies. 
       Unfortunately, Microsoft.DevDiv.targets completely overwrites the PrepareResourcesDependsOnProperty 
       (as a bug workaround-see comment there).
  -->
    <PrepareResourcesDependsOn>
      XamlMarkupCompilePass1;
      XamlMarkupCompilePass2;
      $(PrepareResourcesDependsOn) 
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <XamlBuildTaskLocation Condition="'$(XamlBuildTaskPath)'==''">$(MSBuildBinPath)</XamlBuildTaskLocation>
    <XamlBuildTaskLocation Condition="'$(XamlBuildTaskPath)'!=''">$(XamlBuildTaskPath)</XamlBuildTaskLocation>
  </PropertyGroup>
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildToolsPath)\Microsoft.Xaml.targets</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <XamlGenCodeFileNames Condition="'$(XamlGenCodeFileNames)'==''">$(MSBuildProjectFile).XamlGeneratedCodeFileListAbsolute.txt</XamlGenCodeFileNames>
    <XamlGenMarkupFileNames Condition="'$(XamlGenMarkupFileNames)'==''">$(MSBuildProjectFile).XamlGeneratedXamlFileListAbsolute.txt</XamlGenMarkupFileNames>
    <XamlPass2FlagFile Condition="'$(XamlPass2FlagFile)'==''">$(MSBuildProjectFile).XamlPass2Flag.txt</XamlPass2FlagFile>
  </PropertyGroup>
  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="XamlAppDef" />
  </ItemGroup>
  <UsingTask Condition="'$(XamlBuildTaskPath)'==''" TaskName="Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask" AssemblyName="$(XamlBuildTaskAssemblyName)" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'!=''" TaskName="Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask" AssemblyFile="$(XamlBuildTaskPath)\XamlBuildTask.dll" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'==''" TaskName="Microsoft.Build.Tasks.Xaml.GenerateTemporaryAssemblyTask" AssemblyName="$(XamlBuildTaskAssemblyName)" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'!=''" TaskName="Microsoft.Build.Tasks.Xaml.GenerateTemporaryAssemblyTask" AssemblyFile="$(XamlBuildTaskPath)\XamlBuildTask.dll" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'==''" TaskName="Microsoft.Build.Tasks.Xaml.CompilationPass2Task" AssemblyName="$(XamlBuildTaskAssemblyName)" />
  <UsingTask Condition="'$(XamlBuildTaskPath)'!=''" TaskName="Microsoft.Build.Tasks.Xaml.CompilationPass2Task" AssemblyFile="$(XamlBuildTaskPath)\XamlBuildTask.dll" />
  <!--
  ================================================================
                         DesignTimeXamlMarkupCompilation
  ================================================================
  -->
  <PropertyGroup>
    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true'">
        DesignTimeXamlMarkupCompilation;
        $(CoreCompileDependsOn)
    </CoreCompileDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <DesignTimeIntermediateOutputPath Condition="'$(DesignTimeIntermediateOutputPath)' == ''">$(IntermediateOutputPath)InProcessTempFiles\</DesignTimeIntermediateOutputPath>
  </PropertyGroup>
  <Target Name="DesignTimeXamlMarkupCompilation">
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(DesignTimeIntermediateOutputPath)" Condition="'@(XamlAppDef)' != ''" />
    <CallTarget Condition="'$(BuildingProject)' != 'true' and '@(XamlAppDef)' != ''" Targets="InProcessXamlMarkupCompilePass1" />
  </Target>
  <!--
  ================================================================
                         InProcessXamlMarkupCompilePass1
  ================================================================
  -->
  <Target Name="InProcessXamlMarkupCompilePass1" Condition="'@(XamlAppDef)' != '' and '$(BuildingProject)' != 'true'">
    <PartialClassGenerationTask BuildTaskPath="$(XamlBuildTaskLocation)" OutputPath="$(DesignTimeIntermediateOutputPath)" Language="$(Language)" ApplicationMarkup="@(XamlAppDef)" References="@(ReferencePath)" RootNamespace="$(RootNamespace)" SourceCodeFiles="@(Compile)" AssemblyName="$(AssemblyName)" IsInProcessXamlMarkupCompile="true" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" XamlBuildTypeInspectionExtensionNames="@(XamlBuildTaskTypeInspectionExtensionName)" XamlBuildTypeGenerationExtensionNames="@(XamlBuildTaskTypeGenerationExtensionName)">
      <Output ItemName="XamlInProcessGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="XamlInProcessGeneratedResources" TaskParameter="GeneratedResources" />
      <!-- This property is not required. However we need to populate it as the output of the task. -->
      <Output PropertyName="XamlInProcessRequiresCompilationPass2" TaskParameter="RequiresCompilationPass2" />
    </PartialClassGenerationTask>
    <ItemGroup>
      <Compile Include="@(XamlInProcessGeneratedCodeFiles)" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                         CleanInProcessXamlGeneratedFiles
  ================================================================
  -->
  <Target Name="CleanInProcessXamlGeneratedFiles" Condition="'@(XamlAppDef)' != '' And '$(BuildingInsideVisualStudio)'!='true'" AfterTargets="DesignTimeXamlMarkupCompilation">
    <ItemGroup>
      <FileWrites Include="$(DesignTimeIntermediateOutputPath)\*" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileReadGeneratedFileList
  ================================================================
  -->
  <Target Name="XamlMarkupCompileReadGeneratedFileList" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" BeforeTargets="XamlMarkupCompilePass1">
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(XamlGenCodeFileNames)">
      <Output TaskParameter="Lines" ItemName="XamlOutputCodeFilesList" />
    </ReadLinesFromFile>
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(XamlGenMarkupFileNames)">
      <Output TaskParameter="Lines" ItemName="XamlOutputMarkupFilesList" />
    </ReadLinesFromFile>
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompilePass1
  ================================================================
  -->
  <Target Name="XamlMarkupCompilePass1" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" Inputs="@(XamlAppDef);@(Compile);$(MSBuildAllProjects);@(ReferencePath)" Outputs="@(XamlOutputMarkupFilesList);&#xD;&#xA;                  @(XamlOutputCodeFilesList);&#xD;&#xA;                  $(IntermediateOutputPath)$(XamlGenCodeFileNames);&#xD;&#xA;                  $(IntermediateOutputPath)$(XamlGenMarkupFileNames);&#xD;&#xA;                  $(IntermediateOutputPath)$(XamlPass2FlagFile);">
    <Message Text="(in) XamlPage: '@(XamlPage)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) XamlAppDef: '@(XamlAppDef)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) SourceCodeFiles: '@(Compile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <ItemGroup>
      <XamlGeneratedResources Remove="@(XamlGeneratedResources)" />
      <XamlGeneratedCodeFiles Remove="@(XamlGeneratedCodeFiles)" />
    </ItemGroup>
    <PartialClassGenerationTask BuildTaskPath="$(XamlBuildTaskLocation)" OutputPath="$(IntermediateOutputPath)" Language="$(Language)" ApplicationMarkup="@(XamlAppDef)" References="@(ReferencePath)" RootNamespace="$(RootNamespace)" SourceCodeFiles="@(Compile)" AssemblyName="$(AssemblyName)" IsInProcessXamlMarkupCompile="false" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" XamlBuildTypeGenerationExtensionNames="@(XamlBuildTaskTypeGenerationExtensionName)" XamlBuildTypeInspectionExtensionNames="@(XamlBuildTaskTypeInspectionExtensionName)">
      <Output ItemName="XamlGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="XamlGeneratedResources" TaskParameter="GeneratedResources" />
      <Output ItemName="XamlFileNames" TaskParameter="ApplicationMarkup" />
      <Output PropertyName="XamlRequiresCompilationPass2" TaskParameter="RequiresCompilationPass2" />
    </PartialClassGenerationTask>
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlGenCodeFileNames)" Lines="@(XamlGeneratedCodeFiles)" Overwrite="true" />
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlGenMarkupFileNames)" Lines="@(XamlGeneratedResources)" Overwrite="true" />
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlPass2FlagFile)" Lines="@(XamlRequiresCompilationPass2)" Overwrite="true" />
    <Message Text="(out) XamlGeneratedCodeFiles: '@(XamlGeneratedCodeFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(out) XamlGeneratedResources: '@(XamlGeneratedResources)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(out) XamlRequiresCompilationPass2 : '$(XamlRequiresCompilationPass2)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileAddFilesGenerated
  ================================================================
  -->
  <Target Name="XamlMarkupCompileAddFilesGenerated" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" AfterTargets="XamlMarkupCompilePass1">
    <ItemGroup>
      <XamlGeneratedCodeFiles Condition="'@(XamlGeneratedCodeFiles)' == ''" Include="@(XamlOutputCodeFilesList)" />
    </ItemGroup>
    <ItemGroup>
      <XamlGeneratedResources Condition="'@(XamlGeneratedResources)' == ''" Include="@(XamlOutputMarkupFilesList)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(XamlGeneratedResources);&#xD;&#xA;                           @(XamlGeneratedCodeFiles);&#xD;&#xA;                           $(IntermediateOutputPath)$(XamlGenCodeFileNames);&#xD;&#xA;                           $(IntermediateOutputPath)$(XamlGenMarkupFileNames)" />
    </ItemGroup>
    <ItemGroup>
      <Compile Include="@(XamlGeneratedCodeFiles)" />
    </ItemGroup>
    <ItemGroup>
      <EmbeddedResource Include="@(XamlGeneratedResources)">
        <GenerateResource>false</GenerateResource>
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </EmbeddedResource>
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileReadPass2Flag
  ================================================================
  -->
  <Target Name="XamlMarkupCompileReadPass2Flag" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" BeforeTargets="XamlMarkupCompilePass2;XamlTemporaryAssemblyGeneration">
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(XamlPass2FlagFile)">
      <Output TaskParameter="Lines" ItemName="XamlRequiresCompilationPass2" />
    </ReadLinesFromFile>
  </Target>
  <!--
  ================================================================
                         XamlTemporaryAssemblyGeneration
  ================================================================
  -->
  <Target Name="XamlTemporaryAssemblyGeneration" Condition="'$(XamlRequiresCompilationPass2)' == 'true' " Inputs="@(XamlAppDef);@(Compile);$(MSBuildAllProjects);@(XamlGeneratedCodeFiles);@(ReferencePath)" Outputs="$(IntermediateOutputPath)$(XamlTemporaryAssemblyName).dll;&#xD;&#xA;                   $(IntermediateOutputPath)$(XamlTemporaryAssemblyName).pdb" DependsOnTargets="XamlMarkupCompilePass1;MarkupCompilePass1">
    <Message Text="(in) MSBuildProjectFile: '$(MSBuildProjectFile)'" Condition="'$(MSBuildTargetsVerbose)' == 'true'" />
    <Message Text="(in) CompileTargetName: '$(CompileTargetName)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) SourceCodeFiles: '@(XamlGeneratedCodeFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <GenerateTemporaryAssemblyTask OutputPath="$(IntermediateOutputPath)" CurrentProject="$(MSBuildProjectFullPath)" SourceCodeFiles="@(XamlGeneratedCodeFiles);@(_GeneratedCodeFiles)" AssemblyName="$(XamlTemporaryAssemblyName)" ApplicationMarkupTypeName="XamlAppDef" CompileTargetName="$(CompileTargetNameForTemporaryAssembly)" ReferencePaths="@(ReferencePath)" GeneratedResourcesFiles="@(XamlGeneratedResources)" />
    <PropertyGroup>
      <_XamlTemporaryAssemblyPath_>$(IntermediateOutputPath)$(XamlTemporaryAssemblyName).dll</_XamlTemporaryAssemblyPath_>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(XamlTemporaryAssemblyName).*" />
    </ItemGroup>
  </Target>
  <Target Name="CompileTemporaryAssembly" DependsOnTargets="BuildOnlySettings;ResolveKeySource;_GenerateCompileInputs;CoreCompile" />
  <!--
  ================================================================
                         XamlMarkupCompilePass2
  ================================================================
  -->
  <Target Name="XamlMarkupCompilePass2" Condition="'$(XamlRequiresCompilationPass2)' == 'true' " Outputs="@(ExtensionGeneratedCodeFiles)" DependsOnTargets="XamlTemporaryAssemblyGeneration">
    <Message Text="(in) XamlPage: '@(XamlPage)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) XamlAppDef: '@(XamlAppDef)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <Message Text="(in) References: '@(ReferencePath);$(_XamlTemporaryAssemblyPath_)'" Condition="'$(MSBuildTargetsVerbose)'=='true'" />
    <CompilationPass2Task BuildTaskPath="$(XamlBuildTaskLocation)" ApplicationMarkup="@(XamlAppDef)" References="@(ReferencePath)" LocalAssemblyReference="$(_XamlTemporaryAssemblyPath_)" AssemblyName="$(AssemblyName)" RootNamespace="$(RootNamespace)" OutputPath="$(IntermediateOutputPath)" Language="$(Language)" SourceCodeFiles="@(Compile)" IsInProcessXamlMarkupCompile="false" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" MSBuildArchitecture="$(PlatformTargetAsMSBuildArchitecture)" XamlBuildTypeInspectionExtensionNames="@(XamlBuildTaskTypeInspectionExtensionName)" ApplicationMarkupWithTypeName="@(XamlFileNames)">
      <Output ItemName="ExtensionGeneratedCodeFiles" TaskParameter="ExtensionGeneratedCodeFiles" />
    </CompilationPass2Task>
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlPass2FlagFile)" Lines="false" Overwrite="true" />
    <Message Text="(out) ExtensionGeneratedCodeFiles: '@(ExtensionGeneratedCodeFiles)'" />
    <!-- Add extension files to the list of generated files so that they can be monitored and cleaned up -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(XamlGenCodeFileNames)" Lines="@(ExtensionGeneratedCodeFiles)" Overwrite="false" />
  </Target>
  <!--
  ================================================================
                         XamlMarkupCompileAddFilesGenerated
  ================================================================
  -->
  <Target Name="XamlMarkupCompileAddExtensionFilesGenerated" Condition="'@(XamlPage)' != '' or '@(XamlAppDef)' != ''" AfterTargets="XamlMarkupCompilePass2">
    <ItemGroup>
      <FileWrites Include="@(ExtensionGeneratedCodeFiles)" />
    </ItemGroup>
    <ItemGroup>
      <Compile Include="@(ExtensionGeneratedCodeFiles)" />
    </ItemGroup>
  </Target>
  <!--
  ================================================================
                 GetCopyToOutputDirectoryXamlAppDefs

  Get all XamlAppDefs that may need to be transferred to the output directory.
  Compare GetCopyToOutputDirectoryItems in Microsoft.Common.targets
  ================================================================
  -->
  <Target Name="GetCopyToOutputDirectoryXamlAppDefs" BeforeTargets="GetCopyToOutputDirectoryItems">
    <ItemGroup>
      <_XamlAppDefItemsToCopy Include="@(XamlAppDef->'%(FullPath)')" Condition="'%(XamlAppDef.CopyToOutputDirectory)'=='Always' or '%(XamlAppDef.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <AssignTargetPath Files="@(_XamlAppDefItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_XamlAppDefItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <!-- The _SourceItems properties are internal to Microsoft.Common.targets,
         but necessary to use here because there is no public equivalent -->
    <ItemGroup>
      <AllItemsFullPathWithTargetPath Include="@(_XamlAppDefItemsToCopyWithTargetPath)" />
      <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_XamlAppDefItemsToCopyWithTargetPath)" Condition="'%(_XamlAppDefItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_SourceItemsToCopyToOutputDirectory Include="@(_XamlAppDefItemsToCopyWithTargetPath)" Condition="'%(_XamlAppDefItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Xaml.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- imports Microsoft.WorkflowBuildExtensions.targets only if TargetFrameworkVersion is v4.5 or above or TargetFrameworkfVersion specified does not conform to the format of vX.X[.X.X] -->
  <!-- Underlying assumption is that there shouldn't be any other versions between v4.0.* and v4.5 -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5' and (!$([System.String]::IsNullOrEmpty('$(TargetFrameworkVersion)')) and !$(TargetFrameworkVersion.StartsWith('v4.0')))) and Exists('$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')" />-->
  <PropertyGroup xmlns="">
    <MsTestToolsTargets Condition="'$(MsTestToolsTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TeamTest\Microsoft.TeamTest.targets</MsTestToolsTargets>
  </PropertyGroup>
  <!--<Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />-->
  <PropertyGroup xmlns="">
    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'" />-->
  <!-- App packaging support -->
  <!--
    Following two targets are needed to be present in every project being built
    because the app packaging targets recursively scan all projects referenced
    from projects that generate app packages for them.
  -->
  <Target Name="CleanAppxPackage" xmlns="" />
  <Target Name="GetPackagingOutputs" xmlns="" />
  <PropertyGroup xmlns="">
    <MsAppxPackageTargets Condition="'$(MsAppxPackageTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\Microsoft.AppXPackage.Targets</MsAppxPackageTargets>
    <!-- Opt-out switch to allow disabling importing the 'AppxPackage' targets for UWP class libraries using modern .NET -->
    <EnableAppxPackageTargetsForUwpClassLibraries Condition="'$(EnableAppxPackageTargetsForUwpClassLibraries)' == ''">true</EnableAppxPackageTargetsForUwpClassLibraries>
  </PropertyGroup>
  <!--
    We want to import the 'AppXPackage' .targets in two scenarios:
      - For legacy UWP, in all cases (original behavior). These projects will always set 'WindowsAppContainer' by default.
      - For UWP (XAML) apps and libraries on modern .NET, we only enable this for class libraries. This allows the existing
        .appx tooling to take care of generating .pri resources without the need to pull in WinAppSDK or other external tools.
        We cannot use this for applications, because the rest of that tooling is not capable of handling modern .NET projects.
        In that case, we either leverage the tooling in WinAppSDK, or DesktopBridge (via a .wapproj project for packaging).
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MsAppxPackageTargets)" Condition="('$(WindowsAppContainer)' == 'true' or ('$(UseUwpTools)' == 'true' and '$(OutputType)' == 'Library' and '$(EnableAppxPackageTargetsForUwpClassLibraries)' != 'false')) and Exists('$(MsAppxPackageTargets)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VisualStudio\v17.0\AppxPackage\Microsoft.AppXPackage.Targets
============================================================================================================================================
-->
  <!-- ========================================================================== -->
  <!-- Note: After updating this file, make sure that                             -->
  <!-- %DepotRoot%\xmake\XmakeCommandLine\Microsoft.Build.CommonTypes.xsd         -->
  <!-- is updated to reflect changes.                                             -->
  <!--                                                                            -->
  <!-- To test whether schema changes are OK, copy changed XSD file to            -->
  <!-- %ProgramFiles(x86)%\Microsoft Visual Studio 15.0\Xml\Schemas\1033\MSBuild, -->
  <!-- then open this file in Visual Studio.                                      -->
  <!-- It should not display any schema warnings in error list window.            -->
  <!-- ========================================================================== -->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <AppxMSBuildToolsPath Condition="'$(AppxMSBuildToolsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\</AppxMSBuildToolsPath>
    <PriProjTaskAssembly Condition="'$(PriProjTaskAssembly)' == ''">$(AppxMSBuildToolsPath)\Microsoft.Build.Packaging.Pri.Tasks.dll</PriProjTaskAssembly>
    <AppxMSBuildTaskAssembly Condition="'$(AppxMSBuildTaskAssembly)' == ''">$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll</AppxMSBuildTaskAssembly>
  </PropertyGroup>
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreateAppInstallerPublishMeta" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreateAppStoreContainer" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExpandPayloadDirectories" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExtractStoreAssociationInformation" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterItemGroup" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterOutUnusedLanguagesResourceFileMaps" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppInstallerFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxLayout" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxPackageRecipe" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxSymbolPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateDisposableSigningCertificate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateFinalAppxLayout" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateLandingPage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateMappingFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateProjectArchitecturesFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetAppxBundlePlatforms" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetAppxFlatBundlePackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetDefaultResourceLanguage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetFrameworkSdkPackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetPackageArchitecture" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkFileFullPath" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkPropertyValue" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetUnionWinmdPropertyValues" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetWindowsDesktopSdkDir" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutAssetPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutPrebuiltPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.HydrateAppxLayoutResourcePackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxContentGroupMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxFlatBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxPack" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ParsePlatformSpecificBundleArtifactsLists" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ReadAppxLayoutTemplate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDisposableSigningCertificate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDuplicateSDKReferences" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemovePayloadDuplicates" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveRedundantCopyLocalItems" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveRedundantXamlFilesFromSdkPayload" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.SignAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.SignAppxPackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.StoreSubmission" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.UpdateAppxManifestForBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifestItems" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxOptionalPackageUploadBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAzureCodeSigningVersion" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAzureKeyVaultVersion" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateBundleMapping" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateConfiguration" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidatePipeline" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidatePublisherName" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateSigningCertificate" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateStoreManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.VerifyAppxBundlePlatforms" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.ExpandPriContent" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriConfigXmlForSplitting" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriConfigXmlForMainPackageFileMap" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriConfigXmlForFullIndex" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.CreatePriFilesForPortableLibraries" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.GenerateMainPriConfigurationFile" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.GeneratePriConfigurationFiles" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.GenerateProjectPriFile" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.RemoveDuplicatePriFiles" />
  <UsingTask AssemblyFile="$(PriProjTaskAssembly)" TaskName="Microsoft.Build.Packaging.Pri.Tasks.UpdateMainPackageFileMap" />
  <!-- Adjust AppxPackage to be true Boolean flag. -->
  <PropertyGroup>
    <AppxPackage Condition="'$(AppxPackage)' != 'true'">false</AppxPackage>
  </PropertyGroup>
  <!-- Adjust DeployOptionalPackages to be true Boolean flag. -->
  <PropertyGroup>
    <DeployOptionalPackages Condition="'$(DeployOptionalPackages)' != 'true'">false</DeployOptionalPackages>
  </PropertyGroup>
  <!-- Flags controlling certain features -->
  <PropertyGroup>
    <AppxUseHardlinksIfPossible Condition="'$(AppxUseHardlinksIfPossible)' == ''">false</AppxUseHardlinksIfPossible>
    <AppxUseHardlinksForNugetIfPossible Condition="'$(AppxUseHardlinksForNugetIfPossible)' == ''">false</AppxUseHardlinksForNugetIfPossible>
    <AppxSkipUnchangedFiles Condition="'$(AppxSkipUnchangedFiles)' == ''">true</AppxSkipUnchangedFiles>
    <AppxGeneratePriEnabled Condition="'$(AppxGeneratePriEnabled)' == ''">true</AppxGeneratePriEnabled>
    <AppxGetPackagePropertiesEnabled Condition="'$(AppxGetPackagePropertiesEnabled)' == ''">true</AppxGetPackagePropertiesEnabled>
    <AppxPackageIncludePrivateSymbols Condition="'$(AppxPackageIncludePrivateSymbols)' == ''">false</AppxPackageIncludePrivateSymbols>
    <AppxSymbolPackageEnabled Condition="'$(AppxSymbolPackageEnabled)' == ''">true</AppxSymbolPackageEnabled>
    <AppxTestLayoutEnabled Condition="'$(AppxTestLayoutEnabled)' == ''">true</AppxTestLayoutEnabled>
    <AppxPackageValidationEnabled Condition="'$(AppxPackageValidationEnabled)' == ''">true</AppxPackageValidationEnabled>
    <AppxHarvestWinmdRegistration Condition="'$(AppxHarvestWinmdRegistration)' == ''">true</AppxHarvestWinmdRegistration>
    <AppxPrependPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == ''">true</AppxPrependPriInitialPath>
    <EnableSigningChecks Condition=" '$(EnableSigningChecks)' == '' ">true</EnableSigningChecks>
    <AppxStrictManifestValidationEnabled Condition="'$(AppxStrictManifestValidationEnabled)' == ''">true</AppxStrictManifestValidationEnabled>
    <AppxFilterOutUnusedLanguagesResourceFileMaps Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == ''">true</AppxFilterOutUnusedLanguagesResourceFileMaps>
    <AppxGeneratePrisForPortableLibrariesEnabled Condition="'$(AppxGeneratePrisForPortableLibrariesEnabled)' == ''">true</AppxGeneratePrisForPortableLibrariesEnabled>
    <AppxGeneratePackageRecipeEnabled Condition="'$(AppxGeneratePackageRecipeEnabled)' == ''">true</AppxGeneratePackageRecipeEnabled>
    <BuildOptionalProjects Condition="'$(BuildOptionalProjects)' == ''">true</BuildOptionalProjects>
    <PackageOptionalProjectsInIdeBuilds Condition="'$(PackageOptionalProjectsInIdeBuilds)' == ''">false</PackageOptionalProjectsInIdeBuilds>
    <AppxStreamableMainPackage Condition="'$(AppxStreamableMainPackage)' == ''">true</AppxStreamableMainPackage>
    <AppxStreamableResourcePackages Condition="'$(AppxStreamableResourcePackages)' == ''">false</AppxStreamableResourcePackages>
    <AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent Condition="'$(AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent)' != 'false'">true</AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent>
    <AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent Condition="'$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)' != 'false'">true</AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent>
    <AppxRemoveRedundantCopyLocalItems Condition="'$(AppxRemoveRedundantCopyLocalItems)' != 'false'">true</AppxRemoveRedundantCopyLocalItems>
    <GenerateLibraryLayout Condition="'$(GenerateLibraryLayout)' == '' AND ('$(OutputType)' != 'AppContainerExe' AND '$(OutputType)' != 'Exe' AND '$(OutputType)' != 'WinExe')">true</GenerateLibraryLayout>
    <UseSdkBuildToolsPackage Condition="'$(UseSdkBuildToolsPackage)' == '' AND '$(WindowsSDKBuildToolsVersion)' != ''">true</UseSdkBuildToolsPackage>
    <GenerateTemporaryStoreCertificate Condition="'$(GenerateTemporaryStoreCertificate)' == ''">false</GenerateTemporaryStoreCertificate>
    <AzureCodeSigningEnabled Condition="'$(AzureCodeSigningEnabled)' == ''">false</AzureCodeSigningEnabled>
    <AzureKeyVaultEnabled Condition="'$(AzureKeyVaultEnabled)' == ''">false</AzureKeyVaultEnabled>
  </PropertyGroup>
  <PropertyGroup>
    <SdkIsRS1OrLater>false</SdkIsRS1OrLater>
    <SdkIsRS1OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.11000.0'">true</SdkIsRS1OrLater>
    <SdkIsRS4OrLater>false</SdkIsRS4OrLater>
    <SdkIsRS4OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.17000.0'">true</SdkIsRS4OrLater>
    <SdkIs22H2OrLater>false</SdkIs22H2OrLater>
    <SdkIs22H2OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.22621.0'">true</SdkIs22H2OrLater>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseSdkBuildToolsPackage)' == 'true'">
    <BuildToolsIs22H2OrLater>false</BuildToolsIs22H2OrLater>
    <BuildToolsIs22H2OrLater Condition="'$(WindowsSDKBuildToolsVersion)' &gt;= '10.0.22621.0'">true</BuildToolsIs22H2OrLater>
  </PropertyGroup>
  <!-- Several tasks rely on loading native dlls which are not available as arm64 in pre-22H2 versions of the SDK and build tools package.
       So if we're running as arm64 and targeting one of these older versions we have to force them to use x64 instead. -->
  <PropertyGroup Condition="'$(UseX64ToolsOnArm64OS)' == '' and '$([System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture)' == 'arm64'">
    <UseX64ToolsOnArm64OS>true</UseX64ToolsOnArm64OS>
    <UseX64ToolsOnArm64OS Condition="'$(UseSdkBuildToolsPackage)' != 'true' and '$(SdkIs22H2OrLater)' == 'true'">false</UseX64ToolsOnArm64OS>
    <UseX64ToolsOnArm64OS Condition="'$(UseSdkBuildToolsPackage)' == 'true' and '$(BuildToolsIs22H2OrLater)' == 'true'">false</UseX64ToolsOnArm64OS>
  </PropertyGroup>
  <UsingTask Condition="'$(UseX64ToolsOnArm64OS)' == 'true'" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifest" AssemblyFile="$(AppxMSBuildTaskAssembly)" Override="true" Architecture="x64" />
  <UsingTask Condition="'$(UseX64ToolsOnArm64OS)' == 'true'" TaskName="Microsoft.Build.AppxPackage.GenerateAppInstallerFile" AssemblyFile="$(AppxMSBuildTaskAssembly)" Override="true" Architecture="x64" />
  <UsingTask Condition="'$(UseX64ToolsOnArm64OS)' == 'true'" TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.CompileXaml" AssemblyFile="$([MSBuild]::Unescape($(WindowsKitsPath)))\bin\$(TargetPlatformVersion)\XamlCompiler\Microsoft.Windows.UI.Xaml.Build.Tasks.dll" Override="true" Architecture="x64" />
  <PropertyGroup>
    <AppxWinMdCacheEnabled Condition="'$(AppxWinMdCacheEnabled)' == ''">true</AppxWinMdCacheEnabled>
    <AppxWinMdCacheDir Condition="'$(AppxWinMdCacheDir)' == ''">$(IntermediateOutputPath).winmd_cache</AppxWinMdCacheDir>
  </PropertyGroup>
  <PropertyGroup>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'Windows Phone'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'WindowsPhoneApp'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(_TargetPlatformIsWindowsPhone)' == ''">false</_TargetPlatformIsWindowsPhone>
  </PropertyGroup>
  <PropertyGroup>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' != 'true' and&#xD;&#xA;                                          '$(PackageCertificateThumbprint)' == '' and&#xD;&#xA;                                          '$(PackageCertificateKeyFile)' == ''">false</AppxPackageSigningEnabled>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' != 'false'">true</AppxPackageSigningEnabled>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AzureCodeSigningDlibVersion)' != ''">
    <AzureCodeSigningEnabled>true</AzureCodeSigningEnabled>
    <SkipPublisherNameValidation>true</SkipPublisherNameValidation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AzureKeyVaultUrl)' != '' and '$(AzureKeyVaultCertificateId)' != ''">
    <AzureKeyVaultEnabled>true</AzureKeyVaultEnabled>
    <AzureKeyVaultDlibFilePath>$(VsInstallRoot)\Common7\IDE\CommonExtensions\Microsoft\TailoredProjectServices\AzureKeyVault\AzureKeyVault.Dlib.dll</AzureKeyVaultDlibFilePath>
    <SkipPublisherNameValidation>true</SkipPublisherNameValidation>
  </PropertyGroup>
  <!-- Various properties not intended for overriding. -->
  <PropertyGroup>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and  '$(SDKIdentifier)' != ''">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(_TargetPlatformIsWindowsPhone)' == 'true'">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(TargetPlatformIdentifier)' == 'Windows'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == ''">6.2.1</AppxOSMinVersion>
  </PropertyGroup>
  <PropertyGroup>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(SDKIdentifier)' != ''">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == ''">$(AppxOSMinVersion)</AppxOSMaxVersionTested>
  </PropertyGroup>
  <PropertyGroup>
    <NuGetTargetFramework Condition="'$(NuGetTargetFramework)'==''">$(TargetPlatformIdentifier),Version=v$(TargetPlatformMinVersion)</NuGetTargetFramework>
    <ResolveAssemblyConflicts>true</ResolveAssemblyConflicts>
    <!--
      If we are on .NET 9 or greater (ie. if this is a UWP app with .NET 9 support), we need to drop unsupported
      runtime identifier. .NET 8 made a breaking changes with respect to RIDs for projects, which means we can't
      use 'win10' anymore, but rather we should just use 'win-' as the prefix. Additionally, several RIDs are not
      supported anymore for latest .NET, such as 'arm'. Note: while technically it is possible to also target .NET
      8 for UWP apps, here we only check for .NET 9, so that we can also indicate 'win-x86' as one of the RIDs. This
      RID is only supported starting from .NET 9. Additionally, UWP only officially supports .NET 9 and above when
      using latest .NET, so .NET 8 is not a scenario we're concerned about here.
      
      We are first checking the target platform identifier to avoid calling 'VersionGreaterThanOrEquals' for UWP
      projects using .NET Native and not latest .NET, to minimize the impact on existing projects not using .NET 9.
      We saw some small perf DDRITs regressions before when we introduced new MSBuild function calls in .targets that
      were shared with existing UWP projects, so we only want to use this when we have excluded that project type.
      UWP projects using .NET Native will always have 'UAP' as target platform identifier.

      Note: this .targets file is also used by C++ projects, so we do two additional things here:
        - Check that 'UsingMicrosoftNETSdk' is set, to further filter out any legacy-style .NET projects
        - Check that 'TargetFrameworkVersion' is set, as otherwise the call to 'VersionGreaterThanOrEquals' will
          fail and produce a build error. C++ projects do not set 'TargetFramework', so the version will be empty.
    -->
    <RuntimeIdentifiers Condition="'$(RuntimeIdentifiers)' == ''&#xD;&#xA;                                   AND '$(UsingMicrosoftNETSdk)' == 'true'&#xD;&#xA;                                   AND '$(TargetPlatformIdentifier)' == 'Windows'&#xD;&#xA;                                   AND '$(TargetFrameworkVersion)' != ''&#xD;&#xA;                                   AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '9.0'))">win-x86;win-x64;win-arm64</RuntimeIdentifiers>
    <RuntimeIdentifiers Condition="'$(RuntimeIdentifiers)' == ''">win10-arm;win10-arm-aot;win10-arm64-aot;win10-x86;win10-x86-aot;win10-x64;win10-x64-aot</RuntimeIdentifiers>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformMinVersion)'!=''">
    <AssetTargetFallback Condition="'$(TargetPlatformMinVersion)' &gt; '10.0.15063.0'">$(AssetTargetFallback);net461</AssetTargetFallback>
  </PropertyGroup>
  <!-- If producing a reference winmd we want to use .net native -->
  <PropertyGroup>
    <ProjectNProfileEnabled Condition="'$(ProjectNProfileEnabled)' == ''">$(ProduceReferenceWinmd)</ProjectNProfileEnabled>
  </PropertyGroup>
  <PropertyGroup>
    <AppxPackageDirName Condition="'$(AppxPackageDirName)' == ''">AppPackages</AppxPackageDirName>
    <AppxPackageDirWasSpecified Condition="'$(AppxPackageDir)' != ''">true</AppxPackageDirWasSpecified>
    <AppxPackageDirInProjectDir>$(ProjectDir)$(AppxPackageDirName)\</AppxPackageDirInProjectDir>
    <PlatformSpecificBundleArtifactsListDirName Condition="'$(PlatformSpecificBundleArtifactsListDirName)' == ''">BundleArtifacts</PlatformSpecificBundleArtifactsListDirName>
    <PlatformSpecificBundleArtifactsListDirWasSpecified Condition="'$(PlatformSpecificBundleArtifactsListDir)' != ''">true</PlatformSpecificBundleArtifactsListDirWasSpecified>
    <PlatformSpecificBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDirInProjectDir>
    <PlatformSpecificUploadBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)Upload\</PlatformSpecificUploadBundleArtifactsListDirInProjectDir>
  </PropertyGroup>
  <!-- Various overridable properties. -->
  <PropertyGroup>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(AppxPackageDirName)\</AppxPackageDir>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == ''">$(AppxPackageDirInProjectDir)</AppxPackageDir>
    <AppxManifestFileName Condition="'$(AppxManifestFileName)' == ''">AppxManifest.xml</AppxManifestFileName>
    <AppxBundleManifestFileName Condition="'$(AppxBundleManifestFileName)' == ''">AppxBundleManifest.xml</AppxBundleManifestFileName>
    <AppxPackageArtifactsDir Condition="'$(AppxPackageArtifactsDir)' == ''" />
    <AppxUploadPackageArtifactsDir Condition="'$(AppxUploadPackageArtifactsDir)' == ''">Upload\</AppxUploadPackageArtifactsDir>
    <ExternalPackagesDir Condition="'$(ExternalPackagesDir)' == ''">ExternalPackages\</ExternalPackagesDir>
    <FinalAppxManifestName Condition="'$(FinalAppxManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxManifestName>
    <FinalAppxUploadManifestName Condition="'$(FinalAppxUploadManifestName)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxUploadManifestName>
    <FinalAppxBundleManifestName Condition="'$(FinalAppxBundleManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)AppxMetadata\$(AppxBundleManifestFileName)</FinalAppxBundleManifestName>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' == ''">true</AppxValidateAppxManifest>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' != 'true'">false</AppxValidateAppxManifest>
    <StoreManifestName Condition="'$(StoreManifestName)' == ''">StoreManifest.xml</StoreManifestName>
    <!-- AppxValidateStoreManifest isn't defined here, because the default depends on the TargetPlatform/Version -->
    <MakePriExeFullPath Condition="'$(MakePriExeFullPath)' == ''" />
    <MakeAppxExeFullPath Condition="'$(MakeAppxExeFullPath)' == ''" />
    <SignAppxPackageExeFullPath Condition="'$(SignAppxPackageExeFullPath)' == ''" />
    <TempCertificateFilePath Condition="$(TempCertificateFilePath) == ''">$(IntermediateOutputPath)StoreKey_Temp.pfx</TempCertificateFilePath>
    <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    <PdbCmfx64ExeFullPath Condition="'$(PdbCmfx64ExeFullPath)' == ''">$(AppxMSBuildToolsPath)\x64\mspdbcmf.exe</PdbCmfx64ExeFullPath>
    <PdbCmfx86ExeFullPath Condition="'$(PdbCmfx86ExeFullPath)' == ''">$(AppxMSBuildToolsPath)\x86\mspdbcmf.exe</PdbCmfx86ExeFullPath>
    <AppxSymbolIntermediateDir Condition="'$(AppxSymbolIntermediateDir)' == ''">$(IntermediateOutputPath)Symbols</AppxSymbolIntermediateDir>
    <AppxUploadSymbolIntermediateDir Condition="'$(AppxUploadSymbolIntermediateDir)' == ''">$(IntermediateOutputPath)Upload.Symbols</AppxUploadSymbolIntermediateDir>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' != 'true'" />
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' == 'true' and '$(AppxPriInitialPath)' == ''" />
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == ''">$(TargetName)</AppxPriInitialPath>
    <ProjectPriFileName Condition="'$(AppxPackage)' == 'true' and '$(ProjectPriFileName)' == ''">resources.pri</ProjectPriFileName>
    <ProjectPriFileName Condition="'$(AppxPackage)' != 'true' and '$(ProjectPriFileName)' == '' and '$(AppxPriInitialPath)' == ''">$(TargetName).pri</ProjectPriFileName>
    <ProjectPriFileName Condition="'$(AppxPackage)' != 'true' and '$(ProjectPriFileName)' == '' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath).pri</ProjectPriFileName>
    <ProjectPriFullPath Condition="'$(ProjectPriFullPath)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriFullPath>
    <ProjectPriUploadFullPath Condition="'$(ProjectPriUploadFullPath)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriUploadFullPath>
    <AppxPackageRecipe Condition="'$(AppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxPackageRecipe>
    <AppxUploadPackageRecipe Condition="'$(AppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxUploadPackageRecipe>
    <FinalAppxPackageRecipe Condition="'$(FinalAppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxPackageRecipe>
    <FinalAppxUploadPackageRecipe Condition="'$(FinalAppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxUploadPackageRecipe>
    <AllowLocalNetworkLoopback Condition="'$(AllowLocalNetworkLoopback)' == ''">true</AllowLocalNetworkLoopback>
    <AppxDefaultHashAlgorithmId Condition="'$(AppxDefaultHashAlgorithmId)' == ''">sha256</AppxDefaultHashAlgorithmId>
    <AppxPackageFileMap Condition="'$(AppxPackageFileMap)' == ''">$(IntermediateOutputPath)package.map.txt</AppxPackageFileMap>
    <AppxUploadPackageFileMap Condition="'$(AppxUploadPackageFileMap)' == ''">$(IntermediateOutputPath)upload.package.map.txt</AppxUploadPackageFileMap>
    <LayoutDir Condition="'$(LayoutDir)'==''">$(TargetDir)AppX</LayoutDir>
    <ManagedWinmdInprocImplementation Condition="'$(ManagedWinmdInprocImplementation)' == ''">CLRHost.dll</ManagedWinmdInprocImplementation>
    <UseIncrementalAppxRegistration Condition="'$(UseIncrementalAppxRegistration)' == ''">true</UseIncrementalAppxRegistration>
    <AppxPackagingInfoFile Condition="'$(AppxPackagingInfoFile)' == ''">$(IntermediateOutputPath)_pkginfo.txt</AppxPackagingInfoFile>
    <AppxOSMinVersionReplaceManifestVersion Condition="'$(AppxOSMinVersionReplaceManifestVersion)' == ''">true</AppxOSMinVersionReplaceManifestVersion>
    <AppxOSMaxVersionTestedReplaceManifestVersion Condition="'$(AppxOSMaxVersionTestedReplaceManifestVersion)' == ''">true</AppxOSMaxVersionTestedReplaceManifestVersion>
    <InstallerFileWritesLogPath Condition="'$(InstallerFileWritesLogPath)' == ''">$(IntermediateOutputPath)_installerinfo.log</InstallerFileWritesLogPath>
    <PackagingFileWritesLogPath Condition="'$(PackagingFileWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingFileWrites.log</PackagingFileWritesLogPath>
    <PackagingDirectoryWritesLogPath Condition="'$(PackagingDirectoryWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingDirectoryWrites.log</PackagingDirectoryWritesLogPath>
    <AppxCopyLocalFilesOutputGroupIncludeXmlFiles Condition="'$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' != 'true'">false</AppxCopyLocalFilesOutputGroupIncludeXmlFiles>
    <AppxPriConfigXmlPackagingSnippetPath Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''" />
    <AppxPriConfigXmlDefaultSnippetPath Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''" />
    <TargetPlatformSdkRootOverride Condition="'$(TargetPlatformSdkRootOverride)' == ''" />
    <TargetPlatformResourceVersion Condition="'$(TargetPlatformResourceVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformResourceVersion>
    <AppxMappingFileDir Condition="'$(AppxMappingFileDir)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)</AppxMappingFileDir>
    <AppxUploadMappingFileDir Condition="'$(AppxUploadMappingFileDir)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)</AppxUploadMappingFileDir>
    <WinMetadataDir Condition="'$(WinMetadataDir)' == ''">WinMetadata</WinMetadataDir>
    <EntryPointDir Condition="'$(EntryPointDir)' == ''">entrypoint</EntryPointDir>
    <AppxManifestTargetPath Condition="'$(AppxManifestTargetPath)' == ''">$(AppxManifestFileName)</AppxManifestTargetPath>
    <DeploymentRecipeTargetPath Condition="'$(DeploymentRecipeTargetPath)' == ''">vs.appxrecipe</DeploymentRecipeTargetPath>
    <AppxBundle Condition="'$(TargetPlatformVersion)' == '8.0'">Never</AppxBundle>
    <AppxBundleDefaultValueUsed Condition="'$(AppxBundle)' == ''">true</AppxBundleDefaultValueUsed>
    <AppxBundleDefaultValueUsed Condition="'$(AppxBundleDefaultValueUsed)' == ''">false</AppxBundleDefaultValueUsed>
    <AppxBundle Condition="'$(AppxBundle)' == ''">Auto</AppxBundle>
    <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''" />
    <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''" />
    <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''" />
    <AppxLayoutFolderName Condition="'$(AppxLayoutFolderName)' == ''">PackageLayout</AppxLayoutFolderName>
    <IntermediateUploadOutputPath Condition="'$(IntermediateUploadOutputPath)' == ''">$(IntermediateOutputPath)Upload\</IntermediateUploadOutputPath>
    <AppxUploadPackagingInfoFile Condition="'$(AppxUploadPackagingInfoFile)' == ''">$(IntermediateUploadOutputPath)_upkginfo.txt</AppxUploadPackagingInfoFile>
    <AppxLayoutDir Condition="'$(AppxLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxLayoutFolderName)\</AppxLayoutDir>
    <AppxUploadLayoutFolderName Condition="'$(AppxUploadLayoutFolderName)' == ''">PackageUploadLayout</AppxUploadLayoutFolderName>
    <AppxUploadLayoutDir Condition="'$(AppxUploadLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxUploadLayoutFolderName)</AppxUploadLayoutDir>
    <AppxBundleSplitResourcesPriPrefix Condition="'$(AppxBundleSplitResourcesPriPrefix)' == ''">split</AppxBundleSplitResourcesPriPrefix>
    <AppxBundlePriConfigXmlForSplittingFileName Condition="'$(AppxBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxBundlePriConfigXmlForSplittingFileName>
    <AppxUploadBundlePriConfigXmlForSplittingFileName Condition="'$(AppxUploadBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxUploadBundlePriConfigXmlForSplittingFileName>
    <AppxBundleAutoResourcePackageQualifiers Condition="'$(AppxBundleAutoResourcePackageQualifiers)' == ''">Language|Scale|DXFeatureLevel</AppxBundleAutoResourcePackageQualifiers>
    <AppxBundleSplitResourcesPriPath Condition="'$(AppxBundleSplitResourcesPriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxBundleSplitResourcesPriPath>
    <AppxBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxBundleSplitResourcesGeneratedFilesListPath>
    <AppxBundleSplitResourcesQualifiersPath Condition="'$(AppxBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxBundleSplitResourcesQualifiersPath>
    <AppxUploadBundleSplitResourcesPriPath Condition="'$(AppxUploadBundleSplitResourcesPriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxUploadBundleSplitResourcesPriPath>
    <AppxUploadBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxUploadBundleSplitResourcesGeneratedFilesListPath>
    <AppxUploadBundleSplitResourcesQualifiersPath Condition="'$(AppxUploadBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxUploadBundleSplitResourcesQualifiersPath>
    <AppxBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateOutputPath)filemap.priconfig.xml</AppxBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateUploadOutputPath)filemap.priconfig.xml</AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxBundleMainPackageFileMapIntermediatePrefix Condition="'$(AppxBundleMainPackageFileMapIntermediatePrefix)' == ''">filemap</AppxBundleMainPackageFileMapIntermediatePrefix>
    <AppxBundleMainPackageFileMapSuffix Condition="'$(AppxBundleMainPackageFileMapSuffix)' == ''">.map</AppxBundleMainPackageFileMapSuffix>
    <AppxBundleMainPackageFileMapIntermediatePath Condition="'$(AppxBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapIntermediatePath>
    <AppxBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxBundleMainPackageFileMapIntermediatePriPath>
    <AppxBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxBundleMainPackageFileMapPrefix Condition="'$(AppxBundleMainPackageFileMapPrefix)' == ''">main</AppxBundleMainPackageFileMapPrefix>
    <AppxBundleMainPackageFileMapPath Condition="'$(AppxBundleMainPackageFileMapPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapPath>
    <AppxUploadBundleMainPackageFileMapIntermediatePath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapIntermediatePath>
    <AppxUploadBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxUploadBundleMainPackageFileMapIntermediatePriPath>
    <AppxUploadBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxUploadBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxUploadBundleMainPackageFileMapPath Condition="'$(AppxUploadBundleMainPackageFileMapPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapPath>
    <AppxBundleFolderSuffix Condition="'$(AppxBundleFolderSuffix)' == ''">_Bundle</AppxBundleFolderSuffix>
    <AppxLayoutFileName Condition="'$(AppxLayoutFileName)' == ''">App.packagelayout</AppxLayoutFileName>
    <UseAppxLayout Condition="'$(UseAppxLayout)' == ''">false</UseAppxLayout>
    <AppxLayoutIsTemplate Condition="'$(AppxLayoutIsTemplate)' == ''">false</AppxLayoutIsTemplate>
    <AppInstallerTemplateFileName Condition="'$(AppInstallerTemplateFileName)' == ''">Package.appinstaller</AppInstallerTemplateFileName>
    <PlatformAppxLayoutFileName>PackageLayout_{0}.xml</PlatformAppxLayoutFileName>
    <PlatformAppxLayoutFile Condition="'$(PlatformAppxLayoutFile)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)$(PlatformAppxLayoutFileName)</PlatformAppxLayoutFile>
    <PlatformAppxLayoutUploadFile Condition="'$(PlatformAppxLayoutUploadFile)' == ''">$(PlatformSpecificUploadBundleArtifactsListDirInProjectDir)$(PlatformAppxLayoutFileName)</PlatformAppxLayoutUploadFile>
    <FinalAppxLayoutFileName>PackageLayout.xml</FinalAppxLayoutFileName>
    <FinalAppxLayoutFile Condition="'$(FinalAppxLayoutFile)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)$(FinalAppxLayoutFileName)</FinalAppxLayoutFile>
    <FinalAppxLayoutUploadFile Condition="'$(FinalAppxLayoutUploadFile)' == ''">$(PlatformSpecificUploadBundleArtifactsListDirInProjectDir)$(FinalAppxLayoutFileName)</FinalAppxLayoutUploadFile>
    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDir>
    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>
    <!-- Continue to honor the UapDefaultAssetScale property for compat reasons.  But going forward advertise the property "AppxDefaultResourceQualifierUAP_{ValueName} as the desired override property. -->
    <UapDefaultAssetScale Condition="'$(UapDefaultAssetScale)' == ''">200</UapDefaultAssetScale>
    <AppxDefaultResourceQualifierUAP_Scale Condition="'$(AppxDefaultResourceQualifierUAP_Scale)' == ''">$(UapDefaultAssetScale)</AppxDefaultResourceQualifierUAP_Scale>
    <AppxDefaultResourceQualifierUAP_Language Condition="'$(AppxDefaultResourceQualifierUAP_Language)' == ''">{DefaultResourceLanguage}</AppxDefaultResourceQualifierUAP_Language>
    <AppxDefaultResourceQualifierUAP_Contrast Condition="'$(AppxDefaultResourceQualifierUAP_Contrast)' == ''">standard</AppxDefaultResourceQualifierUAP_Contrast>
    <AppxDefaultResourceQualifierUAP_HomeRegion Condition="'$(AppxDefaultResourceQualifierUAP_HomeRegion)' == ''">001</AppxDefaultResourceQualifierUAP_HomeRegion>
    <AppxDefaultResourceQualifierUAP_TargetSize Condition="'$(AppxDefaultResourceQualifierUAP_TargetSize)' == ''">256</AppxDefaultResourceQualifierUAP_TargetSize>
    <AppxDefaultResourceQualifierUAP_LayoutDirection Condition="'$(AppxDefaultResourceQualifierUAP_LayoutDirection)' == ''">LTR</AppxDefaultResourceQualifierUAP_LayoutDirection>
    <AppxDefaultResourceQualifierUAP_DxFeatureLevel Condition="'$(AppxDefaultResourceQualifierUAP_DxFeatureLevel)' == ''">DX9</AppxDefaultResourceQualifierUAP_DxFeatureLevel>
    <AppxDefaultResourceQualifierUAP_Platform Condition="'$(AppxDefaultResourceQualifierUAP_Platform)' == ''">UAP</AppxDefaultResourceQualifierUAP_Platform>
    <DisableAppxManifestItemPackageContentValidation Condition="'$(DisableAppxManifestItemPackageContentValidation)' == ''">false</DisableAppxManifestItemPackageContentValidation>
    <RemoveNonLayoutFiles Condition="'$(RemoveNonLayoutFiles)' == ''">true</RemoveNonLayoutFiles>
    <IncludeLayoutFilesInPackage Condition="'$(IncludeLayoutFilesInPackage)' == ''">false</IncludeLayoutFilesInPackage>
    <AppxSubfolderWithFilesToBeEmbedded Condition="'$(AppxSubfolderWithFilesToBeEmbedded)' == ''">embed</AppxSubfolderWithFilesToBeEmbedded>
    <AppxLogTelemetryFromSideloadingScript Condition="'$(AppxLogTelemetryFromSideloadingScript)' == ''">true</AppxLogTelemetryFromSideloadingScript>
    <AppxExcludeArmFrameworkSdkPackagesFromLayout Condition="'$(AppxExcludeArmFrameworkSdkPackagesFromLayout)' == ''">false</AppxExcludeArmFrameworkSdkPackagesFromLayout>
    <AppxExcludeX86FrameworkSdkPackagesFromLayout Condition="'$(AppxExcludeX86FrameworkSdkPackagesFromLayout)' == ''">false</AppxExcludeX86FrameworkSdkPackagesFromLayout>
    <AzureKeyVaultVisualStudioCredentialOnly Condition="'$(AzureKeyVaultVisualStudioCredentialOnly)' == ''">false</AzureKeyVaultVisualStudioCredentialOnly>
  </PropertyGroup>
  <PropertyGroup>
    <AppxDefaultResourceQualifiers_Windows_80>Language={DefaultResourceLanguage}</AppxDefaultResourceQualifiers_Windows_80>
    <AppxDefaultResourceQualifiers_Windows_81>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_81>
    <AppxDefaultResourceQualifiers_Windows_Phone>Language={DefaultResourceLanguage}|Contrast=standard|Scale=240|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Theme=Dark|AlternateForm=</AppxDefaultResourceQualifiers_Windows_Phone>
    <AppxDefaultResourceQualifiers_Windows_82>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_82>
    <AppxDefaultResourceQualifiers_UAP>Language=$(AppxDefaultResourceQualifierUAP_Language)|Contrast=$(AppxDefaultResourceQualifierUAP_Contrast)|Scale=$(AppxDefaultResourceQualifierUAP_Scale)|HomeRegion=$(AppxDefaultResourceQualifierUAP_HomeRegion)|TargetSize=$(AppxDefaultResourceQualifierUAP_TargetSize)|LayoutDirection=$(AppxDefaultResourceQualifierUAP_LayoutDirection)|DXFeatureLevel=$(AppxDefaultResourceQualifierUAP_DxFeatureLevel)|Configuration=$(AppxDefaultResourceQualifierUAP_Configuration)|AlternateForm=$(AppxDefaultResourceQualifierUAP_AlternateForm)|Platform=$(AppxDefaultResourceQualifierUAP_Platform)</AppxDefaultResourceQualifiers_UAP>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">$(AppxDefaultResourceQualifiers_Windows_80)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.1'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.2'">$(AppxDefaultResourceQualifiers_Windows_82)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Portable'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(SDKIdentifier)' != ''">$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">$(AppxDefaultResourceQualifiers_Windows_Phone)</AppxDefaultResourceQualifiers>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AppxOmitSchemaFromResourcePacks)' == ''">
    <AppxOmitSchemaFromResourcePacks Condition="'$(TargetPlatformIdentifier)' == 'UAP'">true</AppxOmitSchemaFromResourcePacks>
    <AppxOmitSchemaFromResourcePacks Condition="'$(TargetPlatformIdentifier)' != 'UAP'">false</AppxOmitSchemaFromResourcePacks>
  </PropertyGroup>
  <!-- If value is still not set, it is a platform yet unknown to us. -->
  <!-- Default to same value as for latest version of Windows.        -->
  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers>$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
  </PropertyGroup>
  <ItemGroup>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha256">
      <Id>SHA256</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha384">
      <Id>SHA384</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha512">
      <Id>SHA512</Id>
    </AppxHashUri>
  </ItemGroup>
  <PropertyGroup>
    <StandardBuildPipeline>1.0</StandardBuildPipeline>
    <UapBuildPipeline>2.0</UapBuildPipeline>
    <AppxPackagePipelineVersion>$(StandardBuildPipeline)</AppxPackagePipelineVersion>
    <AppxPackagePipelineVersion Condition="'$(SDKIdentifier)' != ''">$(UapBuildPipeline)</AppxPackagePipelineVersion>
  </PropertyGroup>
  <PropertyGroup>
    <AppxLayoutEnabled Condition="'$(AppxLayoutEnabled)' != 'false' and&#xD;&#xA;                                  '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and&#xD;&#xA;                                  '$(SdkIsRS4OrLater)' == 'true'">true</AppxLayoutEnabled>
    <AppxLayoutEnabled Condition="'$(AppxLayoutEnabled)' != 'true'">false</AppxLayoutEnabled>
  </PropertyGroup>
  <PropertyGroup>
    <AppxPackageEncryptionEnabled Condition="'$(AppxPackageEncryptionEnabled)' == '' or '$(SdkIsRS1OrLater)' != 'true'">false</AppxPackageEncryptionEnabled>
  </PropertyGroup>
  <!-- Backwards compatablity with PreDev16 work. Use properties below for a more clear workflow and better named variables. -->
  <PropertyGroup>
    <UapAppxPackageBuildModeStoreUploadLegacy>StoreUpload</UapAppxPackageBuildModeStoreUploadLegacy>
    <UapAppxPackageBuildModeCI>CI</UapAppxPackageBuildModeCI>
  </PropertyGroup>
  <PropertyGroup>
    <UapAppxPackageBuildModeSideloadOnly>SideloadOnly</UapAppxPackageBuildModeSideloadOnly>
    <UapAppxPackageBuildModeStoreAndSideload>StoreAndSideload</UapAppxPackageBuildModeStoreAndSideload>
    <UapAppxPackageBuildModeStoreOnly>StoreOnly</UapAppxPackageBuildModeStoreOnly>
  </PropertyGroup>
  <PropertyGroup>
    <UapAppxPackageBuildModeIsValid>false</UapAppxPackageBuildModeIsValid>
  </PropertyGroup>
  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeStoreUploadLegacy or the new flag UapAppxPackageBuildModeStoreAndSideload, prep all the appropriate flags to produce an appxupload & sideload package-->
  <PropertyGroup Condition="('$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreAndSideload)' or '$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreUploadLegacy)') and&#xD;&#xA;                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and&#xD;&#xA;                            '$(UseDotNetNativeToolchain)' != 'false' and&#xD;&#xA;                            '$(Configuration)' != 'Debug'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>true</BuildAppxUploadPackageForUap>
    <BuildAppxSideloadPackageForUap>true</BuildAppxSideloadPackageForUap>
    <AppxPackageIsForStore>true</AppxPackageIsForStore>
  </PropertyGroup>
  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeSideloadOnly, prep all the appropriate flags to produce an appx sideload package-->
  <PropertyGroup Condition="'$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeSideloadOnly)' and&#xD;&#xA;                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
    <BuildAppxSideloadPackageForUap>true</BuildAppxSideloadPackageForUap>
    <AppxPackageIsForStore>false</AppxPackageIsForStore>
  </PropertyGroup>
  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeStore or UapAppxPackageBuildModeCI, prep all the appropriate flags to produce an APPX for store upload only-->
  <PropertyGroup Condition="('$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreOnly)' or '$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeCI)') and&#xD;&#xA;                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(UseDotNetNativeToolchain)' != 'false' and '$(Configuration)' != 'Debug'">true</BuildAppxUploadPackageForUap>
    <AppxPackageIsForStore>false</AppxPackageIsForStore>
    <AppxPackageIsForStore Condition="'$(UseDotNetNativeToolchain)' != 'false' and '$(Configuration)' != 'Debug'">true</AppxPackageIsForStore>
    <BuildAppxSideloadPackageForUap>false</BuildAppxSideloadPackageForUap>
  </PropertyGroup>
  <!-- Combined checks to see if we should run the store-publishing steps added for the UAP flow. -->
  <PropertyGroup>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == '' and&#xD;&#xA;                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and&#xD;&#xA;                                             '$(UseDotNetNativeToolchain)' != 'false' and&#xD;&#xA;                                             '$(Configuration)' != 'Debug' and&#xD;&#xA;                                             '$(AppxPackageIsForStore)' == 'true'">true</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == ''">false</BuildAppxUploadPackageForUap>
  </PropertyGroup>
  <!-- Combined checks to see if we should run the sideload steps added -->
  <PropertyGroup>
    <BuildAppxSideloadPackageForUap Condition="'$(BuildAppxSideloadPackageForUap)' == '' and&#xD;&#xA;                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</BuildAppxSideloadPackageForUap>
    <BuildAppxSideloadPackageForUap Condition="'$(BuildAppxSideloadPackageForUap)' == ''">false</BuildAppxSideloadPackageForUap>
  </PropertyGroup>
  <!-- If packaging for the store, force package encryption to be skipped -->
  <PropertyGroup>
    <AppxPackageEncryptionEnabled Condition="'$(AppxPackageIsForStore)' == 'true'">false</AppxPackageEncryptionEnabled>
  </PropertyGroup>
  <!-- Calculate whether to allow debug framework references in app manifest.    -->
  <!-- Allow overriding this from command line or user config file if necessary. -->
  <PropertyGroup Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">
    <!-- Allow debug framework references when not packaging for the store. -->
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageIsForStore)' != 'true'">true</AppxPackageAllowDebugFrameworkReferencesInManifest>
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">false</AppxPackageAllowDebugFrameworkReferencesInManifest>
  </PropertyGroup>
  <!--
        When building on the command line or in TFS (determined by looking at the $(BuildingInsideVisualStudio) property), if build is invoked on an
        app package-producing project, the package for the project will be produced as part of building the project without specifying any additional
        flags or targets. This is control by an MSBuild property named GenerateAppxPackageOnBuild which is set to true by default.

        If $(BuildingInsideVisualStudio) = false and $(GenerateAppxPackageOnBuild) = true, then build will also produce a package.
    -->
  <PropertyGroup>
    <GenerateAppxPackageOnBuild Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</GenerateAppxPackageOnBuild>
  </PropertyGroup>
  <PropertyGroup>
    <_OverriddenDisableXbf>false</_OverriddenDisableXbf>
    <_OverriddenDisableXbf Condition="'$(DisableEmbeddedXbf)' != ''">true</_OverriddenDisableXbf>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_OverriddenDisableXbf)' == 'false'">
    <DisableEmbeddedXbf Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">false</DisableEmbeddedXbf>
    <DisableEmbeddedXbf Condition="'$(GenerateAppxPackageOnBuild)' != 'true'">true</DisableEmbeddedXbf>
    <DisableEmbeddedXbf Condition="'$(Configuration)'!='Debug'">false</DisableEmbeddedXbf>
  </PropertyGroup>
  <PropertyGroup>
    <UseSubFolderForOutputDirDuringMultiPlatformBuild Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</UseSubFolderForOutputDirDuringMultiPlatformBuild>
    <UseSubFolderForOutputDirDuringMultiPlatformBuild Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == ''">false</UseSubFolderForOutputDirDuringMultiPlatformBuild>
  </PropertyGroup>
  <!-- Names of the files which are allways present on the machine and should not be part of the payload. -->
  <ItemGroup>
    <AppxSystemBinary Include="CLRHost.dll" />
    <AppxSystemBinary Include="CLRHost.exe" />
    <AppxSystemBinary Include="WWAHost.exe" />
  </ItemGroup>
  <!-- Reserved file names which cannot appear in the package. -->
  <ItemGroup>
    <AppxReservedFileName Include="$(AppxManifestFileName)" />
    <AppxReservedFileName Include="AppxBlockMap.xml" />
    <AppxReservedFileName Include="[Content_Types].xml" />
    <AppxReservedFileName Include="AppxSignature.p7x" />
    <AppxReservedFileName Include="Microsoft.System.Package.Metadata" />
  </ItemGroup>
  <!-- XPath queries used to extract file names from the manifest. -->
  <ItemGroup>
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:InProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:OutOfProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:ProxyStub/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:GameExplorer/@GameDefinitionContainer" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:Certificates/m:Certificate/@Content" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/@Executable" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/m:Extensions/m:Extension/@Executable" />
  </ItemGroup>
  <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Square71x71Logo">
      <DescriptionID>Square71x71Logo</DescriptionID>
      <ExpectedScaleDimensions>400:284x284;200:142x142;100:71x71;150:107x107;125:89x89</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>400:600x600;200:300x300;100:150x150;150:225x225;125:188x188</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>400:1240x600;200:620x300;100:310x150;150:465x225;125:388x188</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>400:1240x1240;200:620x620;100:310x310;150:465x465;125:388x388</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/@Square44x44Logo">
      <DescriptionID>SmallLogo</DescriptionID>
      <ExpectedScaleDimensions>400:176x176;200:88x88;100:44x44;150:66x66;125:55x55</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;24;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Properties/m:Logo">
      <DescriptionID>StoreLogo</DescriptionID>
      <ExpectedScaleDimensions>400:200x200;200:100x100;150:75x75;125:63x63;100:50x50</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>400:96x96;200:48x48;150:36x36;125:30x30;100:24x24</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>400:2480x1200;200:1240x600;150:930x450;125:775x375;100:620x300</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>
  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="AppxSourceContentGroupMap" />
  </ItemGroup>
  <!-- The reverse map needs to be added only in appx bundles and only on F5. -->
  <PropertyGroup Condition="'$(InsertReverseMap)' == ''">
    <InsertReverseMap Condition="'$(AppxBundle)' == 'Always' or '$(AppxBundle)' == 'Auto'">true</InsertReverseMap>
    <InsertReverseMap Condition="'$(InsertReverseMap)' == '' or '$(GenerateAppxPackageOnBuild)' == 'true' or '$(OutputType)' != 'WindowsWebApplication'">false</InsertReverseMap>
  </PropertyGroup>
  <PropertyGroup>
    <_ProjectPriFullPathOriginal>$(ProjectPriFullPath)</_ProjectPriFullPathOriginal>
  </PropertyGroup>
  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true'">
    <_ReverseMapProjectPriDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriFullPath)'))\ReverseMap\</_ReverseMapProjectPriDirectory>
    <_ReverseMapProjectPriFileName>$([System.IO.Path]::GetFileName('$(ProjectPriFullPath)'))</_ReverseMapProjectPriFileName>
    <ProjectPriFullPath>$(_ReverseMapProjectPriDirectory)$(_ReverseMapProjectPriFileName)</ProjectPriFullPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <_ReverseMapProjectPriUploadDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriUploadFullPath)'))\ReverseMap\</_ReverseMapProjectPriUploadDirectory>
    <_ReverseMapProjectPriUploadFileName>$([System.IO.Path]::GetFileName('$(ProjectPriUploadFullPath)'))</_ReverseMapProjectPriUploadFileName>
    <ProjectPriUploadFullPath>$(_ReverseMapProjectPriUploadDirectory)$(_ReverseMapProjectPriUploadFileName)</ProjectPriUploadFullPath>
  </PropertyGroup>
  <!-- This property is used to trigger a perf optimization in the CreatePriFilesForPortableLibraries task. -->
  <!-- When true we will skip generating an intermediate pri file in certain cases and instead just specify -->
  <!-- the resource file when generating the project's final pri file.                                      -->
  <PropertyGroup Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</SkipIntermediatePriGenerationForResourceFiles>
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">false</SkipIntermediatePriGenerationForResourceFiles>
  </PropertyGroup>
  <!-- WinMDExp.exe and AL.exe are tools that we need for building WinMD files and resource files respectively.  They usually  -->
  <!-- ship as part of the .Net SDK, but we point the common targets to our own copies so we don't require that dependency.    -->
  <PropertyGroup>
    <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == '' and EXISTS( '$(AppxMSBuildToolsPath)WinMDExp.exe' ) ">$(AppxMSBuildToolsPath)</WinMdExpToolPath>
    <AlToolPath Condition="'$(AlToolPath)' == '' and EXISTS( '$(AppxMSBuildToolsPath)Al.exe' ) ">$(AppxMSBuildToolsPath)</AlToolPath>
  </PropertyGroup>
  <!-- Manifest metadata items. -->
  <!-- Those will be transformed into Name/Value or Name/Version pairs as follows:                         -->
  <!--                                                                                                     -->
  <!-- If identity of the item (attribute 'Include') points to existing file and there is                  -->
  <!-- no supplied value or version, file version of given file will be extracted and stored               -->
  <!-- as Version attribute of metadata with name equal to file name and extension.                        -->
  <!--                                                                                                     -->
  <!-- If item has metadata 'Value', then it is directly stored in the manifest as name/value pair.        -->
  <!-- If item has metadata 'Version', then it is directly stored in the manifest as name/version pair.    -->
  <!--                                                                                                     -->
  <!-- If metadata 'Name' is supplied, it will be used instead of identity of the item. This is useful     -->
  <!-- if we use binary to extract file version, but want to give it different name in generated manifest. -->
  <ItemGroup Label="AppxManifestMetadata">
    <AppxManifestMetaData Include="SharedGUID" Condition="'$(SharedGUID)' != ''">
      <Value>$(SharedGUID)</Value>
    </AppxManifestMetaData>
    <AppxManifestMetaData Include="CodeSharingProject" Condition=" '$(HasSharedItems)' == 'true' or '$(CodeSharingProject)' != '' ">
      <Value Condition=" '$(CodeSharingProject)' != '' ">$(CodeSharingProject)</Value>
      <Value Condition=" '$(CodeSharingProject)' == '' ">248F659F-DAC5-46E8-AC09-60EC9FC95053</Value>
    </AppxManifestMetaData>
    <AppxManifestMetadata Include="TargetFrameworkMoniker" Condition="'$(TargetFrameworkMoniker)' != ''">
      <Value>$(TargetFrameworkMoniker)</Value>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="VisualStudio">
      <Version>$(VisualStudioVersion)</Version>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="VisualStudioEdition" Condition="'$(VisualStudioEdition)' != ''">
      <Value>$(VisualStudioEdition)</Value>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="$(ComSpec)">
      <Name>OperatingSystem</Name>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll" />
    <AppxManifestMetaData Include="ProjectGUID" Condition="'$(ProjectGUID)' != ''">
      <Value>$(ProjectGUID)</Value>
    </AppxManifestMetaData>
  </ItemGroup>
  <!--<Import Project="$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props" Condition="EXISTS( '$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props' )" />-->
  <!-- Mapping between OS version (6.*) and marketing version string. -->
  <!-- There is no guarantee that NTVersion always consists of first two parts of OSVersion, hence a separate field. -->
  <ItemGroup>
    <PlatformVersionDescription Include="Windows 8.0">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.0</TargetPlatformVersion>
      <OSDescription>Windows 8.0</OSDescription>
      <OSVersion>6.2.1</OSVersion>
      <NTVersion>6.2</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.1">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows 8.1</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone 8.1">
      <TargetPlatformIdentifier>WindowsPhoneApp</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone Silverlight 8.1">
      <TargetPlatformIdentifier>Windows Phone</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.2">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.2</TargetPlatformVersion>
      <OSDescription>Windows 8.2</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="UAP 1.0">
      <TargetPlatformIdentifier>UAP</TargetPlatformIdentifier>
      <TargetPlatformVersion>0.8.0.0</TargetPlatformVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
  </ItemGroup>
  <!-- Packaging output group default values -->
  <PropertyGroup>
    <IncludeBuiltProjectOutputGroup Condition="'$(IncludeBuiltProjectOutputGroup)' == ''">true</IncludeBuiltProjectOutputGroup>
    <IncludeDebugSymbolsProjectOutputGroup Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == ''">true</IncludeDebugSymbolsProjectOutputGroup>
    <IncludeDocumentationProjectOutputGroup Condition="'$(IncludeDocumentationProjectOutputGroup)' == ''">false</IncludeDocumentationProjectOutputGroup>
    <IncludeSatelliteDllsProjectOutputGroup Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == ''">false</IncludeSatelliteDllsProjectOutputGroup>
    <IncludeSourceFilesProjectOutputGroup Condition="'$(IncludeSourceFilesProjectOutputGroup)' == ''">false</IncludeSourceFilesProjectOutputGroup>
    <IncludeContentFilesProjectOutputGroup Condition="'$(IncludeContentFilesProjectOutputGroup)' == ''">true</IncludeContentFilesProjectOutputGroup>
    <IncludeSGenFilesOutputGroup Condition="'$(IncludeSGenFilesOutputGroup)' == ''">false</IncludeSGenFilesOutputGroup>
    <IncludeCopyLocalFilesOutputGroup Condition="'$(IncludeCopyLocalFilesOutputGroup)' == ''">true</IncludeCopyLocalFilesOutputGroup>
    <IncludeGetCopyToOutputDirectoryItemsOutputGroup Condition="'$(IncludeGetCopyToOutputDirectoryItemsOutputGroup)' == ''">true</IncludeGetCopyToOutputDirectoryItemsOutputGroup>
    <IncludeOptionalProjectsOutputGroup Condition="'$(IncludeOptionalProjectsOutputGroup)' == ''">true</IncludeOptionalProjectsOutputGroup>
    <IncludeComFilesOutputGroup Condition="'$(IncludeComFilesOutputGroup)' == ''">false</IncludeComFilesOutputGroup>
    <IncludeCustomOutputGroupForPackaging Condition="'$(IncludeCustomOutputGroupForPackaging)' == ''">false</IncludeCustomOutputGroupForPackaging>
    <IncludeCopyWinmdArtifactsOutputGroup Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == ''">true</IncludeCopyWinmdArtifactsOutputGroup>
    <IncludeSDKRedistOutputGroup Condition="'$(IncludeSDKRedistOutputGroup)' == ''">true</IncludeSDKRedistOutputGroup>
    <IncludePriFilesOutputGroup Condition="'$(IncludePriFilesOutputGroup)' == ''">true</IncludePriFilesOutputGroup>
    <IncludeGetResolvedSDKReferences Condition="'$(IncludeGetResolvedSDKReferences)' == ''">true</IncludeGetResolvedSDKReferences>
    <IncludeProjectPriFile Condition="'$(IncludeProjectPriFile)' == ''">true</IncludeProjectPriFile>
  </PropertyGroup>
  <!-- Entry points for the project systems. -->
  <PropertyGroup Condition="'$(AppxPackage)' == 'true'">
    <CleanPackageAction>_CleanAppxPackage</CleanPackageAction>
    <PackageAction>_GenerateAppxPackage</PackageAction>
    <RebuildPackageAction>_RebuildAppxPackage</RebuildPackageAction>
  </PropertyGroup>
  <!-- Tie into rebuild sequence, to set flag if we are doing rebuilding. -->
  <Target Name="_BeforeBeforeRebuild" BeforeTargets="BeforeRebuild">
    <PropertyGroup>
      <_Rebuilding>true</_Rebuilding>
    </PropertyGroup>
  </Target>
  <!-- Alter behavior of task ResolveAssemblyReferences to error on architecture mismatch. -->
  <PropertyGroup>
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)' == ''">Error</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
  </PropertyGroup>
  <!-- ============================================================================================ -->
  <!-- Overriding Publish target from Microsoft.Common.targets to tie into command-line publishing. -->
  <!-- ============================================================================================ -->
  <Target Name="Publish" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="Build;$(PackageAction)" />
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
        Actions happening during the build
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _ValidateConfiguration;
      _ValidateAzureCodeSigningVersion;
      _ValidateAzureKeyVaultVersion;
      _ValidateSigningCertificate;
      _ValidatePublisherName;
      _ValidatePaths;
      _ComputeBuildAppxUploadPackageForUapFlag;
      _GetAppxManifestSchemaItems;
      _FindAndValidateBundleMappingFile;
      _GetSdkToolPaths;
      _GetPriConfigXmlSnippets;
      _ReadAppxLayout;
      _ValidatePresenceOfAppxManifestItems;
      GetPackagingOutputs;
      _GetPackageProperties;
      _AddUnionWinmd;
      _AddFxWinmd;
      _GenerateProjectPriFile;
      _ComputeAppxPackagePayload;
      _GenerateAppxManifest;
      _ValidateStoreManifest;
      _BuildOptionalProjects;
      _GenerateBundleMappingFile;
      _GenerateBundleManifest;
      _GenerateAppxPackageRecipe;
      _GenerateAppxUploadPackageRecipe;
      _ConvertAppxContentGroupMap;
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn Condition=" '$(GenerateAppxPackageOnBuild)' == 'true'">
      $(PrepareForRunDependsOn);
      $(PackageAction)
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _AppendToReadTlogFile;
      _AppendToWriteTlogFile;
      _AppendToPackagingWriteLogs
    </PrepareForRunDependsOn>
  </PropertyGroup>
  <Target Name="_ValidatePipeline">
    <ValidatePipeline PipelineVersion="$(AppxPackagePipelineVersion)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <Target Name="_ValidateAzureCodeSigningVersion" Condition="$(AzureCodeSigningEnabled)">
    <ValidateAzureCodeSigningVersion UseSdkBuildToolsPackage="$(UseSdkBuildToolsPackage)" WindowsSDKBuildToolsVersion="$(WindowsSDKBuildToolsVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" />
  </Target>
  <Target Name="_ValidateAzureKeyVaultVersion" Condition="$(AzureKeyVaultEnabled)">
    <ValidateAzureKeyVaultVersion TargetPlatformVersion="$(TargetPlatformVersion)" />
  </Target>
  <!-- Validate that the signing path and thumbprint match -->
  <Target Name="_ValidateSigningCertificate" DependsOnTargets="_FindStoreAssociationFile" Condition="'$(AppxPackage)' == 'true' and&#xD;&#xA;                     '$(AzureCodeSigningEnabled)' != 'true' and&#xD;&#xA;                     '$(AzureKeyVaultEnabled)' != 'true'">
    <!--
      If no thumbprint or cert file is provided, but we're generating sideload packages during a store build...
      Generate a disposable certificate and enable package signing so the sideload packages get signed properly.
    -->
    <GenerateDisposableSigningCertificate Condition="'$(GenerateTemporaryStoreCertificate)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'" AppxManifest="@(AppxManifest)" StoreAssociationFile="@(StoreAssociationFile)">
      <Output TaskParameter="DisposableSigningCertificateThumbprint" PropertyName="PackageCertificateThumbprint" />
      <Output TaskParameter="EnableAppxPackageSigning" PropertyName="AppxPackageSigningEnabled" />
    </GenerateDisposableSigningCertificate>
    <!--
      We need to clear the PackageCertificateKeyFile property if a disposable signing certificate is being
      generated. This is because the ValidateSigningCertificate requires PackageCertificateThumbprint to match
      the thumbprint of the certificate held within the pfx defined by PackageCertificateKeyFile
    -->
    <PropertyGroup Condition="'$(GenerateTemporaryStoreCertificate)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <PackageCertificateKeyFile />
    </PropertyGroup>
    <ValidateSigningCertificate Condition="'$(AppxPackageSigningEnabled)' == 'true' and '$(AzureCodeSigningEnabled)' != 'true'" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Validate that the publisher name is appropriate for the build scenario -->
  <Target Name="_ValidatePublisherName" DependsOnTargets="_FindStoreAssociationFile" Condition="'$(AppxPackage)' == 'true' and&#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(SkipPublisherNameValidation)' != 'true'">
    <ValidatePublisherName IsPackageSigningEnabled="$(AppxPackageSigningEnabled)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" EnableSigningChecks="$(EnableSigningChecks)" AppxManifest="@(AppxManifest)" StoreAssociationFile="@(StoreAssociationFile)" />
  </Target>
  <!-- Clean up the temporary certificate created for store test package signing -->
  <Target Name="_RemoveDisposableSigningCertificate">
    <RemoveDisposableSigningCertificate Condition="'$(GenerateTemporaryStoreCertificate)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'" CertificateThumbprint="$(PackageCertificateThumbprint)" />
  </Target>
  <!-- Validates directory paths and ensures trailing slashes -->
  <Target Name="_ValidatePaths">
    <PropertyGroup>
      <AppxPackageDir Condition="!HasTrailingSlash('$(AppxPackageDir)')">$(AppxPackageDir)\</AppxPackageDir>
      <AppxLayoutDir Condition="!HasTrailingSlash('$(AppxLayoutDir)')">'$(AppxLayoutDir)'\</AppxLayoutDir>
      <AppxUploadLayoutDir Condition="!HasTrailingSlash('$(AppxUploadLayoutDir)')">$(AppxUploadLayoutDir)\</AppxUploadLayoutDir>
      <PlatformSpecificBundleArtifactsListDir Condition="!HasTrailingSlash('$(PlatformSpecificBundleArtifactsListDir)')">$(PlatformSpecificBundleArtifactsListDir)\</PlatformSpecificBundleArtifactsListDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificUploadBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>
  </Target>
  <Target Name="_GetPackageFileExtensions">
    <PropertyGroup Condition="'$(PackageExtPrefix)' == ''">
      <PackageExtPrefix>appx</PackageExtPrefix>
      <PackageExtPrefix Condition="'$(TargetPlatformMinVersion)' &gt;= '10.0.17200.0'">msix</PackageExtPrefix>
    </PropertyGroup>
    <PropertyGroup>
      <AppxPackageExtension Condition="'$(AppxPackageExtension)' == ''">.$(PackageExtPrefix)</AppxPackageExtension>
      <AppxPackageEncryptedExtension Condition="'$(AppxPackageEncryptedExtension)' == ''">.e$(PackageExtPrefix)</AppxPackageEncryptedExtension>
      <AppxSymbolPackageExtension Condition="'$(AppxSymbolPackageExtension)' == ''">.appxsym</AppxSymbolPackageExtension>
      <AppxBundleExtension Condition="'$(AppxBundleExtension)' == ''">.$(PackageExtPrefix)bundle</AppxBundleExtension>
      <AppxBundleEncryptedExtension Condition="'$(AppxBundleEncryptedExtension)' == ''">.e$(PackageExtPrefix)bundle</AppxBundleEncryptedExtension>
      <AppxStoreContainerExtension Condition="'$(AppxStoreContainerExtension)' == ''">.$(PackageExtPrefix)upload</AppxStoreContainerExtension>
      <AppxIntermediateExtension Condition="'$(AppxIntermediateExtension)' == ''">.intermediate</AppxIntermediateExtension>
    </PropertyGroup>
  </Target>
  <!-- If the AutoIncrementPackageRevision flag is false, delete the AppxPackageTestDir in order to ensure all files in the folder are up to date. -->
  <Target Name="_DeleteAppxOutputFolderIfNecessary" Condition="('$(BuildingInsideVisualStudio)' != 'true' or '$(AppxAutoIncrementPackageRevision)' != 'true') and Exists($(AppxPackageTestDir))">
    <RemoveDir Directories="$(AppxPackageTestDir)" />
  </Target>
  <!-- Calculates AppxManifestSchema items. -->
  <PropertyGroup>
    <_GetAppxManifestSchemaItemsDependsOn>
      $(_GetAppxManifestSchemaItemsDependsOn);
      _GetAppxManifestSchemaItemsFromSdk;
      _GetAppxManifestSchemaItemsFromPackage
    </_GetAppxManifestSchemaItemsDependsOn>
  </PropertyGroup>
  <Target Name="_GetAppxManifestSchemaItems" Condition="'@(AppxManifestSchema)' == ''" DependsOnTargets="$(_GetAppxManifestSchemaItemsDependsOn)" />
  <!-- Schemas installed via nupkg -->
  <Target Name="_GetAppxManifestSchemaItemsFromPackage" Condition="'$(UseSdkBuildToolsPackage)' == 'true'">
    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
    </PropertyGroup>
    <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows'">
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and '$(SDKVersion)' == '10.0'">
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\FoundationManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/foundation/windows10</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(WindowsSDKSchemasFolder)\UapManifestSchema.xsd">
        <NamespaceAlias>uap</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/uap/windows10</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
  </Target>
  <!--
    For UWP apps using modern .NET, the 'UseUwpTools' property will be set. In that case,
    we can use a private property to fixup the targets below that were originally only
    meant to work on legacy UWP, which has 'TargetPlatformIdentifier' set to 'UAP'. For
    modern .NET, that property will be 'Windows' instead, but the logic for this value
    would not be correct for code being compiled to be used in a UWP application.
  -->
  <PropertyGroup>
    <_TargetPlatformIdentifierForPriResources Condition="'$(UseUwpTools)' == true">UAP</_TargetPlatformIdentifierForPriResources>
    <_TargetPlatformIdentifierForPriResources Condition="'$(UseUwpTools)' != true">$(TargetPlatformIdentifier)</_TargetPlatformIdentifierForPriResources>
  </PropertyGroup>
  <!-- Schemas installed via SDK msi -->
  <Target Name="_GetAppxManifestSchemaItemsFromSdk" Condition="'$(UseSdkBuildToolsPackage)' != 'true'">
    <GetSdkPropertyValue Condition="'$(_TargetPlatformIdentifierForPriResources)' == 'Windows'" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsSDK80Path" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <GetSdkPropertyValue Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsPhoneSdkDir" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <GetSdkPropertyValue Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsSdkDir" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <ItemGroup Condition="'$(_TargetPlatformIdentifierForPriResources)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(_TargetPlatformIdentifierForPriResources)' == 'Windows' and '$(TargetPlatformVersion)' != '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and '$(SDKVersion)' == '10.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\FoundationManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/foundation/windows10</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\UapManifestSchema.xsd">
        <NamespaceAlias>uap</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/uap/windows10</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v3.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013_v2.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2014.xsd">
        <NamespaceAlias>m3</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxPhoneManifestSchema2014.xsd">
        <NamespaceAlias>mp</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/phone/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>
    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <_StoreManifestSchemaDir>$(_TargetPlatformSdkDir)\Include\WinRT\</_StoreManifestSchemaDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and !Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <_StoreManifestSchemaDir>$(CURRENTVSINSTALLDIR)Xml\Schemas\</_StoreManifestSchemaDir>
    </PropertyGroup>
    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <StoreManifestSchema Include="$(_StoreManifestSchemaDir)StoreManifest.xsd">
        <NamespaceAlias>store</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/StoreManifest</NamespaceUri>
      </StoreManifestSchema>
    </ItemGroup>
    <!--
            Define AppxValidateStoreManifest based on whether we ended up with any
            StoreManifestSchemas or not.  This keeps the logic agnostic about which
            TargetPlatform/Version supports validating the Store manifest.
        -->
    <PropertyGroup>
      <AppxValidateStoreManifest Condition="'$(AppxValidateStoreManifest)' == '' and '@(StoreManifestSchema)' != ''">true</AppxValidateStoreManifest>
    </PropertyGroup>
    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == '' and '$(SDKIdentifier)' != ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2012/build</MetadataNamespaceUri>
    </PropertyGroup>
  </Target>
  <!-- Finds SDK tool executables paths. -->
  <PropertyGroup>
    <_GetSdkToolsPathsDependsOn>
      $(_GetSdkToolsPathsDependsOn);
      _GetSdkToolsPathsFromSdk;
      _GetSdkToolsPathsFromPackage
    </_GetSdkToolsPathsDependsOn>
  </PropertyGroup>
  <Target Name="_GetSdkToolPaths" DependsOnTargets="$(_GetSdkToolsPathsDependsOn)" />
  <!-- Tools installed via nupkg -->
  <Target Name="_GetSdkToolsPathsFromPackage" Condition="'$(UseSdkBuildToolsPackage)' == 'true'" />
  <!-- Tools installed via SDK msi-->
  <Target Name="_GetSdkToolsPathsFromSdk" Condition="'$(UseSdkBuildToolsPackage)' != 'true'">
    <PropertyGroup>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' == ''">false</MSBuildExtensionsPath64Exists>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' != ''">true</MSBuildExtensionsPath64Exists>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(AppxGeneratePriEnabled)' == 'true' or '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'" FileName="MakePri.exe" FullFilePath="$(MakePriExeFullPath)" FileArchitecture="$(MakePriArchitecture)" RequireExeExtension="true" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakePriExeFullPath" />
      <Output TaskParameter="ActualFileArchitecture" PropertyName="MakePriArchitecture" />
    </GetSdkFileFullPath>
    <!--Use the x64 version of MakeAppx.exe on Arm64 OS if necessary.-->
    <PropertyGroup Condition="'$(MakeAppxArchitecture)' == ''">
      <MakeAppxArchitecture Condition="'$(UseX64ToolsOnArm64OS)'=='true'">x64</MakeAppxArchitecture>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true' or '@(BundleMappingFile)' != ''" FileName="MakeAppx.exe" FullFilePath="$(MakeAppxExeFullPath)" FileArchitecture="$(MakeAppxArchitecture)" RequireExeExtension="true" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakeAppxExeFullPath" />
    </GetSdkFileFullPath>
    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true'" FileName="signtool.exe" FullFilePath="$(SignAppxPackageExeFullPath)" FileArchitecture="$(SignToolArchitecture)" RequireExeExtension="true" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="SignAppxPackageExeFullPath" />
    </GetSdkFileFullPath>
    <PropertyGroup Condition="'$(AppxPackagingArchitecture)' == ''">
      <AppxPackagingArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</AppxPackagingArchitecture>
      <AppxPackagingArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</AppxPackagingArchitecture>
      <AppxPackagingArchitecture Condition="'$(UseX64ToolsOnArm64OS)'=='false'">ARM64</AppxPackagingArchitecture>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''" FileName="Microsoft.Windows.Build.Appx.AppxPackaging.dll.manifest" FullFilePath="$(AppxPackagingComponentManifestPath)" FileArchitecture="$(AppxPackagingArchitecture)" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="AppxPackagingComponentManifestPath" />
    </GetSdkFileFullPath>
    <PropertyGroup Condition="'$(MrmSupportLibraryArchitecture)' == ''">
      <MrmSupportLibraryArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</MrmSupportLibraryArchitecture>
      <MrmSupportLibraryArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</MrmSupportLibraryArchitecture>
      <MrmSupportLibraryArchitecture Condition="'$(UseX64ToolsOnArm64OS)'=='false'">ARM64</MrmSupportLibraryArchitecture>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''" FileName="MrmSupport.dll" FullFilePath="$(MrmSupportLibraryPath)" FileArchitecture="$(MrmSupportLibraryArchitecture)" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MrmSupportLibraryPath" />
    </GetSdkFileFullPath>
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="MakePriExtensionPath" VsTelemetrySession="$(VsTelemetrySession)" Condition="'$(MakePriExtensionPath)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath" />
    </GetSdkPropertyValue>
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(_TargetPlatformIdentifierForPriResources)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="MakePriExtensionPath_x64" VsTelemetrySession="$(VsTelemetrySession)" Condition="'$(MakePriExtensionPath_x64)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath_x64" />
    </GetSdkPropertyValue>
    <!--Clear out MakePriExtensionPath for UAP projects since it should never be used.-->
    <PropertyGroup Condition="'$(SDKIdentifier)' != ''">
      <MakePriExtensionPath />
      <MakePriExtensionPath_x64 />
    </PropertyGroup>
    <PropertyGroup>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' != 'amd64'">$(MakePriExtensionPath)</OutOfProcessMakePriExtensionPath>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' == 'amd64'">$(MakePriExtensionPath_x64)</OutOfProcessMakePriExtensionPath>
    </PropertyGroup>
    <PropertyGroup>
      <InProcessMakePriExtensionPath Condition="!$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath)</InProcessMakePriExtensionPath>
      <InProcessMakePriExtensionPath Condition="$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath_x64)</InProcessMakePriExtensionPath>
    </PropertyGroup>
  </Target>
  <!-- Calculates paths to priconfig.xml snippets -->
  <Target Name="_GetPriConfigXmlSnippets">
    <ItemGroup Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''">
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.packaging.xml'" />
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.packaging.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>
    <PropertyGroup Condition="'@(_AppxPriConfigXmlPackagingSnippetItem)' != ''">
      <AppxPriConfigXmlPackagingSnippetPath>%(_AppxPriConfigXmlPackagingSnippetItem.FullPath)</AppxPriConfigXmlPackagingSnippetPath>
    </PropertyGroup>
    <ItemGroup Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''">
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.default.xml'" />
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.default.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>
    <PropertyGroup Condition="'@(_AppxPriConfigXmlDefaultSnippetItem)' != ''">
      <AppxPriConfigXmlDefaultSnippetPath>%(_AppxPriConfigXmlDefaultSnippetItem.FullPath)</AppxPriConfigXmlDefaultSnippetPath>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <ValidatePresenceOfAppxManifestItemsDependsOn>
      $(ValidatePresenceOfAppxManifestItemsDependsOn);
    </ValidatePresenceOfAppxManifestItemsDependsOn>
  </PropertyGroup>
  <!-- Finds out if there is a custom AppxManifest override item, -->
  <!-- validates that one and only one manifest exists,           -->
  <!-- extracts identity name and version out of the manifest,    -->
  <!-- defines ProjectPriIndexName,                               -->
  <!-- and defines SourceAppxManifest item.                       -->
  <Target Name="_ValidatePresenceOfAppxManifestItems" DependsOnTargets="$(ValidatePresenceOfAppxManifestItemsDependsOn)">
    <ItemGroup>
      <CustomAppxManifest Include="@(Content)" Condition="'%(Identity)' == '$(AppxManifestFileName)'" />
    </ItemGroup>
    <ValidateAppxManifestItems AppxPackageProject="$(AppxPackage)" AppxManifestItems="@(AppxManifest)" CustomAppxManifestItems="@(CustomAppxManifest)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IdentityName" PropertyName="AppxManifestIdentityName" />
      <Output TaskParameter="IdentityVersion" PropertyName="AppxManifestIdentityVersion" />
    </ValidateAppxManifestItems>
    <ItemGroup>
      <SourceAppxManifest Include="@(AppxManifest)" Condition="'@(AppxManifest)' != ''" />
      <SourceAppxManifest Include="@(CustomAppxManifest)" Condition="'@(CustomAppxManifest)' != ''" />
    </ItemGroup>
    <PropertyGroup Condition="'$(ProjectPriIndexName)' == ''">
      <ProjectPriIndexName Condition="'$(AppxPackage)' == 'true'">$(AppxManifestIdentityName)</ProjectPriIndexName>
      <ProjectPriIndexName Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == ''">$(TargetName)</ProjectPriIndexName>
      <ProjectPriIndexName Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)</ProjectPriIndexName>
    </PropertyGroup>
    <PropertyGroup>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' == ''">false</_CustomAppxManifestUsed>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' != ''">true</_CustomAppxManifestUsed>
    </PropertyGroup>
  </Target>
  <!-- ============================ -->
  <!-- Generating project PRI file. -->
  <!-- ============================ -->
  <PropertyGroup>
    <_GenerateProjectPriFileDependsOn>
      $(_GenerateProjectPriFileDependsOn);
      BeforeGenerateProjectPriFile;
      _GeneratePrisForPortableLibraries;
      _GetPriFilesFromPayload;
      _ComputeInputPriFiles;
      _GenerateProjectPriConfigurationFiles;
      _CalculateInputsForGenerateProjectPriFileCore;
      _GenerateProjectPriFileCore;
      _AddFileReadsAndFileWritesForProjectPri;
      _CreateProjectPriFileItem;
      _ExpandProjectPriFile;
      _ExpandPriFiles;
      _ExpandPriUploadFiles;
      AfterGenerateProjectPriFile
    </_GenerateProjectPriFileDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <_SupportEmbedFileResources Condition="'$(_SupportEmbedFileResources)' =='' AND ('$(TargetPlatformIdentifier)' == 'UAP' OR '$(UseUwpTools)' == 'true')">true</_SupportEmbedFileResources>
    <_PriConfigXmlPath>$(IntermediateOutputPath)priconfig.xml</_PriConfigXmlPath>
    <_UnfilteredLayoutResfilesPath>$(IntermediateOutputPath)unfiltered.layout.resfiles</_UnfilteredLayoutResfilesPath>
    <_FilteredLayoutResfilesPath>$(IntermediateOutputPath)filtered.layout.resfiles</_FilteredLayoutResfilesPath>
    <_FilteredPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateOutputPath)filtered.package.layout.resfiles</_FilteredPackageLayoutFilePath>
    <_ExcludedPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateOutputPath)excluded.package.layout.resfiles</_ExcludedPackageLayoutFilePath>
    <_FilteredUploadPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateUploadOutputPath)filtered.package.layout.resfiles</_FilteredUploadPackageLayoutFilePath>
    <_ExcludedUploadPackageLayoutFilePath Condition="'$(FilterSatelliteAssembliesForMakePri)' != '' AND '$(FilterSatelliteAssembliesForMakePri)' != 'false'">$(IntermediateUploadOutputPath)excluded.package.layout.resfiles</_ExcludedUploadPackageLayoutFilePath>
    <_ExcludedLayoutResfilesPath>$(IntermediateOutputPath)excluded.layout.resfiles</_ExcludedLayoutResfilesPath>
    <_ResourcesResfilesPath>$(IntermediateOutputPath)resources.resfiles</_ResourcesResfilesPath>
    <_PriResfilesPath>$(IntermediateOutputPath)pri.resfiles</_PriResfilesPath>
    <_EmbedFileResfilePath Condition="'$(_SupportEmbedFileResources)' == 'true'">$(IntermediateOutputPath)$(AppxSubfolderWithFilesToBeEmbedded)\embed.resfiles</_EmbedFileResfilePath>
    <_QualifiersPath>$(IntermediateOutputPath)qualifiers.txt</_QualifiersPath>
    <_MultipleQualifiersPerDimensionFoundPath>$(IntermediateOutputPath)MultipleQualifiersPerDimensionFound.txt</_MultipleQualifiersPerDimensionFoundPath>
  </PropertyGroup>
  <Target Name="_GenerateProjectPriFile" Condition="'$(AppxGeneratePriEnabled)' == 'true'" DependsOnTargets="$(_GenerateProjectPriFileDependsOn)" />
  <!-- Override to specify actions to happen before generating project PRI file. -->
  <Target Name="BeforeGenerateProjectPriFile" />
  <!-- Generates a PRI file for all managed libraries that contain .resources files   -->
  <!-- in them (and their satellites).  This allows a .NET Portable Library to be     -->
  <!-- built with only .resources files, yet still be localized when compiled into    -->
  <!-- an AppX package where the ResourceManager uses the WinRT resource manager.     -->
  <Target Name="_GeneratePrisForPortableLibraries" Condition="'$(AppxPackage)' == 'true' and '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'">
    <!--
    Do not rename or delete the item groups _LibrariesUnfiltered and CreatedResWFiles

    In case of compiling Universal app, the item group _LibrariesUnfiltered will get initialized with the filtered list of
    the app assemblies excluding the framework assemblies.
    the initialization will occur in the target _GetLibrariesToGeneratePrisForUWPApps in the file Microsoft.Net.CoreRuntime.targets.
    also _GetLibrariesToGeneratePrisForUWPApps will fill the initial list of CreatedResWFiles.
    -->
    <ItemGroup Condition="'@(_LibrariesUnfiltered)' == '' and '@(CreatedResWFiles)' == '' and '$(NetCoreGeneratePrisForPortableLibraries)'!='true'">
      <_LibrariesUnfiltered Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(_LibrariesUnfiltered)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_LibrariesFiltered" />
    </RemovePayloadDuplicates>
    <ItemGroup>
      <_Libraries Include="@(_LibrariesFiltered)" Condition="'%(_LibrariesFiltered.BaseAssemblyFullPath)' == ''" />
      <_Libraries Include="@(_LibrariesFiltered)" Condition="'%(_LibrariesFiltered.BaseAssemblyFullPath)' != ''">
        <OriginalItemSpec>%(_LibrariesFiltered.BaseAssemblyFullPath)</OriginalItemSpec>
      </_Libraries>
    </ItemGroup>
    <GenerateResource SdkToolsPath="$(ResgenToolPath)" ExtractResWFiles="true" Sources="@(_Libraries)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache" OutputDirectory="$(IntermediateOutputPath)" ExecuteAsTool="false" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
      <Output TaskParameter="FilesWritten" ItemName="ExtractedFileWrites" />
      <Output TaskParameter="OutputResources" ItemName="CreatedResWFiles" />
    </GenerateResource>
    <ItemGroup>
      <FileWrites Include="@(ExtractedFileWrites)" />
    </ItemGroup>
    <!-- Now generate a PRI file for each set of ResW files (ie, a main assembly + all satellites). -->
    <!-- Note: The task relies on some metadata set on each ITaskItem, set by GenerateResource.  -->
    <CreatePriFilesForPortableLibraries MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" ContentToIndex="@(CreatedResWFiles)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxCreatePriFilesForPortableLibrariesAdditionalMakepriExeParameters)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" SkipIntermediatePriGenerationForResourceFiles="$(SkipIntermediatePriGenerationForResourceFiles)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
      <Output TaskParameter="CreatedPriFiles" ItemName="_PortableLibraryCreatedPriFiles" />
      <Output TaskParameter="UnprocessedReswFiles_DefaultLanguage" ItemName="_UnprocessedReswFiles_DefaultLanguage" />
      <Output TaskParameter="UnprocessedReswFiles_OtherLanguages" ItemName="_UnprocessedReswFiles_OtherLanguages" />
    </CreatePriFilesForPortableLibraries>
    <!-- Add all resw files we didn't generate a pri file for to the PRIResource group so they get included during           -->
    <!-- final pri generation, with the exception of those that need to be indexed using a language other than the project's -->
    <!-- default.  This group will always be empty if SkipIntermediatePriGenerationForResourceFiles is false.                -->
    <ItemGroup>
      <PRIResource Include="@(_UnprocessedReswFiles_DefaultLanguage)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>
  </Target>
  <!-- Get list of PRI files from the payload. -->
  <Target Name="_GetPriFilesFromPayload" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.pri'&#xD;&#xA;                                            and '%(ProjectName)' != '$(ProjectName)'" />
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.pri'&#xD;&#xA;                                            and '%(ProjectName)' == '$(ProjectName)'&#xD;&#xA;                                            and '%(OutputGroup)' != 'ProjectPriFile'" />
    </ItemGroup>
    <RemoveDuplicatePriFiles Inputs="@(_PriFilesFromPayloadRaw)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_PriFilesFromPayload" />
    </RemoveDuplicatePriFiles>
  </Target>
  <!-- Compute final list of input PRI files. -->
  <Target Name="_ComputeInputPriFiles" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <_PriFile Include="@(_PriFilesFromPayload)" />
      <_PriFile Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>
  </Target>
  <!-- Generates configuration files for makepri.exe. -->
  <Target Name="_GenerateProjectPriConfigurationFiles" DependsOnTargets="_GetPackageFileExtensions" Inputs="$(MSBuildAllProjects);@(_PriFile);$(AppxPriConfigXmlDefaultSnippetPath);@(PackagingOutputs)" Outputs="$(_PriConfigXmlPath);$(_UnfilteredLayoutResfilesPath);$(_FilteredLayoutResfilesPath);$(_ExcludedLayoutResfilesPath);$(_ResourcesResfilesPath);$(_PriResfilesPath)">
    <ItemGroup>
      <!--
        First, build out the complete list of files we want to consider for the layout.
        Then exclude anything that matches any pattern or filename listed in _AppxLayoutAssetPackageFiles.
        We could do this as a 'Remove' operation, but by building an oracle we don't modify, we simplify future manipulations of this data set.
      -->
      <_LayoutFileSource Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup' and '%(ProjectName)' == '$(ProjectName)'" />
      <_LayoutFileSource Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'" />
      <_LayoutFile Include="@(_LayoutFileSource)" Exclude="@(_AppxLayoutAssetPackageFiles)" />
      <_EmbedFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'EmbedOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'" />
      <_EmbedFileCopy Include="@(_EmbedFile->'$(IntermediateOutputPath)$(AppxSubfolderWithFilesToBeEmbedded)\%(TargetPath)')" />
      <!-- If we have the .xbf we don't need the .xaml file-->
      <_LayoutFileXbfXaml Include="$([System.IO.Path]::ChangeExtension('%(_LayoutFile.Identity)','.xaml'))" Condition="'%(Extension)' == '.xbf'" />
      <_LayoutFile Remove="@(_LayoutFileXbfXaml)" />
    </ItemGroup>
    <!-- Filter out PRIResource files which are marked by C++ project system as ExcludedFromBuild -->
    <ItemGroup>
      <_PRIResourceFiltered Include="@(PRIResource)" Condition="'%(PRIResource.ExcludedFromBuild)' != 'true'" />
    </ItemGroup>
    <GeneratePriConfigurationFiles UnfilteredLayoutResfilesPath="$(_UnfilteredLayoutResfilesPath)" FilteredLayoutResfilesPath="$(_FilteredLayoutResfilesPath)" ExcludedLayoutResfilesPath="$(_ExcludedLayoutResfilesPath)" ResourcesResfilesPath="$(_ResourcesResfilesPath)" PriResfilesPath="$(_PriResfilesPath)" EmbedFileResfilePath="$(_EmbedFileResfilePath)" LayoutFiles="@(_LayoutFile)" PRIResourceFiles="@(_PRIResourceFiltered)" PriFiles="@(_PriFile)" EmbedFiles="@(_EmbedFile)" IntermediateExtension="$(AppxIntermediateExtension)" UnprocessedResourceFiles_OtherLanguages="@(_UnprocessedReswFiles_OtherLanguages)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AdditionalResourceResFiles" ItemName="_AdditionalResourceResFiles" />
    </GeneratePriConfigurationFiles>
    <CreatePriConfigXmlForFullIndex PriConfigXmlPath="$(_PriConfigXmlPath)" LayoutResfilesPath="$(_FilteredLayoutResfilesPath)" ResourcesResfilesPath="$(_ResourcesResfilesPath)" PriResfilesPath="$(_PriResfilesPath)" EmbedFileResfilePath="$(_EmbedFileResfilePath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" AdditionalResourceResFiles="@(_AdditionalResourceResFiles)" VsTelemetrySession="$(VsTelemetrySession)" />
    <!-- Copy Embed files to location expected by embed indexer-->
    <MakeDir Directories="$(IntermediateOutputPath)$(AppxSubfolderWithFilesToBeEmbedded)" />
    <Copy SourceFiles="@(_EmbedFile)" DestinationFiles="@(_EmbedFileCopy)" SkipUnchangedFiles="true" />
  </Target>
  <Target Name="_SuppressDeploymentOnlyFeatures">
    <!-- Disable adding the reverse map to the PRI file. This is necessary when building from the packaging wizard. -->
    <PropertyGroup>
      <InsertReverseMap>false</InsertReverseMap>
      <ProjectPriFullPath>$(_ProjectPriFullPathOriginal)</ProjectPriFullPath>
      <DisableEmbeddedXbf Condition="'$(_OverriddenDisableXbf)' == 'false'">False</DisableEmbeddedXbf>
    </PropertyGroup>
  </Target>
  <!-- Calculate inputs for _GenerateProjectPriFileCore. -->
  <Target Name="_CalculateInputsForGenerateProjectPriFileCore">
    <ItemGroup>
      <_GenerateProjectPriFileCoreInput Include="$(_PriConfigXmlPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_FilteredLayoutResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_ResourcesResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_PriResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="@(PRIResource)" />
      <_GenerateProjectPriFileCoreInput Include="@(_PriFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(SourceAppxManifest)" />
      <_GenerateProjectPriFileCoreInput Include="$(_EmbedFileResfilePath)" />
      <_GenerateProjectPriFileCoreInput Include="@(_EmbedFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(_AdditionalResourceResFiles)" />
    </ItemGroup>
  </Target>
  <!-- Generates intermediate PRI file for the current project. -->
  <Target Name="_GenerateProjectPriFileCore" Inputs="$(MSBuildAllProjects);@(_GenerateProjectPriFileCoreInput)" Outputs="$(ProjectPriFullPath)">
    <MakeDir Condition="'$(InsertReverseMap)' == 'true'" Directories="$(_ReverseMapProjectPriDirectory)" />
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(_PriConfigXmlPath)" IndexFilesForQualifiersCollection="$(_FilteredLayoutResfilesPath);$(_ResourcesResfilesPath)" ProjectPriIndexName="$(ProjectPriIndexName)" InsertReverseMap="$(InsertReverseMap)" ProjectDirectory="$(ProjectDir)" OutputFileName="$(ProjectPriFullPath)" QualifiersPath="$(_QualifiersPath)" IntermediateExtension="$(AppxIntermediateExtension)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" MultipleQualifiersPerDimensionFoundPath="$(_MultipleQualifiersPerDimensionFoundPath)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Add FileReads and FileWrites done during generation of project PRI file. -->
  <Target Name="_AddFileReadsAndFileWritesForProjectPri">
    <ItemGroup>
      <FileReads Include="@(_GenerateProjectPriFileCoreInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(_PriConfigXmlPath)" />
      <FileWrites Include="$(_PriConfigXmlPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_UnfilteredLayoutResfilesPath)" />
      <FileWrites Include="$(_UnfilteredLayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_FilteredLayoutResfilesPath)" />
      <FileWrites Include="$(_FilteredLayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_ExcludedLayoutResfilesPath)" />
      <FileWrites Include="$(_ExcludedLayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_ResourcesResfilesPath)" />
      <FileWrites Include="$(_ResourcesResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_PriResfilesPath)" />
      <FileWrites Include="$(_PriResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(ProjectPriFullPath)" />
      <FileWrites Include="$(_QualifiersPath)" />
      <FileWrites Include="$(_QualifiersPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_MultipleQualifiersPerDimensionFoundPath)" />
      <FileWrites Include="@(_AdditionalResourceResFiles)" />
      <FileWrites Include="@(_AdditionalResourceResFiles->'%(Identity)$(AppxIntermediateExtension)')" />
    </ItemGroup>
  </Target>
  <!--Create ProjectPriFile item. -->
  <Target Name="_CreateProjectPriFileItem" Condition="'$(AppxPackage)' == 'true'">
    <ItemGroup>
      <ProjectPriFile Remove="@(ProjectPriFile)" />
      <ProjectPriFile Include="$(ProjectPriFullPath)">
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <OsVersion>$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentVersion)</OsVersion>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi Condition="'$(OsVersion)' &lt; '6.3'">false</AppxUseResourceIndexerApi>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi>true</AppxUseResourceIndexerApi>
    </PropertyGroup>
  </Target>
  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandProjectPriFile" Condition="'$(AppxPackage)' == 'true' and '$(AppxUseResourceIndexerApi)' == 'false'">
    <ExpandPriContent Inputs="@(ProjectPriFile)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="IndexedPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <PropertyGroup>
    <GetCopyToOutputDirectoryItemsDependsOn>
      <!-- ResolveProjectReferences has to come before the DependsOn as AssignTargetPath will cause _SplitProjectReferencesByFileExistence to run which will be skipped due
       to no _ProjectReferenceWithConfiguration then when we try to run it later it will be skipped because it was already 'built successfully' -->
      ResolveProjectReferences;
      $(GetCopyToOutputDirectoryItemsDependsOn);
      _SetPortablePriProperties;
      AddPriPayloadFilesToCopyToOutputDirectoryItems
    </GetCopyToOutputDirectoryItemsDependsOn>
  </PropertyGroup>
  <Target Name="_SetPortablePriProperties" Condition="'$(TargetPlatformIdentifier)' == 'Portable'" DependsOnTargets="ImplicitlyExpandTargetFramework">
    <PropertyGroup>
      <_PortablePriResourcesEnabled Condition="'%(ReferencePath.FileName)' == 'System.Runtime.WindowsRuntime.UI.Xaml'">true</_PortablePriResourcesEnabled>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_PortablePriResourcesEnabled)' != 'true'">
      <AppxGeneratePriEnabled>false</AppxGeneratePriEnabled>
      <AppxGeneratePrisForPortableLibrariesEnabled>false</AppxGeneratePrisForPortableLibrariesEnabled>
      <AppxGetPackagePropertiesEnabled>false</AppxGetPackagePropertiesEnabled>
      <IncludeProjectPriFile>false</IncludeProjectPriFile>
    </PropertyGroup>
  </Target>
  <!-- .pri files may contain asset files that are not included as part of the project outputs, because of this we need to expand the pri and add the files to the copy local output -->
  <Target Name="AddPriPayloadFilesToCopyToOutputDirectoryItems" Condition="'$(AppxGeneratePriEnabled)' != 'false' AND '$(SkipAddPriPayloadFilesToCopyToOutputDirectoryItems)' != 'true'" DependsOnTargets="_GetSdkToolPaths;$(AllOutputGroupsDependsOn)">
    <ItemGroup>
      <_PriFilesToExpandFromReference Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" />
      <_PriFilesToExpandFromReference Include="@(ReferenceCopyLocalPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" KeepDuplicates="false" />
    </ItemGroup>
    <ExpandPriContent Condition="'$(MakePriExeFullPath)' != ''" Inputs="@(_PriFilesToExpandFromReference)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)" ExcludeXamlFromLibraryLayoutsWhenXbfIsPresent="$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_ExtraPriPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Include="@(_ExtraPriPayloadFiles)" KeepMetadata="TargetPath">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </_AllChildProjectItemsWithTargetPath>
    </ItemGroup>
  </Target>
  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandMainPriFile">
    <ExpandPriContent Inputs="$(AppxBundleSplitResourcesPriPath)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="IndexedMainPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriFiles">
    <ItemGroup>
      <_PriFilesToExpand Include="@(_PriFilesFromPayload)" Condition="'%(OutputGroup)' != 'ProjectPriFile'&#xD;&#xA;                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'" />
    </ItemGroup>
    <ExpandPriContent Inputs="@(_PriFilesToExpand)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)" ExcludeXamlFromLibraryLayoutsWhenXbfIsPresent="$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriUploadFiles" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_PriUploadFilesToExpand Include="@(_PriFilesFromPayload)" Condition="'%(OutputGroup)' != 'ProjectPriUploadFile'&#xD;&#xA;                                      and '%(OutputGroup)' != 'ProjectPriFile'&#xD;&#xA;                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'" />
    </ItemGroup>
    <ExpandPriContent Inputs="@(_PriUploadFilesToExpand)" MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" IntermediateDirectory="$(IntermediateOutputPath)" AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)" ExcludeXamlFromLibraryLayoutsWhenXbfIsPresent="$(AppxExcludeXamlFromLibraryLayoutsWhenXbfIsPresent)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriUploadPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>
  </Target>
  <!-- Override to specify actions to happen after generating project PRI file. -->
  <Target Name="AfterGenerateProjectPriFile" />
  <PropertyGroup>
    <_ProjectArchitecturesFilePath>$(IntermediateOutputPath)ProjectArchitectures.txt</_ProjectArchitecturesFilePath>
  </PropertyGroup>
  <!-- Add Union winmd to payload if Appx contains managed component to make JITer happy -->
  <Target Name="_AddUnionWinmd" Condition="'$(AppxPackage)' == 'true' AND '$(TargetPlatformIdentifier)' == 'UAP' AND $(SkipUnionWinmd) != 'true'">
    <ItemGroup>
      <_PackagingOutputWinmd Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'" />
    </ItemGroup>
    <GetUnionWinmdPropertyValues TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" WinmdFiles="@(_PackagingOutputWinmd)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="UnionWinmdRequired" PropertyName="_UnionWinmdRequired" />
    </GetUnionWinmdPropertyValues>
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsSDK_UnionMetadataPath" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PropertyValue" PropertyName="_UnionMetadataPath" />
    </GetSdkPropertyValue>
    <ItemGroup>
      <UnionWinmdPath Condition="'$(_UnionMetadataPath)' == ''" Include="$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd" />
      <UnionWinmdPath Condition="'$(_UnionMetadataPath)' != ''" Include="$(_UnionMetadataPath)\Windows.winmd" />
      <UnionMetadataWinmd Include="@(UnionWinmdPath)" Condition="Exists(@(UnionWinmdPath)) AND ('IncludeWindowsSdkWinmd' == 'true' OR '$(_UnionWinmdRequired)' == 'true')">
        <ResolvedFrom>GetSDKReferenceFiles</ResolvedFrom>
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>$(WinMetadataDir)\Windows.winmd</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </UnionMetadataWinmd>
      <PackagingOutputs Include="@(UnionMetadataWinmd)" />
    </ItemGroup>
  </Target>
  <!-- Add referenced winmds from Framework SDKs -->
  <Target Name="_AddFxWinmd" Condition="'$(AppxPackage)' == 'true' AND&#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_FrameworkSdkReference Include="@(ResolvedSDKReference)" Condition=" '%(ResolvedSDKReference.FrameworkIdentity)' != '' " />
    </ItemGroup>
    <PropertyGroup>
      <_FrameworkSdkNames>@(_FrameworkSdkReference->'%(SDKName)', ';')</_FrameworkSdkNames>
    </PropertyGroup>
    <ItemGroup>
      <WinmdsFromFrameworkSDKs Include="@(ReferencesFromSDK)" Condition="$(_FrameworkSdkNames.Contains('%(ReferencesFromSDK.ReferenceFromSDK)')) and&#xD;&#xA;                                          '%(ReferencesFromSDK.WinMDFile)'=='true'">
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>$(WinMetadataDir)\$([System.IO.Path]::GetFileName(%(ReferencesFromSDK.Identity)))</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </WinmdsFromFrameworkSDKs>
      <PackagingOutputs Include="@(WinmdsFromFrameworkSDKs)" />
    </ItemGroup>
  </Target>
  <!-- =================================================================================================== -->
  <!-- Computes the AppxUpload creation flag for UAP if the user did not specify a UapAppxPackageBuildMode -->
  <!-- =================================================================================================== -->
  <Target Name="_ComputeBuildAppxUploadPackageForUapFlag" DependsOnTargets="_FindStoreAssociationFile">
    <!-- When buildling from the commandline, if the BuildMode is NOT set but an AppxUpload package is requested, we have to make a couple extra checks -->
    <PropertyGroup Condition="'$(BuildingInsideVisualStudio)' != 'true' and&#xD;&#xA;                              '$(UapAppxPackageBuildModeIsValid)' == 'false' and&#xD;&#xA;                              '$(BuildAppxUploadPackageForUap)' != ''">
      <!-- First, we assume that this flow should NOT be creating an .appxupload/.msixupload package -->
      <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
      <!-- If we are here, the build mode was NOT explicitly set. So, only produce an .appxupload/.msixupload if:
        - we are in the UAP pipeline
        - AND the .NetNative toolchain is not disabled (doing a negative check as non .net platforms may leave this value blank)
        - AND the project configuration is not Debug (doing a negative check to avoid ruling out custom build configurations)
        - AND the store association file exists
      -->
      <BuildAppxUploadPackageForUap Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and&#xD;&#xA;                                               '$(UseDotNetNativeToolchain)' != 'false' and&#xD;&#xA;                                               '$(Configuration)' != 'Debug' and&#xD;&#xA;                                               '%(StoreAssociationFile.Identity)' != ''">true</BuildAppxUploadPackageForUap>
    </PropertyGroup>
  </Target>
  <!-- ================================================================================================== -->
  <!-- Computes Appx package payload that will be included in the appx package (excluding Appx manifest). -->
  <!-- ================================================================================================== -->
  <Target Name="_ComputeAppxPackagePayload" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="_FindSourceAppxContentGroupMap">
    <RemoveRedundantCopyLocalItems Condition="'$(AppxRemoveRedundantCopyLocalItems)' == 'true'" Inputs="@(PackagingOutputs)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_PackagingOutputsWithoutRedundantCopyLocalItems" />
    </RemoveRedundantCopyLocalItems>
    <ItemGroup Condition="'$(AppxRemoveRedundantCopyLocalItems)' != 'true'">
      <_PackagingOutputsWithoutRedundantCopyLocalItems Include="@(PackagingOutputs)" />
    </ItemGroup>
    <ItemGroup>
      <_UnfilteredAppxPackagePayload Include="@(_PackagingOutputsWithoutRedundantCopyLocalItems)" Condition="'%(Extension)' != '.pri' AND&#xD;&#xA;                                                                                                             '%(OutputGroup)' != 'GetResolvedSDKReferences' AND&#xD;&#xA;                                                                                                             '%(OutputGroup)' != '_GetProjectArchitecture' AND&#xD;&#xA;                                                                                                             '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'" />
      <_UnfilteredAppxPackagePayload Include="@(_ExpandedPriPayload)" />
      <_UnfilteredAppxPackagePayload Include="@(ProjectPriFile)" />
    </ItemGroup>
    <!-- Users can manually populate the AppxPackagePayload. In the .NetNative case, this is handled by ILC. Otherwise, we need to retain those files -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true'">
      <!-- If the user added a payload with a rooted path, we can safely use that -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'true'" Include="@(AppxPackagePayload->'%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>
      <!-- If the user added a payload with a relative path, we make the assumption that it's relative to the project root and build out the full path -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'false'" Include="@(AppxPackagePayload->'$(MSBuildProjectDirectory)\%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>
      <!-- Reset the AppxPackagePayload to avoid duplicate entries later -->
      <AppxPackagePayload Remove="@(AppxPackagePayload)" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_UnfilteredAppxUploadPackagePayload Include="@(_PackagingOutputsWithoutRedundantCopyLocalItems)" Condition="'%(Extension)' != '.pri' AND&#xD;&#xA;                                                                                                                   '%(OutputGroup)' != 'GetResolvedSDKReferences' AND&#xD;&#xA;                                                                                                                   '%(OutputGroup)' != '_GetProjectArchitecture' AND&#xD;&#xA;                                                                                                                   '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'" />
      <_UnfilteredAppxUploadPackagePayload Include="@(_ExpandedPriUploadPayload)" />
      <_UnfilteredAppxUploadPackagePayload Include="@(ProjectPriUploadFile)" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(_UnfilteredAppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="AppxPackagePayload" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="@(_UnfilteredAppxUploadPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="DeDupedAppxUploadPackagePayload" />
    </RemovePayloadDuplicates>
    <!--
        If packaging outputs contain a file named AppxManifest.xml, this is an override manifest and it is handled elsewhere.
        If packaging outputs contain the store association file, we need to remove it. Furthermore,
        we need to remove the SourceAppxContentGroupMap file, or if producing an Appx Bundle, the AppxContentGroupMap as well.
        Except for builds using PackageLayout - in that case, we leave the AppxContentGroupMap in.
    -->
    <ItemGroup>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == '$(AppxManifestFileName)'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'Package.StoreAssociation.xml'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'SourceAppxContentGroupMap.xml'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'$(UseAppxLayout)' != 'true' AND&#xD;&#xA;                                                                    '$(ProduceAppxBundle)' == 'true' AND&#xD;&#xA;                                                                    '%(TargetPath)' == 'AppxContentGroupMap.xml'" />
      <!-- If we're flat bundling, remove any assets that will be placed in the dedicated asset package. -->
      <AppxPackagePayload Remove="@(_AppxLayoutAssetPackageFiles)" Condition="'$(UseAppxLayout)' == 'true'" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <DeDupedAppxUploadPackagePayload Remove="@(DeDupedAppxUploadPackagePayload)" Condition="'%(TargetPath)' == '$(AppxManifestFileName)'" />
    </ItemGroup>
    <!-- If we are NOT going through the .Net Native toolchain, this generated payload becomes the payload we'll package for upload -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackagePayload Include="@(DeDupedAppxUploadPackagePayload)" />
    </ItemGroup>
    <!-- If the Upload packaging outputs contain the store association file, the SourceAppxContentGroupMap file, 
         or if producing an Appx Bundle, the AppxContentGroupMap, we need to remove it
         Except for builds using PackageLayout - in that case, we leave the AppxContentGroupMap in.
    -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(TargetPath)' == 'Package.StoreAssociation.xml'" />
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(TargetPath)' == 'SourceAppxContentGroupMap.xml'" />
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'$(UseAppxLayout)' != 'true' AND&#xD;&#xA;                                                                                '$(ProduceAppxBundle)' == 'true' AND&#xD;&#xA;                                                                                '%(TargetPath)' == 'AppxContentGroupMap.xml'" />
      <!-- If we're flat bundling, remove any assets that will be placed in the dedicated asset package. -->
      <AppxUploadPackagePayload Remove="@(_AppxLayoutAssetPackageFiles)" Condition="'$(UseAppxLayout)' == 'true'" />
    </ItemGroup>
    <ItemGroup>
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'&#xD;&#xA;                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' != ''" />
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'&#xD;&#xA;                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' == ''">
        <MSBuildSourceProjectFile>$(MSBuildProjectFullPath)</MSBuildSourceProjectFile>
      </_ProjectArchitectureFromPayload>
    </ItemGroup>
    <GenerateProjectArchitecturesFile ProjectArchitectures="@(_ProjectArchitectureFromPayload)" ProjectArchitecturesFilePath="$(_ProjectArchitecturesFilePath)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <FileWrites Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>
  </Target>
  <!-- BEGIN APPXLAYOUT PREPARATION -->
  <!-- ==================================================================================== -->
  <!-- Ingest AppxLayout files.                                                             -->
  <!-- Happens prior to kicking off any other work.                                         -->
  <!-- ==================================================================================== -->
  <PropertyGroup>
    <_ReadAppxLayoutDependsOn>
      _FindAppxLayoutFile;
      _ReadAppxLayoutTemplate;
    </_ReadAppxLayoutDependsOn>
  </PropertyGroup>
  <Target Name="_ReadAppxLayout" Condition="'$(AppxLayoutEnabled)' == 'true'" DependsOnTargets="$(_ReadAppxLayoutDependsOn)" />
  <!-- ===================================================================================== -->
  <!-- Locate the .packagelayout file.                                                          -->
  <!-- ===================================================================================== -->
  <Target Name="_FindAppxLayoutFile">
    <ItemGroup Condition="'@(AppxLayoutFile)' == ''">
      <AppxLayoutFile Include="@(PackageLayout)" Condition="'%(Identity)' != ''" />
      <AppxLayoutFile Include="@(Content)" Condition="'%(Identity)' == '$(AppxLayoutFileName)' and '$(AppxLayoutFile)' == ''" />
      <AppxLayoutFile Include="@(Text)" Condition="'%(Identity)' == '$(AppxLayoutFileName)' and '$(AppxLayoutFile)' == ''" />
      <None Remove="@(PackageLayout)" Condition="'%(Identity)' == '$(AppxLayoutFileName)'" />
    </ItemGroup>
    <PropertyGroup>
      <UseAppxLayout Condition="'%(AppxLayoutFile.Identity)' == ''">false</UseAppxLayout>
      <UseAppxLayout Condition="'%(AppxLayoutFile.Identity)' != ''">true</UseAppxLayout>
    </PropertyGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Getting template components.                                                          -->
  <!-- ===================================================================================== -->
  <Target Name="_ReadAppxLayoutTemplate" Condition="'$(UseAppxLayout)' == 'true'">
    <ReadAppxLayoutTemplate AppxLayoutTemplatePath="@(AppxLayoutFile)" GenerateSideloadItems="$(BuildAppxSideloadPackageForUap)" GenerateUploadItems="$(BuildAppxUploadPackageForUap)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AppxLayoutIsValid" PropertyName="_UseAppxLayoutFlag" />
      <Output TaskParameter="AppxLayoutIsTemplate" PropertyName="_AppxLayoutIsTemplateFlag" />
      <Output TaskParameter="GeneratedPackageFamilies" ItemName="_GeneratedPackageFamilies" />
      <Output TaskParameter="GeneratedPackages" ItemName="_GeneratedPackages" />
      <Output TaskParameter="GeneratedResourcePackages" ItemName="_GeneratedResourcePackages" />
      <Output TaskParameter="GeneratedAssetPackages" ItemName="_GeneratedAssetPackages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="PackageFamilies" ItemName="_PackageFamilies" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="Packages" ItemName="_Packages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="ResourcePackages" ItemName="_ResourcePackages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="AssetPackages" ItemName="_AssetPackages" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="Files" ItemName="_Files" />
      <Output Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" TaskParameter="Resources" ItemName="_Resources" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadPackageFamilies" ItemName="_UploadPackageFamilies" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadPackages" ItemName="_UploadPackages" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadResourcePackages" ItemName="_UploadResourcePackages" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadAssetPackages" ItemName="_UploadAssetPackages" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadFiles" ItemName="_UploadFiles" />
      <Output Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" TaskParameter="UploadResources" ItemName="_UploadResources" />
      <Output TaskParameter="OptionalPackages" ItemName="_OptionalPackages" />
      <Output TaskParameter="PrebuiltPackages" ItemName="_PrebuiltPackages" />
      <Output TaskParameter="AssetPackageFiles" ItemName="_AssetPackageFiles" />
    </ReadAppxLayoutTemplate>
    <ItemGroup>
      <_AppxLayoutGeneratedPackageFamilies Include="@(_GeneratedPackageFamilies)" />
      <_AppxLayoutGeneratedPackages Include="@(_GeneratedPackages)" />
      <_AppxLayoutGeneratedResourcePackages Include="@(_GeneratedResourcePackages)" />
      <_AppxLayoutGeneratedAssetPackages Include="@(_GeneratedAssetPackages)" />
      <_AppxLayoutOptionalPackages Include="@(_OptionalPackages)" />
      <_AppxLayoutPrebuiltPackages Include="@(_PrebuiltPackages)" />
      <_AppxLayoutAssetPackageFiles Include="@(_AssetPackageFiles)" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutPackageFamilies Include="@(_PackageFamilies)" />
      <_AppxLayoutPackages Include="@(_Packages)" />
      <_AppxLayoutResourcePackages Include="@(_ResourcePackages)" />
      <_AppxLayoutAssetPackages Include="@(_AssetPackages)" />
      <_AppxLayoutFiles Include="@(_Files)" />
      <_AppxLayoutResources Include="@(_Resources)" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadPackageFamilies Include="@(_UploadPackageFamilies)" />
      <_AppxLayoutUploadPackages Include="@(_UploadPackages)" />
      <_AppxLayoutUploadResourcePackages Include="@(_UploadResourcePackages)" />
      <_AppxLayoutUploadAssetPackages Include="@(_UploadAssetPackages)" />
      <_AppxLayoutUploadFiles Include="@(_UploadFiles)" />
      <_AppxLayoutUploadResources Include="@(_UploadResources)" />
    </ItemGroup>
    <PropertyGroup>
      <UseAppxLayout>$(_UseAppxLayoutFlag)</UseAppxLayout>
      <AppxLayoutIsTemplate>$(_AppxLayoutIsTemplateFlag)</AppxLayoutIsTemplate>
    </PropertyGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Convert any GeneratedPackage templates into actual Package entries.                   -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutMainPackage" Condition="'$(UseAppxLayout)' == 'true' and&#xD;&#xA;                     '$(AppxLayoutIsTemplate)' == 'true'">
    <!-- Generate SIDELOAD PackageFamilies and Packages from the template, if requested -->
    <HydrateAppxLayoutPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" GeneratedPackageFamilies="@(_AppxLayoutGeneratedPackageFamilies)" GeneratedPackages="@(_AppxLayoutGeneratedPackages)" PackageFamilies="@(_AppxLayoutPackageFamilies)" Packages="@(_AppxLayoutPackages)" PackageExtPrefix="$(PackageExtPrefix)" Platforms="$(AppxBundlePlatforms)" Architecture="$(PackageArchitecture)" FileMap="$(AppxBundleMainPackageFileMapPath)" ContentGroupMap="$(AppxContentGroupMapFullPath)" PackageFamilyManifest="@(FinalAppxManifest)" PackageManifest="@(AppxManifestForBundle)" AppName="$(ProjectName)" AppVersion="$(AppxManifestIdentityVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewPackageFamilies" ItemName="HydratePackagePackageFamilies" />
      <Output TaskParameter="NewPackages" ItemName="HydratePackagePackages" />
      <Output TaskParameter="NewFiles" ItemName="HydratePackageFiles" />
      <Output TaskParameter="NewResources" ItemName="HydratePackageResources" />
    </HydrateAppxLayoutPackage>
    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutPackageFamilies Include="@(HydratePackagePackageFamilies)" />
      <_AppxLayoutPackages Include="@(HydratePackagePackages)" />
      <_AppxLayoutFiles Include="@(HydratePackageFiles)" />
      <_AppxLayoutResources Include="@(HydratePackageResources)" />
    </ItemGroup>
    <!-- Generate UPLOAD PackageFamilies and Packages from the template, if requested -->
    <HydrateAppxLayoutPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" GeneratedPackageFamilies="@(_AppxLayoutGeneratedPackageFamilies)" GeneratedPackages="@(_AppxLayoutGeneratedPackages)" PackageFamilies="@(_AppxLayoutUploadPackageFamilies)" Packages="@(_AppxLayoutUploadPackages)" PackageExtPrefix="$(PackageExtPrefix)" Platforms="$(AppxBundlePlatforms)" Architecture="$(PackageArchitecture)" FileMap="$(AppxUploadBundleMainPackageFileMapPath)" ContentGroupMap="$(AppxContentGroupMapFullPath)" PackageFamilyManifest="@(FinalAppxUploadManifest)" PackageManifest="@(AppxUploadManifestForBundle)" AppName="$(ProjectName)" AppVersion="$(AppxManifestIdentityVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewPackageFamilies" ItemName="HydratePackageUploadPackageFamilies" />
      <Output TaskParameter="NewPackages" ItemName="HydratePackageUploadPackages" />
      <Output TaskParameter="NewFiles" ItemName="HydratePackageUploadFiles" />
      <Output TaskParameter="NewResources" ItemName="HydratePackageUploadResources" />
    </HydrateAppxLayoutPackage>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadPackageFamilies Include="@(HydratePackageUploadPackageFamilies)" />
      <_AppxLayoutUploadPackages Include="@(HydratePackageUploadPackages)" />
      <_AppxLayoutUploadFiles Include="@(HydratePackageUploadFiles)" />
      <_AppxLayoutUploadResources Include="@(HydratePackageUploadResources)" />
    </ItemGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Convert any GeneratedResourcePackage templates into actual ResourcePackage entries.   -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutResourcePackage" Condition="'$(UseAppxLayout)' == 'true' and&#xD;&#xA;                     '$(AppxLayoutIsTemplate)' == 'true'">
    <!-- Generate SIDELOAD ResourcePackages from the template -->
    <HydrateAppxLayoutResourcePackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" GeneratedResourcePackages="@(_AppxLayoutGeneratedResourcePackages)" PackageFamilies="@(_AppxLayoutPackageFamilies)" PackageExtPrefix="$(PackageExtPrefix)" ResourcePackages="@(_AppxLayoutResourcePackages)" FileMaps="@(_AppxBundleResourceFileMaps)" ContentGroupMap="$(AppxContentGroupMapFullPath)" PackageManifest="@(AppxManifestForBundle)" AppName="$(ProjectName)" AppVersion="$(AppxManifestIdentityVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewResourcePackages" ItemName="HydrateResPackResourcePackages" />
      <Output TaskParameter="NewFiles" ItemName="HydrateResPackFiles" />
      <Output TaskParameter="NewResources" ItemName="HydrateResPackResources" />
    </HydrateAppxLayoutResourcePackage>
    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutResourcePackages Include="@(HydrateResPackResourcePackages)" />
      <_AppxLayoutFiles Include="@(HydrateResPackFiles)" />
      <_AppxLayoutResources Include="@(HydrateResPackResources)" />
    </ItemGroup>
    <!-- Generate UPLOAD ResourcePackages from the template -->
    <HydrateAppxLayoutResourcePackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" GeneratedResourcePackages="@(_AppxLayoutGeneratedResourcePackages)" PackageFamilies="@(_AppxLayoutUploadPackageFamilies)" PackageExtPrefix="$(PackageExtPrefix)" ResourcePackages="@(_AppxLayoutUploadResourcePackages)" FileMaps="@(_AppxUploadBundleResourceFileMaps)" ContentGroupMap="$(AppxContentGroupMapFullPath)" PackageManifest="@(AppxUploadManifestForBundle)" AppName="$(ProjectName)" AppVersion="$(AppxManifestIdentityVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewResourcePackages" ItemName="HydrateResPackUploadResourcePackages" />
      <Output TaskParameter="NewFiles" ItemName="HydrateResPackUploadFiles" />
      <Output TaskParameter="NewResources" ItemName="HydrateResPackUploadResources" />
    </HydrateAppxLayoutResourcePackage>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadResourcePackages Include="@(HydrateResPackUploadResourcePackages)" />
      <_AppxLayoutUploadFiles Include="@(HydrateResPackUploadFiles)" />
      <_AppxLayoutUploadResources Include="@(HydrateResPackUploadResources)" />
    </ItemGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Convert any GeneratedAssetPackage templates into actual AssetPackage entries.   -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutAssetPackage" Condition="'$(UseAppxLayout)' == 'true' and&#xD;&#xA;                     '$(AppxLayoutIsTemplate)' == 'true' and&#xD;&#xA;                     ('$(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)')">
    <HydrateAppxLayoutAssetPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" GeneratedAssetPackages="@(_AppxLayoutGeneratedAssetPackages)" PackageFamilies="@(_AppxLayoutPackageFamilies)" PackageExtPrefix="$(PackageExtPrefix)" AssetPackages="@(_AppxLayoutAssetPackages)" PackageManifest="@(AppxManifestForBundle)" AppName="$(ProjectName)" AppVersion="$(AppxManifestIdentityVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewAssetPackages" ItemName="HydrateAssetPackAssetPackages" />
      <Output TaskParameter="NewFiles" ItemName="HydrateAssetPackFiles" />
    </HydrateAppxLayoutAssetPackage>
    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutAssetPackages Include="@(HydrateAssetPackAssetPackages)" />
      <_AppxLayoutFiles Include="@(HydrateAssetPackFiles)" />
    </ItemGroup>
    <HydrateAppxLayoutAssetPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" GeneratedAssetPackages="@(_AppxLayoutGeneratedAssetPackages)" PackageFamilies="@(_AppxLayoutUploadPackageFamilies)" PackageExtPrefix="$(PackageExtPrefix)" AssetPackages="@(_AppxLayoutUploadAssetPackages)" PackageManifest="@(AppxUploadManifestForBundle)" AppName="$(ProjectName)" AppVersion="$(AppxManifestIdentityVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="NewAssetPackages" ItemName="HydrateAssetPackUploadAssetPackages" />
      <Output TaskParameter="NewFiles" ItemName="HydrateAssetPackUploadFiles" />
    </HydrateAppxLayoutAssetPackage>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadAssetPackages Include="@(HydrateAssetPackUploadAssetPackages)" />
      <_AppxLayoutUploadFiles Include="@(HydrateAssetPackUploadFiles)" />
    </ItemGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Convert any Optional or External packages into actual PrebuiltPackage entries.        -->
  <!--   NOTE: this step needs to happen even for non-template appxlayouts                   -->
  <!--         since we can't handle true optional PackageFamily entries.                    -->
  <!-- ===================================================================================== -->
  <Target Name="_HydrateAppxLayoutPrebuiltPackage" Condition="'$(UseAppxLayout)' == 'true' and&#xD;&#xA;                     '$(AppxLayoutIsTemplate)' == 'true' and&#xD;&#xA;                     ('$(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)')">
    <HydrateAppxLayoutPrebuiltPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" PrebuiltPackages="@(_AppxLayoutPrebuiltPackages)" ExternalPackages="@(BundleMappingSideloadExternalPackages)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FinalPrebuiltPackage" ItemName="HydratePrebuiltPrebuildPackages" />
    </HydrateAppxLayoutPrebuiltPackage>
    <ItemGroup Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
      <_AppxLayoutFinalPrebuiltPackages Include="@(HydratePrebuiltPrebuildPackages)" />
    </ItemGroup>
    <HydrateAppxLayoutPrebuiltPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" PrebuiltPackages="@(_AppxLayoutPrebuiltPackages)" ExternalPackages="@(BundleMappingUploadExternalPackages)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FinalPrebuiltPackage" ItemName="HydratePrebuiltUploadPrebuildPackages" />
    </HydrateAppxLayoutPrebuiltPackage>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_AppxLayoutUploadFinalPrebuiltPackages Include="@(HydratePrebuiltUploadPrebuildPackages)" />
    </ItemGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Generate the platform AppxLayout file for sideload package bundling.                  -->
  <!-- ===================================================================================== -->
  <Target Name="_CreatePlatformAppxLayoutFiles" Condition="'$(UseAppxLayout)' == 'true' and&#xD;&#xA;                     '$(AppxLayoutIsTemplate)' == 'true'">
    <GenerateAppxLayout Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" AppxLayoutFile="$(PlatformAppxLayoutFile)" Architecture="$(PackageArchitecture)" PackageFamilies="@(_AppxLayoutPackageFamilies)" Packages="@(_AppxLayoutPackages)" ResourcePackages="@(_AppxLayoutResourcePackages)" AssetPackages="@(_AppxLayoutAssetPackages)" PrebuiltPackages="@(_AppxLayoutFinalPrebuiltPackages)" Files="@(_AppxLayoutFiles)" Resources="@(_AppxLayoutResources)" VsTelemetrySession="$(VsTelemetrySession)" />
    <GenerateAppxLayout Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" AppxLayoutFile="$(PlatformAppxLayoutUploadFile)" Architecture="$(PackageArchitecture)" PackageFamilies="@(_AppxLayoutUploadPackageFamilies)" Packages="@(_AppxLayoutUploadPackages)" ResourcePackages="@(_AppxLayoutUploadResourcePackages)" AssetPackages="@(_AppxLayoutUploadAssetPackages)" PrebuiltPackages="@(_AppxLayoutUploadFinalPrebuiltPackages)" Files="@(_AppxLayoutUploadFiles)" Resources="@(_AppxLayoutUploadResources)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- ===================================================================================== -->
  <!-- Generate the final AppxLayout package.                                                -->
  <!-- ===================================================================================== -->
  <Target Name="_CreateAppxLayoutPackage" Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);$(PackageCertificateKeyFile)" Outputs="$(AppxPackageOutput)" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' == 'true'" DependsOnTargets="_DeleteAppxOutputFolderIfNecessary">
    <GenerateFinalAppxLayout AppxLayoutFile="$(PlatformAppxLayoutFile)" Platforms="$(AppxBundlePlatforms)" FinalAppxLayoutFile="$(FinalAppxLayoutFile)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IsFlatBundle" PropertyName="_AppxLayoutFlatBundleIsFlat" />
    </GenerateFinalAppxLayout>
    <MakeAppxFlatBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" PackageLayout="$(FinalAppxLayoutFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" AppxPackageDir="$(AppxPackageTestDir)" Output="$(AppxPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)" />
    <RemoveDir Directories="$(AppxPackageTestExternalPackagesDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(BundleMappingSideloadExternalPackages)" DestinationFolder="$(AppxPackageTestExternalPackagesDir)" />
    <GetAppxFlatBundlePackages AppxPackageDir="$(AppxPackageTestDir)" AppxBundleFinalName="$(AppxBundleNameForOutput)" PackageExtPrefix="$(PackageExtPrefix)" ReturnBundlesOnly="!$(_AppxLayoutFlatBundleIsFlat)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="CreatedPackages" ItemName="AppxLayoutContents" />
    </GetAppxFlatBundlePackages>
    <SignAppxPackages Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackagesToSign="@(AppxLayoutContents)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" ExportCertificate="true" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackages>
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(ResolvedThumbprint)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>
  <!-- ===================================================================================== -->
  <!-- Generate the final AppxLayout upload package.                                         -->
  <!-- ===================================================================================== -->
  <Target Name="_CreateAppxLayoutUploadPackage" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadPackageOutput)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' == 'true'">
    <!-- Package the Upload Appx -->
    <GenerateFinalAppxLayout AppxLayoutFile="$(PlatformAppxLayoutUploadFile)" Platforms="$(AppxBundlePlatforms)" FinalAppxLayoutFile="$(FinalAppxLayoutUploadFile)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="IsFlatBundle" PropertyName="_AppxLayoutUploadFlatBundleIsFlat" />
    </GenerateFinalAppxLayout>
    <MakeAppxFlatBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" PackageLayout="$(FinalAppxLayoutUploadFile)" HashAlgorithmId="$(AppxHashAlgorithmId)" AppxPackageDir="$(AppxUploadPackageDir)" Output="$(AppxUploadPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)" />
    <GetAppxFlatBundlePackages AppxPackageDir="$(AppxUploadPackageDir)" AppxBundleFinalName="$(AppxBundleNameForOutput)" PackageExtPrefix="$(PackageExtPrefix)" ReturnBundlesOnly="!$(_AppxLayoutUploadFlatBundleIsFlat)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="CreatedPackages" ItemName="AppxLayoutUploadContents" />
    </GetAppxFlatBundlePackages>
    <SignAppxPackages Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackagesToSign="@(AppxLayoutUploadContents)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" ExportCertificate="true" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackages>
    <RemoveDir Directories="$(AppxUploadPackageExternalpackagesDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(BundleMappingUploadExternalPackages)" DestinationFolder="$(AppxUploadPackageExternalPackagesDir)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(ResolvedThumbprint)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>
  <!-- END APPXLAYOUT -->
  <!-- ==================================================================================== -->
  <!-- Generating Appx manifest.                                                            -->
  <!-- Happens after generating PRI file, for every project which can be packaged/deployed. -->
  <!-- ==================================================================================== -->
  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>
      $(_GenerateAppxManifestDependsOn);
      BeforeGenerateAppxManifest;
      _GenerateAdditionalFrameworkSDKReference;
      _GetRecursiveResolvedSDKReferences;
      _CopyCurrentProjectAppxManifestOverride;
      _CopyCurrentProjectAppxUploadManifestOverride;
      _CalculateInputsForGenerateCurrentProjectAppxManifest;
      _GenerateCurrentProjectAppxManifest;
      _CreateFinalAppxManifestItem;
      _FindStoreAssociationFile;
      _ValidateAppxManifest;
      BeforeCopyAppxManifestToUpload;
      _CopyProjectAppxManifestToAppxUpload;
      AfterGenerateAppxManifest
    </_GenerateAppxManifestDependsOn>
  </PropertyGroup>
  <Target Name="BeforeCopyAppxManifestToUpload" />
  <Target Name="_GenerateAdditionalFrameworkSDKReference">
    <PropertyGroup>
      <_AdjustedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_AdjustedPlatform>
      <_AdjustedPlatform Condition="'$(Platform)' == 'Win32'">x86</_AdjustedPlatform>
    </PropertyGroup>
    <ItemGroup>
      <_IntermediateFrameworkSdkReference Include="@(AppxPackageRegistration)" Condition="'@(AppxPackageRegistration)' != ''&#xD;&#xA;                   AND ('$(Configuration)' == '%(AppxPackageRegistration.Configuration)' OR '%(AppxPackageRegistration.Configuration)' == '')&#xD;&#xA;                   AND ('$(_AdjustedPlatform)' == '%(AppxPackageRegistration.Architecture)' OR '%(AppxPackageRegistration.Configuration)' == '')">
        <SDKName Condition="%(AppxPackageRegistration.Name) != ''">%(AppxPackageRegistration.Name)</SDKName>
        <SDKName Condition="%(AppxPackageRegistration.Name) == ''">%(AppxPackageRegistration.Filename)</SDKName>
        <TargetedSDKConfiguration>%(AppxPackageRegistration.Configuration)</TargetedSDKConfiguration>
        <TargetedSDKArchitecture>%(AppxPackageRegistration.Architecture)</TargetedSDKArchitecture>
        <AppxLocation>%(AppxPackageRegistration.Identity)</AppxLocation>
      </_IntermediateFrameworkSdkReference>
      <FrameworkSdkReference Include="@(_IntermediateFrameworkSdkReference)">
        <FrameworkIdentity>Name = %(_IntermediateFrameworkSdkReference.SDKName), MinVersion = %(_IntermediateFrameworkSdkReference.Version), Publisher = %(_IntermediateFrameworkSdkReference.Publisher)</FrameworkIdentity>
      </FrameworkSdkReference>
    </ItemGroup>
  </Target>
  <Target Name="_GenerateAppxManifest" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(_GenerateAppxManifestDependsOn)" />
  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxManifest" />
  <!-- Extract SDK references from the payload and filters out duplicates. -->
  <Target Name="_GetRecursiveResolvedSDKReferences">
    <ItemGroup>
      <_UnfilteredRecursiveResolvedSDKReference Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'GetResolvedSDKReferences'" />
    </ItemGroup>
    <RemoveDuplicateSDKReferences Inputs="@(_UnfilteredRecursiveResolvedSDKReference)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="RecursiveResolvedSDKReference" />
    </RemoveDuplicateSDKReferences>
    <ItemGroup>
      <FrameworkSdkReference Include="@(RecursiveResolvedSDKReference)" Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' != ''" />
    </ItemGroup>
    <ItemGroup>
      <NonFrameworkSdkReference Include="@(RecursiveResolvedSDKReference)" Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' == ''" />
    </ItemGroup>
    <!-- Add non-framework SDK versions to manifest build metadata. -->
    <ItemGroup>
      <AppxManifestMetadata Include="@(NonFrameworkSdkReference)">
        <Name>%(NonFrameworkSdkReference.SimpleName)</Name>
        <Version>%(NonFrameworkSdkReference.Version)</Version>
      </AppxManifestMetadata>
    </ItemGroup>
    <GetFrameworkSdkPackages FrameworkSdkReferences="@(FrameworkSdkReference)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkSdkPackage" />
    </GetFrameworkSdkPackages>
  </Target>
  <!-- Copy overriden AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxManifestOverride" Condition="Exists(@(CustomAppxManifest))" Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)" Outputs="$(FinalAppxManifestName)">
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(CustomAppxManifest)" DestinationFiles="$(FinalAppxManifestName)" />
  </Target>
  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxUploadManifestOverride" Condition="Exists(@(CustomAppxManifest)) and '$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)" Outputs="$(FinalAppxUploadManifestName)">
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(CustomAppxManifest)" DestinationFiles="$(FinalAppxUploadManifestName)" />
  </Target>
  <!-- Calculates list of input for _GenerateCurrentProjectAppxManifest target. -->
  <Target Name="_CalculateInputsForGenerateCurrentProjectAppxManifest">
    <ItemGroup Condition="'$(AppxHarvestWinmdRegistration)' == 'true'">
      <_WinmdFilesFromWinmdArtifacts Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'&#xD;&#xA;                                            and '%(PackagingOutputs.OutputGroup)' == 'CopyWinmdArtifactsOutputGroup'&#xD;&#xA;                                            and '%(PackagingOutputs.ProjectName)' != '$(ProjectName)'&#xD;&#xA;                                            and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromReferences Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'&#xD;&#xA;                                        and '%(PackagingOutputs.OutputGroup)' == 'CopyLocalFilesOutputGroup'&#xD;&#xA;                                        and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromOtherGroups Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'&#xD;&#xA;                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyWinmdArtifactsOutputGroup'&#xD;&#xA;                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyLocalFilesOutputGroup'&#xD;&#xA;                                         and '%(PackagingOutputs.ResolvedFrom)' != 'GetSDKReferenceFiles'&#xD;&#xA;                                         and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromSDKs Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'&#xD;&#xA;                                  and '%(PackagingOutputs.ResolvedFrom)' == 'GetSDKReferenceFiles'&#xD;&#xA;                                  and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromWinmdArtifacts)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromReferences)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromOtherGroups)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>
    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromSDKs)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_AppxSDKWinmdFilesForHarvest" />
    </RemovePayloadDuplicates>
    <ItemGroup>
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifestSchema)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(PackageCertificateKeyFile)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxWinmdFilesToHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxSDKWinmdFilesForHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(_QualifiersPath)" />
    </ItemGroup>
  </Target>
  <!-- Generates a final AppxManifest.xml that will be included in the appx package. -->
  <!-- The generation includes pre-processing of any tokens in the input manifest file to produce a valid appx manifest file. -->
  <!-- Input: [AppxManifest] Name of the manifest file template. -->
  <!-- Output: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_GenerateCurrentProjectAppxManifest" Condition="Exists(@(AppxManifest))" Inputs="$(MSBuildAllProjects);@(_GenerateCurrentProjectAppxManifestInput)" Outputs="$(FinalAppxManifestName)">
    <ItemGroup>
      <AppxManifestMetadata Include="$(MakePriExeFullPath)" />
    </ItemGroup>
    <GenerateAppxManifest AppxManifestInput="@(AppxManifest)" AppxManifestOutput="$(FinalAppxManifestName)" ApplicationExecutableName="$(TargetName)" FrameworkSdkReferences="@(FrameworkSdkReference)" NonFrameworkSdkReferences="@(NonFrameworkSdkReference)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" DefaultResourceLanguage="$(DefaultResourceLanguage)" QualifiersPath="$(_QualifiersPath)" PackageArchitecture="$(PackageArchitecture)" SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)" WinmdFiles="@(_AppxWinmdFilesToHarvest)" ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)" OSMinVersion="$(AppxOSMinVersion)" OSMaxVersionTested="$(AppxOSMaxVersionTested)" OSMinVersionReplaceManifestVersion="$(AppxOSMinVersionReplaceManifestVersion)" OSMaxVersionTestedReplaceManifestVersion="$(AppxOSMaxVersionTestedReplaceManifestVersion)" PackageSigningEnabled="$(AppxPackageSigningEnabled)" EnableSigningChecks="$(EnableSigningChecks)" ManifestMetadata="@(AppxManifestMetadata)" MetadataNamespaceUri="$(MetadataNamespaceUri)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" VsTelemetrySession="$(VsTelemetrySession)" WinmdCacheEnabled="$(AppxWinMdCacheEnabled)" WinmdCacheDir="$(AppxWinMdCacheDir)" />
    <ItemGroup>
      <AllGeneratedManifests Include="$(FinalAppxManifestName)" />
      <FileWrites Conditon="'$(AppxWinMdCacheEnabled)' == 'true'" Include="$(AppxWinMdCacheDir)\**\*" />
    </ItemGroup>
    <Message Text="$(MSBuildProjectName) -&gt; $(FinalAppxManifestName)" />
  </Target>
  <!-- In order for incremental build and clean to work correctly,       -->
  <!-- we are creating build item @(FinalAppxManifest) and @(FileWrites) -->
  <!-- in the target which always executes.                              -->
  <Target Name="_CreateFinalAppxManifestItem">
    <ItemGroup>
      <FinalAppxManifest Include="$(FinalAppxManifestName)" />
    </ItemGroup>
    <ItemGroup>
      <FileReads Include="@(CustomAppxManifest)" />
      <FileReads Include="@(_GenerateCurrentProjectAppxManifestInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(FinalAppxManifest)" />
    </ItemGroup>
  </Target>
  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyProjectAppxManifestToAppxUpload" Condition="('$(UseDotNetNativeToolchain)' != 'true' OR $([System.String]::Concat(',', $(AllowedPlatformsForProjectN.ToUpper()), ',').Contains(',$(PlatformTarget.ToUpper()),')) != 'true')&#xD;&#xA;                     AND '$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);" Outputs="$(FinalAppxUploadManifestName)">
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SourceFiles="@(FinalAppxManifest)" DestinationFiles="$(FinalAppxUploadManifestName)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SourceFiles="@(ProjectPriFile)" DestinationFiles="$(ProjectPriUploadFullPath)" />
    <ItemGroup>
      <FinalAppxUploadManifest Include="$(FinalAppxUploadManifestName)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(FinalAppxUploadManifest)" />
    </ItemGroup>
  </Target>
  <!-- Finds store association file. -->
  <Target Name="_FindStoreAssociationFile">
    <ItemGroup Condition="'@(StoreAssociationFile)' == ''">
      <StoreAssociationFile Include="@(Content)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
      <StoreAssociationFile Include="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml' and '$(StoreAssociationFile)' == ''" />
      <None Remove="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
    </ItemGroup>
  </Target>
  <!-- Finds and validates the bundle mapping file. -->
  <Target Name="_FindAndValidateBundleMappingFile">
    <ItemGroup Condition="'@(BundleMappingFile)' == ''">
      <BundleMappingFile Include="@(BundleMapping)" Condition="'%(Identity)' == 'Bundle.Mapping.txt'" />
      <BundleMappingFile Include="@(Content)" Condition="'%(Identity)' == 'Bundle.Mapping.txt' and '$(BundleMappingFile)' == ''" />
      <BundleMappingFile Include="@(Text)" Condition="'%(Identity)' == 'Bundle.Mapping.txt' and '$(BundleMappingFile)' == ''" />
      <None Remove="@(BundleMapping)" Condition="'%(Identity)' == 'Bundle.Mapping.txt'" />
    </ItemGroup>
    <ValidateBundleMapping Condition="'@(BundleMappingFile)' != ''" Input="@(BundleMappingFile)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="ExternalPackages" ItemName="_BundleMappingExternalPackages" />
      <Output TaskParameter="OptionalProjects" ItemName="_BundleMappingOptionalProjects" />
    </ValidateBundleMapping>
  </Target>
  <!-- Validates final Appx manifest. -->
  <Target Name="_ValidateAppxManifest" Condition="'$(SkipAppxManifestValidation)' != 'true'">
    <ValidateAppxManifest Input="@(FinalAppxManifest)" SourceAppxManifest="@(SourceAppxManifest)" AppxManifestSchema="@(AppxManifestSchema)" StoreAssociationFile="@(StoreAssociationFile)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" OSMinVersion="$(AppxOSMinVersion)" OSMaxVersionTested="$(AppxOSMaxVersionTested)" PlatformVersionDescriptions="@(PlatformVersionDescription)" ResolvedSDKReferences="@(RecursiveResolvedSDKReference)" ValidateWinmds="$(_CustomAppxManifestUsed)" StrictManifestValidationEnabled="$(AppxStrictManifestValidationEnabled)" WinmdFiles="@(_AppxWinmdFilesToHarvest)" SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)" NonFrameworkSdkReferences="@(NonFrameworkSdkReference)" ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)" ValidateManifest="$(AppxValidateAppxManifest)" AppxPackagingComponentManifestPath="$(AppxPackagingComponentManifestPath)" FrameworkSdkPackages="@(FrameworkSdkPackage)" VsTelemetrySession="$(VsTelemetrySession)" ProjectCapabilities="@(ProjectCapability)" WinmdCacheEnabled="$(AppxWinMdCacheEnabled)" WinMdCacheDir="$(AppxWinMdCacheDir)">
      <Output TaskParameter="Resources" ItemName="_ManifestResources" />
    </ValidateAppxManifest>
  </Target>
  <!-- Override to specify actions to happen after generating Appx manifest. -->
  <Target Name="AfterGenerateAppxManifest" />
  <!-- Validates Store manifest if it exists. -->
  <Target Name="_ValidateStoreManifest" Condition="'$(AppxValidateStoreManifest)' == 'true' and Exists($(StoreManifestName))">
    <ValidateStoreManifest Input="$(StoreManifestName)" StoreManifestSchema="@(StoreManifestSchema)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- ========================================================================================= -->
  <!-- Generating Appx package recipe.                                                           -->
  <!-- Happens after generating Appx manifest, for every project which can be packaged/deployed. -->
  <!-- ========================================================================================= -->
  <!-- Ensure Fast UpToDate check also consider the .appxrecipe file as an output -->
  <ItemGroup Condition="'$(AppxPackage)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxPackageRecipe)" />
  </ItemGroup>
  <ItemGroup Condition="'$(AppxPackage)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxUploadPackageRecipe)" />
  </ItemGroup>
  <PropertyGroup>
    <_GenerateAppxPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxPackageRecipe;
      _GenerateAppxPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxPackageRecipe
    </_GenerateAppxPackageRecipeDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <_GenerateAppxUploadPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxUploadPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxUploadPackageRecipe;
      _GenerateAppxUploadPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxUploadPackageRecipe
    </_GenerateAppxUploadPackageRecipeDependsOn>
  </PropertyGroup>
  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxPackageRecipe" />
  <Target Name="_GenerateAppxPackageRecipe" Condition="'$(AppxPackage)' == 'true' and&#xD;&#xA;                     '$(AppxGeneratePackageRecipeEnabled)' == 'true'" DependsOnTargets="$(_GenerateAppxPackageRecipeDependsOn)" />
  <Target Name="_GenerateAppxUploadPackageRecipe" Condition="'$(AppxPackage)' == 'true' and&#xD;&#xA;                     '$(AppxGeneratePackageRecipeEnabled)' == 'true' and&#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true'" DependsOnTargets="$(_GenerateAppxUploadPackageRecipeDependsOn)" />
  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_CalculateInputsForGenerateAppxPackageRecipe">
    <ItemGroup>
      <_GenerateAppxPackageRecipeInput Include="@(FinalAppxManifest)" />
      <_GenerateAppxPackageRecipeInput Include="@(AppxPackagePayload)" />
      <_GenerateAppxPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
      <_GenerateAppxPackageRecipeInput Include="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />
    </ItemGroup>
    <ItemGroup>
      <PDBPayload Include="@(AppxPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_CalculateInputsForGenerateAppxUploadPackageRecipe">
    <ItemGroup>
      <_GenerateAppxUploadPackageRecipeInput Include="@(FinalAppxUploadManifest)" />
      <_GenerateAppxUploadPackageRecipeInput Include="@(AppxUploadPackagePayload)" />
      <_GenerateAppxUploadPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>
    <ItemGroup>
      <PDBUploadPayload Include="@(AppxUploadPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>
    <!-- The uploaded .appx package should never include pdb's -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_GenerateAppxPackageRecipeFile" Inputs="$(MSBuildAllProjects);@(_GenerateAppxPackageRecipeInput)" Outputs="$(AppxPackageRecipe)" DependsOnTargets="_FindAppxContentGroupMap">
    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForRecipeFile" />
    </RemovePayloadDuplicates>
    <!-- Set the RecipeContentGroupMap if the AppxContentGroupMap file is not already included in the payload. This happens when ProduceAppxBundle is not true. -->
    <PropertyGroup>
      <RecipeContentGroupMap Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxContentGroupMapFullPath)</RecipeContentGroupMap>
    </PropertyGroup>
    <GenerateAppxPackageRecipe AppxContentGroupMap="$(RecipeContentGroupMap)" AppxManifestXml="%(FinalAppxManifest.FullPath)" AppxBundleManifestXml="$(FinalAppxBundleManifestName)" SourceAppxManifest="@(SourceAppxManifest)" SolutionConfiguration="$(Configuration)|$(Platform)" PayloadFiles="@(_DeduplicatedAppxPackagePayloadForRecipeFile)" FrameworkSdkPackages="@(FrameworkSdkPackage)" RecipeFile="$(AppxPackageRecipe)" SystemBinaries="@(AppxSystemBinary)" ReservedFileNames="@(AppxReservedFileName)" AppxManifestSchemas="@(AppxManifestSchema)" ManifestFileNameQueries="@(AppxManifestFileNameQuery)" ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)" AdditionalReRegisterAppIfChangedTargetPaths="@(AdditionalReRegisterAppIfChangedTargetPaths)" PackageArchitecture="$(PackageArchitecture)" ProjectDir="$(ProjectDir)" IntermediateOutputPath="$(IntermediateOutputPath)" MakePriExtensionPath="$(InProcessMakePriExtensionPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" PlatformVersionDescriptions="@(PlatformVersionDescription)" IndexedPayloadFiles="@(IndexedPayloadFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" UseResourceIndexerApi="$(AppxUseResourceIndexerApi)" DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)" RemoteDeploymentType="$(RemoteDeploymentType)" PackageRegistrationPath="$(PackageRegistrationPath)" RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)" WindowsSdkPath="$(WindowsSdkPath)" LayoutDir="$(LayoutDir)" OptionalProjectRecipeFiles="@(BundleMappingRecipes)" DeployOptionalPackages="$(DeployOptionalPackages)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <AllGeneratedRecipes Include="$(AppxPackageRecipe)" />
    </ItemGroup>
    <Message Text="$(MSBuildProjectName) -&gt; $(AppxPackageRecipe)" />
  </Target>
  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_GenerateAppxUploadPackageRecipeFile" Inputs="$(MSBuildAllProjects);@(_GenerateAppxUploadPackageRecipeInput)" Outputs="$(AppxUploadPackageRecipe)">
    <RemovePayloadDuplicates Inputs="@(AppxUploadPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxUploadPackagePayloadForRecipeFile" />
    </RemovePayloadDuplicates>
    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(TargetDir)$(AppxUploadPackageArtifactsDir)" />
    <GenerateAppxPackageRecipe AppxManifestXml="%(FinalAppxUploadManifest.FullPath)" AppxBundleManifestXml="$(FinalAppxBundleManifestName)" SourceAppxManifest="@(SourceAppxManifest)" SolutionConfiguration="$(Configuration)|$(Platform)" PayloadFiles="@(_DeduplicatedAppxUploadPackagePayloadForRecipeFile)" FrameworkSdkPackages="@(FrameworkSdkPackage)" RecipeFile="$(AppxUploadPackageRecipe)" SystemBinaries="@(AppxSystemBinary)" ReservedFileNames="@(AppxReservedFileName)" AppxManifestSchemas="@(AppxManifestSchema)" ManifestFileNameQueries="" ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)" PackageArchitecture="$(PackageArchitecture)" ProjectDir="$(ProjectDir)" IntermediateOutputPath="$(IntermediateOutputPath)" MakePriExtensionPath="$(InProcessMakePriExtensionPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" PlatformVersionDescriptions="@(PlatformVersionDescription)" IndexedPayloadFiles="@(IndexedPayloadFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" UseResourceIndexerApi="$(AppxUseResourceIndexerApi)" DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)" RemoteDeploymentType="$(RemoteDeploymentType)" PackageRegistrationPath="$(PackageRegistrationPath)" RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)" WindowsSdkPath="$(WindowsSdkPath)" LayoutDir="$(LayoutDir)" DeployOptionalPackages="$(DeployOptionalPackages)" VsTelemetrySession="$(VsTelemetrySession)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(AppxUploadPackageRecipe)" />
  </Target>
  <!-- Add FileReads and FileWrites done during generation of package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxPackageRecipe">
    <ItemGroup>
      <FileReads Include="@(_GenerateAppxPackageRecipeInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(AppxPackageRecipe)" />
    </ItemGroup>
  </Target>
  <!-- Add FileReads and FileWrites done during generation of upload package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxUploadPackageRecipe">
    <ItemGroup>
      <FileReads Include="@(_GenerateAppxUploadPackageRecipeInput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageRecipe)" />
    </ItemGroup>
  </Target>
  <!-- ==================================================================================== -->
  <!-- Creates a .tlog file from the FileReads items so that up-to-date check works in C++. -->
  <!-- ==================================================================================== -->
  <Target Name="_AppendToReadTlogFile" Condition="'$(Language)' == 'C++' and '@(FileReads)' != ''">
    <ItemGroup>
      <_FileReadsWithoutPDBs Include="@(FileReads)" Condition="%(Extension) != '.pdb'" />
    </ItemGroup>
    <WriteLinesToFile File="$(TLogLocation)$(ProjectName).read.1u.tlog" Lines="^$(ProjectPath);@(_FileReadsWithoutPDBs->'%(Fullpath)')" Encoding="Unicode" />
  </Target>
  <!-- ============================================================================ -->
  <!-- Creates a .tlog file from the FileWrites items so Clean target works in C++. -->
  <!-- ============================================================================ -->
  <Target Name="_AppendToWriteTlogFile" Condition="'$(Language)' == 'C++' and '@(FileWrites)' != ''">
    <WriteLinesToFile File="$(TLogLocation)$(ProjectName).write.1u.tlog" Lines="^$(ProjectPath);@(FileWrites->'%(Fullpath)')" Encoding="Unicode" />
  </Target>
  <!-- Remember packaging files and directories to clean later.   -->
  <!-- We have to roll our own because targets which handle       -->
  <!-- regular FileWrites items are not considering those outside -->
  <!-- output or intermediate directory.                          -->
  <Target Name="_AppendToPackagingWriteLogs">
    <WriteLinesToFile Condition="'@(PackagingFileWrites)' != ''" File="$(PackagingFileWritesLogPath)" Lines="@(PackagingFileWrites->'%(Fullpath)')" Encoding="Unicode" />
    <WriteLinesToFile Condition="'@(PackagingDirectoryWrites)' != ''" File="$(PackagingDirectoryWritesLogPath)" Lines="@(PackagingDirectoryWrites->'%(Fullpath)')" Encoding="Unicode" />
  </Target>
  <!-- =============================== -->
  <!-- Generating Appx package.        -->
  <!-- Happens when invoked explictly. -->
  <!-- =============================== -->
  <Target Name="_CalculateXbfSupport">
    <PropertyGroup>
      <_SupportXbfAsEmbedFileResources Condition="'$(_SupportEmbedFileResources)' == 'true' and '$(DisableEmbeddedXbf)' == 'false'">true</_SupportXbfAsEmbedFileResources>
      <_SupportXbfAsEmbedFileResources Condition="'$(DisableEmbeddedXbf)' == 'true'">false</_SupportXbfAsEmbedFileResources>
      <_SupportXbfAsEmbedFileResources Condition="'$(_SupportXbfAsEmbedFileResources)' == '' AND '$(_SupportEmbedFileResources)' == 'true'">true</_SupportXbfAsEmbedFileResources>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <_CleanArtifacts>
      _RemoveDisposableSigningCertificate;
    </_CleanArtifacts>
    <_GenerateAppxPackageBaseDependsOn>
      _ComputeAppxPackageOutput;
      _CreateAppxPackage;
      _CreateAppxBundlePlatformSpecificArtifacts;
      $(_CleanArtifacts);
    </_GenerateAppxPackageBaseDependsOn>
    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">
      $(_GenerateAppxPackageDependsOn);
      $(_GenerateAppxPackageBaseDependsOn);
      _ContinuousStoreSubmission;
    </_GenerateAppxPackageDependsOn>
    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' != 'true'">
      $(_GenerateAppxPackageDependsOn);
      _SuppressDeploymentOnlyFeatures;
      Build;
      $(_GenerateAppxPackageBaseDependsOn);
    </_GenerateAppxPackageDependsOn>
  </PropertyGroup>
  <Target Name="_GenerateAppxPackage" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(_GenerateAppxPackageDependsOn)">
    <Delete Files="$(InstallerFileWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <WriteLinesToFile Condition="'@(InstallerFileWrites)' != ''" File="$(InstallerFileWritesLogPath)" Lines="@(InstallerFileWrites->'%(Fullpath)')" Encoding="Unicode" />
    <ItemGroup>
      <FileWrites Include="$(InstallerFileWritesLogPath)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <_CreateAppxPackageDependsOn>
      _ValidateAppxPackage;
      _GenerateAppxPackageFile;
      _GenerateAppxUploadPackageFile;
      _GenerateAppxSymbolPackage;
      _GenerateAppxUploadSymbolPackage;
      _CreateAppStoreContainerForUAP;
      _CreateTestLayout;

      <!-- App Installer -->
      GenerateAppInstallerForPackage;

      _AddWindowsInstallScriptToTestLayout;
    </_CreateAppxPackageDependsOn>
  </PropertyGroup>
  <!-- Computes Appx package output (file name and directory). -->
  <Target Name="_ComputeAppxPackageOutput" DependsOnTargets="_GetPackageFileExtensions">
    <ReadLinesFromFile File="$(_MultipleQualifiersPerDimensionFoundPath)" Condition="'$(AppxBundle)' == 'Auto' and Exists($(_MultipleQualifiersPerDimensionFoundPath))">
      <Output TaskParameter="Lines" PropertyName="_MultipleQualifiersPerDimensionFound" />
    </ReadLinesFromFile>
    <PropertyGroup Condition="'$(AppxBundle)' == 'Auto'">
      <_MultipleQualifiersPerDimensionFound Condition="'$(_MultipleQualifiersPerDimensionFound)' != 'true'">false</_MultipleQualifiersPerDimensionFound>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.0'">
      <ProduceAppxBundle>false</ProduceAppxBundle>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetPlatformVersion)' != '8.0'">
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Auto'">$(_MultipleQualifiersPerDimensionFound)</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Never'">false</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Always'">true</ProduceAppxBundle>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageName)' != ''">
      <AppxPackageNameNeutral>$(AppxPackageName)</AppxPackageNameNeutral>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageName)' == ''">
      <AppxPackageNameNeutral>$(ProjectName)_$(AppxManifestIdentityVersion)</AppxPackageNameNeutral>
      <_AppxPackageConfiguration Condition="'$(Configuration)' != 'Release'">_$(Configuration)</_AppxPackageConfiguration>
      <AppxPackageName>$(AppxPackageNameNeutral)_$(Platform)$(_AppxPackageConfiguration)</AppxPackageName>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxStoreContainer)' == '' and '$(ProduceAppxBundle)' == 'false'">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageName)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>
    <!-- compute paths for appx -->
    <PropertyGroup Condition="'$(AppxPackageTestDir)' == ''">
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\</AppxPackageTestDir>
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\</AppxPackageTestDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageTestExternalPackagesDir)' == ''">
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxPackageOutput)' == ''">
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'true'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageExtension)</AppxPackageOutput>
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'true'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageEncryptedExtension)</AppxPackageOutput>
    </PropertyGroup>
    <!-- compute paths for Upload appx & symbols -->
    <PropertyGroup Condition="'$(AppxUploadPackageDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'false'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageName)\</AppxUploadPackageDir>
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'true'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\</AppxUploadPackageDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadPackageExternalpackagesDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageExternalpackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageName)\$(ExternalPackagesDir)</AppxUploadPackageExternalpackagesDir>
      <AppxUploadPackageExternalpackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\$(ExternalPackagesDir)</AppxUploadPackageExternalpackagesDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadPackageOutput)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxPackageExtension)</AppxUploadPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxSymbolPackageIntermediate)' == ''">
      <AppxSymbolPackageIntermediate>$(AppxSymbolIntermediateDir)\$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageIntermediate>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxSymbolPackageOutput)' == ''">
      <AppxSymbolPackageOutput>$(AppxPackageTestDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadSymbolPackageOutput)' == ''">
      <AppxUploadSymbolPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxUploadSymbolPackageOutput>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundleDir Condition="'$(AppxBundleDir)' == ''">$(IntermediateOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxBundleDir>
      <AppxBundleDir Condition="!HasTrailingSlash('$(AppxBundleDir)')">$(AppxBundleDir)\</AppxBundleDir>
    </PropertyGroup>
    <PropertyGroup>
      <AppxUploadBundleDir Condition="'$(AppxUploadBundleDir)' == ''">$(IntermediateUploadOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxUploadBundleDir>
      <AppxUploadBundleDir Condition="!HasTrailingSlash('$(AppxUploadBundleDir)')">$(AppxUploadBundleDir)\</AppxUploadBundleDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxMainPackageOutput)' == ''">
      <AppxMainPackageOutput>$(TargetDir)$(AppxPackageName)$(AppxPackageExtension)</AppxMainPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadMainPackageOutput)' == ''">
      <AppxUploadMainPackageOutput>$(TargetDir)Upload\$(AppxPackageName)$(AppxPackageExtension)</AppxUploadMainPackageOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxResourcePackOutputBase)' == ''">
      <AppxResourcePackOutputBase>$(TargetDir)$(AppxPackageNameNeutral)</AppxResourcePackOutputBase>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadResourcePackOutputBase)' == ''">
      <AppxUploadResourcePackOutputBase>$(TargetDir)Upload\$(AppxPackageNameNeutral)</AppxUploadResourcePackOutputBase>
    </PropertyGroup>
  </Target>
  <!-- Extracts hash URI from store association file or provide default. -->
  <!-- Extracts packaging platforms, too.                                -->
  <Target Name="_ExtractStoreAssociationInformation" DependsOnTargets="_FindStoreAssociationFile;_ComputeAppxPackageOutput" BeforeTargets="_CreateAppxPackage;_CreateMainPackage;_CreateResourcePackages;_CreateBundle;_CalculateAppxBundleProperties">
    <PropertyGroup>
      <_ExtractPlatforms Condition="'$(AppxBundlePlatforms)' == '' and '$(ProduceAppxBundle)' == 'true'">true</_ExtractPlatforms>
      <_ExtractPlatforms Condition="'$(_ExtractPlatforms)' == ''">false</_ExtractPlatforms>
    </PropertyGroup>
    <ExtractStoreAssociationInformation StoreAssociationFile="@(StoreAssociationFile)" HashUris="@(AppxHashUri)" ExtractPlatforms="$(_ExtractPlatforms)" VsTelemetrySession="$(VsTelemetrySession)" Condition="'@(StoreAssociationFile)' != ''">
      <Output TaskParameter="HashAlgorithmId" PropertyName="AppxHashAlgorithmId" />
      <Output TaskParameter="Platforms" PropertyName="_Platforms" />
    </ExtractStoreAssociationInformation>
    <Warning Condition="('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' == '' and '$(AppxBundlePlatforms)' == '')&#xD;&#xA;                         or ('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(_Platforms)' == '')" Text="APPX4001: Build property AppxBundlePlatforms is not explicitly set and is calculated based on currently building architecture. Use 'Create App Package' wizard or edit project file to set it." />
    <Warning Condition="'$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(AppxBundlePlatforms)' == '' and '$(_Platforms)' != ''" Text="APPX4002: Build property AppxBundlePlatforms is not explicitly set and is calculated based on uploaded packages in the Store for currently building app. Use 'Create App Package' wizard or edit project file to set it." />
    <PropertyGroup Condition="'$(AppxHashAlgorithmId)' == ''">
      <AppxHashAlgorithmId>$(AppxDefaultHashAlgorithmId)</AppxHashAlgorithmId>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_ExtractPlatforms)' == 'true'">
      <AppxBundlePlatforms>$(_Platforms.Replace(';', '|'))</AppxBundlePlatforms>
    </PropertyGroup>
  </Target>
  <!-- Executes pre-upload validation of the appx package. -->
  <Target Name="_ValidateAppxPackage" Condition="'$(AppxPackageValidationEnabled)' == 'true'">
    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForValidation" />
    </RemovePayloadDuplicates>
    <ValidateAppxPackage SourceAppxManifest="@(SourceAppxManifest)" AppxManifest="@(FinalAppxManifest)" StoreAssociationFile="@(StoreAssociationFile)" PackageArchitecture="$(PackageArchitecture)" AppxPackagePayload="@(_DeduplicatedAppxPackagePayloadForValidation)" AppxManifestSchemas="@(AppxManifestSchema)" ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)" ResolvedSDKReferences="@(RecursiveResolvedSDKReference)" AllowDebugFrameworkReferencesInManifest="$(AppxPackageAllowDebugFrameworkReferencesInManifest)" ProjectDir="$(ProjectDir)" MakePriExtensionPath="$(InProcessMakePriExtensionPath)" IndexedPayloadFiles="@(IndexedPayloadFiles)" OSMinVersion="$(AppxOSMinVersion)" ProduceAppxBundle="$(ProduceAppxBundle)" IndexedMainPayloadFiles="@(IndexedMainPayloadFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" UseResourceIndexerApi="$(AppxUseResourceIndexerApi)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <Target Name="_CreateAppxPackage" Condition="'$(ProduceAppxBundle)' == 'false' and '$(UseAppxLayout)' != 'true'" DependsOnTargets="$(_CreateAppxPackageDependsOn)" />
  <!-- The following target generates the appx package. -->
  <Target Name="_GenerateAppxPackageFile" Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);@(AppxPackagePayload);$(PackageCertificateKeyFile)" Outputs="$(AppxPackageOutput)" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'" DependsOnTargets="_FindAppxContentGroupMap;_DeleteAppxOutputFolderIfNecessary">
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForPackaging" />
    </RemovePayloadDuplicates>
    <WriteLinesToFile File="$(AppxPackageFileMap)" Lines="[Files];&#xD;&#xA;                                 @(FinalAppxManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');&#xD;&#xA;                                 @(_DeduplicatedAppxPackagePayloadForPackaging->'%22%(Identity)%22 %22%(TargetPath)%22')" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(AppxPackageFileMap)" />
    </ItemGroup>
    <!-- Package and sign the Test Appx -->
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxContentGroupMap="$(AppxContentGroupMapFullPath)" AppxStreamableMainPackage="$(AppxStreamableMainPackage)" AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)" ResourcePack="false" Parameters="$(CreatePackageMakeAppxParameters)" EncryptAppxPackage="$(AppxPackageEncryptionEnabled)" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" FileMap="$(AppxPackageFileMap)" Output="$(AppxPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <FinalAppxPackageItem Include="$(AppxPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <AllBuiltSideloadPackages Include="$(AppxPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="@(FinalAppxPackageItem)" />
      <InstallerFileWrites Include="@(FinalAppxPackageItem)" />
    </ItemGroup>
    <WriteLinesToFile File="$(AppxPackagingInfoFile)" Overwrite="true" Lines="%(FinalAppxPackageItem.FullPath)" />
    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>
    <Message Importance="high" Text="$(MSBuildProjectName) -&gt; %(FinalAppxPackageItem.FullPath)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="@(FinalAppxPackageItem)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" ExportCertificate="true" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(ResolvedThumbprint)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>
  <!-- The following target generates the appx Upload package. -->
  <Target Name="_GenerateAppxUploadPackageFile" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest);@(AppxUploadPackagePayload);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadPackageOutput)" DependsOnTargets="_FindAppxContentGroupMap">
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <RemovePayloadDuplicates Inputs="@(AppxUploadPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxUploadPackagePayloadForPackaging" />
    </RemovePayloadDuplicates>
    <WriteLinesToFile File="$(AppxUploadPackageFileMap)" Lines="[Files];&#xD;&#xA;                                 @(FinalAppxUploadManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');&#xD;&#xA;                                 @(_DeduplicatedAppxUploadPackagePayloadForPackaging->'%22%(Identity)%22 %22%(TargetPath)%22')" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageFileMap)" />
    </ItemGroup>
    <!-- Package and sign the Upload Appx -->
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxContentGroupMap="$(AppxContentGroupMapFullPath)" AppxStreamableMainPackage="$(AppxStreamableMainPackage)" AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)" ResourcePack="false" Parameters="$(CreatePackageMakeAppxParameters)" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" FileMap="$(AppxUploadPackageFileMap)" Output="$(AppxUploadPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)" IsUploadPackageOrComponent="true" />
    <ItemGroup>
      <FinalAppxUploadPackageItem Include="$(AppxUploadPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <AllBuiltUploadPackages Include="$(AppxUploadPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>
    <Message Importance="high" Text="$(MSBuildProjectName) -&gt; %(FinalAppxUploadPackageItem.FullPath)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="@(FinalAppxUploadPackageItem)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" ExportCertificate="true" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>
  <!-- The following target creates the appx symbol package. -->
  <Target Name="_GenerateAppxSymbolPackage" Condition="'$(AppxSymbolPackageEnabled)' == 'true' and &#xD;&#xA;                     '@(PDBPayload)' != '' and&#xD;&#xA;                     '$(BuildAppxSideloadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(PDBPayload);@(FinalAppxManifest)" Outputs="$(AppxSymbolPackageIntermediate)">
    <PropertyGroup>
      <ReconstituteFastlinkPdbs Condition="'$(ReconstituteFastlinkPdbs)' == ''">true</ReconstituteFastlinkPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>
    <GenerateAppxSymbolPackage MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)" InputPdbs="@(PDBPayload)" ProjectName="$(MSBuildProjectName)" StripPrivateSymbols="$(StripPrivateSymbols)" IntermediateSymbolRoot="$(AppxSymbolIntermediateDir)" ReconstituteFastlinkPdbs="$(ReconstituteFastlinkPdbs)" AppxSymbolPackageOutput="$(AppxSymbolPackageIntermediate)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="OutputPdbs" ItemName="OutputPdbFiles" />
    </GenerateAppxSymbolPackage>
    <ItemGroup>
      <FinalAppxSymbolPackageItem Include="$(AppxSymbolPackageIntermediate)" />
    </ItemGroup>
    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxSymbolPackageItem)" />
      <FileWrites Include="@(OutputPdbFiles)" />
      <PackagingDirectoryWrites Include="$(AppxSymbolIntermediateDir)" />
    </ItemGroup>
  </Target>
  <!-- The following target creates the Upload appx symbol package. -->
  <Target Name="_GenerateAppxUploadSymbolPackage" Condition="'$(AppxSymbolPackageEnabled)' == 'true' and &#xD;&#xA;                     '@(PDBUploadPayload)' != '' and &#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(PDBUploadPayload);@(FinalAppxManifest)" Outputs="$(AppxUploadSymbolPackageOutput)">
    <PropertyGroup>
      <ReconstituteFastlinkPdbs Condition="'$(ReconstituteFastlinkPdbs)' == ''">true</ReconstituteFastlinkPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>
    <GenerateAppxSymbolPackage MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)" InputPdbs="@(PDBUploadPayload)" ProjectName="$(MSBuildProjectName)" IntermediateSymbolRoot="$(AppxUploadSymbolIntermediateDir)" StripPrivateSymbols="$(StripPrivateSymbols)" ReconstituteFastlinkPdbs="$(ReconstituteFastlinkUploadPdbs)" AppxSymbolPackageOutput="$(AppxUploadSymbolPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="OutputPdbs" ItemName="OutputPdbUploadFiles" />
    </GenerateAppxSymbolPackage>
    <ItemGroup>
      <FinalAppxUploadSymbolPackageItem Include="$(AppxUploadSymbolPackageOutput)" />
    </ItemGroup>
    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxUploadSymbolPackageItem)" />
      <FileWrites Include="@(OutputPdbUploadFiles)" />
      <PackagingDirectoryWrites Include="$(AppxUploadSymbolIntermediateDir)" />
    </ItemGroup>
    <Message Text="$(MSBuildProjectName) -&gt; $(AppxUploadSymbolPackageOutput)" />
  </Target>
  <!-- Creates a test layout for testing of the appx package. -->
  <Target Name="_CreateTestLayout" Condition="'$(AppxTestLayoutEnabled)' == 'true' and&#xD;&#xA;                     '$(BuildAppxSideloadPackageForUap)' == 'true'">
    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(FileName)%(Extension)')" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxExcludeArmFrameworkSdkPackagesFromLayout)' != 'true'">
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'arm'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'arm'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxExcludeX86FrameworkSdkPackagesFromLayout)' != 'true'">
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'x86'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'x86'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>
    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' != 'neutral' and '%(Architecture)' != 'arm' and '%(Architecture)' != 'x86'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' != 'neutral' and '%(Architecture)' != 'arm' and '%(Architecture)' != 'x86'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_TestLayoutSourceFiles)" DestinationFiles="@(_TestLayoutTargetFiles)" />
    <!-- Copy the .appxsym files to the output directory -->
    <Copy Condition="Exists('$(AppxSymbolPackageIntermediate)')" UseHardlinksIfPossible="false" SourceFiles="$(AppxSymbolPackageIntermediate)" DestinationFiles="$(AppxSymbolPackageOutput)" />
    <ItemGroup>
      <InstallerFileWrites Include="@(_TestLayoutTargetFiles)" />
      <PackagingFileWrites Include="@(_TestLayoutTargetFiles)" />
      <PackagingDirectoryWrites Include="$(AppxPackageTestDir)" />
    </ItemGroup>
  </Target>
  <!-- Find the AppxContentGroupMap path. -->
  <Target Name="_FindAppxContentGroupMap">
    <ItemGroup Condition="'@(AppxContentGroupMap)' == ''">
      <AppxContentGroupMap Include="@(Content)" Condition="'%(Identity)' == 'AppxContentGroupMap.xml'" />
    </ItemGroup>
    <!-- Handle the case where the project is a VC Project -->
    <ItemGroup Condition="'@(AppxContentGroupMap)' == ''">
      <AppxContentGroupMap Include="@(Xml)" Condition="'%(Filename)%(Extension)' == 'AppxContentGroupMap.xml'" />
    </ItemGroup>
    <PropertyGroup>
      <AppxContentGroupMapFullPath>%(AppxContentGroupMap.FullPath)</AppxContentGroupMapFullPath>
    </PropertyGroup>
  </Target>
  <!-- Find the SourceAppxContentGroupMap path. -->
  <Target Name="_FindSourceAppxContentGroupMap">
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(AppxSourceContentGroupMap)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>
    <!-- Handle the case where the project is a JS project -->
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(Content)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>
    <!-- Handle the case where the project is a VC Project -->
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(Xml)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>
  </Target>
  <!-- Convert the SourceAppxContentGroupMap file into the target AppxContentGroupMap. -->
  <Target Name="_ConvertAppxContentGroupMap" Condition="'$(ConvertSourceAppxContentGroupMap)' == 'true'" DependsOnTargets="_FindAppxContentGroupMap;_FindSourceAppxContentGroupMap" Outputs="$(AppxMainPackageOutput)">
    <MakeAppxContentGroupMap MakeAppxExeFullPath="$(MakeAppxExeFullPath)" Output="$(AppxContentGroupMapFullPath)" SourceAppxContentGroupMap="@(SourceAppxContentGroupMap)" LayoutResFile="$(_UnfilteredLayoutResfilesPath)" ResourcePackFile="$(ProjectPriFullPath)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Add install script for Windows packages/bundles to the test layout. -->
  <Target Name="_AddWindowsInstallScriptToTestLayout" Condition="'$(AppxTestLayoutEnabled)' == 'true' and&#xD;&#xA;                     '$(_TargetPlatformIsWindowsPhone)' != 'true' and&#xD;&#xA;                     '$(BuildAppxSideloadPackageForUap)' == 'true'">
    <ItemGroup>
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)Add-AppDevPackage.ps1" />
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)**\Add-AppDevPackage.psd1" />
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)Install.ps1" />
    </ItemGroup>
    <ItemGroup>
      <_PowerShellScriptsDestination Include="@(_PowerShellScriptsSource->'$(AppxPackageTestDir)%(RecursiveDir)%(FileName)%(Extension)')" />
    </ItemGroup>
    <!--Copy install scripts to app package location.-->
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="true" SourceFiles="@(_PowerShellScriptsSource)" DestinationFiles="@(_PowerShellScriptsDestination)" ContinueOnError="$(ContinueOnError)" />
    <ItemGroup>
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)LogSideloadingTelemetry.ps1" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.Diagnostics.Tracing.EventSource.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.VisualStudio.Telemetry.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.VisualStudio.RemoteControl.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Microsoft.VisualStudio.Utilities.Internal.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)Newtonsoft.Json.dll" />
      <_PowerShellScriptTelemetryDependenciesSource Include="$(AppxMSBuildToolsPath)System.Runtime.CompilerServices.Unsafe.dll" />
    </ItemGroup>
    <ItemGroup>
      <_PowerShellScriptTelemetryDependenciesDestination Include="@(_PowerShellScriptTelemetryDependenciesSource->'$(AppxPackageTestDir)TelemetryDependencies\%(FileName)%(Extension)')" />
    </ItemGroup>
    <!--Copy install script telemetry dependencies to app package location if necessary.-->
    <Copy Condition="'$(AppxLogTelemetryFromSideloadingScript)' == 'true'" UseHardlinksIfPossible="false" SkipUnchangedFiles="true" SourceFiles="@(_PowerShellScriptTelemetryDependenciesSource)" DestinationFiles="@(_PowerShellScriptTelemetryDependenciesDestination)" ContinueOnError="$(ContinueOnError)" />
    <ItemGroup>
      <PackagingFileWrites Include="@(_PowerShellScriptsDestination)" />
      <PackagingFileWrites Include="@(_PowerShellScriptTelemetryDependenciesDestination)" Condition="'$(AppxLogTelemetryFromSideloadingScript)' == 'true'" />
    </ItemGroup>
  </Target>
  <!-- Creates .appxupload/.msixupload file containing .appx/.msix and optional .appxsym/.msix, -->
  <!-- which is used for uploading to Windows App Store.                -->
  <!-- only gets built if the package is for the Universal App Store              -->
  <Target Name="_CreateAppStoreContainerForUAP" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadPackageItem);@(FinalAppxUploadSymbolPackageItem)" Outputs="$(AppxStoreContainer)">
    <ItemGroup>
      <!-- create temp item just to use .FullPath -->
      <_AppxStoreContainer Include="$(AppxStoreContainer)" />
    </ItemGroup>
    <MakeDir Directories="$(AppxPackageDir)" />
    <CreateAppStoreContainer Items="@(FinalAppxUploadPackageItem);@(FinalAppxUploadSymbolPackageItem)" ProjectName="$(MSBuildProjectName)" OutputPath="%(_AppxStoreContainer.FullPath)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
    <WriteLinesToFile File="$(AppxUploadPackagingInfoFile)" Overwrite="true" Lines="$([System.IO.Path]::GetFullPath('$(AppxStoreContainer)'))" />
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackagingInfoFile)" />
    </ItemGroup>
  </Target>
  <!-- ================================================== -->
  <!-- Create platform-specific artifacts for app bundle. -->
  <!-- ================================================== -->
  <PropertyGroup>
    <_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
      $(Before_CreateAppxBundlePlatformSpecificArtifacts)

      _GetPackageProperties;

      _CreatePackageLayout_CalculateInputsAndOutputs;
      _CreatePackageLayout;
      _CreatePackageLayout_AddFileWrites;

      _CreateUploadPackageLayout_CalculateInputsAndOutputs;
      _CreateUploadPackageLayout;
      _CreateUploadPackageLayout_AddFileWrites;

      _GetDefaultResourceLanguage;

      _CreatePriConfigXmlForSplitting;
      _CreatePriConfigXmlForSplitting_AddFileWrites;

      _CreateUploadPriConfigXmlForSplitting;
      _CreateUploadPriConfigXmlForSplitting_AddFileWrites;

      _SplitResourcesPri_CalculateInputsAndOutputs;
      _SplitResourcesPri;
      _SplitResourcesPri_AddFileWrites;

      _SplitUploadResourcesPri_CalculateInputsAndOutputs;
      _SplitUploadResourcesPri;
      _SplitUploadResourcesPri_AddFileWrites;

      _ExpandMainPriFile;
      _ValidateAppxPackage;

      _CreatePriConfigXmlForMainPackageFileMap;
      _CreatePriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateUploadPriConfigXmlForMainPackageFileMap;
      _CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateMainPackageFileMap;
      _CreateMainPackageFileMap_AddFileWrites;

      _CreateUploadMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateUploadMainPackageFileMap;
      _CreateUploadMainPackageFileMap_AddFileWrites;

      _UpdateMainPackageFileMap;
      _UpdateMainPackageFileMap_AddFileWrites;

      _UpdateUploadMainPackageFileMap;
      _UpdateUploadMainPackageFileMap_AddFileWrites;

      _UpdateAppxManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxManifestForBundle;
      _UpdateAppxManifestForBundle_AddFileWrites;

      _UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxUploadManifestForBundle;
      _UpdateAppxUploadManifestForBundle_AddFileWrites;

      <!-- Create main app packages --><!-- UAP -->
      _CreateMainPackage;
      _CreateMainPackage_AddFileWrites;

      _CreateMainUploadPackage;
      _CreateMainUploadPackage_AddFileWrites;

      <!-- Flat Bundle -->
      _HydrateAppxLayoutMainPackage;

      <!-- Create symbol packages --><!-- UAP -->
      _GenerateAppxSymbolPackage;
      _GenerateAppxUploadSymbolPackage;

      <!-- Create resource packages --><!-- UAP -->
      _CreateResourcePackages_CalculateInputsAndOutputs;
      _CreateResourcePackages;
      _CreateResourcePackages_AddFileWrites;

      _CreateUploadResourcePackages_CalculateInputsAndOutputs;
      _CreateUploadResourcePackages;
      _CreateUploadResourcePackages_AddFileWrites;

      <!-- Flat Bundle -->
      _HydrateAppxLayoutResourcePackage;
      _HydrateAppxLayoutAssetPackage;
      _HydrateAppxLayoutPrebuiltPackage;

      _CreatePlatformSpecificArtifactsList;
      _CreatePlatformSpecificUploadArtifactsList;

      _CreatePlatformAppxLayoutFiles;

      _CreateAppxBundleFiles;
      _CreateAppxLayoutFiles;
      _CreateTestLayout;

      <!-- App Installer -->
      GenerateAppInstallerForBundle;

      $(After_CreateAppxBundlePlatformSpecificArtifacts)
    </_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
  </PropertyGroup>
  <Target Name="_CreateAppxBundlePlatformSpecificArtifacts" Condition="'$(ProduceAppxBundle)' == 'true' AND ('$(RequestingProject)' == '' OR '$(RequestingProject)' == '$(ProjectName)')" DependsOnTargets="$(_CreateAppxBundlePlatformSpecificArtifactsDependsOn)" />
  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout_CalculateInputsAndOutputs">
    <RemovePayloadDuplicates Inputs="@(AppxPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxPackagePayloadForPackageLayout" />
    </RemovePayloadDuplicates>
    <ItemGroup>
      <_PackageLayoutFileSource Include="@(_DeduplicatedAppxPackagePayloadForPackageLayout)" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_PackageLayoutFileSource Remove="@(_PackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ItemGroup>
      <_PackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
    </ItemGroup>
    <ItemGroup>
      <_PackageLayoutFileTarget Include="@(_PackageLayoutFileSource->'$(AppxLayoutDir)%(TargetPath)')" />
    </ItemGroup>
  </Target>
  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <RemovePayloadDuplicates Inputs="@(AppxUploadPackagePayload)" HasSharedItems="$(HasSharedItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="_DeduplicatedAppxUploadPackagePayloadForPackageLayout" />
    </RemovePayloadDuplicates>
    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(IntermediateUploadOutputPath)" />
    <ItemGroup>
      <_UploadPackageLayoutFileSource Include="@(_DeduplicatedAppxUploadPackagePayloadForPackageLayout)" />
    </ItemGroup>
    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_UploadPackageLayoutFileSource Remove="@(_UploadPackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ItemGroup>
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriUploadFullPath)" />
    </ItemGroup>
    <ItemGroup>
      <_UploadPackageLayoutFileTarget Include="@(_UploadPackageLayoutFileSource->'$(AppxUploadLayoutDir)%(TargetPath)')" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout">
    <RemoveDir Directories="$(AppxLayoutDir)" />
    <FilterItemGroup SourceItemGroup="@(_PackageLayoutFileSource)" FilterProperty="NuGetSourceType" FilterValue="Package" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetContent" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutContent" />
    </FilterItemGroup>
    <FilterItemGroup SourceItemGroup="@(_PackageLayoutFileTarget)" FilterProperty="NuGetSourceType" FilterValue="Package" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetTarget" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutTarget" />
    </FilterItemGroup>
    <Copy SourceFiles="@(_PackageLayoutContent)" DestinationFiles="@(_PackageLayoutTarget)" UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />
    <Copy SourceFiles="@(_PackageLayoutNugetContent)" DestinationFiles="@(_PackageLayoutNugetTarget)" UseHardlinksIfPossible="$(AppxUseHardlinksForNugetIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(AppxLayoutDir)" />
  </Target>
  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <RemoveDir Directories="$(AppxUploadLayoutDir)" />
    <FilterItemGroup SourceItemGroup="@(_UploadPackageLayoutFileSource)" FilterProperty="NuGetSourceType" FilterValue="Package" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetContent" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutContent" />
    </FilterItemGroup>
    <FilterItemGroup SourceItemGroup="@(_UploadPackageLayoutFileTarget)" FilterProperty="NuGetSourceType" FilterValue="Package" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetTarget" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutTarget" />
    </FilterItemGroup>
    <Copy SourceFiles="@(_PackageLayoutContent)" DestinationFiles="@(_PackageLayoutTarget)" UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />
    <Copy SourceFiles="@(_PackageLayoutNugetContent)" DestinationFiles="@(_PackageLayoutNugetTarget)" UseHardlinksIfPossible="$(AppxUseHardlinksForNugetIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />
    <Message Text="$(MSBuildProjectName) -&gt; $(AppxUploadLayoutDir)" />
  </Target>
  <!-- add sideload file writes -->
  <Target Name="_CreatePackageLayout_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_PackageLayoutFileTarget)" />
      <PackagingDirectoryWrites Include="$(AppxLayoutDir)" />
    </ItemGroup>
  </Target>
  <!-- Add upload file writes -->
  <Target Name="_CreateUploadPackageLayout_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_UploadPackageLayoutFileTarget)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadLayoutDir)" />
    </ItemGroup>
  </Target>
  <!-- Create sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxBundlePriConfigXmlForSplittingFileName)">
    <CreatePriConfigXmlForSplitting PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)" ResourcesPriFilePath="$(ProjectPriFullPath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" OmitSchemaFromResourcePacks="$(AppxOmitSchemaFromResourcePacks)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Create upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <CreatePriConfigXmlForSplitting PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" ResourcesPriFilePath="$(ProjectPriFullPath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- File writes for the sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>
  <!-- file writes for the upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>
  <!-- Prepare to split the sideload resources pri -->
  <Target Name="_SplitResourcesPri_CalculateInputsAndOutputs">
    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Prepare to split the upload resources pri -->
  <Target Name="_SplitUploadResourcesPri_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Split the sideload pri -->
  <Target Name="_SplitResourcesPri" Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)" Outputs="$(AppxBundleSplitResourcesGeneratedFilesListPath);@(_AppxBundleSplitResourcesGeneratedFiles)">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxLayoutDir)" OutputFileName="$(AppxBundleSplitResourcesPriPath)" GeneratedFilesListPath="$(AppxBundleSplitResourcesGeneratedFilesListPath)" QualifiersPath="$(AppxBundleSplitResourcesQualifiersPath)" IntermediateExtension="$(AppxIntermediateExtension)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Split the upload pri -->
  <Target Name="_SplitUploadResourcesPri" Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)" Outputs="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath);@(_AppxUploadBundleSplitResourcesGeneratedFiles)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxUploadLayoutDir)" OutputFileName="$(AppxUploadBundleSplitResourcesPriPath)" GeneratedFilesListPath="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)" QualifiersPath="$(AppxUploadBundleSplitResourcesQualifiersPath)" IntermediateExtension="$(AppxIntermediateExtension)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))" File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Wrap up splitting the sideload pri -->
  <Target Name="_SplitResourcesPri_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>
  <!-- Wrap up splitting the upload pri -->
  <Target Name="_SplitUploadResourcesPri_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)">
    <!-- Filter satellite assemblies out -->
    <GenerateMainPriConfigurationFile Condition="'$(_FilteredPackageLayoutFilePath)' != ''" FilteredPackageLayoutFilePath="$(_FilteredPackageLayoutFilePath)" PackageLayoutFiles="@(_PackageLayoutFileTarget)" ExcludedPackageLayoutFilePath="$(_ExcludedPackageLayoutFilePath)" />
    <PropertyGroup Condition="'$(_FilteredPackageLayoutFilePath)' != ''">
      <_FilteredPackageLayoutFileFullPath>$([System.IO.Path]::GetFullPath($(_FilteredPackageLayoutFilePath)))</_FilteredPackageLayoutFileFullPath>
      <_FilteredPackageLayoutUploadFileFullPath>$([System.IO.Path]::GetFullPath($(_FilteredUploadPackageLayoutFilePath)))</_FilteredPackageLayoutUploadFileFullPath>
    </PropertyGroup>
    <!-- PackageLayoutFilePath needs to be a fullpath as the ProjectRoot we use later for generating the pri file will fail to resolve the file -->
    <CreatePriConfigXmlForMainPackageFileMap PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" PackageLayoutFilePath="$(_FilteredPackageLayoutFileFullPath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Create the upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)" Outputs="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <!-- Filter satellite assemblies out -->
    <GenerateMainPriConfigurationFile Condition="'$(_FilteredUploadPackageLayoutFilePath)' != ''" FilteredPackageLayoutFilePath="$(_FilteredUploadPackageLayoutFilePath)" PackageLayoutFiles="@(_UploadPackageLayoutFileTarget)" ExcludedPackageLayoutFilePath="$(_ExcludedUploadPackageLayoutFilePath)" />
    <CreatePriConfigXmlForMainPackageFileMap PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" PackageLayoutFilePath="$(_FilteredPackageLayoutUploadFileFullPath)" PriInitialPath="$(AppxPriInitialPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" IntermediateExtension="$(AppxIntermediateExtension)" PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)" PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformResourceVersion)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Filewrites for sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_FilteredPackageLayoutFilePath)" />
      <FileWrites Include="$(_ExcludedPackageLayoutFilePath)" />
    </ItemGroup>
  </Target>
  <!-- Filewrites for upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_FilteredUploadPackageLayoutFilePath)" />
      <FileWrites Include="$(_ExcludedUploadPackageLayoutFilePath)" />
    </ItemGroup>
  </Target>
  <!-- Prepare to create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap_CalculateInputsAndOutputs">
    <ItemGroup>
      <_AppxBundleMainPackageMapInputs Include="$(AppxLayoutDir)\**\*" />
    </ItemGroup>
    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Prepare to create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_AppxUploadBundleMainPackageMapInputs Include="$(AppxUploadLayoutDir)\**\*" />
    </ItemGroup>
    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap" Inputs="$(MSBuildAllProjects);@(_AppxBundleMainPackageMapInputs)" Outputs="$(AppxBundleMainPackageFileMapIntermediatePath)">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxLayoutDir)" OutputFileName="$(AppxBundleMainPackageFileMapIntermediatePriPath)" GeneratedFilesListPath="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" IntermediateExtension="$(AppxIntermediateExtension)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap" Inputs="$(MSBuildAllProjects);@(_AppxUploadBundleMainPackageMapInputs)" Outputs="$(AppxUploadBundleMainPackageFileMapIntermediatePath)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)" MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)" PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" ProjectPriIndexName="$(ProjectPriIndexName)" MappingFileFormat="AppX" ProjectDirectory="$(AppxUploadLayoutDir)" OutputFileName="$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)" GeneratedFilesListPath="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)" AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)" IntermediateExtension="$(AppxIntermediateExtension)" AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>
    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))" File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>
  </Target>
  <!-- Wrap up creating the sideload file map -->
  <Target Name="_CreateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>
  <!-- Wrap up creating the upload file map -->
  <Target Name="_CreateUploadMainPackageFileMap_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>
  <!-- Update the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxBundleMainPackageFileMapIntermediatePath);$(AppxBundleSplitResourcesPriPath);$(_ExcludedLayoutResfilesPath)" Outputs="$(AppxBundleMainPackageFileMapPath)" DependsOnTargets="_FindAppxContentGroupMap">
    <ItemGroup>
      <_AppxBundleSplitResourcesPriPathItem Include="$(AppxBundleSplitResourcesPriPath)" />
    </ItemGroup>
    <ItemGroup>
      <_ExcludedFromResourceIndexFileList Include="$(_ExcludedLayoutResfilesPath)" />
      <_ExcludedFromResourceIndexFileList Include="$(_ExcludedPackageLayoutFilePath)" />
    </ItemGroup>
    <UpdateMainPackageFileMap AppxContentGroupMap="$(AppxContentGroupMapFullPath)" Input="$(AppxBundleMainPackageFileMapIntermediatePath)" ExcludedFromResourceIndexFileList="@(_ExcludedFromResourceIndexFileList)" PackageLayout="$(AppxLayoutDir)" InputFileList="$(FileMapInputList)" Output="$(AppxBundleMainPackageFileMapPath)" SplitResourcesPriPath="%(_AppxBundleSplitResourcesPriPathItem.FullPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Update the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap" Inputs="$(MSBuildAllProjects);$(AppxUploadBundleMainPackageFileMapIntermediatePath);$(AppxUploadBundleSplitResourcesPriPath);$(_ExcludedLayoutResfilesPath)" Outputs="$(AppxUploadBundleMainPackageFileMapPath)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" DependsOnTargets="_FindAppxContentGroupMap">
    <ItemGroup>
      <_AppxUploadBundleSplitResourcesPriPathItem Include="$(AppxUploadBundleSplitResourcesPriPath)" />
    </ItemGroup>
    <ItemGroup>
      <_ExcludedUploadFromResourceIndexFileList Include="$(_ExcludedLayoutResfilesPath)" />
      <_ExcludedUploadFromResourceIndexFileList Include="$(_ExcludedUploadPackageLayoutFilePath)" />
    </ItemGroup>
    <UpdateMainPackageFileMap AppxContentGroupMap="$(AppxContentGroupMapFullPath)" Input="$(AppxUploadBundleMainPackageFileMapIntermediatePath)" ExcludedFromResourceIndexFileList="@(_ExcludedUploadFromResourceIndexFileList)" PackageLayout="$(AppxUploadLayoutDir)" InputFileList="$(UploadFileMapInputList)" Output="$(AppxUploadBundleMainPackageFileMapPath)" SplitResourcesPriPath="%(_AppxUploadBundleSplitResourcesPriPathItem.FullPath)" DefaultResourceLanguage="$(DefaultResourceLanguage)" DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Wrap up updating the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>
  <!--Wrap up updating the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>
  <!-- Prepare to update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_CalculateInputsAndOutputs">
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest->'%(RootDir)%(Directory)ForBundle\%(Filename)%(Extension)')" />
    </ItemGroup>
  </Target>
  <!-- Prepare to update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <!-- split.pri gets added in a previous step and should not be re-added here -->
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest->'%(RootDir)%(Directory)ForUploadBundle\%(Filename)%(Extension)')" Condition="'%(FinalAppxUploadManifest.TargetPath)' != 'split.pri'" />
    </ItemGroup>
  </Target>
  <!-- Update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle" Inputs="$(MSBuildAllProjects);@(FinalAppxManifest)" Outputs="@(AppxManifestForBundle)">
    <MakeDir Directories="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />
    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxManifest)" AppxManifestForBundle="@(AppxManifestForBundle)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle" Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest)" Outputs="@(AppxUploadManifestForBundle)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <MakeDir Directories="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />
    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxUploadManifest)" AppxManifestForBundle="@(AppxUploadManifestForBundle)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- Wrap up updating the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(AppxManifestForBundle)" />
      <PackagingDirectoryWrites Include="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>
  </Target>
  <!-- Wrap up updating the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(AppxUploadManifestForBundle)" />
      <PackagingUploadDirectoryWrites Include="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>
  </Target>
  <!-- Create the sideload appx -->
  <Target Name="_CreateMainPackage" Inputs="$(MSBuildAllProjects);@(AppxManifestForBundle);$(AppxBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)" Outputs="$(AppxMainPackageOutput)" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'" DependsOnTargets="_FindAppxContentGroupMap;_DeleteAppxOutputFolderIfNecessary">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxContentGroupMap="$(AppxContentGroupMapFullPath)" AppxStreamableMainPackage="$(AppxStreamableMainPackage)" AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)" ResourcePack="false" Parameters="$(CreatePackageMakeAppxParameters)" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxManifestForBundle)" FileMap="$(AppxBundleMainPackageFileMapPath)" Output="$(AppxMainPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="$(AppxMainPackageOutput)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxMainPackageOutput)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxMainPackageOutput) (unsigned)" />
    <ItemGroup>
      <InstallerFileWrites Include="@(AppxMainPackageOutput)" />
    </ItemGroup>
  </Target>
  <!-- Create the upload appx -->
  <Target Name="_CreateMainUploadPackage" Inputs="$(MSBuildAllProjects);@(AppxUploadManifestForBundle);$(AppxUploadBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadMainPackageOutput)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'" DependsOnTargets="_FindAppxContentGroupMap">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxContentGroupMap="$(AppxContentGroupMapFullPath)" AppxStreamableMainPackage="$(AppxStreamableMainPackage)" AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)" ResourcePack="false" Parameters="$(CreatePackageMakeAppxParameters)" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxUploadManifestForBundle)" FileMap="$(AppxUploadBundleMainPackageFileMapPath)" Output="$(AppxUploadMainPackageOutput)" VsTelemetrySession="$(VsTelemetrySession)" IsUploadPackageOrComponent="true" />
  </Target>
  <!-- Wrap up creating the sideload package -->
  <Target Name="_CreateMainPackage_AddFileWrites" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxMainPackageOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>
  <!-- Wrap up creating the upload package -->
  <Target Name="_CreateMainUploadPackage_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadMainPackageOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>
  <!-- Resource packages are created during the build of the platform which will produce the bundle.               -->
  <!-- There is a work item to validate that assumption which will move resource pack generation to target Bundle. -->
  <!-- 635606: Resource Packs: Validate generated resource packs file maps across architectures                   -->
  <!-- Prep to create the sideload resource packages -->
  <Target Name="_CreateResourcePackages_CalculateInputsAndOutputs" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">
    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>
    <ItemGroup>
      <_AppxBundleResourceFileMapsIntermediate Include="@(_AppxBundleSplitResourcesGeneratedFiles)" Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxBundleResourceFileMapsIntermediate>
    </ItemGroup>
    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxBundleResourceFileMapsIntermediate)" FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)" MapSuffix="$(AppxBundleMainPackageFileMapSuffix)" Languages="@(_ManifestResources-&gt;WithMetadataValue('Dimension', 'Language')-&gt;'%(Value)')" VsTelemetrySession="$(VsTelemetrySession)" Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'">
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>
    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxBundleResourceFileMaps Include="@(_AppxBundleResourceFileMapsIntermediate)" />
    </ItemGroup>
  </Target>
  <!-- Prep to create the upload resource packages -->
  <Target Name="_CreateUploadResourcePackages_CalculateInputsAndOutputs" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and&#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true'">
    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>
    <ItemGroup Condition="'$(UseAppxLayout)' != 'true'">
      <_AppxUploadBundleResourceFileMapsIntermediate Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxUploadResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxUploadBundleResourceFileMapsIntermediate>
    </ItemGroup>
    <ItemGroup Condition="'$(UseAppxLayout)' == 'true'">
      <_AppxUploadBundleResourceFileMapsIntermediate Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxUploadResourcePackOutputBase)\$(AppxPackageNameNeutral)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','-').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxUploadBundleResourceFileMapsIntermediate>
    </ItemGroup>
    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxUploadBundleResourceFileMapsIntermediate)" FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)" MapSuffix="$(AppxBundleMainPackageFileMapSuffix)" Languages="@(_ManifestResources-&gt;WithMetadataValue('Dimension', 'Language')-&gt;'%(Value)')" VsTelemetrySession="$(VsTelemetrySession)" Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'">
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxUploadBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>
    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxUploadBundleResourceFileMaps Include="@(_AppxUploadBundleResourceFileMapsIntermediate)" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateResourcePackages" Inputs="@(_AppxBundleResourceFileMaps)" Outputs="%(ResourcePack)" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and&#xD;&#xA;                     '$(BuildAppxSideloadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'" DependsOnTargets="_FindAppxContentGroupMap">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxContentGroupMap="$(AppxContentGroupMapFullPath)" AppxStreamableMainPackage="$(AppxStreamableMainPackage)" AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)" ResourcePack="true" Parameters="$(CreateResourcePackageMakeAppxParameters)" EncryptAppxPackage="$(AppxPackageEncryptionEnabled)" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxManifestForBundle)" FileMap="%(_AppxBundleResourceFileMaps.Identity)" Output="%(_AppxBundleResourceFileMaps.ResourcePack)" VsTelemetrySession="$(VsTelemetrySession)" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="%(_AppxBundleResourceFileMaps.ResourcePack)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; %(_AppxBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(MSBuildProjectName) -&gt; %(_AppxBundleResourceFileMaps.ResourcePack) (unsigned)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateUploadResourcePackages" Inputs="@(_AppxUploadBundleResourceFileMaps)" Outputs="%(ResourcePack)" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and&#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'" DependsOnTargets="_FindAppxContentGroupMap">
    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxContentGroupMap="$(AppxContentGroupMapFullPath)" AppxStreamableMainPackage="$(AppxStreamableMainPackage)" AppxStreamableResourcePackages="$(AppxStreamableResourcePackages)" ResourcePack="true" Parameters="$(CreateResourcePackageMakeAppxParameters)" HashAlgorithmId="$(AppxHashAlgorithmId)" ValidateResourcesReferencedByManifest="false" AppxManifest="@(AppxUploadManifestForBundle)" FileMap="%(_AppxUploadBundleResourceFileMaps.Identity)" Output="%(_AppxUploadBundleResourceFileMaps.ResourcePack)" VsTelemetrySession="$(VsTelemetrySession)" IsUploadPackageOrComponent="true" />
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="%(_AppxUploadBundleResourceFileMaps.ResourcePack)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; %(_AppxUploadBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(MSBuildProjectName) -&gt; %(_AppxUploadBundleResourceFileMaps.ResourcePack) (unsigned)" />
  </Target>
  <Target Name="_CreateResourcePackages_AddFileWrites" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateUploadResourcePackages_AddFileWrites" Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and&#xD;&#xA;                     '$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
  </Target>
  <!-- Create sideload artifacts list -->
  <Target Name="_CreatePlatformSpecificArtifactsList">
    <MakeDir Directories="$(PlatformSpecificBundleArtifactsListDir)" />
    <ItemGroup>
      <_AppxBundleResourcePack Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
    <ItemGroup>
      <_PlatformSpecificBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxMainPackageOutput)'))" Condition="Exists($(AppxMainPackageOutput))" />
      <_PlatformSpecificBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxSymbolPackageIntermediate)'))" Condition="Exists($(AppxSymbolPackageIntermediate))" />
      <_PlatformSpecificBundleArtifact Include="ResourcePack=%(_AppxBundleResourcePack.FullPath)" Condition="'@(_AppxBundleResourcePack)' != ''" />
    </ItemGroup>
    <Delete Files="$(AppxBundlePlatformSpecificArtifactsListPath)" />
    <WriteLinesToFile File="$(AppxBundlePlatformSpecificArtifactsListPath)" Lines="@(_PlatformSpecificBundleArtifact)" />
    <!-- Creating packaging info file for every architecture we are building. -->
    <!-- That way, wizard completion page can know which architectures are    -->
    <!-- included in the bundle.                                              -->
    <PropertyGroup Condition="'$(AppxBundleNameForOutput)' == ''">
      <AppxBundleNameForOutput>$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)</AppxBundleNameForOutput>
      <AppxBundleNameForOutput Condition="'$(UseAppxLayout)' == 'true'">$(AppxBundleNameForOutput)</AppxBundleNameForOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxBundleOutput)' == ''">
      <AppxBundleOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'true'">$(AppxPackageTestDir)$(AppxBundleNameForOutput)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxBundleOutput>
      <AppxBundleOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'true'">$(AppxPackageTestDir)$(AppxBundleNameForOutput)$(_AppxPackageConfiguration)$(AppxBundleEncryptedExtension)</AppxBundleOutput>
    </PropertyGroup>
    <WriteLinesToFile File="$(AppxPackagingInfoFile)" Overwrite="true" Lines="$([System.IO.Path]::GetFullPath('$(AppxBundleOutput)'))" />
    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>
  </Target>
  <!-- Create upload artifacts list -->
  <Target Name="_CreatePlatformSpecificUploadArtifactsList" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <MakeDir Directories="$(PlatformSpecificUploadBundleArtifactsListDir)" />
    <ItemGroup>
      <_AppxUploadBundleResourcePack Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>
    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadMainPackageOutput)'))" Condition="Exists($(AppxUploadMainPackageOutput)) and '$(UseAppxLayout)' != 'true'" />
      <_PlatformSpecificUploadBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadSymbolPackageOutput)'))" Condition="Exists($(AppxUploadSymbolPackageOutput))" />
      <_PlatformSpecificUploadBundleArtifact Include="ResourcePack=%(_AppxUploadBundleResourcePack.FullPath)" Condition="'@(_AppxUploadBundleResourcePack)' != ''" />
    </ItemGroup>
    <Delete Files="$(AppxBundlePlatformSpecificUploadArtifactsListPath)" />
    <WriteLinesToFile File="$(AppxBundlePlatformSpecificUploadArtifactsListPath)" Lines="@(_PlatformSpecificUploadBundleArtifact)" />
    <PropertyGroup Condition="'$(AppxUploadBundleOutput)' == '' and '$(UseAppxLayout)' != 'true'">
      <AppxUploadBundleOutput>$(AppxUploadPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxUploadBundleOutput>
    </PropertyGroup>
    <PropertyGroup Condition="'$(AppxUploadBundleOutput)' == '' and '$(UseAppxLayout)' == 'true'">
      <AppxUploadBundleOutput>$(AppxUploadPackageDir)$(AppxPackageNameNeutralFlatBundle)$(AppxBundleExtension)</AppxUploadBundleOutput>
    </PropertyGroup>
  </Target>
  <!-- ============================= -->
  <!-- Produce the app bundle files. -->
  <!-- ============================= -->
  <PropertyGroup>
    <_CreateAppxBundleFilesDependsOn>
      $(BeforeCreateAppxBundleFiles);

      _GetSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      _GetPackageProperties;

      _GetOtherPlatformsToBundle;
      _ProducePlatformSpecificBundleArtifactsForOtherPlatforms;

      _GetPlatformSpecificBundleArtifacts;

      _CreateBundle_CalculateInputsAndOutputs;
      _CreateBundle_GenerateBundleMappingFile;
      _CreateBundle_CopyExternalPackages;
      _CreateBundle;
      _CreateBundle_AddFileWrites;
      _CopyAppxSymToOutput;

      _CreateUploadBundle_CalculateInputsAndOutputs;
      _CreateUploadBundle_GenerateBundleMappingFile;
      _CreateUploadBundle_CopyExternalPackages;
      _CreateUploadBundle;
      _CreateUploadBundle_AddFileWrites;

      _CreateAppStoreBundleContainer_CalculateInputsAndOutputs;
      _CreateAppStoreBundleContainer;
      _CreateAppStoreBundleContainer_AddFileWrites;

      _AddWindowsInstallScriptToTestLayout;

      $(AfterCreateAppxBundleFiles)
    </_CreateAppxBundleFilesDependsOn>
  </PropertyGroup>
  <Target Name="_CreateAppxBundleFiles" Condition="('$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)' or '$(GenerateAppxPackageOnBuild)' == 'true') and&#xD;&#xA;                     '$(_SkipBundleCreation)' != 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'" DependsOnTargets="$(_CreateAppxBundleFilesDependsOn)" />
  <PropertyGroup>
    <_CreateAppxLayoutFilesDependsOn>
      $(BeforeCreateAppxLayoutFiles);

      _GetSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      _GetPackageProperties;

      _GetOtherPlatformsToBundle;
      _ProducePlatformSpecificBundleArtifactsForOtherPlatforms;

      _GetPlatformSpecificBundleArtifacts;

      _CreateAppxLayoutPackage;
      _CreateAppxLayoutUploadPackage;

      _CreateAppStoreBundleContainer_CalculateInputsAndOutputs;
      _CreateAppStoreBundleContainer;
      _CreateAppStoreBundleContainer_AddFileWrites;

      _AddWindowsInstallScriptToTestLayout;

      $(AfterCreateAppxLayoutFiles)
    </_CreateAppxLayoutFilesDependsOn>
  </PropertyGroup>
  <Target Name="_CreateAppxLayoutFiles" Condition="('$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)' or '$(GenerateAppxPackageOnBuild)' == 'true') and&#xD;&#xA;                     '$(_SkipBundleCreation)' != 'true' and&#xD;&#xA;                     '$(UseAppxLayout)' == 'true'" DependsOnTargets="$(_CreateAppxLayoutFilesDependsOn)" />
  <Target Name="_GetOtherPlatformsToBundle" Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">
    <PropertyGroup>
      <_AdjustedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_AdjustedPlatform>
      <_AdjustedPlatform Condition="'$(Platform)' == 'Win32'">x86</_AdjustedPlatform>
    </PropertyGroup>
    <ItemGroup>
      <_OtherPlatformToBundle Condition="'%(Identity)' != '$(_AdjustedPlatform)'" Include="@(AppxBundlePlatformWithAnyCPU)" />
    </ItemGroup>
  </Target>
  <Target Name="_ProducePlatformSpecificBundleArtifactsForOtherPlatforms" Condition="'@(_OtherPlatformToBundle)' != ''" Inputs="@(_OtherPlatformToBundle)" Outputs="%(Identity).AlwaysRun">
    <PropertyGroup>
      <_TargetToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetToBuild>
      <_TargetToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetToBuild>
    </PropertyGroup>
    <PropertyGroup Condition="'$(SolutionPath)' == '' or '$(SolutionPath)' == '*Undefined*'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>false</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse />
    </PropertyGroup>
    <MSBuild Projects="$(SolutionPath)" Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*'" Targets="GetSolutionConfigurationContents" Properties="Configuration=$(Configuration);Platform=%(_OtherPlatformToBundle.Identity)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="TargetOutputs" PropertyName="_SolutionConfigurationContentsToUse" />
    </MSBuild>
    <PropertyGroup Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*' and '$(IsOptionalProject)' != 'true'">
      <_FileToBuild>$(SolutionPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(IsOptionalProject)' == 'true'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse />
    </PropertyGroup>
    <ItemGroup>
      <_InternalBuildProperties Include="ShouldUnsetParentConfigurationAndPlatform=$(_ShouldUnsetParentConfigurationAndPlatform)" />
      <_InternalBuildProperties Include="CurrentSolutionConfigurationContents=$(_SolutionConfigurationContentsToUse)" />
      <_InternalBuildProperties Include="Configuration=$(Configuration)" />
      <_InternalBuildProperties Include="Platform=%(_OtherPlatformToBundle.Identity)" />
      <_InternalBuildProperties Include="_SkipBundleCreation=true" />
      <_InternalBuildProperties Include="PlatformSpecificBundleArtifactsListDir=$(PlatformSpecificBundleArtifactsListDir)" />
      <_InternalBuildProperties Include="AppxPackageDir=$(AppxPackageDir)" />
      <_InternalBuildProperties Include="OriginalTargetDir=$(TargetDir)" />
      <_InternalBuildProperties Include="RequestingProject=$(ProjectName)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == 'true'">
      <InternalBuildOutputPath>$(OutputPath)</InternalBuildOutputPath>
      <InternalBuildOutputPath Condition="!HasTrailingSlash('$(InternalBuildOutputPath)')">$(InternalBuildOutputPath)\</InternalBuildOutputPath>
      <InternalBuildOutputPath>$(InternalBuildOutputPath)%(_OtherPlatformToBundle.Identity)\</InternalBuildOutputPath>
      <InternalBuildOutDir>$(OutDir)</InternalBuildOutDir>
      <InternalBuildOutDir Condition="!HasTrailingSlash('$(InternalBuildOutDir)')">$(InternalBuildOutDir)\</InternalBuildOutDir>
      <InternalBuildOutDir>$(InternalBuildOutDir)%(_OtherPlatformToBundle.Identity)\</InternalBuildOutDir>
    </PropertyGroup>
    <ItemGroup Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == 'true'">
      <_InternalBuildProperties Include="OutputPath=$(InternalBuildOutputPath)" />
      <_InternalBuildProperties Include="OutDir=$(InternalBuildOutDir)" />
    </ItemGroup>
    <!-- Build the package(s) for other platforms that will be included in the bundle. -->
    <MSBuild Projects="$(_FileToBuild)" Targets="$(_TargetToBuild)" Properties="@(_InternalBuildProperties)" ContinueOnError="$(ContinueOnError)" />
  </Target>
  <Target Name="_GetPlatformSpecificBundleArtifacts">
    <ItemGroup>
      <_PlatformSpecificBundleArtifact Remove="@(_PlatformSpecificBundleArtifact)" />
    </ItemGroup>
    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Remove="@(_PlatformSpecificUploadBundleArtifact)" />
    </ItemGroup>
    <ParsePlatformSpecificBundleArtifactsLists Files="$(PlatformSpecificBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>
    <ParsePlatformSpecificBundleArtifactsLists Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Files="$(PlatformSpecificUploadBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificUploadBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>
    <ItemGroup>
      <_MainPackageToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'MainPackage'" />
      <_SymbolPackageToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourcePackToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_MainUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'MainPackage'" />
      <_SymbolUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourceUploadPackToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>
  </Target>
  <!-- Prep to create the sideload bundle -->
  <Target Name="_CreateBundle_CalculateInputsAndOutputs">
    <ItemGroup>
      <_CreateBundleInputs Include="@(_MainPackageToBundle)" />
      <_CreateBundleInputs Include="@(_ResourcePackToBundle)" />
    </ItemGroup>
  </Target>
  <!-- Prep the sideload bundle mapping file -->
  <Target Name="_CreateBundle_GenerateBundleMappingFile" Condition="'@(BundleMappingFile)' != ''">
    <!--Include the list of External Packages in the appropriate ItemGroup-->
    <ItemGroup>
      <BundleMappingSideloadExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>
    <GenerateMappingFile Files="@(_CreateBundleInputs)" ExternalPackages="@(BundleMappingSideloadExternalPackages)" TargetDirectory="$(AppxMappingFileDir)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="MappingFile" PropertyName="AppxBundleMappingFile" />
    </GenerateMappingFile>
  </Target>
  <Target Name="_CreateBundle_CopyExternalPackages" Condition="'@(BundleMappingFile)' != ''">
    <RemoveDir Directories="$(AppxPackageTestExternalPackagesDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(BundleMappingSideloadExternalPackages)" DestinationFolder="$(AppxPackageTestExternalPackagesDir)" />
  </Target>
  <!-- Prep to create the upload bundle -->
  <Target Name="_CreateUploadBundle_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <_CreateUploadBundleInputs Include="@(_MainUploadPackageToBundle)" />
      <_CreateUploadBundleInputs Include="@(_ResourceUploadPackToBundle)" />
    </ItemGroup>
  </Target>
  <!-- Prep the upload bundle mapping file -->
  <Target Name="_CreateUploadBundle_GenerateBundleMappingFile" Condition="'@(BundleMappingFile)' != ''">
    <!--Include the list of External Packages in the appropriate ItemGroup-->
    <ItemGroup>
      <BundleMappingUploadExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>
    <GenerateMappingFile Files="@(_CreateUploadBundleInputs)" ExternalPackages="@(BundleMappingUploadExternalPackages)" TargetDirectory="$(AppxUploadMappingFileDir)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="MappingFile" PropertyName="AppxUploadBundleMappingFile" />
    </GenerateMappingFile>
  </Target>
  <Target Name="_CreateUploadBundle_CopyExternalPackages" Condition="'@(BundleMappingFile)' != ''">
    <RemoveDir Directories="$(AppxUploadPackageExternalpackagesDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(BundleMappingUploadExternalPackages)" DestinationFolder="$(AppxUploadPackageExternalpackagesDir)" />
  </Target>
  <!-- Create the sideload bundle -->
  <Target Name="_CreateBundle" Inputs="$(MSBuildAllProjects);@(_CreateBundleInputs);$(PackageCertificateKeyFile)" Outputs="$(AppxBundleOutput)" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)" AppxBundlePlatforms="@(AppxBundlePlatform)" />
    <RemoveDir Directories="$(AppxBundleDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_CreateBundleInputs)" DestinationFolder="$(AppxBundleDir)" />
    <ItemGroup>
      <_AppxBundleContent Include="$(AppxBundleDir)*" />
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>
    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" EncryptAppxPackage="$(AppxPackageEncryptionEnabled)" AppxBundleManifestVersion="$(AppxBundleManifestVersion)" BundleDir="$(AppxBundleDir)" Output="$(AppxBundleOutput)" BundleMappingFile="$(AppxBundleMappingFile)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <AllBuiltSideloadPackages Include="$(AppxBundleOutput)" />
    </ItemGroup>
    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'" AppxPackageToSign="$(AppxBundleOutput)" CertificateThumbprint="$(PackageCertificateThumbprint)" CertificateFile="$(PackageCertificateKeyFile)" CertificatePassword="$(PackageCertificatePassword)" HashAlgorithmId="$(AppxHashAlgorithmId)" EnableSigningChecks="$(EnableSigningChecks)" SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)" TempCertificateFilePath="$(TempCertificateFilePath)" ExportCertificate="true" VsTelemetrySession="$(VsTelemetrySession)" SigningTimestampServerUrl="$(AppxPackageSigningTimestampServerUrl)" SigningTimestampDigestAlgorithm="$(AppxPackageSigningTimestampDigestAlgorithm)" AzureCodeSigningEnabled="$(AzureCodeSigningEnabled)" AzureCodeSigningDlibFilePath="$(AzureCodeSigningDlibFilePath)" AzureCodeSigningEndpoint="$(AzureCodeSigningEndpoint)" AzureCodeSigningAccountName="$(AzureCodeSigningAccountName)" AzureCodeSigningCertificateProfileName="$(AzureCodeSigningCertificateProfileName)" AzureKeyVaultEnabled="$(AzureKeyVaultEnabled)" AzureKeyVaultDlibFilePath="$(AzureKeyVaultDlibFilePath)" AzureKeyVaultUrl="$(AzureKeyVaultUrl)" AzureKeyVaultCertificateId="$(AzureKeyVaultCertificateId)" AzureKeyVaultVisualStudioCredentialOnly="$(AzureKeyVaultVisualStudioCredentialOnly)">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint" />
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>
    <Message Importance="high" Text="$(MSBuildProjectName) -&gt; $(AppxBundleOutput)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -&gt; $(AppxPackagePublicKeyFile)" />
    <ItemGroup>
      <InstallerFileWrites Include="$(AppxPackagePublicKeyFile)" />
    </ItemGroup>
  </Target>
  <!-- Create the upload bundle -->
  <Target Name="_CreateUploadBundle" Inputs="$(MSBuildAllProjects);@(_CreateUploadBundleInputs);$(PackageCertificateKeyFile)" Outputs="$(AppxUploadBundleOutput)" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)" AppxBundlePlatforms="@(AppxBundlePlatform)" />
    <RemoveDir Directories="$(AppxUploadBundleDir)" />
    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)" SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" SourceFiles="@(_CreateUploadBundleInputs)" DestinationFolder="$(AppxUploadBundleDir)" />
    <ItemGroup>
      <_AppxUploadBundleContent Include="$(AppxUploadBundleDir)*" />
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>
    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" AppxBundleManifestVersion="$(AppxBundleManifestVersion)" BundleDir="$(AppxUploadBundleDir)" Output="$(AppxUploadBundleOutput)" BundleMappingFile="$(AppxUploadBundleMappingFile)" VsTelemetrySession="$(VsTelemetrySession)" IsUploadPackageOrComponent="true" />
    <!-- Validate that all Optional Packages are store associated. -->
    <ValidateAppxOptionalPackageUploadBundle Condition="'@(BundleMappingSideloadExternalPackages)' != ''" SideloadOptionalPackages="@(BundleMappingSideloadExternalPackages)" StoreAssociatedOptionalPackages="@(BundleMappingUploadExternalPackages)" VsTelemetrySession="$(VsTelemetrySession)" />
    <ItemGroup>
      <AllBuiltUploadPackages Include="$(AppxUploadBundleOutput)" />
    </ItemGroup>
  </Target>
  <!-- wrap up creating the sideload bundle -->
  <Target Name="_CreateBundle_AddFileWrites" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxBundleOutput)" />
      <InstallerFileWrites Include="$(AppxBundleOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>
  <!-- Copy the .appxsym files to the output directory -->
  <Target Name="_CopyAppxSymToOutput" Condition="'$(BuildAppxSideloadPackageForUap)' == 'true'">
    <Copy UseHardlinksIfPossible="false" SourceFiles="@(_SymbolPackageToBundle)" DestinationFolder="$(AppxPackageTestDir)" />
  </Target>
  <!-- wrap up creating the upload bundle -->
  <Target Name="_CreateUploadBundle_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxUploadBundleOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>
  <!--create the final appxupload bundle inputs-->
  <Target Name="_CreateAppStoreBundleContainer_CalculateInputsAndOutputs" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup Condition="'$(UseAppxLayout)' != 'true'">
      <_CreateAppStoreBundleContainerInputs Include="$(AppxUploadBundleOutput)" />
      <_CreateAppStoreBundleContainerInputs Include="@(_SymbolUploadPackageToBundle)" />
    </ItemGroup>
    <ItemGroup Condition="'$(UseAppxLayout)' == 'true'">
      <_CreateAppStoreBundleContainerInputs Include="@(AppxLayoutUploadContents)" />
      <_CreateAppStoreBundleContainerInputs Include="@(_SymbolUploadPackageToBundle)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(AppxStoreContainer)' == ''">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)_bundle$(_AppxPackageConfiguration)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>
  </Target>
  <Target Name="_CreateAppStoreBundleContainer" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'" Inputs="$(MSBuildAllProjects);@(_CreateAppStoreBundleContainerInputs)" Outputs="$(AppxStoreContainer)">
    <MakeDir Directories="$(AppxPackageDir)" />
    <CreateAppStoreContainer Items="@(_CreateAppStoreBundleContainerInputs)" ProjectName="$(MSBuildProjectName)" OutputPath="$(AppxStoreContainer)" VsTelemetrySession="$(VsTelemetrySession)" />
    <WriteLinesToFile File="$(AppxUploadPackagingInfoFile)" Overwrite="true" Lines="$([System.IO.Path]::GetFullPath('$(AppxStoreContainer)'))" />
    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackagingInfoFile)" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateAppStoreBundleContainer_AddFileWrites" Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
  </Target>
  <!-- =============================== -->
  <!-- Atomic set creation support.    -->
  <!-- =============================== -->
  <Target Name="_BuildOptionalProjects" Condition="'$(BuildOptionalProjects)' == 'true' and&#xD;&#xA;                     ('$(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)') and&#xD;&#xA;                     (('@(BundleMappingFile)' != '' and '@(_BundleMappingOptionalProjects)' != '') or '@(_AppxLayoutOptionalPackages)' != '')">
    <!--Combine the target to build with GetOptionalProjectOutputs to get back the details we need.-->
    <PropertyGroup>
      <_TargetsToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetsToBuild>
      <_TargetsToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetsToBuild>
      <_TargetsToBuild>$(_TargetsToBuild);GetOptionalProjectOutputs</_TargetsToBuild>
    </PropertyGroup>
    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>
    <!--Build the properties list. Split over multiple lines so it's a bit easier to read.-->
    <PropertyGroup>
      <_BuildProperties>Platform=$(Platform);Configuration=$(Configuration)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);UAPAppxPackageBuildMode=$(UAPAppxPackageBuildMode)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);AppxPackageIsForStore=$(AppxPackageIsForStore)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);IncludeOptionalProjectsOutputGroup=true</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);IsOptionalProject=true</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);BuildingInsideVisualStudio=false</_BuildProperties>
      <_BuildProperties Condition="'$(BuildingInsideVisualStudio)' == 'true'">$(_BuildProperties);GenerateAppxPackageOnBuild=$(PackageOptionalProjectsInIdeBuilds)</_BuildProperties>
      <_BuildProperties Condition="'$(BuildingInsideVisualStudio)' != 'true'">$(_BuildProperties);GenerateAppxPackageOnBuild=$(GenerateAppxPackageOnBuild)</_BuildProperties>
    </PropertyGroup>
    <!--Create the project references for the build.-->
    <ItemGroup>
      <OptionalProjectBuildReferences Include="@(_BundleMappingOptionalProjects)" Condition="'@(_BundleMappingOptionalProjects)' != ''">
        <Properties>$(_BuildProperties)</Properties>
      </OptionalProjectBuildReferences>
      <OptionalProjectBuildReferences Include="@(_AppxLayoutOptionalPackages)" Condition="'@(_AppxLayoutOptionalPackages)' != ''">
        <Properties>$(_BuildProperties)</Properties>
      </OptionalProjectBuildReferences>
    </ItemGroup>
    <!--Build the list of Optional Projects and capture the output from each.-->
    <MSBuild Condition="'$(BuildingInsideVisualStudio)' == 'true'" Projects="@(OptionalProjectBuildReferences)" BuildInParallel="false" ContinueOnError="$(_ContinueOnError)" Targets="$(_TargetsToBuild)">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputs" />
    </MSBuild>
    <MSBuild Condition="'$(BuildingInsideVisualStudio)' != 'true'" Projects="@(OptionalProjectBuildReferences)" BuildInParallel="$(BuildInParallel)" ContinueOnError="$(_ContinueOnError)" RemoveProperties="AppxPackageDir;OutputPath" Targets="$(_TargetsToBuild)">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputs" />
    </MSBuild>
    <!--For Deployment (i.e. debug) builds we just want recipes, manifests, and any external packages.-->
    <ItemGroup>
      <BundleMappingRecipes Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='Recipe'" />
      <BundleMappingExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='Manifest'" />
    </ItemGroup>
    <!--For packaging builds, split sideload and upload into their own groups. Both get the same list of External Packages.-->
    <ItemGroup>
      <BundleMappingSideloadExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='SideloadPackage'" />
    </ItemGroup>
    <ItemGroup>
      <BundleMappingUploadExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='UploadPackage'" />
    </ItemGroup>
  </Target>
  <!-- Prep the deployable bundle mapping file -->
  <Target Name="_GenerateBundleMappingFile" Condition="'@(BundleMappingFile)' != '' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'">
    <!--Include the list of External Packages in the appropriate ItemGroup-->
    <ItemGroup>
      <BundleMappingExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>
    <GenerateMappingFile Files="$(FinalAppxManifestName)" ExternalPackages="@(BundleMappingExternalPackages)" TargetDirectory="$(AppxMappingFileDir)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="MappingFile" PropertyName="AppxBundleMappingFile" />
    </GenerateMappingFile>
  </Target>
  <Target Name="_GenerateBundleManifest" Condition="'@(BundleMappingFile)' != '' and&#xD;&#xA;                     '@(_BundleMappingOptionalProjects)' != '' and&#xD;&#xA;                     '$(UseAppxLayout)' != 'true'">
    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)" Output="$(FinalAppxBundleManifestName)" BundleDir="$(AppxBundleDir)" GenerateBundleManifestOnly="true" BundleMappingFile="$(AppxBundleMappingFile)" VsTelemetrySession="$(VsTelemetrySession)" />
  </Target>
  <!-- =============================== -->
  <!-- Clean/Rebuild support.          -->
  <!-- =============================== -->
  <!-- Cleans current project and any referenced projects' appx package artifacts. -->
  <Target Name="_CleanAppxPackage" Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == 'true'" DependsOnTargets="$(_CleanAppxPackageDependsOn)" AfterTargets="Clean">
    <ReadLinesFromFile File="$(PackagingDirectoryWritesLogPath)" Condition="Exists($(PackagingDirectoryWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_DirectoriesToRemove" />
    </ReadLinesFromFile>
    <RemoveDir Directories="@(_DirectoriesToRemove)" ContinueOnError="true" />
    <Delete Files="$(PackagingDirectoryWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <ReadLinesFromFile File="$(PackagingFileWritesLogPath)" Condition="Exists($(PackagingFileWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_FilesToRemove" />
    </ReadLinesFromFile>
    <Delete Files="@(_FilesToRemove)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <Delete Files="$(PackagingFileWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
  </Target>
  <!-- Rebuild appx package target and entry point. -->
  <Target Name="_RebuildAppxPackage" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(CleanPackageAction);$(PackageAction)" />
  <!-- ========================================== -->
  <!-- Returns Architecture for given Platform.   -->
  <!-- ========================================== -->
  <Target Name="_GetProjectArchitecture" Returns="@(ProjectArchitecture)">
    <PropertyGroup>
      <_ProjectArchitectureOutput>Invalid</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'AnyCPU'">neutral</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x86'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'Win32'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x64'">x64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm'">arm</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm64'">arm64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm64ec'">arm64ec</_ProjectArchitectureOutput>
    </PropertyGroup>
    <ItemGroup>
      <ProjectArchitecture Include="$(_ProjectArchitectureOutput)" />
    </ItemGroup>
  </Target>
  <!-- ========================================== -->
  <!-- Getting all packaging outputs.             -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->
  <PropertyGroup>
    <GetPackagingOutputsDependsOn>
      $(GetPackagingOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      _CalculateXbfSupport;
    </GetPackagingOutputsDependsOn>
  </PropertyGroup>
  <Target Name="GetPackagingOutputs" Returns="@(PackagingOutputs)" DependsOnTargets="$(GetPackagingOutputsDependsOn)">
    <CallTarget Targets="BuiltProjectOutputGroup" Condition="'$(IncludeBuiltProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_BuiltProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_BuiltProjectOutputGroupOutput.FinalOutputPath)">
        <TargetPath>%(_BuiltProjectOutputGroupOutput.TargetPath)</TargetPath>
        <OutputGroup>BuiltProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="DebugSymbolsProjectOutputGroup" Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DebugSymbolsProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_DebugSymbolsProjectOutputGroupOutput.FinalOutputPath)">
        <OutputGroup>DebugSymbolsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="DocumentationProjectOutputGroup" Condition="'$(IncludeDocumentationProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DocumentationProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_DocumentationProjectOutputGroupOutput)">
        <OutputGroup>DocumentationProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SatelliteDllsProjectOutputGroup" Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SatelliteDllsProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SatelliteDllsProjectOutputGroupOutput)">
        <OutputGroup>SatelliteDllsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SourceFilesProjectOutputGroup" Condition="'$(IncludeSourceFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFilesProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SourceFilesProjectOutputGroupOutput)">
        <OutputGroup>SourceFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SGenFilesOutputGroup" Condition="'$(IncludeSGenFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SGenFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SGenFilesOutputGroupOutput)">
        <OutputGroup>SGenFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="CopyLocalFilesOutputGroup" Condition="'$(IncludeCopyLocalFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyLocalFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyLocalFilesOutputGroupOutput)">
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="GetCopyToOutputDirectoryItemsOutputGroup" Condition="'$(IncludeGetCopyToOutputDirectoryItemsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetCopyToOutputDirectoryItemsOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_GetCopyToOutputDirectoryItemsOutputGroupOutput)">
        <OutputGroup>GetCopyToOutputDirectoryItemsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="ComFilesOutputGroup" Condition="'$(IncludeComFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ComFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ComFilesOutputGroupOutput)">
        <OutputGroup>ComFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="CopyWinmdArtifactsOutputGroup" Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyWinmdArtifactsOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyWinmdArtifactsOutputGroupOutput)">
        <OutputGroup>CopyWinmdArtifactsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput" />
    </CallTarget>
    <ItemGroup Condition="'$(AppxExcludeXbfFromSdkPayloadWhenXamlIsPresent)' == 'true'">
      <!-- If extension SDK contains both XAML and XBF files, do not package XBF files from SDK -->
      <_SDKRedistRedundantXBF Include="@(_SDKRedistOutputGroupOutput->'%(RootDir)%(Directory)%(Filename).xbf')" Condition="'%(Extension)'=='.xaml'" />
      <_SDKRedistOutputGroupOutput Remove="@(_SDKRedistRedundantXBF)" />
    </ItemGroup>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SDKRedistOutputGroupOutput)">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Remove="@(RemoveSdkFilesFromAppxPackage)" />
    </ItemGroup>
    <CallTarget Targets="PriFilesOutputGroup" Condition="'$(IncludePriFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_PriFilesOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_PriFilesOutputGroupOutput)">
        <OutputGroup>PriFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="ContentFilesProjectOutputGroup" Condition="'$(IncludeContentFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ContentFilesProjectOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ContentFilesProjectOutputGroupOutput)">
        <OutputGroup>ContentFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_ContentFilesProjectOutputGroupOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <CallTarget Targets="CustomOutputGroupForPackaging" Condition="'$(IncludeCustomOutputGroupForPackaging)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CustomOutputGroupForPackagingOutput" />
    </CallTarget>
    <ItemGroup Condition="'$(DisableEmbeddedXbf)' != 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_CustomOutputGroupForPackagingOutput Remove="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'" />
    </ItemGroup>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' != '.xbf'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' != 'true'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' == 'true'">
        <OutputGroup>EmbedOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>
    <ExpandPayloadDirectories Inputs="@(_PackagingOutputsUnexpanded)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsExpanded" />
    </ExpandPayloadDirectories>
    <CallTarget Targets="GetResolvedSDKReferences" Condition="'$(IncludeGetResolvedSDKReferences)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetResolvedSDKReferencesOutputWithoutMetadata" />
    </CallTarget>
    <ItemGroup>
      <_GetResolvedSDKReferencesOutput Include="@(_GetResolvedSDKReferencesOutputWithoutMetadata)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_GetResolvedSDKReferencesOutput>
    </ItemGroup>
    <CallTarget Targets="_GetProjectArchitecture">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectArchitecture" />
    </CallTarget>
    <ItemGroup>
      <_ProjectArchitectureItem Include="@(_ProjectArchitecture)">
        <OutputGroup>_GetProjectArchitecture</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_ProjectArchitectureItem>
    </ItemGroup>
    <ItemGroup>
      <ProjectPriFile Include="$(ProjectPriFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>
    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <ProjectPriUploadFile Include="$(ProjectPriUploadFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriUploadFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriUploadFile>
    </ItemGroup>
    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>
    <MSBuild Projects="@(ProjectReferenceWithConfiguration)" Targets="GetPackagingOutputs" BuildInParallel="$(BuildInParallel)" Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)" Condition="'@(ProjectReferenceWithConfiguration)' != ''&#xD;&#xA;                 and '%(ProjectReferenceWithConfiguration.BuildReference)' == 'true'&#xD;&#xA;                 and '%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == 'true'" ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackagingOutputsFromOtherProjects" />
    </MSBuild>
    <ItemGroup>
      <_PackagingOutputsOutsideLayout Include="@(ProjectPriFile)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsExpanded)" />
      <_PackagingOutputsOutsideLayout Include="@(_GetResolvedSDKReferencesOutput)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsFromOtherProjects)" />
    </ItemGroup>
    <ItemGroup>
      <PathsToExcludeFromLayoutOutputGroup Include="@(_PackagingOutputsOutsideLayout->'%(TargetPath)')" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(AppxManifestTargetPath)" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(DeploymentRecipeTargetPath)" />
    </ItemGroup>
    <ItemGroup>
      <DirsToExcludeFromLayoutOutputGroup Include="$(WinMetadataDir)" />
      <DirsToExcludeFromLayoutOutputGroup Include="$(EntryPointDir)" />
    </ItemGroup>
    <ExpandPayloadDirectories Condition="'$(IncludeLayoutFilesInPackage)' == 'true'" Inputs="$(LayoutDir)" TargetDirsToExclude="@(DirsToExcludeFromLayoutOutputGroup)" TargetFilesToExclude="@(PathsToExcludeFromLayoutOutputGroup)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsFromLayout" />
    </ExpandPayloadDirectories>
    <ItemGroup>
      <PackagingOutputs Include="@(_PackagingOutputsFromLayout)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>LayoutOutputGroup</OutputGroup>
      </PackagingOutputs>
      <PackagingOutputs Include="@(_PackagingOutputsOutsideLayout)" />
      <PackagingOutputs Include="@(_ProjectArchitectureItem)" />
    </ItemGroup>
    <!-- Remove all .xaml files from the payload that correlate with a .xbf file -->
    <ItemGroup>
      <_PackagingOutputsXbfXaml Include="$([System.IO.Path]::ChangeExtension('%(PackagingOutputs.Identity)','.xaml'))" Condition="'%(Extension)' == '.xbf'" />
      <PackagingOutputs Remove="@(_PackagingOutputsXbfXaml)" />
    </ItemGroup>
  </Target>
  <!-- ========================================== -->
  <!-- Getting all Optional Project outputs.      -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->
  <PropertyGroup>
    <GetOptionalProjectOutputsDependsOn>
      $(GetOptionalProjectOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </GetOptionalProjectOutputsDependsOn>
  </PropertyGroup>
  <Target Name="GetOptionalProjectOutputs" Returns="@(OptionalProjectOutputs)" DependsOnTargets="$(GetOptionalProjectOutputsDependsOn)">
    <CallTarget Targets="OptionalProjectsOutputGroup" Condition="'$(IncludeOptionalProjectsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectsOutputGroupOutput" />
    </CallTarget>
    <ItemGroup>
      <_OptionalProjectsOutputs Include="@(_OptionalProjectsOutputGroupOutput)">
        <OutputGroup>OptionalProjectsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_OptionalProjectsOutputs>
    </ItemGroup>
    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">true</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">false</_ContinueOnError>
    </PropertyGroup>
    <MSBuild Projects="@(OptionalProjectBuildReferences)" Targets="GetOptionalProjectOutputs" BuildInParallel="$(BuildInParallel)" Properties="%(OptionalProjectBuildReferences.SetConfiguration); %(OptionalProjectBuildReferences.SetPlatform)" ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputsFromOtherProjects" />
    </MSBuild>
    <ItemGroup>
      <_AllOptionalProjectOutputs Include="@(_OptionalProjectsOutputs)" />
      <_AllOptionalProjectOutputs Include="@(_OptionalProjectOutputsFromOtherProjects)" />
    </ItemGroup>
    <ItemGroup>
      <OptionalProjectOutputs Include="@(_AllOptionalProjectOutputs)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>OptionalProjectOutputGroup</OutputGroup>
      </OptionalProjectOutputs>
    </ItemGroup>
  </Target>
  <!-- ============================== -->
  <!-- Getting package architecture.  -->
  <!-- ============================== -->
  <PropertyGroup>
    <_GetPackagePropertiesDependsOn>
      $(_GetPackagePropertiesDependsOn);
      _GetProjectArchitecture;
      _GetRecursiveProjectArchitecture;
      _GetPackageArchitecture;
      _GetDefaultResourceLanguage;
      _CalculateAppxBundleProperties;
    </_GetPackagePropertiesDependsOn>
  </PropertyGroup>
  <!-- Gets some package properties. -->
  <Target Name="_GetPackageProperties" Condition="'$(AppxGetPackagePropertiesEnabled)' == 'true'" DependsOnTargets="$(_GetPackagePropertiesDependsOn)" />
  <!-- Extract Project Architecture from the payload -->
  <Target Name="_GetRecursiveProjectArchitecture">
    <ItemGroup>
      <_RecursiveProjectArchitecture Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == '_GetProjectArchitecture'" />
      <_RecursiveProjectArchitecture Remove="@(_RecursiveProjectArchitecture)" Condition="'%(ProjectName)' == '$(ProjectName)'" />
    </ItemGroup>
  </Target>
  <!-- Gets package architecture. -->
  <Target Name="_GetPackageArchitecture">
    <GetPackageArchitecture Platform="$(Platform)" ProjectArchitecture="@(ProjectArchitecture)" RecursiveProjectArchitecture="@(_RecursiveProjectArchitecture)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="PackageArchitecture" PropertyName="PackageArchitecture" />
    </GetPackageArchitecture>
  </Target>
  <!-- Gets default resource language for the package. -->
  <Target Name="_GetDefaultResourceLanguage">
    <GetDefaultResourceLanguage DefaultLanguage="$(DefaultLanguage)" SourceAppxManifest="@(SourceAppxManifest)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="DefaultResourceLanguage" PropertyName="DefaultResourceLanguage" />
    </GetDefaultResourceLanguage>
  </Target>
  <Target Name="_CalculateAppxBundleProperties" Condition="'$(AppxBundle)' != 'Never'">
    <PropertyGroup>
      <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''">$(PackageArchitecture)</AppxBundlePlatforms>
    </PropertyGroup>
    <GetAppxBundlePlatforms Input="$(AppxBundlePlatforms)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Platforms" ItemName="AppxBundlePlatform" />
      <Output TaskParameter="Last" PropertyName="AppxBundleLastPlatform" />
    </GetAppxBundlePlatforms>
    <ItemGroup>
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' == 'neutral'" Include="@(AppxBundlePlatform -> 'AnyCPU')" />
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' != 'neutral'" Include="@(AppxBundlePlatform)" />
    </ItemGroup>
    <PropertyGroup>
      <_AppxBundlePlatformsForNamingIntermediate>@(AppxBundlePlatformWithAnyCPU)</_AppxBundlePlatformsForNamingIntermediate>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundlePlatformsForNaming>$(_AppxBundlePlatformsForNamingIntermediate.Replace(';','_'))</AppxBundlePlatformsForNaming>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleProducingPlatform>
      <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleResourcePacksProducingPlatform>
    </PropertyGroup>
    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true'&#xD;&#xA;                              and '$(BuildingInsideVisualStudio)' == 'true'&#xD;&#xA;                              and  $(AppxBundlePlatformsForNaming.Contains('_'))">
      <AppxPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxPackageDirInProjectDir)</AppxPackageDir>
      <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true'&#xD;&#xA;                              and '$(BuildingInsideVisualStudio)' == 'true'&#xD;&#xA;                              and  $(AppxBundlePlatformsForNaming.Contains('_'))&#xD;&#xA;                              and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxUploadPackageDirInProjectDir)</AppxUploadPackageDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>
    <PropertyGroup>
      <AppxBundlePlatformSpecificArtifactsListPath>$(PlatformSpecificBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificArtifactsListPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxBundlePlatformSpecificUploadArtifactsListPath>$(PlatformSpecificUploadBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificUploadArtifactsListPath>
    </PropertyGroup>
  </Target>
  <!-- ====================== -->
  <!-- Project output groups. -->
  <!-- ====================== -->
  <!-- Targets that all output groups defined in this targets depends on. -->
  <PropertyGroup>
    <AllOutputGroupsDependsOn>
      $(AllOutputGroupsDependsOn)
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </AllOutputGroupsDependsOn>
  </PropertyGroup>
  <!-- ======================================= -->
  <!-- Output group including CopyLocal files. -->
  <!-- ======================================= -->
  <PropertyGroup>
    <CopyLocalFilesOutputGroupDependsOn>
      $(CopyLocalFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyLocalFilesOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="CopyLocalFilesOutputGroup" DependsOnTargets="$(CopyLocalFilesOutputGroupDependsOn)" Returns="@(CopyLocalFilesOutputGroupOutput)">
    <ItemGroup>
      <_CopyLocalFilesOutputGroupOutputFromReferences Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Extension)' != '.xml' or '$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' == 'true'">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </_CopyLocalFilesOutputGroupOutputFromReferences>
    </ItemGroup>
    <!-- Sometimes, we get duplicate entries here from NuGet packages which are not normalized -->
    <!-- i.e., one entry will have ..\..-style paths embedded, and other will not.             -->
    <!-- Remove those duplicates first before proceeding to look for WINMD implementations.    -->
    <RemovePayloadDuplicates Inputs="@(_CopyLocalFilesOutputGroupOutputFromReferences)" ProjectName="$(ProjectName)" Platform="$(Platform)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="Filtered" ItemName="CopyLocalFilesOutputGroupOutput" />
    </RemovePayloadDuplicates>
    <!-- In case of Winmd files, we may not get implementation -->
    <!-- file as separate CopyLocal file (if exist), so we are -->
    <!-- extracting it here.                                   -->
    <ItemGroup>
      <_WinmdWithImplementation Include="@(CopyLocalFilesOutputGroupOutput)" Condition="'%(CopyLocalFilesOutputGroupOutput.Extension)' == '.winmd'&#xD;&#xA;                       AND '%(CopyLocalFilesOutputGroupOutput.Filename)' != 'platform'&#xD;&#xA;                       AND '%(CopyLocalFilesOutputGroupOutput.Implementation)' != ''" />
      <!-- Determine if any existing copy-local item has already -->
      <!-- satisfied the implementation                          -->
      <_WinmdWithImplementationTargetPath Include="@(_WinmdWithImplementation->'%(DestinationSubDirectory)%(Implementation)')">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </_WinmdWithImplementationTargetPath>
      <_CopyLocalFilesOutputGroupOutputTargetPath Include="@(CopyLocalFilesOutputGroupOutput->'%(TargetPath)')" />
      <!-- intersect on targetpath -->
      <_WinmdSatifiedImplementation Include="@(_WinmdWithImplementationTargetPath)" Condition="'@(_WinmdWithImplementationTargetPath)' == '@(_CopyLocalFilesOutputGroupOutputTargetPath)' AND '%(Identity)' != ''" />
      <_WinmdWithImplementation Remove="@(_WinmdSatifiedImplementation->'%(OriginalItemSpec)')" />
    </ItemGroup>
    <!-- If a WINMD is coming from a NuGet package, the implementation DLL may not be delivered along with WINMD, but as       -->
    <!-- a separate item through CopyLocal or other packaging group. If DLL is not present on constructed location, remove it. -->
    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)" Condition="Exists('%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)')">
        <TargetPath>%(_WinmdWithImplementation.DestinationSubDirectory)%(_WinmdWithImplementation.Implementation)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- ================================================================================= -->
  <!-- Output group including CopyLocal files from target GetCopyToOutputDirectoryItems. -->
  <!-- ================================================================================= -->
  <PropertyGroup>
    <GetCopyToOutputDirectoryItemsOutputGroupDependsOn>
      $(GetCopyToOutputDirectoryItemsOutputGroupDependsOn);
      GetCopyToOutputDirectoryItems;
      $(AllOutputGroupsDependsOn)
    </GetCopyToOutputDirectoryItemsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="GetCopyToOutputDirectoryItemsOutputGroup" DependsOnTargets="$(GetCopyToOutputDirectoryItemsOutputGroupDependsOn)" Returns="@(GetCopyToOutputDirectoryItemsOutputGroupOutput)">
    <ItemGroup>
      <GetCopyToOutputDirectoryItemsOutputGroupOutput Include="@(AllItemsFullPathWithTargetPath)" />
    </ItemGroup>
  </Target>
  <!-- ============================================== -->
  <!-- Output group including OptionalProjects files. -->
  <!-- ============================================== -->
  <PropertyGroup>
    <OptionalProjectsOutputGroupDependsOn>
      $(OptionalProjectsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </OptionalProjectsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="OptionalProjectsOutputGroup" DependsOnTargets="$(OptionalProjectsOutputGroupDependsOn)" Returns="@(OptionalProjectsOutputGroupOutput)">
    <ItemGroup>
      <OptionalProjectsOutputGroupOutput Include="@(AllBuiltSideloadPackages)">
        <FileType>SideloadPackage</FileType>
        <TargetPath>%(AllBuiltSideloadPackages.Filename)%(AllBuiltSideloadPackages.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllBuiltUploadPackages)">
        <FileType>UploadPackage</FileType>
        <TargetPath>%(AllBuiltUploadPackages.Filename)%(AllBuiltUploadPackages.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllGeneratedManifests)">
        <FileType>Manifest</FileType>
        <TargetPath>%(AllGeneratedManifests.Filename)%(AllGeneratedManifests.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllGeneratedRecipes)">
        <FileType>Recipe</FileType>
        <TargetPath>%(AllGeneratedRecipes.Filename)%(AllGeneratedRecipes.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- =========================================== -->
  <!-- Output group including COM reference files. -->
  <!-- =========================================== -->
  <PropertyGroup>
    <ComFilesOutputGroupDependsOn>
      $(ComFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </ComFilesOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ComFilesOutputGroup" DependsOnTargets="$(ComFilesOutputGroupDependsOn)" Returns="@(ComFilesOutputGroupOutputs)">
    <ItemGroup>
      <ComFilesOutputGroupOutputs Include="@(ReferenceComWrappersToCopyLocal)">
        <TargetPath>%(ReferenceComWrappersToCopyLocal.Filename)%(ReferenceComWrappersToCopyLocal.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(ResolvedIsolatedComModules)">
        <TargetPath>%(ResolvedIsolatedComModules.Filename)%(ResolvedIsolatedComModules.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(NativeReferenceFile)">
        <TargetPath>%(NativeReferenceFile.Filename)%(NativeReferenceFile.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
    </ItemGroup>
  </Target>
  <!-- ============================================ -->
  <!-- Output group including Winmd artifact files. -->
  <!-- ============================================ -->
  <PropertyGroup>
    <CopyWinmdArtifactsOutputGroupDependsOn>
      $(CopyWinmdArtifactsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyWinmdArtifactsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="CopyWinmdArtifactsOutputGroup" DependsOnTargets="$(CopyWinmdArtifactsOutputGroupDependsOn)" Returns="@(CopyWinmdArtifactsOutputGroupOutputs)">
    <ItemGroup>
      <CopyWinmdArtifactsOutputGroupOutputs Include="@(FinalWinmdExpArtifacts ->'%(FullPath)')">
        <TargetPath>%(FinalWinmdExpArtifacts.DestinationSubDirectory)%(FinalWinmdExpArtifacts.Filename)%(FinalWinmdExpArtifacts.Extension)</TargetPath>
      </CopyWinmdArtifactsOutputGroupOutputs>
    </ItemGroup>
  </Target>
  <!-- ===================== -->
  <!-- Prepare layout target -->
  <!-- ===================== -->
  <PropertyGroup>
    <PrepareLayoutDependsOn>
      $(PrepareLayoutDependsOn);
      BeforePrepareLayout;
      _PrepareLayout;
      AfterPrepareLayout
    </PrepareLayoutDependsOn>
  </PropertyGroup>
  <!-- Prepares layout for debbuging/launching. -->
  <Target Name="PrepareLayout" Condition="'$(AppxPackage)' == 'true'" DependsOnTargets="$(PrepareLayoutDependsOn)" />
  <!-- Implement BeforePrepareLayout to influence final APPX layout recipe content.                          -->
  <!-- Here one can specify these additional items:                                                          -->
  <!-- (TODO: final extensibility items list and names - depending how much InternalPrepareLayout recognize) -->
  <!--                                                                                                       -->
  <!--    @(AppxAdditionalPackageContent)                                                                    -->
  <!--    @(AppxAdditionalSDKDependencies)                                                                   -->
  <!--    @(AppxAdditionalPRI)                                                                               -->
  <!--    @(AppxAdditionalWinmd)                                                                             -->
  <!--                                                                                                       -->
  <Target Name="BeforePrepareLayout" />
  <!-- Internal prepare layout target. -->
  <Target Name="_PrepareLayout" Inputs="$(MSBuildAllProjects);$(AppxPackageRecipe)" Outputs="$(FinalAppxPackageRecipe)">
    <!-- TODO: PRI and Winmd merge steps will be moved here -->
    <Copy UseHardlinksIfPossible="false" SourceFiles="$(AppxPackageRecipe)" DestinationFiles="$(FinalAppxPackageRecipe)" />
  </Target>
  <!-- Implement AfterPrepareLayout if needed to modify layout in more custom way. -->
  <!-- Here one can do arbitraty changes to $(FinalAppxPackageRecipe)              -->
  <Target Name="AfterPrepareLayout" />
  <!-- BEGIN APPINSTALLER PREPARATION -->
  <!-- ===================================================================================== -->
  <!-- Locate the .appinstaller file.                                                        -->
  <!-- ===================================================================================== -->
  <PropertyGroup>
    <AppInstallerDependsOn>
      GenerateAppInstallerFileForPackage;
      CreateAppInstallerPublishMeta;
      GeneratePublishHtmlForAppInstaller
    </AppInstallerDependsOn>
  </PropertyGroup>
  <Target Name="GenerateAppInstallerForBundle" Condition="'$(GenerateAppInstallerFile)' == 'true' AND '$(ProduceAppxBundle)' == 'true'" DependsOnTargets="$(AppInstallerDependsOn)" />
  <Target Name="GenerateAppInstallerForPackage" Condition="'$(GenerateAppInstallerFile)' == 'true' AND '$(ProduceAppxBundle)' == 'false'" DependsOnTargets="$(AppInstallerDependsOn)" />
  <Target Name="GeneratePublishHtmlForAppInstaller" DependsOnTargets="CreateAppInstallerPublishMeta">
    <PropertyGroup>
      <PublishLogoPath Condition="'$(PublishLogoPath)' == ''">%(AppInstallerPublishMeta.LogoPath)</PublishLogoPath>
    </PropertyGroup>
    <GenerateLandingPage OutputFolder="%(AppInstallerPublishMeta.OutputFolder)" AppName="%(AppInstallerPublishMeta.AppName)" AppDescription="%(AppInstallerPublishMeta.AppDescription)" Version="%(AppInstallerPublishMeta.Version)" RequiredOS="%(AppInstallerPublishMeta.RequiredOS)" PublisherName="%(AppInstallerPublishMeta.PublisherName)" SupportedArchitectures="%(AppInstallerPublishMeta.SupportedArchitectures)" AdditionalLinksMap="%(AppInstallerPublishMeta.AdditionalLinks)" TileColor="%(AppInstallerPublishMeta.TileColor)" ButtonMap="%(AppInstallerPublishMeta.ButtonMap)" ImageFile="$(PublishLogoPath)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="LandingPagePath" PropertyName="LandingPagePath" />
    </GenerateLandingPage>
    <ItemGroup>
      <InstallerFileWrites Include="$(LandingPagePath)" />
    </ItemGroup>
  </Target>
  <Target Name="CreateAppInstallerPublishMeta">
    <CreateAppInstallerPublishMeta AppInstallerMetaSearchDirectory="$(PlatformSpecificBundleArtifactsListDirInProjectDir)" IsBundle="$(ProduceAppxBundle)" AppVersion="$(AppInstallerVersion)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AppInstallerPublishMeta" ItemName="AppInstallerPublishMeta" />
    </CreateAppInstallerPublishMeta>
  </Target>
  <Target Name="_FindAppInstallerTemplateFile">
    <ItemGroup Condition="'@(AppInstallerTemplateFile)' == ''">
      <AppInstallerTemplateFile Include="@(Content)" Condition="'%(Identity)' == '$(AppInstallerTemplateFileName)'" />
      <AppInstallerTemplateFile Include="@(None)" Condition="'%(Identity)' == '$(AppInstallerTemplateFileName)' and '$(AppInstallerTemplateFile)' == ''" />
      <None Remove="@(None)" Condition="'%(Identity)' == '$(AppInstallerTemplateFileName)'" />
    </ItemGroup>
  </Target>
  <Target Name="GenerateAppInstallerFileForPackage" DependsOnTargets="_FindAppInstallerTemplateFile">
    <PropertyGroup>
      <AppInstallerPackageOutputFile>$(AppxPackageOutput)</AppInstallerPackageOutputFile>
      <AppInstallerPackageOutputFile Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxBundleOutput)</AppInstallerPackageOutputFile>
    </PropertyGroup>
    <GenerateAppInstallerFile AppInstallerTemplateFile="@(AppInstallerTemplateFile)" FinalAppxManifestFile="$(FinalAppxManifestName)" HoursBetweenUpdateChecks="$(HoursBetweenUpdateChecks)" AppInstallerCheckForUpdateFrequency="$(AppInstallerCheckForUpdateFrequency)" AppInstallerUpdateFrequency="$(AppInstallerUpdateFrequency)" AppInstallerUri="$(AppInstallerUri)" BundleArtifactsDir="$(PlatformSpecificBundleArtifactsListDirInProjectDir)" ProjectFileDir="$(MSBuildProjectDirectory)" AppxBundlePlatforms="$(AppxBundlePlatforms)" ProjectName="$(ProjectName)" ProduceAppxBundle="$(ProduceAppxBundle)" FrameworkSdkPackages="@(FrameworkSdkPackage)" AppxPackageDir="$(AppxPackageDir)" AppxUri="$(AppInstallerPackageOutputFile)" AppxPackagingComponentManifestPath="$(AppxPackagingComponentManifestPath)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="AppInstallerFileWrites" ItemName="AppInstallerFileWrites" />
      <Output TaskParameter="AppInstallerFilePath" ItemName="AppInstallerFilePath" />
      <Output TaskParameter="AppInstallerVersion" PropertyName="AppInstallerVersion" />
    </GenerateAppInstallerFile>
    <ItemGroup>
      <FileWrites Include="@(AppInstallerFileWrites)" />
      <InstallerFileWrites Include="@(AppInstallerFilePath)" />
    </ItemGroup>
  </Target>
  <!-- Adjusting SDK payload. -->
  <PropertyGroup>
    <SDKRedistOutputGroupDependsOn>
      $(SDKRedistOutputGroupDependsOn);
      _ProcessPriFilesFromSdkPayload
    </SDKRedistOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="_ProcessPriFilesFromSdkPayload" Condition="'$(AppxProcessPriFilesFromSdkPayload)' == 'true'" DependsOnTargets="ExpandSDKReferences;_GetSdkToolPaths">
    <RemoveRedundantXamlFilesFromSdkPayload SdkPayload="@(ResolvedRedistFiles)" MrmSupportLibraryPath="$(MrmSupportLibraryPath)" VsTelemetrySession="$(VsTelemetrySession)">
      <Output TaskParameter="FilesToRemove" ItemName="_RedistFilesToRemove" />
    </RemoveRedundantXamlFilesFromSdkPayload>
    <ItemGroup>
      <ResolvedRedistFiles Remove="@(_RedistFilesToRemove)" />
    </ItemGroup>
  </Target>
  <Target Name="_ContinuousStoreSubmission" Condition="'$(BuildingInsideVisualStudio)' != 'true' and $(AppxStoreContainer) != '' and '$(Configuration)' != 'Debug' and '@(StoreAssociationFile)' != ''" DependsOnTargets="_FindStoreAssociationFile">
    <StoreSubmission StoreAssociationFile="@(StoreAssociationFile)" AppxUploadPackage="$(AppxStoreContainer)" VsTelemetrySession="$(VsTelemetrySession)" EnableDirectStoreSubmission="$(EnableDirectStoreSubmission)" OverwritePendingSubmission="$(OverwritePendingSubmission)" />
  </Target>
  <Target Name="_ValidateConfiguration">
    <ValidateConfiguration TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" ProjectLanguage="$(Language)" VsTelemetrySession="$(VsTelemetrySession)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Platform="$(Platform)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')" />-->
  <!-- Import NuGet.targets (required for GetReferenceNearestTargetFrameworkTask and used for Restore functionality) -->
  <PropertyGroup xmlns="">
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetRestoreTargets)" Condition="'$(IsRestoreTargetsFileLoaded)' != 'true' and Exists('$(NuGetRestoreTargets)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************

  This target file contains the NuGet Restore target for walking the project and reference graph
  and restoring dependencies from the graph.

  Ways to use this targets file:
  1. Invoke it directly and provide project file paths using $(RestoreGraphProjectInput).
  2. With a solution this may be used as a target in the metaproj.
  3. Import the targets file from a project.

  Restore flow summary:
  1. Top level projects (entry points) are determined.
  2. Each project and all of its project references are walked recursively.
  3. The project is evaluated for each $(TargetFramework). Items are created
     for project properties and dependencies. Each item is marked
     with the project it came from so that it can be matched up later.
  4. All restore items generated by the walk are grouped together by
     project and convert into a project spec.

  The result file contains:
  1. A list of projects to restore.
  2. The complete closure of all projects referenced (Includes project references that are not being restored directly).
  3. Package and project dependencies for each project.
  4. DotnetCliTool references
  -->
  <PropertyGroup>
    <!-- Mark that this target file has been loaded.  -->
    <IsRestoreTargetsFileLoaded>true</IsRestoreTargetsFileLoaded>
    <!-- Load NuGet.Build.Tasks.dll, this can be overridden to use a different version with $(RestoreTaskAssemblyFile) -->
    <RestoreTaskAssemblyFile Condition=" '$(RestoreTaskAssemblyFile)' == '' ">NuGet.Build.Tasks.dll</RestoreTaskAssemblyFile>
    <!-- Do not hide errors and warnings by default -->
    <HideWarningsAndErrors Condition=" '$(HideWarningsAndErrors)' == '' ">false</HideWarningsAndErrors>
    <!-- Recurse by default -->
    <RestoreRecursive Condition=" '$(RestoreRecursive)' == '' ">true</RestoreRecursive>
    <RestoreUseSkipNonexistentTargets Condition=" '$(RestoreUseSkipNonexistentTargets)' == '' ">true</RestoreUseSkipNonexistentTargets>
    <!-- RuntimeIdentifier compatibility check -->
    <ValidateRuntimeIdentifierCompatibility Condition=" '$(ValidateRuntimeIdentifierCompatibility)' == '' ">false</ValidateRuntimeIdentifierCompatibility>
    <!-- Error handling while walking projects -->
    <RestoreContinueOnError Condition=" '$(RestoreContinueOnError)' == '' ">WarnAndContinue</RestoreContinueOnError>
    <!-- Build in parallel -->
    <RestoreBuildInParallel Condition=" '$(BuildInParallel)' != '' ">$(BuildInParallel)</RestoreBuildInParallel>
    <RestoreBuildInParallel Condition=" '$(RestoreBuildInParallel)' == '' ">true</RestoreBuildInParallel>
    <!-- Check if the restore target was executed on a sln file -->
    <_RestoreSolutionFileUsed Condition=" '$(_RestoreSolutionFileUsed)' == '' AND '$(SolutionDir)' != '' AND $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' ">true</_RestoreSolutionFileUsed>
    <!-- We default to MSBuildInteractive. -->
    <NuGetInteractive Condition=" '$(NuGetInteractive)' == '' ">$(MSBuildInteractive)</NuGetInteractive>
    <!-- Mark that this targets file supports package download. -->
    <PackageDownloadSupported>true</PackageDownloadSupported>
    <!-- Mark that this targets file GetReferenceNearestTargetFrameworkTask task supports the TargetPlatformMoniker -->
    <GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>true</GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>
    <!-- Flag if the Central package file is enabled -->
    <_CentralPackageVersionsEnabled Condition="'$(ManagePackageVersionsCentrally)' == 'true' AND '$(CentralPackageVersionsFileImported)' == 'true'">true</_CentralPackageVersionsEnabled>
  </PropertyGroup>
  <!--
    Visual Studio's project property page requires defaults to be set to inform customers what the default values are.
    Project-system uses DefaultValueSourceLocation.AfterContext to detect when a customer's project changes the value, so these defaults must be set here in the targets file.
  -->
  <PropertyGroup>
    <!-- Enable NuGetAudit by default -->
    <NuGetAudit Condition=" '$(NuGetAudit)' == '' ">true</NuGetAudit>
    <!-- Report all severity vulnerabilities (low severity and higher). Allowed values are: low, moderate, high, critical -->
    <NuGetAuditLevel Condition=" '$(NuGetAuditLevel)' == '' ">low</NuGetAuditLevel>
    <!-- Report known vulnerabilities on direct and transitive dependencies for .NET 10 and higher, direct only otherwise -->
    <NuGetAuditMode Condition=" '$(NuGetExeSkipSdkAnalysisLevelCheck)' != 'true'&#xD;&#xA;                    AND '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xD;&#xA;                    AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '10.0'))">all</NuGetAuditMode>
    <NuGetAuditMode Condition=" '$(NuGetAuditMode)' == '' ">direct</NuGetAuditMode>
  </PropertyGroup>
  <PropertyGroup>
    <RestoreEnablePackagePruning Condition="$(RestoreEnablePackagePruning) == '' ">false</RestoreEnablePackagePruning>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Exclude packages from changing restore inputs.  -->
    <_GenerateRestoreGraphProjectEntryInputProperties>ExcludeRestorePackageImports=true</_GenerateRestoreGraphProjectEntryInputProperties>
    <!-- Standalone mode
         This is used by NuGet.exe to inject targets into the project that will be
         walked next. In normal /t:Restore mode this causes a duplicate import
         since NuGet.targets it loaded as part of MSBuild, there is should be
         skipped. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(RestoreUseCustomAfterTargets)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      NuGetRestoreTargets=$(MSBuildThisFileFullPath);
      RestoreUseCustomAfterTargets=$(RestoreUseCustomAfterTargets);
      CustomAfterMicrosoftCommonCrossTargetingTargets=$(MSBuildThisFileFullPath);
      CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
    </_GenerateRestoreGraphProjectEntryInputProperties>
    <!-- Include SolutionDir and SolutionName for solution restores and persist these properties during the walk. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(_RestoreSolutionFileUsed)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      _RestoreSolutionFileUsed=true;
      SolutionDir=$(SolutionDir);
      SolutionName=$(SolutionName);
      SolutionFileName=$(SolutionFileName);
      SolutionPath=$(SolutionPath);
      SolutionExt=$(SolutionExt);
    </_GenerateRestoreGraphProjectEntryInputProperties>
  </PropertyGroup>
  <ItemGroup Condition="'$(ManagePackageVersionsCentrally)' == 'true' And '$(RestoreEnableGlobalPackageReference)' != 'false'">
    <!--
        Add GlobalPackageReference items to the PackageReference item group with no version.

        Global package references only include the same assets as a development dependency (runtime; build; native; contentfiles; analyzers)
        because those kind of packages are the best candidate for a global package reference.  They are generally packages that
        extend the build.

        Global package references have all assets private because central package references are generally packages that provide
        versioning, signing, etc and should not flow to downstream dependencies.  Also, central package references are already
        referenced by every project in the tree so they don't need to be transitive.
      -->
    <PackageReference Include="@(GlobalPackageReference)" Version="" IncludeAssets="Runtime;Build;Native;contentFiles;Analyzers" PrivateAssets="All" />
    <!--
        Add GlobalPackageReference items to the PackageVersion item group with the version.
      -->
    <PackageVersion Include="@(GlobalPackageReference)" Version="%(Version)" />
  </ItemGroup>
  <!-- Tasks -->
  <UsingTask TaskName="NuGet.Build.Tasks.RestoreTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.WriteRestoreGraphTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectJsonPathTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetCentralPackageVersionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageDownloadsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreFrameworkReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreNuGetAuditSuppressionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePrunePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreDotnetCliToolsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetProjectTargetFrameworksTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSolutionProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSettingsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.WarnForInvalidProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetReferenceNearestTargetFrameworkTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectStyleTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.NuGetMessageTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.CheckForDuplicateNuGetItemsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetGlobalPropertyValueTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <!--
    ============================================================
    Restore
    Main entry point for restoring packages
    ============================================================
  -->
  <Target Name="Restore" DependsOnTargets="_GenerateRestoreGraph">
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreGraphEntry)">
      <Output TaskParameter="Filtered" ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>
    <!-- Call restore -->
    <RestoreTask RestoreGraphItems="@(_RestoreGraphEntryFiltered)" RestoreDisableParallel="$(RestoreDisableParallel)" RestoreNoCache="$(RestoreNoCache)" RestoreNoHttpCache="$(RestoreNoHttpCache)" RestoreIgnoreFailedSources="$(RestoreIgnoreFailedSources)" RestoreRecursive="$(RestoreRecursive)" RestoreForce="$(RestoreForce)" HideWarningsAndErrors="$(HideWarningsAndErrors)" Interactive="$(NuGetInteractive)" RestoreForceEvaluate="$(RestoreForceEvaluate)" RestorePackagesConfig="$(RestorePackagesConfig)" EmbedFilesInBinlog="$(RestoreEmbedFilesInBinlog)">
      <Output TaskParameter="EmbedInBinlog" ItemName="EmbedInBinlog" />
      <Output TaskParameter="ProjectsRestored" PropertyName="RestoreProjectCount" />
      <Output TaskParameter="ProjectsAlreadyUpToDate" PropertyName="RestoreSkippedCount" />
      <Output TaskParameter="ProjectsAudited" PropertyName="RestoreProjectsAuditedCount" />
    </RestoreTask>
  </Target>
  <!--
    ============================================================
    GenerateRestoreGraphFile
    Writes the output of _GenerateRestoreGraph to disk
    ============================================================
  -->
  <Target Name="GenerateRestoreGraphFile" DependsOnTargets="_GenerateRestoreGraph">
    <!-- Validate  -->
    <Error Condition="$(RestoreGraphOutputPath) == ''" Text="Missing RestoreGraphOutputPath property!" />
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreGraphEntry)">
      <Output TaskParameter="Filtered" ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>
    <!-- Write file -->
    <WriteRestoreGraphTask RestoreGraphItems="@(_RestoreGraphEntryFiltered)" RestoreGraphOutputPath="$(RestoreGraphOutputPath)" RestoreRecursive="$(RestoreRecursive)" />
  </Target>
  <!--
    ============================================================
    CollectPackageReferences
    Gathers all PackageReference items from the project.
    This target may be used as an extension point to modify
    package references before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageReferences" Returns="@(PackageReference)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageReferencesContinueOnError>$(ContinueOnError)</CollectPackageReferencesContinueOnError>
      <CollectPackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageReferencesContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageReference)" ItemName="PackageReference" LogCode="NU1504" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPackageReferencesContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageReferences" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageReferences)' != ''">
      <PackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(DeduplicatedPackageReferences)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectCentralPackageVersions
    Gathers all PackageVersion items from the central package versions file.
    ============================================================
  -->
  <Target Name="CollectCentralPackageVersions" Returns="@(PackageVersion)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectCentralPackageVersionsContinueOnError>$(ContinueOnError)</CollectCentralPackageVersionsContinueOnError>
      <CollectCentralPackageVersionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectCentralPackageVersionsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageVersion)" ItemName="PackageVersion" LogCode="NU1506" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectCentralPackageVersionsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageVersions" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageVersions)' != ''">
      <PackageVersion Remove="@(PackageVersion)" />
      <PackageVersion Include="@(DeduplicatedPackageVersions)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectPackageDownloads
    Gathers all PackageDownload items from the project.
    This target may be used as an extension point to modify
    package downloads before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageDownloads" Returns="@(PackageDownload)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageDownloadsContinueOnError>$(ContinueOnError)</CollectPackageDownloadsContinueOnError>
      <CollectPackageDownloadsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageDownloadsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageDownload)" ItemName="PackageDownload" LogCode="NU1505" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPackageDownloadsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageDownloads" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageDownloads)' != ''">
      <PackageDownload Remove="@(PackageDownload)" />
      <PackageDownload Include="@(DeduplicatedPackageDownloads)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectFrameworkReferences
    ============================================================
  -->
  <Target Name="CollectFrameworkReferences" Returns="@(_FrameworkReferenceForRestore)">
    <ItemGroup>
      <_FrameworkReferenceForRestore Include="@(FrameworkReference)" Condition="'%(FrameworkReference.IsTransitiveFrameworkReference)' != 'true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectNuGetAuditSuppressions
    Gathers all NuGetAuditSuppress items from the project.
    This target may be used as an extension point to modify
    advisory suppressions before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectNuGetAuditSuppressions" Returns="@(NuGetAuditSuppress)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectNuGetAuditSuppressionsContinueOnError>$(ContinueOnError)</CollectNuGetAuditSuppressionsContinueOnError>
      <CollectNuGetAuditSuppressionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectNuGetAuditSuppressionsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Items="@(NuGetAuditSuppress)" ItemName="NuGetAuditSuppress" LogCode="NU1508" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectNuGetAuditSuppressionsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedNuGetAuditSuppressions" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedNuGetAuditSuppressions)' != ''">
      <NuGetAuditSuppress Remove="@(NuGetAuditSuppress)" />
      <NuGetAuditSuppress Include="@(DeduplicatedNuGetAuditSuppressions)" />
    </ItemGroup>
  </Target>
  <Target Name="CollectPrunePackageReferences" Returns="@(PrunePackageReference)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPrunePackageReferencesContinueOnError>$(ContinueOnError)</CollectPrunePackageReferencesContinueOnError>
      <CollectPrunePackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPrunePackageReferencesContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PrunePackageReference)" ItemName="PrunePackageReference" LogCode="NU1509" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPrunePackageReferencesContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPrunePackageReference" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPrunePackageReference)' != ''">
      <PrunePackageReference Remove="@(PrunePackageReference)" />
      <PrunePackageReference Include="@(DeduplicatedPrunePackageReference)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _CollectRestoreInputs
    Runs all the 'Collect' targets
    ============================================================
  -->
  <Target Name="_CollectRestoreInputs" DependsOnTargets="CollectPackageReferences;CollectPackageDownloads;CollectFrameworkReferences;CollectCentralPackageVersions;CollectNuGetAuditSuppressions;CollectPrunePackageReferences" />
  <!--
    ============================================================
    _LoadRestoreGraphEntryPoints
    Find project entry points and load them into items.
    ============================================================
  -->
  <Target Name="_LoadRestoreGraphEntryPoints" Returns="@(RestoreGraphProjectInputItems)">
    <!-- Allow overriding items with RestoreGraphProjectInput -->
    <ItemGroup Condition=" @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(RestoreGraphProjectInput)" />
    </ItemGroup>
    <!-- Project case -->
    <ItemGroup Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) != 'true' AND @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <!-- Solution case -->
    <GetRestoreSolutionProjectsTask Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' AND @(RestoreGraphProjectInputItems) == '' " ProjectReferences="@(ProjectReference)" SolutionFilePath="$(MSBuildProjectFullPath)">
      <Output TaskParameter="OutputProjectReferences" ItemName="RestoreGraphProjectInputItems" />
    </GetRestoreSolutionProjectsTask>
  </Target>
  <!--
    ============================================================
    _FilterRestoreGraphProjectInputItems
    Filter out unsupported project entry points.
    ============================================================
  -->
  <Target Name="_FilterRestoreGraphProjectInputItems" DependsOnTargets="_LoadRestoreGraphEntryPoints" Returns="@(FilteredRestoreGraphProjectInputItems)">
    <PropertyGroup>
      <RestoreProjectFilterMode Condition=" '$(RestoreProjectFilterMode)' == '' ">exclusionlist</RestoreProjectFilterMode>
    </PropertyGroup>
    <!-- Filter to a list of known supported types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" Condition=" '%(RestoreGraphProjectInputItems.Extension)' == '.csproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.vbproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.fsproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.nuproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.proj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.msbuildproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.vcxproj' " />
    </ItemGroup>
    <!-- Filter out disallowed types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'exclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" Condition=" '%(RestoreGraphProjectInputItems.Extension)' != '.metaproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.shproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vcxitems'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vdproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '' " />
    </ItemGroup>
    <!-- No filtering -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' != 'exclusionlist' AND '$(RestoreProjectFilterMode)' != 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" />
    </ItemGroup>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_FilteredRestoreGraphProjectInputItemsTmp)">
      <Output TaskParameter="Filtered" ItemName="FilteredRestoreGraphProjectInputItemsWithoutDuplicates" />
    </RemoveDuplicates>
    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" Targets="_IsProjectRestoreSupported" SkipNonexistentTargets="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" Targets="_IsProjectRestoreSupported" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>
    <!-- Warn for projects that do not support restore. -->
    <WarnForInvalidProjectsTask Condition=" '$(DisableWarnForInvalidRestoreProjects)' != 'true' AND '$(HideWarningsAndErrors)' != 'true' " AllProjects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" ValidProjects="@(FilteredRestoreGraphProjectInputItems)" />
  </Target>
  <!--
    ============================================================
    _GenerateRestoreGraph
    Entry point for creating the project to project restore graph.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraph" DependsOnTargets="_FilterRestoreGraphProjectInputItems;_GetAllRestoreProjectPathItems" Returns="@(_RestoreGraphEntry)">
    <Message Text="Generating dg file" Importance="low" />
    <Message Text="%(_RestoreProjectPathItems.Identity)" Importance="low" />
    <!-- Use all projects if RestoreRecursive is true. Otherwise use only the top level projects. -->
    <ItemGroup>
      <_GenerateRestoreGraphProjectEntryInput Include="@(FilteredRestoreGraphProjectInputItems)" Condition=" '$(RestoreRecursive)' != 'true' " />
      <_GenerateRestoreGraphProjectEntryInput Include="@(_RestoreProjectPathItems)" Condition=" '$(RestoreRecursive)' == 'true' " />
    </ItemGroup>
    <!-- Add top level entries to the direct restore list. These projects will also restore tools. -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_GenerateRestoreGraphProjectEntryInput)" Targets="_GenerateRestoreGraphProjectEntry" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
    <!-- Generate a spec for every project including dependencies. -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_RestoreProjectPathItems)" Targets="_GenerateProjectRestoreGraph" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreGraphProjectEntry
    Top level entry point within a project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraphProjectEntry" DependsOnTargets="_GenerateRestoreSpecs;_GenerateDotnetCliToolReferenceSpecs" Returns="@(_RestoreGraphEntry)">
    <!-- Returns restore graph entries for the project and all dependencies -->
  </Target>
  <!--
    ============================================================
    _GenerateRestoreSpecs
    Mark entry points for restore.
    ============================================================
  -->
  <Target Name="_GenerateRestoreSpecs" DependsOnTargets="_GetRestoreProjectStyle" Returns="@(_RestoreGraphEntry)">
    <Message Text="Restore entry point $(MSBuildProjectFullPath)" Importance="low" />
    <!-- Mark entry point -->
    <ItemGroup Condition=" '$(RestoreProjects)' == '' OR '$(RestoreProjects)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())" Condition=" '$(RestoreProjectStyle)' != 'Unknown' ">
        <Type>RestoreSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateDotnetCliToolReferenceSpecs
    Collect DotnetCliToolReferences
    ============================================================
  -->
  <Target Name="_GenerateDotnetCliToolReferenceSpecs" DependsOnTargets="_GetRestoreSettings" Returns="@(_RestoreGraphEntry)">
    <PropertyGroup>
      <DotnetCliToolTargetFramework Condition=" '$(DotnetCliToolTargetFramework)' == '' ">netcoreapp1.0</DotnetCliToolTargetFramework>
    </PropertyGroup>
    <!-- Write out tool references -->
    <GetRestoreDotnetCliToolsTask Condition=" '$(RestoreDotnetCliToolReferences)' == '' OR '$(RestoreDotnetCliToolReferences)' == 'true' " ProjectPath="$(MSBuildProjectFullPath)" ToolFramework="$(DotnetCliToolTargetFramework)" RestorePackagesPath="$(_OutputPackagesPath)" RestoreFallbackFolders="$(_OutputFallbackFolders)" RestoreSources="$(_OutputSources)" RestoreConfigFilePaths="$(_OutputConfigFilePaths)" DotnetCliToolReferences="@(DotnetCliToolReference)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreDotnetCliToolsTask>
  </Target>
  <!--
    ============================================================
    _GetProjectJsonPath
    Discover the project.json path if one exists for the project.
    ============================================================
  -->
  <Target Name="_GetProjectJsonPath" Returns="$(_CurrentProjectJsonPath)">
    <!-- Get project.json path -->
    <!-- Skip this if the project style is already set. -->
    <GetRestoreProjectJsonPathTask ProjectPath="$(MSBuildProjectFullPath)" Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == '' ">
      <Output TaskParameter="ProjectJsonPath" PropertyName="_CurrentProjectJsonPath" />
    </GetRestoreProjectJsonPathTask>
  </Target>
  <!--
    ============================================================
    _GetRestoreProjectStyle
    Determine the project restore type.
    ============================================================
  -->
  <Target Name="_GetRestoreProjectStyle" DependsOnTargets="_GetProjectJsonPath;CollectPackageReferences" Returns="$(RestoreProjectStyle);$(PackageReferenceCompatibleProjectStyle)">
    <!--
      Older versions of MSBuild do not support the Count() item function which is an optimization.  Expanding the
      entire item list into a semicolon delimited string is slower but older versions of MSBuild don't support it so
      use the older logic if necessary
    -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &lt; '15.0'">
      <_HasPackageReferenceItems Condition="'@(PackageReference)' != ''">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &gt;= '15.0'">
      <_HasPackageReferenceItems Condition="@(PackageReference-&gt;Count()) &gt; 0">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <GetRestoreProjectStyleTask HasPackageReferenceItems="$(_HasPackageReferenceItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" MSBuildProjectName="$(MSBuildProjectName)" ProjectJsonPath="$(_CurrentProjectJsonPath)" RestoreProjectStyle="$(RestoreProjectStyle)">
      <Output TaskParameter="ProjectStyle" PropertyName="RestoreProjectStyle" />
      <Output TaskParameter="IsPackageReferenceCompatibleProjectStyle" PropertyName="PackageReferenceCompatibleProjectStyle" />
    </GetRestoreProjectStyleTask>
    <PropertyGroup>
      <_HasPackageReferenceItems />
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    EnableIntermediateOutputPathMismatchWarning
    If using PackageReference, enable an MSBuild warning if BaseIntermediateOutputPath is set to something different
    than MSBuildProjectExtensionsPath, because it may be unexpected that the assets and related files wouldn't be written
    to the BaseIntermediateOutputPath.
    ============================================================
  -->
  <Target Name="EnableIntermediateOutputPathMismatchWarning" DependsOnTargets="_GetRestoreProjectStyle" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(RestoreProjectStyle)' == 'PackageReference'">
    <PropertyGroup Condition="'$(EnableBaseIntermediateOutputPathMismatchWarning)' == ''">
      <EnableBaseIntermediateOutputPathMismatchWarning>true</EnableBaseIntermediateOutputPathMismatchWarning>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworksOutput
    Read target frameworks from the project.
    Non-NETCore project frameworks will be returned.
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksOutput" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride" Returns="@(_RestoreTargetFrameworksOutputFiltered)">
    <PropertyGroup>
      <_RestoreProjectFramework />
      <_TargetFrameworkToBeUsed Condition=" '$(_TargetFrameworkOverride)' == '' ">$(TargetFrameworks)</_TargetFrameworkToBeUsed>
    </PropertyGroup>
    <!-- For project.json projects target frameworks will be read from project.json. -->
    <GetProjectTargetFrameworksTask Condition=" '$(RestoreProjectStyle)' != 'ProjectJson'" ProjectPath="$(MSBuildProjectFullPath)" TargetFrameworks="$(_TargetFrameworkToBeUsed)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)">
      <Output TaskParameter="ProjectTargetFrameworks" PropertyName="_RestoreProjectFramework" />
    </GetProjectTargetFrameworksTask>
    <ItemGroup Condition=" '$(_RestoreProjectFramework)' != '' ">
      <_RestoreTargetFrameworksOutputFiltered Include="$(_RestoreProjectFramework.Split(';'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworksAsItems
    Read $(TargetFrameworks) from the project as items.
    Projects that do not have $(TargetFrameworks) will noop.
    If $(TargetFramework) is specified globally, it'll be preferred over $(TargetFrameworks)
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksAsItems" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride" Returns="@(_RestoreTargetFrameworkItems)">
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' == '' ">
      <_RestoreTargetFrameworkItems Include="$(TargetFrameworks.Split(';'))" />
    </ItemGroup>
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' != '' ">
      <_RestoreTargetFrameworkItems Include="$(_TargetFrameworkOverride)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettings
    ============================================================
  -->
  <Target Name="_GetRestoreSettings" Condition=" '$(RestoreProjectStyle)' == 'PackageReference' OR '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == 'DotnetToolReference' OR '$(RestoreProjectStyle)' == 'PackagesConfig'" DependsOnTargets="_GetRestoreSettingsOverrides;_GetRestoreSettingsCurrentProject;_GetRestoreSettingsAllFrameworks" Returns="$(_OutputSources);$(_OutputPackagesPath);$(_OutputRepositoryPath);$(_OutputFallbackFolders);$(_OutputConfigFilePaths)">
    <PropertyGroup Condition=" '$(RestoreSolutionDirectory)' == '' AND '$(RestoreProjectStyle)' == 'PackagesConfig' AND '$(SolutionDir)' != '*Undefined*'">
      <RestoreSolutionDirectory>$(SolutionDir)</RestoreSolutionDirectory>
    </PropertyGroup>
    <!-- For transitive project styles, we rely on evaluating all the settings and including them in the dg spec to faciliate no-op restore-->
    <GetRestoreSettingsTask ProjectUniqueName="$(MSBuildProjectFullPath)" RestoreSources="$(RestoreSources)" RestorePackagesPath="$(RestorePackagesPath)" RestoreRepositoryPath="$(RestoreRepositoryPath)" RestoreFallbackFolders="$(RestoreFallbackFolders)" RestoreConfigFile="$(RestoreConfigFile)" RestoreRootConfigDirectory="$(RestoreRootConfigDirectory)" RestoreSolutionDirectory="$(RestoreSolutionDirectory)" RestoreSettingsPerFramework="@(_RestoreSettingsPerFramework)" RestorePackagesPathOverride="$(_RestorePackagesPathOverride)" RestoreRepositoryPathOverride="$(_RestoreRepositoryPathOverride)" RestoreSourcesOverride="$(_RestoreSourcesOverride)" RestoreFallbackFoldersOverride="$(_RestoreFallbackFoldersOverride)" RestoreProjectStyle="$(RestoreProjectStyle)" MSBuildStartupDirectory="$(MSBuildStartupDirectory)">
      <Output TaskParameter="OutputSources" PropertyName="_OutputSources" />
      <Output TaskParameter="OutputPackagesPath" PropertyName="_OutputPackagesPath" />
      <Output TaskParameter="OutputRepositoryPath" PropertyName="_OutputRepositoryPath" />
      <Output TaskParameter="OutputFallbackFolders" PropertyName="_OutputFallbackFolders" />
      <Output TaskParameter="OutputConfigFilePaths" PropertyName="_OutputConfigFilePaths" />
    </GetRestoreSettingsTask>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsCurrentProject
    Generate items for a single framework.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsCurrentProject" Condition=" '$(TargetFrameworks)' == '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' " DependsOnTargets="_GetRestoreSettingsPerFramework" Returns="@(_RestoreSettingsPerFramework)" />
  <!--
    ============================================================
    _GetRestoreSettingsAllFrameworks
    Generate items for all frameworks.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsAllFrameworks" Condition=" '$(TargetFrameworks)' != '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems;_GetRestoreProjectStyle" Returns="@(_RestoreSettingsPerFramework)">
    <!-- Read additional sources and fallback folders for each framework  -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GetRestoreSettingsPerFramework" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreSettingsPerFramework" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsPerFramework
    Generate items with framework specific settings.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsPerFramework" Returns="@(_RestoreSettingsPerFramework)">
    <ItemGroup>
      <_RestoreSettingsPerFramework Include="$([System.Guid]::NewGuid())">
        <RestoreAdditionalProjectSources>$(RestoreAdditionalProjectSources)</RestoreAdditionalProjectSources>
        <RestoreAdditionalProjectFallbackFolders>$(RestoreAdditionalProjectFallbackFolders)</RestoreAdditionalProjectFallbackFolders>
        <RestoreAdditionalProjectFallbackFoldersExcludes>$(RestoreAdditionalProjectFallbackFoldersExcludes)</RestoreAdditionalProjectFallbackFoldersExcludes>
      </_RestoreSettingsPerFramework>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectSpec
    Generate a restore project spec for the current project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectSpec" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworksOutput;_GetRestoreSettings" Returns="@(_RestoreGraphEntry)">
    <!-- Determine the restore output path -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <RestoreOutputPath Condition=" '$(RestoreOutputPath)' == '' ">$(MSBuildProjectExtensionsPath)</RestoreOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(RestoreOutputPath)" Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson'">
      <Output TaskParameter="AbsolutePaths" PropertyName="RestoreOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <!--
      Determine project name for the assets file.
      Highest priority: PackageId
      If PackageId does not exist use: AssemblyName
      If AssemblyName does not exist fallback to the project file name without the extension: $(MSBuildProjectName)

      For non-PackageReference projects use only: $(MSBuildProjectName)
    -->
    <PropertyGroup>
      <_RestoreProjectName>$(MSBuildProjectName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(AssemblyName)' != '' ">$(AssemblyName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(PackageId)' != '' ">$(PackageId)</_RestoreProjectName>
    </PropertyGroup>
    <!--
      Determine project version for .NETCore projects
      Default to 1.0.0
      Use Version if it exists
      Override with PackageVersion if it exists (same as pack)
    -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreProjectVersion>1.0.0</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(Version)' != '' ">$(Version)</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(PackageVersion)' != '' ">$(PackageVersion)</_RestoreProjectVersion>
    </PropertyGroup>
    <!-- Determine if this will use cross targeting -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(TargetFrameworks)' != '' ">
      <_RestoreCrossTargeting>true</_RestoreCrossTargeting>
    </PropertyGroup>
    <!-- Determine if ContentFiles should be written by NuGet -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_RestoreSkipContentFileWrite)' == '' ">
      <_RestoreSkipContentFileWrite Condition=" '$(TargetFrameworks)' == '' AND '$(TargetFramework)' == '' ">true</_RestoreSkipContentFileWrite>
    </PropertyGroup>
    <!-- Write properties for the top level entry point -->
    <ItemGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <Version>$(_RestoreProjectVersion)</Version>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <RuntimeIdentifiers>$(RuntimeIdentifiers);$(RuntimeIdentifier)</RuntimeIdentifiers>
        <RuntimeSupports>$(RuntimeSupports)</RuntimeSupports>
        <CrossTargeting>$(_RestoreCrossTargeting)</CrossTargeting>
        <RestoreLegacyPackagesDirectory>$(RestoreLegacyPackagesDirectory)</RestoreLegacyPackagesDirectory>
        <ValidateRuntimeAssets>$(ValidateRuntimeIdentifierCompatibility)</ValidateRuntimeAssets>
        <SkipContentFileWrite>$(_RestoreSkipContentFileWrite)</SkipContentFileWrite>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <TreatWarningsAsErrors>$(TreatWarningsAsErrors)</TreatWarningsAsErrors>
        <WarningsAsErrors>$(WarningsAsErrors)</WarningsAsErrors>
        <WarningsNotAsErrors>$(WarningsNotAsErrors)</WarningsNotAsErrors>
        <NoWarn>$(NoWarn)</NoWarn>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <_CentralPackageVersionsEnabled>$(_CentralPackageVersionsEnabled)</_CentralPackageVersionsEnabled>
        <CentralPackageFloatingVersionsEnabled>$(CentralPackageFloatingVersionsEnabled)</CentralPackageFloatingVersionsEnabled>
        <CentralPackageVersionOverrideEnabled>$(CentralPackageVersionOverrideEnabled)</CentralPackageVersionOverrideEnabled>
        <CentralPackageTransitivePinningEnabled>$(CentralPackageTransitivePinningEnabled)</CentralPackageTransitivePinningEnabled>
        <NuGetAudit>$(NuGetAudit)</NuGetAudit>
        <NuGetAuditLevel>$(NuGetAuditLevel)</NuGetAuditLevel>
        <NuGetAuditMode>$(NuGetAuditMode)</NuGetAuditMode>
        <SdkAnalysisLevel>$(SdkAnalysisLevel)</SdkAnalysisLevel>
        <UsingMicrosoftNETSdk>$(UsingMicrosoftNETSdk)</UsingMicrosoftNETSdk>
        <RestoreUseLegacyDependencyResolver>$(RestoreUseLegacyDependencyResolver)</RestoreUseLegacyDependencyResolver>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Use project.json -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectJsonPath>$(_CurrentProjectJsonPath)</ProjectJsonPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Use packages.config -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'PackagesConfig' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config')">$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config</PackagesConfigPath>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.config')">$(MSBuildProjectDirectory)\packages.config</PackagesConfigPath>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <Sources>$(_OutputSources)</Sources>
        <SolutionDir>$(SolutionDir)</SolutionDir>
        <RepositoryPath>$(_OutputRepositoryPath)</RepositoryPath>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
        <NuGetAudit>$(NuGetAudit)</NuGetAudit>
        <NuGetAuditLevel>$(NuGetAuditLevel)</NuGetAuditLevel>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Non-NuGet type -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'Unknown' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateProjectRestoreGraph
    Recursively walk project to project references.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraph" DependsOnTargets="&#xD;&#xA;      _GetRestoreProjectStyle;&#xD;&#xA;      _GenerateRestoreProjectSpec;&#xD;&#xA;      _GenerateRestoreDependencies" Returns="@(_RestoreGraphEntry)">
    <!-- Output from dependency targets -->
  </Target>
  <!--
    ============================================================
    _GenerateRestoreDependencies
    Generate items for package and project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreDependencies" DependsOnTargets="_GenerateProjectRestoreGraphAllFrameworks;_GenerateProjectRestoreGraphCurrentProject" Returns="@(_RestoreGraphEntry)" />
  <!--
    ============================================================
    _GenerateProjectRestoreGraphAllFrameworks
    Walk dependencies for all frameworks.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphAllFrameworks" Condition=" '$(TargetFrameworks)' != '' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems" Returns="@(_RestoreGraphEntry)">
    <!-- Get project and package references  -->
    <!-- Evaluate for each framework -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GenerateProjectRestoreGraphPerFramework" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateProjectRestoreGraphCurrentProject
    Walk dependencies with the current framework.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphCurrentProject" Condition=" '$(TargetFrameworks)' == '' " DependsOnTargets="_GenerateProjectRestoreGraphPerFramework" Returns="@(_RestoreGraphEntry)" />
  <!--
    ============================================================
    _GenerateProjectRestoreGraphPerFramework
    Walk dependencies using $(TargetFramework)
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphPerFramework" DependsOnTargets="_GetRestoreProjectStyle;_CollectRestoreInputs" Returns="@(_RestoreGraphEntry)">
    <!-- Write out project references -->
    <GetRestoreProjectReferencesTask ProjectUniqueName="$(MSBuildProjectFullPath)" ProjectReferences="@(ProjectReference)" TargetFrameworks="$(TargetFramework)" ParentProjectPath="$(MSBuildProjectFullPath)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreProjectReferencesTask>
    <!-- Write out package references-->
    <GetRestorePackageReferencesTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" PackageReferences="@(PackageReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePackageReferencesTask>
    <!-- Write out central package versions -->
    <GetCentralPackageVersionsTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_CentralPackageVersionsEnabled)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" CentralPackageVersions="@(PackageVersion)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetCentralPackageVersionsTask>
    <!-- Write out package downloads -->
    <GetRestorePackageDownloadsTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" PackageDownloads="@(PackageDownload)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePackageDownloadsTask>
    <!-- Write out Framework References-->
    <GetRestoreFrameworkReferencesTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" FrameworkReferences="@(FrameworkReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreFrameworkReferencesTask>
    <!-- Write out advisory suppressions-->
    <GetRestoreNuGetAuditSuppressionsTask ProjectUniqueName="$(MSBuildProjectFullPath)" NuGetAuditSuppressions="@(NuGetAuditSuppress)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreNuGetAuditSuppressionsTask>
    <!-- Write out pruned package references-->
    <GetRestorePrunePackageReferencesTask ProjectUniqueName="$(MSBuildProjectFullPath)" PrunePackageReferences="@(PrunePackageReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePrunePackageReferencesTask>
    <!-- Write out target framework information -->
    <ItemGroup Condition="  '$(PackageReferenceCompatibleProjectStyle)' == 'true'">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>TargetFrameworkInformation</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <PackageTargetFallback>$(PackageTargetFallback)</PackageTargetFallback>
        <AssetTargetFallback>$(AssetTargetFallback)</AssetTargetFallback>
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion)</TargetFrameworkVersion>
        <TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
        <TargetFrameworkProfile>$(TargetFrameworkProfile)</TargetFrameworkProfile>
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetPlatformVersion>$(TargetPlatformVersion)</TargetPlatformVersion>
        <TargetPlatformMinVersion>$(TargetPlatformMinVersion)</TargetPlatformMinVersion>
        <CLRSupport>$(CLRSupport)</CLRSupport>
        <RuntimeIdentifierGraphPath>$(RuntimeIdentifierGraphPath)</RuntimeIdentifierGraphPath>
        <WindowsTargetPlatformMinVersion>$(WindowsTargetPlatformMinVersion)</WindowsTargetPlatformMinVersion>
        <RestoreEnablePackagePruning>$(RestoreEnablePackagePruning)</RestoreEnablePackagePruning>
        <NuGetAuditMode>$(NuGetAuditMode)</NuGetAuditMode>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsCurrentProject
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsCurrentProject" Condition=" '$(TargetFrameworks)' == '' " DependsOnTargets="_GenerateRestoreProjectPathItemsPerFramework" Returns="@(_RestoreProjectPathItems)" />
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsPerFramework
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsPerFramework" Returns="@(_RestoreProjectPathItems)">
    <!-- Get the absolute paths to all projects -->
    <ConvertToAbsolutePath Paths="@(ProjectReference)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_RestoreGraphAbsoluteProjectPaths" />
    </ConvertToAbsolutePath>
    <ItemGroup>
      <_RestoreProjectPathItems Include="$(_RestoreGraphAbsoluteProjectPaths)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItems
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItems" DependsOnTargets="_GenerateRestoreProjectPathItemsAllFrameworks;_GenerateRestoreProjectPathItemsCurrentProject" Returns="@(_CurrentRestoreProjectPathItems)">
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreProjectPathItems)">
      <Output TaskParameter="Filtered" ItemName="_CurrentRestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsAllFrameworks
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsAllFrameworks" Condition=" '$(TargetFrameworks)' != '' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems" Returns="@(_RestoreProjectPathItems)">
    <!-- Get all project references for the current project  -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GenerateRestoreProjectPathItemsPerFramework" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="$(MSBuildProjectFullPath)" Targets="_GenerateRestoreProjectPathItemsPerFramework" ContinueOnError="$(RestoreContinueOnError)" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathWalk
    Recursively walk projects
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathWalk" DependsOnTargets="_GenerateRestoreProjectPathItems" Returns="@(_RestoreProjectPathItems)">
    <!-- Walk project references  -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_CurrentRestoreProjectPathItems)" Targets="_GenerateRestoreProjectPathWalk" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(_CurrentRestoreProjectPathItems)" Targets="_GenerateRestoreProjectPathWalk" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>
    <!-- Include the current project in the result -->
    <ItemGroup>
      <_GenerateRestoreProjectPathWalkOutputs Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_GenerateRestoreProjectPathWalkOutputs)">
      <Output TaskParameter="Filtered" ItemName="_RestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
    _GetAllRestoreProjectPathItems
    Get the full list of known projects.
    This includes all child projects from all target frameworks.
    ============================================================
  -->
  <Target Name="_GetAllRestoreProjectPathItems" DependsOnTargets="_FilterRestoreGraphProjectInputItems" Returns="@(_RestoreProjectPathItems)">
    <NuGetMessageTask Name="DeterminingProjectsToRestore" Importance="High" />
    <!-- Walk projects -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(FilteredRestoreGraphProjectInputItems)" Targets="_GenerateRestoreProjectPathWalk" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(FilteredRestoreGraphProjectInputItems)" Targets="_GenerateRestoreProjectPathWalk" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_RestoreProjectPathItemsOutputs)">
      <Output TaskParameter="Filtered" ItemName="_RestoreProjectPathItemsWithoutDupes" />
    </RemoveDuplicates>
    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_RestoreProjectPathItemsWithoutDupes)" Targets="_IsProjectRestoreSupported" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(_RestoreProjectPathItemsWithoutDupes)" Targets="_IsProjectRestoreSupported" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsOverrides
    Get global property overrides that should be resolved
    against the current working directory instead of the project.
    This is done by calling into NuGet.targets in a new scope,
    project properties will not be returned by the calls below.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsOverrides" Returns="$(_RestorePackagesPathOverride);$(_RestoreRepositoryPathOverride);$(_RestoreSourcesOverride);$(_RestoreFallbackFoldersOverride)">
    <!-- RestorePackagesPathOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestorePackagesPath)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestorePackagesPathOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestorePackagesPathOverride" />
    </MSBuild>
    <!-- RestoreRepositoryPathOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreRepositoryPathOverride)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreRepositoryPathOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreRepositoryPathOverride" />
    </MSBuild>
    <!-- RestoreSourcesOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreSources)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreSourcesOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreSourcesOverride" />
    </MSBuild>
    <!-- RestoreFallbackFoldersOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreFallbackFolders)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreFallbackFoldersOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreFallbackFoldersOverride" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestorePackagesPathOverride
    ============================================================
  -->
  <Target Name="_GetRestorePackagesPathOverride" Returns="$(_RestorePackagesPathOverride)">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestorePackagesPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreRepositoryPathOverride
    ============================================================
  -->
  <Target Name="_GetRestoreRepositoryPathOverride" Returns="$(_RestoreRepositoryPathOverride)">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestoreRepositoryPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreSourcesOverride
    ============================================================
  -->
  <Target Name="_GetRestoreSourcesOverride" Returns="$(_RestoreSourcesOverride)">
    <PropertyGroup>
      <_RestoreSourcesOverride>$(RestoreSources)</_RestoreSourcesOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreFallbackFoldersOverride
    ============================================================
  -->
  <Target Name="_GetRestoreFallbackFoldersOverride" Returns="$(_RestoreFallbackFoldersOverride)">
    <PropertyGroup>
      <_RestoreFallbackFoldersOverride>$(RestoreFallbackFolders)</_RestoreFallbackFoldersOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworkOverride
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworkOverride" Condition=" '$(_DisableNuGetRestoreTargetFrameworksOverride)' != 'true' " Returns="$(_TargetFrameworkOverride)">
    <GetGlobalPropertyValueTask PropertyName="TargetFramework" Condition=" '$(TargetFrameworks)' != '' ">
      <Output TaskParameter="GlobalPropertyValue" PropertyName="_TargetFrameworkOverride" />
    </GetGlobalPropertyValueTask>
    <!-- Only set the override if TargetFrameworks has not been overriden as well. In that case, prefer it. -->
  </Target>
  <!--
    ============================================================
    _GetTargetFrameworkOverrides
    ============================================================
  -->
  <Target Name="_GetTargetFrameworkOverrides" Returns="$(_TargetFrameworkOverride)">
    <PropertyGroup>
      <_TargetFrameworkOverride Condition=" '$(TargetFrameworks)' == '' ">$(TargetFramework)</_TargetFrameworkOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _IsProjectRestoreSupported
    Verify restore targets exist in the project.
    ============================================================
  -->
  <Target Name="_IsProjectRestoreSupported" Returns="@(_ValidProjectsForRestore)">
    <ItemGroup>
      <_ValidProjectsForRestore Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Import NuGet.RestoreEx.targets if the MSBuild property 'RestoreEnableStaticGraph'
    is 'true'.  This file overrides the Restore target to use MSBuild Static Graph
    to load and evaluate projects which is much faster.

    This feature is not supported for NuGet.exe scenarios and NuGet.RestoreEx.targets
    won't exist in that case.
    ============================================================
  -->
  <!--<Import Project="NuGet.RestoreEx.targets" Condition="'$(RestoreUseStaticGraphEvaluation)' == 'true' And Exists('NuGet.RestoreEx.targets')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonTargets)" Condition="'$(CustomAfterMicrosoftCommonTargets)' != '' and Exists('$(CustomAfterMicrosoftCommonTargets)')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.DesktopBridge.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.DesktopBridge.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <DesktopBridgeCommonTargets Condition="'$(DesktopBridgeCommonTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\DesktopBridge\Microsoft.DesktopBridge.Common.targets</DesktopBridgeCommonTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(DesktopBridgeCommonTargets)" Condition="Exists('$(DesktopBridgeCommonTargets)') and '$(SkipImportDesktopBridgeCommonTargets)' != 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\DesktopBridge\Microsoft.DesktopBridge.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.DesktopBridge.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DesktopBridgeSelfContained)' == 'true'">
    <SelfContained>true</SelfContained>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DesktopBridgeSelfContained)' == 'true'">
    <RuntimeIdentifier Condition="'$(Platform)' == 'x86'">win-x86</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(Platform)' == 'Win32'">win-x86</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(Platform)' == 'AnyCPU'">win-x86</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(Platform)' == 'Any CPU'">win-x86</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(Platform)' == 'x64'">win-x64</RuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DesktopBridgeSelfContained)' == 'true' AND '$(DesktopBridgeIdentifier)' != ''">
    <RuntimeIdentifier>$(DesktopBridgeIdentifier)</RuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup>
    <DesktopBridgeOutputGroupsDependsOn>
      $(DesktopBridgeOutputGroupsDependsOn);
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </DesktopBridgeOutputGroupsDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <DesktopBridgeCopyLocalOutputGroupDependsOn>
      $(DesktopBridgeOutputGroupsDependsOn);
      $(DesktopBridgeCopyLocalOutputGroupDependsOn);
    </DesktopBridgeCopyLocalOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesktopBridgeCopyLocalOutputGroup" DependsOnTargets="$(DesktopBridgeCopyLocalOutputGroupDependsOn)" Returns="@(DesktopBridgeCopyLocalOutputGroupOutput)">
    <ItemGroup>
      <DesktopBridgeCopyLocalOutputGroupOutput Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Extension)' != '.xml'">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </DesktopBridgeCopyLocalOutputGroupOutput>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <DesktopBridgeComFilesOutputGroupDependsOn>
      $(DesktopBridgeOutputGroupsDependsOn)
      $(DesktopBridgeComFilesOutputGroupDependsOn);
    </DesktopBridgeComFilesOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesktopBridgeComFilesOutputGroup" DependsOnTargets="$(DesktopBridgeComFilesOutputGroupDependsOn)" Returns="@(DesktopBridgeComFilesOutputGroupOutputs)">
    <ItemGroup>
      <DesktopBridgeComFilesOutputGroupOutputs Include="@(ReferenceComWrappersToCopyLocal)">
        <TargetPath>%(ReferenceComWrappersToCopyLocal.Filename)%(ReferenceComWrappersToCopyLocal.Extension)</TargetPath>
      </DesktopBridgeComFilesOutputGroupOutputs>
      <DesktopBridgeComFilesOutputGroupOutputs Include="@(ResolvedIsolatedComModules)">
        <TargetPath>%(ResolvedIsolatedComModules.Filename)%(ResolvedIsolatedComModules.Extension)</TargetPath>
      </DesktopBridgeComFilesOutputGroupOutputs>
      <DesktopBridgeComFilesOutputGroupOutputs Include="@(NativeReferenceFile)">
        <TargetPath>%(NativeReferenceFile.Filename)%(NativeReferenceFile.Extension)</TargetPath>
      </DesktopBridgeComFilesOutputGroupOutputs>
    </ItemGroup>
  </Target>
  <PropertyGroup Condition="'$(_WapBuildingInsideVisualStudio)' == 'true'">
    <CoreCompileDependsOn>
      $(CoreCompileDependsOn);
      _WapComputeNonExistentFileProperty
    </CoreCompileDependsOn>
  </PropertyGroup>
  <!-- When building inside VisualStudio the CoreCompile task always gets run, this target is to replicate that behavior since we set 'BuildingInsideVisualStudio' to false -->
  <Target Name="_WapComputeNonExistentFileProperty" Condition="('$(BuildingOutOfProcess)' != 'true') and (('$(BuildingProject)' == 'false') or ('$(UseHostCompilerIfAvailable)' == 'true'))">
    <PropertyGroup>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <DesktopBridgePublishItemsOutputGroupDependsOn>
      $(DesktopBridgeOutputGroupsDependsOn);
      $(DesktopBridgePublishItemsOutputGroupDependsOn);
      PublishItemsOutputGroup
    </DesktopBridgePublishItemsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesktopBridgePublishItemsOutputGroup" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" DependsOnTargets="$(DesktopBridgePublishItemsOutputGroupDependsOn)" Returns="@(DesktopBridgePublishItemsOutputGroupOutputs)">
    <ItemGroup>
      <DesktopBridgePublishItemsOutputGroupOutputs Include="@(PublishItemsOutputGroupOutputs->'%(OutputPath)')" TargetPath="%(PublishItemsOutputGroupOutputs.RelativePath)" OutputGroup="DesktopBridgePublishItemsOutputGroup" />
    </ItemGroup>
  </Target>
  <!-- If this project or any project that this references is a UAP project -->
  <Target Name="_CheckForGenerateAppxPackageOnBuild" DependsOnTargets="AssignProjectConfiguration" Returns="$(ReferencesUWPProject)">
    <PropertyGroup>
      <ReferencesUWPProject Condition="'$(TargetPlatformIdentifier)' == 'UAP' AND ('$(OutputType)' == 'AppContainerExe' OR '$(OutputType)' == 'Exe')">true</ReferencesUWPProject>
    </PropertyGroup>
    <MSBuild Condition="'$(ReferencesUWPProject)' != 'true'" Projects="@(ProjectReferenceWithConfiguration)" Properties="%(ProjectReferenceWithConfiguration.SetConfiguration);%(ProjectReferenceWithConfiguration.SetPlatform)" Targets="_CheckForGenerateAppxPackageOnBuild" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" PropertyName="ReferencesUWPProject" />
    </MSBuild>
  </Target>
  <Target Name="GetDeployableContentReferenceOutputs" DependsOnTargets="AssignProjectConfiguration" Returns="@(DeployableContentReference)">
    <ItemGroup>
      <DeployableContentReference Include="@(ProjectReferenceWithConfiguration)" Condition="'%(ProjectReferenceWithConfiguration.DeploymentContent)' == 'true'">
        <SourceDeployableProjectReference>$(ProjectName)</SourceDeployableProjectReference>
      </DeployableContentReference>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <DesktopBridgeFrameworkSDKRegistrationOutputGroupDependsOn>
      $(DesktopBridgeOutputGroupsDependsOn);
      $(DesktopBridgeFrameworkSDKRegistrationOutputGroupDependsOn)
    </DesktopBridgeFrameworkSDKRegistrationOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesktopBridgeFrameworkSDKRegistrationOutputGroup" DependsOnTargets="$(DesktopBridgeFrameworkSDKRegistrationOutputGroupDependsOn)" Returns="@(DesktopBridgeFrameworkSDKRegistrationOutputGroupOutputs)">
    <ItemGroup>
      <DesktopBridgeFrameworkSDKRegistrationOutputGroupOutputs Include="@(FrameworkSdkReference)" />
    </ItemGroup>
    <MSBuild Projects="@(ProjectReferenceWithConfiguration)" Targets="_GenerateAdditionalFrameworkSDKReference;_GetRecursiveResolvedSDKReferences;DesktopBridgeFrameworkSDKRegistrationOutputGroup" BuildInParallel="$(BuildInParallel)" Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)" Condition="'@(ProjectReferenceWithConfiguration)' != ''&#xD;&#xA;                 and '%(ProjectReferenceWithConfiguration.BuildReference)' == 'true'&#xD;&#xA;                 and '%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == 'true'" SkipNonexistentTargets="true" ContinueOnError="true">
      <Output TaskParameter="TargetOutputs" ItemName="DesktopBridgeFrameworkSDKRegistrationOutputGroupOutputs" />
    </MSBuild>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.DesktopBridge.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.Docker.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Docker.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\Sdks\Microsoft.Docker.Sdk\build\Microsoft.Docker.targets" Condition="Exists('$(MSBuildExtensionsPath)\Sdks\Microsoft.Docker.Sdk\build\Microsoft.Docker.targets')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Sdks\Microsoft.Docker.Sdk\build\Microsoft.Docker.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Docker.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
  ***********************************************************************************************

  Docker Common Properties

  ***********************************************************************************************
  -->
  <PropertyGroup>
    <DockerBuildTasksAssembly>$(MSBuildThisFileDirectory)..\tools\Microsoft.Docker.BuildTasks.dll</DockerBuildTasksAssembly>
    <DockerIntermediateOutputPath>obj\Docker</DockerIntermediateOutputPath>
    <DockerPublishDirectory>$(DockerIntermediateOutputPath)\publish</DockerPublishDirectory>
  </PropertyGroup>
  <!--
  ***********************************************************************************************

  Docker Common Targets

  ***********************************************************************************************
  -->
  <UsingTask TaskName="ComposeBuild" AssemblyFile="$(DockerBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveAppType" AssemblyFile="$(DockerBuildTasksAssembly)" />
  <UsingTask TaskName="UpdateComposeVsGeneratedFiles" AssemblyFile="$(DockerBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveTargetFramework" AssemblyFile="$(DockerBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveTargetFrameworkVersion" AssemblyFile="$(DockerBuildTasksAssembly)" />
  <!--
  ***********************************************************************************************

  TARGET : DockerResolveAppType

  ***********************************************************************************************
  -->
  <Target Name="DockerResolveAppType">
    <ResolveAppType DockerComposeProjectPath="$(DockerComposeProjectPath)" PublishAot="$(PublishAot)" ServiceNames="$(DockerComposeServiceNames)" ProjectCapability="@(ProjectCapability)" OutputType="$(OutputType)" ProjectTypeGuids="$(ProjectTypeGuids)" FunctionsExecutionModel="$(FunctionsExecutionModel)">
      <Output TaskParameter="AppType" PropertyName="DockerAppType" />
    </ResolveAppType>
  </Target>
  <!--
  ***********************************************************************************************

  TARGET : DockerUpdateComposeVsGeneratedFiles

  ***********************************************************************************************
  -->
  <Target Name="DockerUpdateComposeVsGeneratedFiles">
    <PropertyGroup>
      <_ContainerStaticWebAssetsManifestPath>$(_GeneratedStaticWebAssetsDevelopmentManifest)</_ContainerStaticWebAssetsManifestPath>
      <_ContainerStaticWebAssetsManifestPath Condition=" '$(_ContainerStaticWebAssetsManifestPath)' == '' ">$(IntermediateOutputPath)$(TargetName).StaticWebAssets.xml</_ContainerStaticWebAssetsManifestPath>
    </PropertyGroup>
    <UpdateComposeVsGeneratedFiles ServiceNames="$(DockerComposeServiceNames)" DockerComposeProjectPath="$(DockerComposeProjectPath)" NuGetPackageRoot="$(NuGetPackageRoot)" NuGetPackageFolders="$(NuGetPackageFolders)" BlazorStaticWebAssetsManifest="$(_ContainerStaticWebAssetsManifestPath)" DockerDevelopmentMode="$(DockerDevelopmentMode)" DockerTargetOS="$(DockerTargetOS)" />
  </Target>
  <!--
  ***********************************************************************************************

  TARGET : DockerResolveTargetFramework

  ***********************************************************************************************
  -->
  <Target Name="DockerResolveTargetFramework">
    <ResolveTargetFramework DockerComposeProjectPath="$(DockerComposeProjectPath)" ServiceNames="$(DockerComposeServiceNames)" ProjectCapability="@(ProjectCapability)">
      <Output TaskParameter="TargetFramework" PropertyName="DockerTargetFramework" />
    </ResolveTargetFramework>
  </Target>
  <!--
  ***********************************************************************************************

  TARGET : DockerResolveTargetFrameworkVersion

  ***********************************************************************************************
  -->
  <Target Name="DockerResolveTargetFrameworkVersion">
    <ResolveTargetFrameworkVersion DockerComposeProjectPath="$(DockerComposeProjectPath)" ServiceNames="$(DockerComposeServiceNames)" TargetFrameworkVersion="$(TargetFrameworkVersion)" />
  </Target>
  <!--
  ***********************************************************************************************

  TARGET : DockerComposeBuild

  ***********************************************************************************************
  -->
  <!-- DockerComposeBuild is invoked during Web publish to Docker service as a normal web project, which happens when Dockerfile is found under the same folder as project file. -->
  <Target Name="DockerComposeBuild">
    <PropertyGroup>
      <_DockerDevelopmentMode Condition=" '$(DockerDevelopmentMode)' != '' ">$(DockerDevelopmentMode)</_DockerDevelopmentMode>
      <_DockerDevelopmentMode Condition=" '$(_DockerDevelopmentMode)' == '' ">Regular</_DockerDevelopmentMode>
      <_DockerBuildingForLaunch Condition=" Exists('$(DockerIntermediateOutputPath)\launch.sem')">True</_DockerBuildingForLaunch>
    </PropertyGroup>
    <!-- Since Publish operation is not on dcproj target, this task executes the DockerGetComposeEnvFile task on the dcproj file. -->
    <MSBuild Projects="$(DockerComposeProjectPath)" Targets="DockerGetComposeEnvFilePath" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' != '' And '$(DockerComposeEnvFilePath)' == '' " Properties="Configuration=$(Configuration)">
      <Output TaskParameter="TargetOutputs" PropertyName="DockerComposeEnvFilePathOutput" />
    </MSBuild>
    <!-- Since Publish operation is not on dcproj target, this task executes the DockerGetComposeBaseFilePath task on the dcproj file. -->
    <MSBuild Projects="$(DockerComposeProjectPath)" Targets="DockerGetComposeBaseFilePath" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' != '' And '$(DockerComposeBaseFilePath)' == '' " Properties="Configuration=$(Configuration)">
      <Output TaskParameter="TargetOutputs" PropertyName="DockerComposeBaseFilePathOutput" />
    </MSBuild>
    <!-- Since Publish operation is not on dcproj target, this task executes the DockerGetAdditionalComposeFilePaths task on the dcproj file. -->
    <MSBuild Projects="$(DockerComposeProjectPath)" Targets="DockerGetAdditionalComposeFilePaths" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' != '' And '$(AdditionalComposeFilePaths)' == '' " Properties="Configuration=$(Configuration)">
      <Output TaskParameter="TargetOutputs" PropertyName="DockerComposeAdditionalFilePathsOutput" />
    </MSBuild>
    <!-- Since Publish operation is not on dcproj target, this task executes the DockerGetComposeBuildArguments task on the dcproj file. -->
    <MSBuild Projects="$(DockerComposeProjectPath)" Targets="DockerGetBuildArguments" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' != '' And '$(DockerComposeBuildArguments)' == '' " Properties="Configuration=$(Configuration)">
      <Output TaskParameter="TargetOutputs" PropertyName="DockerComposeBuildArgumentsOutput" />
    </MSBuild>
    <!-- Since Publish operation is not on dcproj target, this task executes the DockerGetComposeProjectName task on the dcproj file. -->
    <MSBuild Projects="$(DockerComposeProjectPath)" Targets="DockerGetDockerComposeProjectName" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' != '' And '$(DockerComposeProjectName)' == '' " Properties="Configuration=$(Configuration)">
      <Output TaskParameter="TargetOutputs" PropertyName="DockerComposeProjectNameOutput" />
    </MSBuild>
    <ComposeBuild DockerComposeProjectPath="$(DockerComposeProjectPath)" DockerDevelopmentMode="$(_DockerDevelopmentMode)" BuildingForLaunch="$(_DockerBuildingForLaunch)" ProjectPath="$(MSBuildProjectFullPath)" NoCache="$(DockerComposeBuildNoCache)" Configuration="$(Configuration)" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' != '' " AdditionalComposeFilePaths="$([MSBuild]::ValueOrDefault('$(DockerComposeAdditionalFilePathsOutput)', '$(AdditionalComposeFilePaths)'))" DockerComposeEnvFilePath="$([MSBuild]::ValueOrDefault('$(DockerComposeEnvFilePathOutput)', '$(DockerComposeEnvFilePath)'))" DockerComposeBaseFilePath="$([MSBuild]::ValueOrDefault('$(DockerComposeBaseFilePathOutput)', '$(DockerComposeBaseFilePath)'))" DockerComposeBuildArguments="$([MSBuild]::ValueOrDefault('$(DockerComposeBuildArgumentsOutput)', '$(DockerComposeBuildArguments)'))" DockerComposeProjectName="$([MSBuild]::ValueOrDefault('$(DockerComposeProjectNameOutput)', '$(DockerComposeProjectName)'))" />
    <CallTarget Targets="ContainerBuild" Condition=" '$(_DockerDevelopmentMode)' == 'Regular' And '$(DockerComposeProjectPath)' == '' " />
  </Target>
  <!--
  ***********************************************************************************************

  TARGET : DockerPackageService

  ***********************************************************************************************
  -->
  <Target Name="DockerPackageService" DependsOnTargets="DockerResolveAppType;DockerResolveTargetFramework">
    <!-- ASP.NET Core -->
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Build" Properties="Configuration=$(Configuration);&#xD;&#xA;                         Platform=$(Platform);&#xD;&#xA;                         WebPublishMethod=FileSystem;&#xD;&#xA;                         DeployOnBuild=True;&#xD;&#xA;                         PublishUrl=$(DockerPublishDirectory);&#xD;&#xA;                         PublishAot=$(PublishAot)" Condition=" '$(DockerAppType)' == 'AspNetCore' " />
    <!-- ASP.NET -->
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Build" Properties="Configuration=$(Configuration);&#xD;&#xA;                         Platform=$(Platform);&#xD;&#xA;                         BuildingInsideVisualStudio=False;&#xD;&#xA;                         WebPublishMethod=FileSystem;&#xD;&#xA;                         DeployTarget=WebPublish;&#xD;&#xA;                         DeployOnBuild=True;&#xD;&#xA;                         PublishUrl=$(DockerPublishDirectory)" Condition=" '$(DockerAppType)' == 'AspNet' " />
    <!-- Console on .NET Core -->
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Publish" Properties="Configuration=$(Configuration);&#xD;&#xA;                         Platform=$(Platform);&#xD;&#xA;                         PublishDir=$(DockerPublishDirectory)" Condition=" '$(DockerAppType)' == 'ConsoleCore' And '$(DockerTargetFramework)' == 'DotNetCore' " />
    <!-- Console on .NET Framework -->
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Build" Properties="Configuration=$(Configuration);&#xD;&#xA;                         Platform=$(Platform)" Condition=" '$(DockerAppType)' == 'Console' And '$(DockerTargetFramework)' == 'DotNetFramework' " />
    <ItemGroup>
      <DockerOutputFiles Include="$(OutputPath)\**\*.*" />
    </ItemGroup>
    <Copy SourceFiles="@(DockerOutputFiles)" DestinationFiles="@(DockerOutputFiles->'$(DockerPublishDirectory)\%(RecursiveDir)%(Filename)%(Extension)')" Condition=" '$(DockerAppType)' == 'Console' And '$(DockerTargetFramework)' == 'DotNetFramework' " />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.Docker.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <MicrosoftNETBuildExtensionsTargets Condition="'$(MicrosoftNETBuildExtensionsTargets)' == ''">$(MSBuildExtensionsPath)\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets</MicrosoftNETBuildExtensionsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MicrosoftNETBuildExtensionsTargets)" Condition="Exists('$(MicrosoftNETBuildExtensionsTargets)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_TargetFrameworkVersionWithoutV>$(TargetFrameworkVersion.TrimStart('vV'))</_TargetFrameworkVersionWithoutV>
    <MicrosoftNETBuildExtensionsTasksAssembly Condition="'$(MicrosoftNETBuildExtensionsTasksAssembly)' == '' AND '$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)\tools\net9.0\Microsoft.NET.Build.Extensions.Tasks.dll</MicrosoftNETBuildExtensionsTasksAssembly>
    <MicrosoftNETBuildExtensionsTasksAssembly Condition="'$(MicrosoftNETBuildExtensionsTasksAssembly)' == ''">$(MSBuildThisFileDirectory)\tools\net472\Microsoft.NET.Build.Extensions.Tasks.dll</MicrosoftNETBuildExtensionsTasksAssembly>
    <!-- Include conflict resolution targets for NETFramework and allow other frameworks to opt-in -->
    <ResolveAssemblyConflicts Condition="'$(ResolveAssemblyConflicts)' == '' AND '$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ResolveAssemblyConflicts>
  </PropertyGroup>
  <!--<Import Project="Microsoft.NET.Build.Extensions.NETFramework.targets" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />-->
  <!-- Only import ConflictResolution targets for non-SDK projects, SDK projects have ConflictResolution built in -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Build.Extensions.ConflictResolution.targets" Condition="'$(ResolveAssemblyConflicts)' == 'true' AND '$(UsingMicrosoftNETSdk)' != 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.ConflictResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.ConflictResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DisableHandlePackageFileConflicts)' != 'true'">
    <!-- Non-SDK using project.json or PackageReference, run after references are read from the lock/assets file -->
    <_HandlePackageFileConflictsAfter>ResolveNuGetPackageAssets</_HandlePackageFileConflictsAfter>
    <!-- In case ResolveNuGetPackageAssets is not run (eg: packages.config), ensure we run before targets that consume references -->
    <_HandlePackageFileConflictsBefore>ResolveAssemblyReferences</_HandlePackageFileConflictsBefore>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.DefaultPackageConflictOverrides.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.DefaultPackageConflictOverrides.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultPackageConflictOverrides.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition="'$(DisableDefaultPackageConflictOverrides)' != 'true'">
    <PackageConflictOverrides Include="Microsoft.NETCore.App" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0')">
      <OverriddenPackages>
        Microsoft.CSharp|4.4.0;
        Microsoft.Win32.Primitives|4.3.0;
        Microsoft.Win32.Registry|4.4.0;
        runtime.debian.8-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.23-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.24-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.13.2-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.42.1-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.Apple|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.rhel.7-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.14.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        System.AppContext|4.3.0;
        System.Buffers|4.4.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.DiagnosticSource|4.4.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.AccessControl|4.4.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Metadata|1.5.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Cng|4.4.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.OpenSsl|4.4.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
    <PackageConflictOverrides Include="NETStandard.Library">
      <OverriddenPackages>
        Microsoft.Win32.Primitives|4.3.0;
        System.AppContext|4.3.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.ConflictResolution.targets
============================================================================================================================================
-->
  <UsingTask TaskName="ResolvePackageFileConflicts" AssemblyFile="$(MicrosoftNETBuildExtensionsTasksAssembly)" />
  <Target Name="_HandlePackageFileConflicts" BeforeTargets="$(_HandlePackageFileConflictsBefore)" AfterTargets="$(_HandlePackageFileConflictsAfter)" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Condition="'@(Reference)' != '' Or '@(ReferenceCopyLocalPaths)' != ''">
    <ResolvePackageFileConflicts References="@(Reference)" ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)" PlatformManifests="@(PackageConflictPlatformManifests)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" PackageOverrides="@(PackageConflictOverrides)" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferencesWithoutConflicts" ItemName="_ReferencesWithoutConflicts" />
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReferenceCopyLocalPathsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_ConflictPackageFiles" />
    </ResolvePackageFileConflicts>
    <!-- Replace Reference / ReferenceCopyLocalPaths with the filtered lists.
         We must remove all and include rather than just remove since removal is based
         only on ItemSpec and duplicate ItemSpecs may exist with different metadata
         (eg: HintPath) -->
    <ItemGroup>
      <Reference Remove="@(Reference)" />
      <Reference Include="@(_ReferencesWithoutConflicts)" />
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" />
      <ReferenceCopyLocalPaths Include="@(_ReferenceCopyLocalPathsWithoutConflicts)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.Net.CoreRuntime.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NetfxCoreRuntimeTargets Condition="'$(NetfxCoreRuntimeTargets)'==''">$(MSBuildProgramFiles32)\MSBuild\15.0\.Net\CoreRuntime\Microsoft.Net.CoreRuntime.targets</NetfxCoreRuntimeTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NetfxCoreRuntimeTargets)" Condition="'$(TargetPlatformIdentifier)' == 'UAP' and '$(AppxPackage)' == 'true' and exists('$(NetfxCoreRuntimeTargets)')">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\tools\CoreRuntime\Microsoft.Net.CoreRuntime.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.CoreRuntime.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Provides a default target platform for finding the ilc.exe version when
       the project is configured to AnyCPU -->
  <PropertyGroup>
    <_PlatformTargetForCoreRuntime Condition="'$(PlatformTarget)'!='AnyCPU'">$(PlatformTarget)</_PlatformTargetForCoreRuntime>
    <_PlatformTargetForCoreRuntime Condition="'$(PlatformTarget)'=='AnyCPU'">x86</_PlatformTargetForCoreRuntime>
  </PropertyGroup>
  <!--
       _TargetsCoreRuntime is one of the main flags that decides whether the toolchain needs to kick-in. It implies:
       - This is a UAP app (including those that are pure C++ or JS)
       - .NetNativeToolchain is not going to be used (i.e.: the default debug configuration)

       The second flag will narrow the condition further to UAP apps that has some managed code in their dependency closure.
       (See _AppContainsManagedCodeInItsClosure)

       This flag (_TargetsCoreRuntime) is also being consumed by project system to decide which debugger guid needs to be used,
       hence if you intend to rename this flag make sure that project system is also updated
  -->
  <PropertyGroup Condition="'$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP' and '$(UseDotNetNativeToolchain)' != 'true'">
    <_TargetsCoreRuntime>true</_TargetsCoreRuntime>
  </PropertyGroup>
  <PropertyGroup>
    <BeforeRunGatekeeperTargets>ComputeWireUpCoreRuntimeGates</BeforeRunGatekeeperTargets>
    <NetCoreGeneratePrisForPortableLibraries>true</NetCoreGeneratePrisForPortableLibraries>
  </PropertyGroup>
  <PropertyGroup>
    <_CoreRuntimeMSBuildTaskAssembly>$(MSBuildThisFileDirectory)\Microsoft.Build.Net.CoreRuntimeTask.dll</_CoreRuntimeMSBuildTaskAssembly>
    <_AppxMSBuildToolsPath Condition="'$(_AppxMSBuildToolsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\</_AppxMSBuildToolsPath>
    <_AppxMSBuildTaskAssembly Condition="'$(_AppxMSBuildTaskAssembly)' == ''">$(_AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll</_AppxMSBuildTaskAssembly>
    <CoreRuntimeSDKName>Microsoft.NET.CoreRuntime, Version=$(_CoreRuntimeVersion)</CoreRuntimeSDKName>
    <VCLibs14SDKName>Microsoft.VCLibs, Version=14.0</VCLibs14SDKName>
  </PropertyGroup>
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.WireUpCoreRuntime" />
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.MergePriConfigTask" />
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.MergeResWFilesTask" />
  <UsingTask AssemblyFile="$(_CoreRuntimeMSBuildTaskAssembly)" TaskName="Microsoft.Build.Net.CoreRuntimeTask.ResourceHandlingTask" />
  <UsingTask AssemblyFile="$(_AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetFrameworkSdkPackages" />
  <!-- Adds a <build:Item> tag for OptimizingToolset and TargetRuntime properties
       WireUpCoreRuntime needs these metadata -->
  <ItemGroup Condition="'$(_TargetsCoreRuntime)'=='true'">
    <AppxManifestMetadata Include="OptimizingToolset">
      <Value>None</Value>
    </AppxManifestMetadata>
    <AppxManifestMetadata Include="TargetRuntime" Condition="'$(TargetRuntime)'!=''">
      <Value>$(TargetRuntime)</Value>
    </AppxManifestMetadata>
  </ItemGroup>
  <Target Name="ComputeWireUpCoreRuntimeGates" AfterTargets="AfterGenerateAppxManifest">
    <!--
         _AppContainsManagedCodeInItsClosure is going to be used as a gate to invoking the toolchain. As name suggests,
         it implies that the app or one of the dependencies in its closure has managed code in it.

         ASSUMPTION: In deciding whether an unmanaged app has a managed dependency we'll defer to the computation of
         whether UnionWinMD needs to be included in the PackagingOutputs or not.
         (See the target _AddUnionWinmd in Microsoft.AppxPackage.Targets)
         Briefly, UnionWinMD is going to be included if any of the winmds that the app is referencing is managed.
         So existance of UnionWinMD is being used as an indicator to existance of managed code.
         This way the cost of computing managed dependency is avoided.
    -->
    <ItemGroup>
      <_UnionMetadataWinMD Include="@(PackagingOutputs)" Condition="'%(Identity)' == '$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd'" />
      <_UnionMetadataWinMD Include="@(PackagingOutputs)" Condition="'%(Identity)' == '$(WindowsSDK_UnionMetadataPath)\Windows.winmd'" />
    </ItemGroup>
    <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed' or '@(_UnionMetadataWinMD)' != ''">
      <_AppContainsManagedCodeInItsClosure>true</_AppContainsManagedCodeInItsClosure>
    </PropertyGroup>
    <!--
         WireUpCoreRuntimeGates is the property that ultimately controls triggering the toolchain. It implies:
         - This is a UAP app that has some managed code in its dependency closure
         - .NetNativeToolchain is not going to be used (i.e.: the default debug configuration)
    -->
    <PropertyGroup Condition="'$(_TargetsCoreRuntime)' == 'true' and '$(_AppContainsManagedCodeInItsClosure)' == 'true'">
      <WireUpCoreRuntimeGates>Satisfied</WireUpCoreRuntimeGates>
    </PropertyGroup>
  </Target>
  <Target Name="ComputeWireUpCoreRuntimeParameters" DependsOnTargets="ComputeWireUpCoreRuntimeGates" Condition="'$(WireUpCoreRuntimeGates)'=='Satisfied'">
    <!-- Compute the input/output location of the WireUpCoreRuntime-->
    <PropertyGroup Condition="'$(WireUpCoreRuntimeOutputPath)'==''">
      <WireUpCoreRuntimeOutputPath>$(OutputPath.TrimEnd('\'))\Core\</WireUpCoreRuntimeOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(WireUpCoreRuntimeOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_WireUpCoreRuntimeOutputPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup>
      <_WireUpCoreRuntimeExitCode>0</_WireUpCoreRuntimeExitCode>
      <_WireUpCoreRuntimeTaskExecuted>false</_WireUpCoreRuntimeTaskExecuted>
    </PropertyGroup>
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <ItemGroup>
      <DependencySDKs Include="$(VCLibs14SDKName)" />
      <!--UWPShim is built against dev14 CRT-->
    </ItemGroup>
    <ResolveSDKReference SDKReferences="@(DependencySDKs)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" ProjectName="$(ProjectName)" InstalledSDKs="@(InstalledSDKLocations)">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedDependencySDKs" />
    </ResolveSDKReference>
    <ItemGroup>
      <CoreRuntimeSDK Include="@(ResolvedDependencySDKs)" Condition="'%(ResolvedDependencySDKs.SDKName)' == '$(CoreRuntimeSDKName)'" />
    </ItemGroup>
    <GetFrameworkSdkPackages FrameworkSdkReferences="@(ResolvedDependencySDKs)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkPackageDependencies" />
    </GetFrameworkSdkPackages>
    <ItemGroup>
      <FrameworkPackagesForTargetArchitecture Include="@(FrameworkPackageDependencies)" Condition="'%(Architecture)' == '$(_PlatformTargetForCoreRuntime)'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Name of manifest file is predefined -->
      <_AppxManifestXmlFileName>AppxManifest.xml</_AppxManifestXmlFileName>
      <!-- Expected location of result manifest file where it supposed to be dropped by WireUpCoreRuntime -->
      <_TransformedAppxManifestXmlFile>$(_WireUpCoreRuntimeOutputPath)$(_AppxManifestXmlFileName)</_TransformedAppxManifestXmlFile>
      <CoreRuntimeSDKLocation Condition="'$(PlatformTarget)' == 'x86'">$(CoreRuntimeSDKRootX86)</CoreRuntimeSDKLocation>
      <CoreRuntimeSDKLocation Condition="'$(PlatformTarget)' == 'x64'">$(CoreRuntimeSDKRootX64)</CoreRuntimeSDKLocation>
      <CoreRuntimeSDKLocation Condition="'$(PlatformTarget)' == 'arm'">$(CoreRuntimeSDKRootArm)</CoreRuntimeSDKLocation>
    </PropertyGroup>
  </Target>
  <Target Name="_GetLibrariesToGeneratePrisForUWPApps" BeforeTargets="_GeneratePrisForPortableLibraries" Condition="'$(TargetPlatformIdentifier)'=='UAP'">
    <ItemGroup>
      <_FullAppLibrariesUnfiltered Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <ConvertToAbsolutePath Paths="$(IntermediateOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="ResWOutputFullPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup Condition="'$(SkipMergingFrameworkResources)' == ''">
      <!--
            When building ProjectN apps in retail mode we need to skip including the framework resources in the app because we optimize the exception stack
            and we use the resource keys instead of the exception messages.
          -->
      <SkipMergingFrameworkResources Condition="'$(_ProjectNToolchainEnabled)'=='true' And '$(Optimize)'=='true' And '$(EnableNetNativeDeveloperExperienceMode)'!='true'">true</SkipMergingFrameworkResources>
      <SkipMergingFrameworkResources Condition="'$(SkipMergingFrameworkResources)' == ''">false</SkipMergingFrameworkResources>
    </PropertyGroup>
    <ResourceHandlingTask AssemblyList="@(_FullAppLibrariesUnfiltered)" OutResWPath="$(ResWOutputFullPath)" SkipFrameworkResources="$(SkipMergingFrameworkResources)" StateFile="$(ResWOutputFullPath.TrimEnd('\'))\ResourceHandlingTask.state">
      <!--
              Explicitly using CreatedResWFiles and _LibrariesUnfiltered item group
              names because we are feeding them into the existing item groups that are
              used as part of _GeneratePrisForPortableLibraries.
          -->
      <Output TaskParameter="ReswFileList" ItemName="CreatedResWFiles" />
      <Output TaskParameter="UnprocessedAssemblyList" ItemName="_LibrariesUnfiltered" />
    </ResourceHandlingTask>
    <ItemGroup>
      <FileWrites Include="$(ResWOutputFullPath.TrimEnd('\'))\ResourceHandlingTask.state" />
      <FileWrites Include="@(CreatedResWFiles)" />
    </ItemGroup>
  </Target>
  <!-- We will always inject the CLR from the framework SDK, so remove it if it was contributed through NuGet -->
  <Target Name="FilterCoreRuntimePayloadFromNuGet" AfterTargets="ResolveReferences" DependsOnTargets="ResolveNuGetPackageAssets" Condition="'$(ResolveNuGetPackages)' == 'true' AND '$(_TargetsCoreRuntime)' == 'true'">
    <PropertyGroup>
      <_CoreRuntimePackageId Condition="'%(ReferenceCopyLocalPaths.FileName)%(ReferenceCopyLocalPaths.Extension)' == 'System.Private.CoreLib.dll' OR '%(ReferenceCopyLocalPaths.FileName)%(ReferenceCopyLocalPaths.Extension)' == 'System.Private.CoreLib.ni.dll'">%(ReferenceCopyLocalPaths.NuGetPackageId)</_CoreRuntimePackageId>
    </PropertyGroup>
    <ItemGroup>
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" Condition="'$(UseAppLocalCoreCLR)' != 'true' AND '%(ReferenceCopyLocalPaths.NuGetPackageId)' == '$(_CoreRuntimePackageId)' AND '$(_CoreRuntimePackageId)' != ''" />
    </ItemGroup>
  </Target>
  <!-- Wire up the CoreRuntime -->
  <Target Name="_WireUpCoreRuntime" Inputs="@(AppxPackagePayload);@(FinalAppxManifest);@(MSBuildAllProjects)" Outputs="$(_TransformedAppxManifestXmlFile)" DependsOnTargets="ComputeWireUpCoreRuntimeParameters" AfterTargets="ComputeWireUpCoreRuntimeGates" Condition="'$(WireUpCoreRuntimeGates)'=='Satisfied'">
    <CreateProperty Value="true">
      <Output PropertyName="_WireUpCoreRuntimeTaskExecuted" TaskParameter="ValueSetByTask" />
    </CreateProperty>
    <WireUpCoreRuntime AppxManifest="@(FinalAppxManifest)" AppxPackagePayload="@(AppxPackagePayload)" OutputPath="$(_WireUpCoreRuntimeOutputPath.TrimEnd('\'))" TargetRuntime="$(TargetRuntime)" TargetArch="$(_PlatformTargetForCoreRuntime)" FrameworkPackages="@(FrameworkPackagesForTargetArchitecture)" CoreRuntimeSDKLocation="$(CoreRuntimeSDKLocation)" CopyWin32ResourcesLocation="$(CopyWin32ResourcesX86Path)">
      <Output TaskParameter="ErrorCode" PropertyName="_WireUpCoreRuntimeExitCode" />
      <Output TaskParameter="FrameworkPackagesNeedsToBeDeployed" PropertyName="FrameworkPackagesNeedsToBeDeployed" />
      <Output TaskParameter="TransformedAppxPackagePayload" ItemName="_TransformedAppxPackagePayload" />
    </WireUpCoreRuntime>
    <!-- Record output files as file writes -->
    <ItemGroup>
      <FileWrites Include="$(_WireUpCoreRuntimeOutputPath)**\*" />
    </ItemGroup>
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true'">
      <FrameworkSdkPackage Include="@(FrameworkPackageDependencies)" Condition="'$(FrameworkPackagesNeedsToBeDeployed)'=='true'" />
    </ItemGroup>
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" />
      <AppxPackagePayload Include="@(_TransformedAppxPackagePayload)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_WireUpCoreRuntimeTaskExecuted)' == 'true' and Exists('$(_TransformedAppxManifestXmlFile)')">
      <FinalAppxManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxManifest Include="$(_TransformedAppxManifestXmlFile)" />
    </ItemGroup>
    <PropertyGroup>
      <_WireUpCoreRuntimeMsg>WireUpCoreRuntime has encountered an error</_WireUpCoreRuntimeMsg>
    </PropertyGroup>
    <Error Condition="'$(_WireUpCoreRuntimeExitCode)' &gt; 0" Text="$(_WireUpCoreRuntimeMsg)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.Net.CoreRuntime.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NetNative.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <UseCacheToolChain Condition="'$(DotNetNativeVersion)'!=''">true</UseCacheToolChain>
    <!-- In general, DotNetNativeVersion and DotNetNativeLibraryVersion should be the same, but keep some flexibility just in case -->
    <DotNetNativeLibraryVersion Condition="'$(DotNetNativeLibraryVersion)'==''">$(DotNetNativeVersion)</DotNetNativeLibraryVersion>
  </PropertyGroup>
  <!-- Projects that set DotNetNativeVersion get the offline package they requested -->
  <PropertyGroup Condition="'$(UseCacheToolChain)'=='true'">
    <DotNetNativeCompilerProps Condition="'$(DotNetNativeCompilerProps)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\Microsoft.Net.Native.Compiler.props</DotNetNativeCompilerProps>
    <ProjectNTargets Condition="'$(ProjectNTargets)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\Microsoft.Net.Native.Compiler.targets</ProjectNTargets>
    <DotNetNativeSharedLibraryarmProps Condition="'$(DotNetNativeSharedLibraryarmProps)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.SharedLibrary-arm\$(DotNetNativeLibraryVersion)\build\Microsoft.Net.Native.SharedLibrary-arm.props</DotNetNativeSharedLibraryarmProps>
    <DotNetNativeSharedLibraryx64Props Condition="'$(DotNetNativeSharedLibraryx64Props)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.SharedLibrary-x64\$(DotNetNativeLibraryVersion)\build\Microsoft.Net.Native.SharedLibrary-x64.props</DotNetNativeSharedLibraryx64Props>
    <DotNetNativeSharedLibraryx86Props Condition="'$(DotNetNativeSharedLibraryx86Props)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.SharedLibrary-x86\$(DotNetNativeLibraryVersion)\build\Microsoft.Net.Native.SharedLibrary-x86.props</DotNetNativeSharedLibraryx86Props>
    <DotNetNativeSharedLibraryarmTargets Condition="'$(DotNetNativeSharedLibraryarmTargets)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.SharedLibrary-arm\$(DotNetNativeLibraryVersion)\build\Microsoft.Net.Native.SharedLibrary-arm.targets</DotNetNativeSharedLibraryarmTargets>
    <DotNetNativeSharedLibraryx64Targets Condition="'$(DotNetNativeSharedLibraryx64Targets)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.SharedLibrary-x64\$(DotNetNativeLibraryVersion)\build\Microsoft.Net.Native.SharedLibrary-x64.targets</DotNetNativeSharedLibraryx64Targets>
    <DotNetNativeSharedLibraryx86Targets Condition="'$(DotNetNativeSharedLibraryx86Targets)'==''">$(MSBuildProgramFiles32)\Microsoft SDKs\NuGetPackages\Microsoft.Net.Native.SharedLibrary-x86\$(DotNetNativeLibraryVersion)\build\Microsoft.Net.Native.SharedLibrary-x86.targets</DotNetNativeSharedLibraryx86Targets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseCacheToolChain)'!='true'">
    <ProjectNTargets Condition="'$(ProjectNTargets)'=='' and '$(PlatformTarget)'!='ARM64'">$(MSBuildProgramFiles32)\MSBuild\15.0\.Net\.NetNative\15.0.24211\Microsoft.NetNative.targets</ProjectNTargets>
  </PropertyGroup>
  <!--<Import Project="$(DotNetNativeCompilerProps)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeCompilerProps)')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(ProjectNTargets)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(ProjectNTargets)')">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\tools\Microsoft.NetNative.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NetNative.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true'">
    <_ProjectNToolchainEnabled>true</_ProjectNToolchainEnabled>
  </PropertyGroup>
  <!-- Make sure WindowsSDK_LibraryPath is available to us so that MCG can load up the libs correctly -->
  <!--<Import Project="$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\Windows.props" Condition="'$(_ProjectNToolchainEnabled)' == 'true' And '$(WindowsSDK_IncludePath)' == '' And Exists('$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\Windows.props')" />-->
  <!--<Import Project="$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\$(TargetPlatformIdentifier)\$(TargetPlatformVersion)\UAP.props" Condition="'$(_ProjectNToolchainEnabled)' == 'true' And '$(WindowsSDK_IncludePath)' == '' And Exists('$(TargetPlatformSdkPath)\DesignTime\CommonConfiguration\Neutral\$(TargetPlatformIdentifier)\$(TargetPlatformVersion)\UAP.props')" />-->
  <!-- Create list of supported platforms based on installed SDKs. 
       VS uses this list to alter UI behavior (project settings). -->
  <PropertyGroup Condition="'$(ProjectNProfileEnabled)' == 'true'">
    <AllowedPlatformsForProjectN Condition="Exists('$(IlcToolPathARM)\ARM\ilc')">ARM</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(IlcToolPathX64)\x64\ilc')">$(AllowedPlatformsForProjectN),x64</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(IlcToolPathX86)\x86\ilc')">$(AllowedPlatformsForProjectN),x86</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN Condition="Exists('$(IlcToolPathArm64)\arm64\ilc')">$(AllowedPlatformsForProjectN),ARM64</AllowedPlatformsForProjectN>
    <AllowedPlatformsForProjectN>$(AllowedPlatformsForProjectN.TrimStart(','))</AllowedPlatformsForProjectN>
  </PropertyGroup>
  <!-- Provides a default target platform for finding the ilc.exe version when
       the project is configured to AnyCPU -->
  <PropertyGroup>
    <_PlatformTargetForIlcVersion Condition="'$(PlatformTarget)'!='AnyCPU'">$(PlatformTarget)</_PlatformTargetForIlcVersion>
    <_PlatformTargetForIlcVersion Condition="'$(PlatformTarget)'=='AnyCPU'">x86</_PlatformTargetForIlcVersion>
  </PropertyGroup>
  <!--WACK approved API list for UWP-->
  <PropertyGroup>
    <_WindowsSDK_SupportedAPIs Condition="'$(_PlatformTargetForIlcVersion)'=='x86'">$(WindowsSDK_SupportedAPIs_x86)</_WindowsSDK_SupportedAPIs>
    <_WindowsSDK_SupportedAPIs Condition="'$(_PlatformTargetForIlcVersion)'=='x64'">$(WindowsSDK_SupportedAPIs_x64)</_WindowsSDK_SupportedAPIs>
    <_WindowsSDK_SupportedAPIs Condition="'$(_PlatformTargetForIlcVersion)'=='arm'">$(WindowsSDK_SupportedAPIs_arm)</_WindowsSDK_SupportedAPIs>
    <_WindowsSDK_SupportedAPIs Condition="'$(_PlatformTargetForIlcVersion)'=='arm64'">$(WindowsSDK_SupportedAPIs_arm64)</_WindowsSDK_SupportedAPIs>
    <!-- If the Windows SDK doesn't carry SupportedAPIs.xml for ARM64, use the file shipped with the compiler. -->
    <NetNativeFallback_WindowsSDK_SupportedAPIs_ARM64Path>$(MSBuildThisFileDirectory)WindowsSDK\SupportedAPIs-arm64.xml</NetNativeFallback_WindowsSDK_SupportedAPIs_ARM64Path>
    <_WindowsSDK_SupportedAPIs Condition="'$(_WindowsSDK_SupportedAPIs)'=='' and '$(_PlatformTargetForIlcVersion)'=='arm64'">$(NetNativeFallback_WindowsSDK_SupportedAPIs_ARM64Path)</_WindowsSDK_SupportedAPIs>
  </PropertyGroup>
  <PropertyGroup>
    <SkipILCompilation>true</SkipILCompilation>
  </PropertyGroup>
  <PropertyGroup>
    <!-- 
         These flags control the behavior of which payload the ProjectN targets is going to create:
         - Sideload payload: contains native binaries as produced by ILC
         - Upload payload: contains IL and extended AppxManifest, which includes the package dependencies (required by Store scenario)

         Sideload payload requires ILC to be invoked but upload payload doesn't. On the other hand, invoking ILC lets you 
         create both payloads without accruing additional cost. This translates to:
         - Invoke ILC when we're creating a sideload package (with or without an upload package) 
         - Don't invoke ILC when we're creating only the upload payload. 
         
         _ProjectNAppxPayloadBuildMode==SideloadAndUploadPayloads implies the former
         _ProjectNAppxPayloadBuildMode==UploadPayload implies the latter.

         Note: BuildAppxSideloadPackageForUap and BuildAppxUploadPackageForUap are available only on Dev14 Update 1 and later. 
         That's why we can't take a direct dependency on these two flags. So instead we define ProjectN specific flags.
      -->
    <_ProjectNAppxPayloadBuildMode_BuildSideLoadPackage>true</_ProjectNAppxPayloadBuildMode_BuildSideLoadPackage>
    <_ProjectNAppxPayloadBuildMode_BuildSideLoadPackage Condition="'$(BuildAppxSideloadPackageForUap)' == 'false'">false</_ProjectNAppxPayloadBuildMode_BuildSideLoadPackage>
    <_ProjectNAppxPayloadBuildMode_BuildOnlyUploadPackage>false</_ProjectNAppxPayloadBuildMode_BuildOnlyUploadPackage>
    <_ProjectNAppxPayloadBuildMode_BuildOnlyUploadPackage Condition="'$(BuildAppxUploadPackageForUap)' == 'true' and '$(BuildAppxSideloadPackageForUap)' == 'false'">true</_ProjectNAppxPayloadBuildMode_BuildOnlyUploadPackage>
    <_ProjectNAppxPayloadBuildMode Condition="'$(_ProjectNAppxPayloadBuildMode_BuildSideLoadPackage)' == 'true'">SideloadAndUploadPayloads</_ProjectNAppxPayloadBuildMode>
    <_ProjectNAppxPayloadBuildMode Condition="'$(_ProjectNAppxPayloadBuildMode_BuildOnlyUploadPackage)' == 'true'">UploadPayload</_ProjectNAppxPayloadBuildMode>
    <_ProjectNAppxPayloadBuildMode Condition="'$(_ProjectNAppxPayloadBuildMode)' == ''">SideloadAndUploadPayloads</_ProjectNAppxPayloadBuildMode>
  </PropertyGroup>
  <!-- Flag to turn on/off consuming shared assembly framework package. By default it's true -->
  <PropertyGroup>
    <PureNative Condition="'$(PureNative)' == ''">false</PureNative>
    <PureNative Condition="'$(_PlatformTargetForIlcVersion)' == 'arm64'">true</PureNative>
    <UseDotNetNativeSharedAssemblyFrameworkPackage Condition="'$(UseDotNetNativeSharedAssemblyFrameworkPackage)' == ''">true</UseDotNetNativeSharedAssemblyFrameworkPackage>
    <GeneratePGD Condition="'$(GeneratePGD)' == ''">false</GeneratePGD>
    <ConsumePGD Condition="'$(ConsumePGD)' == ''">false</ConsumePGD>
    <UseDotNetNativeLogger Condition="'$(UseDotNetNativeLogger)' == ''">true</UseDotNetNativeLogger>
    <!-- List of ilc options which can be specified from a project's .csproj file-->
    <UniversalGenericsOptOut Condition="'$(UniversalGenericsOptOut)' == ''">false</UniversalGenericsOptOut>
    <ShortcutGenericAnalysis Condition="'$(ShortcutGenericAnalysis)' == ''">false</ShortcutGenericAnalysis>
    <SingleThreadNUTC Condition="'$(SingleThreadNUTC)' == ''">false</SingleThreadNUTC>
    <Use64BitCompiler Condition="'$(Use64BitCompiler)' == ''">false</Use64BitCompiler>
    <DisableMetadataStackTraceResolution Condition="'$(DisableMetadataStackTraceResolution)' == ''">false</DisableMetadataStackTraceResolution>
    <DisableStackTraceMetadata Condition="'$(DisableStackTraceMetadata)' == ''">false</DisableStackTraceMetadata>
    <DisableExceptionMessages Condition="'$(DisableExceptionMessages)' ==''">false</DisableExceptionMessages>
    <UseAppLocalCrt Condition="'$(UseAppLocalCrt)' == ''">false</UseAppLocalCrt>
    <OptimizeForSize Condition="'$(OptimizeForSize)' == ''">false</OptimizeForSize>
    <AlignMethodsAtMinimalBoundaries Condition="'$(AlignMethodsAtMinimalBoundaries)' == ''">false</AlignMethodsAtMinimalBoundaries>
    <LargeAddressAware Condition="'$(LargeAddressAware)' == ''">false</LargeAddressAware>
    <NoLinkerSymbols Condition="'$(NoLinkerSymbols)' == ''">false</NoLinkerSymbols>
    <OutOfProcPDB Condition="'$(OutOfProcPDB)' == ''">false</OutOfProcPDB>
    <!-- End of ilc options-->
  </PropertyGroup>
  <!-- Adds a <build:Item> tag containing the version of ilc.exe in
       the output AppxManifest if the project is using ProjectN -->
  <PropertyGroup>
    <IlcToolPath Condition="'$(_PlatformTargetForIlcVersion)'=='arm'">$(IlcToolPathARM)</IlcToolPath>
    <IlcToolPath Condition="'$(_PlatformTargetForIlcVersion)'=='x64'">$(IlcToolPathX64)</IlcToolPath>
    <IlcToolPath Condition="'$(_PlatformTargetForIlcVersion)'=='x86'">$(IlcToolPathX86)</IlcToolPath>
    <IlcToolPath Condition="'$(_PlatformTargetForIlcVersion)'=='arm64'">$(IlcToolPathArm64)</IlcToolPath>
    <_IlcVersionPath Condition="$(IlcToolPath)!=''">$(IlcToolPath)\$(_PlatformTargetForIlcVersion)\ilc\ilc.exe</_IlcVersionPath>
    <_IlcVersionPath Condition="$(_IlcVersionPath)==''">$(MSBuildThisFileDirectory.TrimEnd('\'))\$(_PlatformTargetForIlcVersion)\ilc\ilc.exe</_IlcVersionPath>
  </PropertyGroup>
  <ItemGroup Condition="'$(_ProjectNToolchainEnabled)'=='true'">
    <AppxManifestMetadata Include="$(_IlcVersionPath)" />
  </ItemGroup>
  <Target Name="SetIlcOptions" BeforeTargets="PrepareILCInputFolder;BeforeGenerateAppxManifest">
    <PropertyGroup>
      <!-- Add Application Context Switches-->
      <!-- Add for backwards compatibility with DisableMetadataStackTraceResolution tag -->
      <AppContextSwitches Condition="'$(DisableMetadataStackTraceResolution)' == 'true'">Diagnostics.DisableMetadataStackTraceResolution;$(AppContextSwitches)</AppContextSwitches>
    </PropertyGroup>
    <ItemGroup Condition="'$(_ProjectNToolchainEnabled)'=='true'">
      <AppxManifestMetadata Include="OptimizingToolset">
        <Value>ilc.exe</Value>
      </AppxManifestMetadata>
      <IlcOption Include="UseDotNetNativeSharedAssemblyFrameworkPackage">
        <Value>$(UseDotNetNativeSharedAssemblyFrameworkPackage)</Value>
      </IlcOption>
      <!-- Add for backwards compatibility with UniversalGenericsOptOut tag -->
      <IlcOption Include="sharedGenericsMode" Condition="$(UniversalGenericsOptOut) == 'true'">
        <Value>StandardHeuristics</Value>
      </IlcOption>
      <IlcOption Include="AppContextSwitches" Condition="'$(AppContextSwitches)' != ''">
        <Value>$(AppContextSwitches)</Value>
      </IlcOption>
      <!-- Add Removable Features -->
      <IlcOption Include="RemovableFeatures" Condition="'$(RemovableFeatures)' != ''">
        <Value>$(RemovableFeatures)</Value>
      </IlcOption>
      <IlcOption Include="DisableStackTraceMetadata">
        <Value>$(DisableStackTraceMetadata)</Value>
      </IlcOption>
      <IlcOption Include="DisableExceptionMessages">
        <Value>$(DisableExceptionMessages)</Value>
      </IlcOption>
      <IlcOption Include="ShortcutGenericAnalysis">
        <Value>$(ShortcutGenericAnalysis)</Value>
      </IlcOption>
      <IlcOption Include="GeneratePGD">
        <Value>$(GeneratePGD)</Value>
      </IlcOption>
      <IlcOption Include="ConsumePGD">
        <Value>$(ConsumePGD)</Value>
      </IlcOption>
      <IlcOption Include="SingleThreadNUTC">
        <Value>$(SingleThreadNUTC)</Value>
      </IlcOption>
      <IlcOption Include="Use64BitCompiler">
        <Value>$(Use64BitCompiler)</Value>
      </IlcOption>
      <IlcOption Include="OptimizeForSize">
        <Value>$(OptimizeForSize)</Value>
      </IlcOption>
      <IlcOption Include="AlignMethodsAtMinimalBoundaries">
        <Value>$(AlignMethodsAtMinimalBoundaries)</Value>
      </IlcOption>
      <IlcOption Include="LargeAddressAware">
        <Value>$(LargeAddressAware)</Value>
      </IlcOption>
      <IlcOption Include="NoLinkerSymbols">
        <Value>$(NoLinkerSymbols)</Value>
      </IlcOption>
      <IlcOption Include="OutOfProcPDB">
        <Value>$(OutOfProcPDB)</Value>
      </IlcOption>
      <AppxManifestMetadata Include="@(IlcOption)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <DotNetNativeVCLibsDependencySDKMoniker>Microsoft.VCLibs, Version=14.0</DotNetNativeVCLibsDependencySDKMoniker>
  </PropertyGroup>
  <!-- 
       Insert the SDK references for VCLibs and Microsoft.Net.Native.Runtime FW packages only if we have .NET Native enabled and the app contains managed code.
       "App contains managed code" is determined by checking the presence of System.Runtime.dll in the _IlcInputPath location since this assembly is deployed only when
       managed code exists in the app.
       
       Store relies on a similar logic as well.
       
       This ensures that we do not accidently insert the reference to Microsoft.Net.Native.Runtime package in purely native projects (e.g. C++ or JS).
   -->
  <Target Name="AddSDKReferences" Condition="'$(_ProjectNToolchainEnabled)'=='true' and Exists('$(_IlcInputPath)System.Runtime.dll')" AfterTargets="PrepareILCInputFolder" DependsOnTargets="QueryDotNetNativeDependencySDKs">
    <ItemGroup>
      <FilteredDotNetNativeDependencySDKs Include="@(ResolvedDotNetNativeDependencySDKs)" />
      <DotNetNativeVCLibsDependencySDK Include="@(ResolvedDotNetNativeDependencySDKs)" Condition="'%(ResolvedDotNetNativeDependencySDKs.SDKName)' == '$(DotNetNativeVCLibsDependencySDKMoniker)'" />
    </ItemGroup>
    <GetFrameworkSdkPackages FrameworkSdkReferences="@(FilteredDotNetNativeDependencySDKs)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkPackageDependencies" />
    </GetFrameworkSdkPackages>
    <ItemGroup>
      <FrameworkPackagesForTargetArchitecture Include="@(FrameworkPackageDependencies)" Condition="'%(Architecture)' == '$(_PlatformTargetForIlcVersion)'" />
      <FrameworkDependencyIdentities Include="%(FrameworkPackagesForTargetArchitecture.FrameworkIdentity)" Condition="'%(FrameworkPackagesForTargetArchitecture.ResolvedSDKReference)' != '@(DotNetNativeVCLibsDependencySDK)'" />
      <FrameworkDependencyIdentities Condition="'%(AppxPackageRegistration.Publisher)' != '' AND ('$(Configuration)' == '%(AppxPackageRegistration.Configuration)' OR '%(AppxPackageRegistration.Configuration)' == '')" Include="Name = %(AppxPackageRegistration.Filename), MinVersion = %(AppxPackageRegistration.Version), Publisher = %(AppxPackageRegistration.Publisher)" />
      <FrameworkSdkPackage Include="@(FrameworkPackageDependencies)" Exclude="@(FrameworkSdkPackage)" />
    </ItemGroup>
    <PropertyGroup>
      <_IlcFrameworkDependencies Condition="'@(FrameworkDependencyIdentities)' != ''">/frameworkDependency:"@(FrameworkDependencyIdentities, '" /frameworkDependency:"')" </_IlcFrameworkDependencies>
    </PropertyGroup>
  </Target>
  <Target Name="QueryDotNetNativeDependencySDKs" DependsOnTargets="ComputeIlcParameters">
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" Condition="'@(InstalledSDKLocations)' == ''">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <ItemGroup>
      <!-- This naively hopes installed packages are compatible with us, but we will
           later insert a package dependency that has the actual required version. -->
      <VCLibsSDK Include="$(DotNetNativeVCLibsDependencySDKMoniker)" />
    </ItemGroup>
    <PropertyGroup>
      <DotNetNativeTargetConfiguration>Retail</DotNetNativeTargetConfiguration>
      <DotNetNativeTargetConfiguration Condition="'$(_IlcBuildType)' == 'chk'">Debug</DotNetNativeTargetConfiguration>
      <VCLibsTargetConfiguration>Retail</VCLibsTargetConfiguration>
    </PropertyGroup>
    <ResolveSDKReference SDKReferences="@(VCLibsSDK)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetedSDKConfiguration="$(VCLibsTargetConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" ProjectName="$(ProjectName)" InstalledSDKs="@(InstalledSDKLocations)">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedDotNetNativeDependencySDKs" />
    </ResolveSDKReference>
    <PropertyGroup Condition="'$(UseNugetInstall)' == 'true'">
      <_IlcSharedAssemblyRootPath Condition="'$(_PlatformTargetForIlcVersion)' == 'x86'">$(ILCSharedAssemblySDKRootX86)</_IlcSharedAssemblyRootPath>
      <_IlcSharedAssemblyRootPath Condition="'$(_PlatformTargetForIlcVersion)' == 'x64'">$(ILCSharedAssemblySDKRootX64)</_IlcSharedAssemblyRootPath>
      <_IlcSharedAssemblyRootPath Condition="'$(_PlatformTargetForIlcVersion)' == 'arm'">$(ILCSharedAssemblySDKRootArm)</_IlcSharedAssemblyRootPath>
      <_IlcSharedAssemblyRootPath Condition="'$(_PlatformTargetForIlcVersion)' == 'arm64'">$(ILCSharedAssemblySDKRootArm64)</_IlcSharedAssemblyRootPath>
    </PropertyGroup>
    <PropertyGroup>
      <_IlcSharedAssemblyDefinitionFile>$(_IlcSharedAssemblyRootPath)\$(_IlcBuildType)\SharedAssemblyILMergeInfo.csv</_IlcSharedAssemblyDefinitionFile>
    </PropertyGroup>
  </Target>
  <Target Name="ComputeExtensionSDKReferencePaths">
    <ItemGroup>
      <!-- Don't include platform.winmd otherwise it will be added to Ilc's /externalReferencePath argument and loaded
           which will cause all sorts of problems because it is not a valid winmd file and it is not valid .NET 
           metadata. For example types don't derived from System.Object. 
      -->
      <ExtensionSDKReferencePath Include="@(ReferencePath-&gt;DirectoryName())" Condition="'%(ReferencePath.CopyLocal)' != 'true' and '%(ReferencePath.ResolvedFrom)' == 'GetSDKReferenceFiles' and '%(ReferencePath.Filename)%(ReferencePath.Extension)' != 'platform.winmd'" KeepDuplicates="false" />
      <ExtensionSDKReferenceWinmds Include="@(ReferencePath)" Condition="'%(ReferencePath.CopyLocal)' != 'true' and '%(ReferencePath.ResolvedFrom)' == 'GetSDKReferenceFiles' and '%(ReferencePath.WinMDFile)'=='true' and '%(ReferencePath.Filename)%(ReferencePath.Extension)' != 'platform.winmd'" KeepDuplicates="false">
        <TargetPath>$(WinMetadataDir)\$([System.IO.Path]::GetFileName(%(ReferencePath.Identity)))</TargetPath>
      </ExtensionSDKReferenceWinmds>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <_GatekeeperPlatformTarget>$(PlatformTarget)</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(IlcToolPath)$(_GatekeeperPlatformTarget)\ilc')">x64</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(IlcToolPath)$(_GatekeeperPlatformTarget)\ilc')">x86</_GatekeeperPlatformTarget>
    <_GatekeeperPlatformTarget Condition="!Exists('$(IlcToolPath)$(_GatekeeperPlatformTarget)\ilc')">arm</_GatekeeperPlatformTarget>
  </PropertyGroup>
  <Target Name="RunGatekeeper" AfterTargets="_WireUpCoreRuntime" DependsOnTargets="ComputeExtensionSDKReferencePaths;ComputeIlcParameters" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(_ProjectNToolchainEnabled)'!='true' and '$(EnableGateKeeperAnalysis)' == 'true' and Exists('$(IlcToolPath)$(_GatekeeperPlatformTarget)\ilc')">
    <PropertyGroup>
      <_GatekeeperCmd>"$(IlcToolPath)$(_GatekeeperPlatformTarget)\ilc\Ilc.exe" --gatekeeper @"$(_IlcIntermediatePath)gkargs.rsp"</_GatekeeperCmd>
      <_TargetPlatformMetadataPath Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('@(UnionWinmdPath)')">$([System.IO.Path]::GetDirectoryName('%(UnionWinmdPath.FullPath)'))</_TargetPlatformMetadataPath>
      <_TargetPlatformMetadataPath Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('$(TargetPlatformWinMDLocation)')">$(TargetPlatformWinMDLocation)</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <ItemGroup>
      <_GatekeeperLibPath Include="$(IlcToolPath)$(_GatekeeperPlatformTarget)\ilc\lib\Private" />
      <_GatekeeperLibPath Include="@(ExtensionSDKReferencePath)" />
      <_GatekeeperWinMDPath Include="$(_TargetPlatformMetadataPath)\*.winmd" />
    </ItemGroup>
    <ConvertToAbsolutePath Paths="$(OutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_GatekeeperInputPath" />
    </ConvertToAbsolutePath>
    <ItemGroup>
      <_GatekeeperArguments Include="/In:&quot;$(_GatekeeperInputPath.TrimEnd('\'))&quot;" />
      <_GatekeeperArguments Include="/Lib:&quot;$(_GatekeeperInputPath.TrimEnd('\'))&quot;" />
      <_GatekeeperArguments Include="@(_GatekeeperLibPath -> '/Lib:&quot;%(Identity)&quot;')" />
      <_GatekeeperArguments Condition="'@(_GatekeeperWinMDPath)' != ''" Include="@(_GatekeeperWinMDPath -> '/WinMD:&quot;%(Identity)&quot;')" />
      <_GatekeeperArguments Condition="'$(ProjectNVSTelemetrySession)' != ''" Include="/VSTelemetrySessionSettings:$(ProjectNVSTelemetrySession)" />
      <_GatekeeperArguments Include="/RdXmlPath:&quot;$(MSBuildThisFileDirectory)LibraryXML&quot;" />
      <_GatekeeperArguments Include="/RunOnlyPreDR" />
    </ItemGroup>
    <MakeDir Directories="$(_IlcIntermediatePath)" />
    <WriteLinesToFile File="$(_IlcIntermediatePath)gkargs.rsp" Lines="@(_GatekeeperArguments)" Overwrite="true" />
    <Exec Command="$(_GatekeeperCmd)">
      <Output TaskParameter="ExitCode" PropertyName="_GatekeeperExitCode" />
    </Exec>
  </Target>
  <UsingTask TaskName="ValidateRdXmlTask" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(IlcToolPath)$(PlatformTarget)\ilc')" />
  <UsingTask TaskName="LoggerBasedExecTask" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(IlcToolPath)$(PlatformTarget)\ilc')" />
  <UsingTask TaskName="IlcErrorTask" AssemblyFile="$(IlcToolPath)$(_PlatformTargetForIlcVersion)\ilc\tools\Microsoft.Build.ILTasks.dll" />
  <UsingTask TaskName="IlcMessageTask" AssemblyFile="$(IlcToolPath)$(_PlatformTargetForIlcVersion)\ilc\tools\Microsoft.Build.ILTasks.dll" />
  <UsingTask TaskName="SharedAssemblyApplicabilityVerifierTask" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" />
  <UsingTask TaskName="ParseILMergeInfoTask" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" />
  <UsingTask TaskName="InjectFrameworkDependenciesTask" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" />
  <UsingTask TaskName="JSONEscapeStringTask" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" />
  <Target Name="ValidateRdXml" AfterTargets="AfterGenerateAppxManifest" BeforeTargets="BuildNativePackage" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(IlcToolPath)$(PlatformTarget)\ilc')">
    <ValidateRdXmlTask Files="@(_IlcInputRdXmlFiles)" />
  </Target>
  <Target Name="CreateNativeWinMD" AfterTargets="ExportWindowsMDFile" Condition="'$(ProduceReferenceWinmd)' == 'true'">
    <!-- Produce a reference [native] WinMD to be used by external components. This is used in the DLC scenario
         where the main app build references the native WinMD built off the optional component build, not its
         actual implementation managed WinMD as that would defy the purpose of optional component separation
         by compiling the functionality of the optional component directly into the main app.
    -->
    <PropertyGroup>
      <InputManagedWinMD>$(_IntermediateWindowsMetadataPath)</InputManagedWinMD>
      <InputManagedWinMDFolder>$([System.IO.Path]::GetDirectoryName('$(InputManagedWinMD)'))</InputManagedWinMDFolder>
      <InputManagedWinMDFileName>$([System.IO.Path]::GetFileName('$(InputManagedWinMD)'))</InputManagedWinMDFileName>
      <OutputNativeWinMD>$(OutDir)Reference\$(InputManagedWinMDFileName)</OutputNativeWinMD>
      <MakeNativeWinMDTool>$(IlcToolPath)$(_PlatformTargetForIlcVersion)\ilc\tools\MakeNativeWinMD.exe</MakeNativeWinMDTool>
    </PropertyGroup>
    <Exec Command="&quot;$(MakeNativeWinMDTool)&quot; &quot;$(InputManagedWinMD)&quot; &quot;$(OutputNativeWinMD)&quot;" />
    <ItemGroup>
      <FileWrites Include="$(OutputNativeWinMD)" />
    </ItemGroup>
  </Target>
  <Target Name="CheckForUnsupportedScenarios" AfterTargets="ValidateRdXml">
    <!-- 
         ASSUMPTION: In deciding whether an unmanaged app has a managed dependency we'll defer to the computation of 
         whether UnionWinMD needs to be included in the PackagingOutputs or not. 
         (See the target _AddUnionWinmd in Microsoft.AppxPackage.Targets)
         Briefly, UnionWinMD is going to be included if any of the winmds that the app is referencing is managed. 
         So existance of UnionWinMD is being used as an indicator to existance of managed code. 
         This way the cost of computing managed dependency is avoided. 
    -->
    <ItemGroup>
      <_UnionMetadataWinMD Include="@(PackagingOutputs)" Condition="'%(Identity)' == '$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd'" />
    </ItemGroup>
    <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed' or '@(_UnionMetadataWinMD)' != ''">
      <_AppContainsManagedCodeInItsClosure>true</_AppContainsManagedCodeInItsClosure>
    </PropertyGroup>
  </Target>
  <Target Name="CheckForOptionalComponent" BeforeTargets="_GenerateCurrentProjectAppxManifest;SetIlcOptions">
    <!--
         Check for the build of an optional component by locating the MainPackageDependency tag
         in the source manifest. Please keep in mind we cannot put this off to the time of creation
         of the final manifest because we need to switch ILC build mode to single-file and that
         propagates to the UseDotNetNativeSharedAssemblyPackage property which is emitted into the
         final manifest.
    -->
    <XmlPeek Namespaces="&lt;Namespace Prefix='uap3' Uri='http://schemas.microsoft.com/appx/manifest/uap/windows10/3'/&gt;" XmlInputPath="@(AppxManifest)" Query="//uap3:MainPackageDependency/@Name">
      <Output TaskParameter="Result" ItemName="MainPackageDependencyName" />
    </XmlPeek>
    <PropertyGroup Condition="'@(MainPackageDependencyName)' != ''">
      <!-- Optional components are currently only supported in single-file build mode -->
      <UseDotNetNativeSharedAssemblyFrameworkPackage>False</UseDotNetNativeSharedAssemblyFrameworkPackage>
    </PropertyGroup>
  </Target>
  <Target Name="CheckForAnyCPU">
    <IlcErrorTask Condition="'$(PlatformTarget)' == 'AnyCPU'" ResourceName="Error_AnyCPU" />
  </Target>
  <UsingTask TaskName="ComputeManagedBinaries" AssemblyFile="$(IlcToolPath)$(PlatformTarget)\ilc\tools\Microsoft.Build.ILTasks.dll" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(IlcToolPath)$(PlatformTarget)\ilc')" />
  <Target Name="ComputeIlcParameters" DependsOnTargets="ComputeExtensionSDKReferencePaths">
    <!-- Compute the target location for ILC outputs -->
    <PropertyGroup Condition="'$(IlcOutputPath)'==''">
      <IlcOutputPath>$(OutputPath)ilc\</IlcOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcOutputPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup Condition="'$(IlcIntermediateRootPath)'==''">
      <IlcIntermediateRootPath>$(IntermediateOutputPath)ilc\</IlcIntermediateRootPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcIntermediateRootPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcIntermediateRootPath" />
    </ConvertToAbsolutePath>
    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" PropertyName="WindowsSdkDir">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>
    <PropertyGroup>
      <WindowsSdkPath Condition="'$(WindowsSdkPath)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</WindowsSdkPath>
      <WindowsSdkPath Condition="'$(WindowsSdkPath)' == ''">$(_TargetPlatformSdkDir)</WindowsSdkPath>
    </PropertyGroup>
    <!--                         Computing full path of rc.exe                            -->
    <!-- RcExeFullPath is set in _GetSdkToolPaths target in Microsoft.AppxPackage.targets -->
    <PropertyGroup>
      <_RcExeFullPath>$(RcExeFullPath)</_RcExeFullPath>
    </PropertyGroup>
    <!-- 
         But earlier versions (i.e.: <= Dev14 Update1 ) of this targets file doesn't set RcExeFullPath. 
         Try to find out where it is by invoking GetSdkFileFullPath task ourselves
     -->
    <PropertyGroup>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' == ''">false</MSBuildExtensionsPath64Exists>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' != ''">true</MSBuildExtensionsPath64Exists>
    </PropertyGroup>
    <GetSdkFileFullPath Condition="'$(_RcExeFullPath)' == ''" FileName="rc.exe" TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)" SDKIdentifier="$(SDKIdentifier)" SDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" TargetPlatformVersion="$(TargetPlatformVersion)" MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="_RcExeFullPath" />
      <Output TaskParameter="ActualFileArchitecture" PropertyName="_RcExeArchitecture" />
    </GetSdkFileFullPath>
    <!--                     End:Computing full path of rc.exe                            -->
    <!-- Prepare ilc arguments. -->
    <PropertyGroup>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(WindowsSDK_LibraryPath)'!=''">$(WindowsSDK_LibraryPath)</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='ARM' And '$(WindowsSDK_LibraryPath_arm)'!=''">$(WindowsSDK_LibraryPath_arm)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='x86' And '$(WindowsSDK_LibraryPath_x86)'!=''">$(WindowsSDK_LibraryPath_x86)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And '$(PlatformTarget)'=='x64' And '$(WindowsSDK_LibraryPath_x64)'!=''">$(WindowsSDK_LibraryPath_x64)\..</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(_TargetPlatformSdkDir)')">$(_TargetPlatformSdkDir.TrimEnd('\'))</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(TargetPlatformSdkPath)\Lib\winv6.4\um')">$(TargetPlatformSdkPath)\Lib\winv6.4\um</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'=='' And Exists('$(TargetPlatformSdkPath)\lib\$(PlatformTarget)')">$(TargetPlatformSdkPath)\lib\$(PlatformTarget)</IlcTargetPlatformSdkLibPath>
      <IlcTargetPlatformSdkLibPath Condition="'$(IlcTargetPlatformSdkLibPath)'==''">$(TargetPlatformSdkPath)\Lib\winv6.3\um</IlcTargetPlatformSdkLibPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(IlcTargetPlatformSdkLibPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_IlcTargetPlatformSdkLibPath" />
    </ConvertToAbsolutePath>
    <PropertyGroup>
      <_IlcBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' == 'true'">chk</_IlcBuildType>
      <_IlcBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' != 'true'">ret</_IlcBuildType>
      <_IlcBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' == 'true'">ret</_IlcBuildType>
      <_IlcBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' != 'true'">chk</_IlcBuildType>
    </PropertyGroup>
    <PropertyGroup>
      <_IlcExitCode />
      <_IlcRootPath Condition="'$(IlcToolPath)'!=''">$(IlcToolPath)\$(_PlatformTargetForIlcVersion)\ilc</_IlcRootPath>
      <_IlcRootPath Condition="'$(_IlcRootPath)'==''">$(MSBuildThisFileDirectory)$(_PlatformTargetForIlcVersion)\ilc</_IlcRootPath>
      <_IlcExePath>$(_IlcRootPath)\ilc.exe</_IlcExePath>
      <_IlcInputPath>$(_IlcIntermediateRootPath)in\</_IlcInputPath>
      <_IlcIntermediatePath>$(_IlcIntermediateRootPath)intermediate\</_IlcIntermediatePath>
      <_IlcVerbosity>normal</_IlcVerbosity>
      <_IlcKeepIntermediates>true</_IlcKeepIntermediates>
      <_IlcSuppressPDBWarnings>true</_IlcSuppressPDBWarnings>
    </PropertyGroup>
    <ItemGroup>
      <_IlcInputRdXmlFiles Include="@(AppxPackagePayload)" Condition="$([System.String]::new('%(AppxPackagePayload.FileName)%(AppxPackagePayload.Extension)').EndsWith('.rd.xml', System.StringComparison.OrdinalIgnoreCase))" />
      <_IlcInputXrXmlFiles Include="@(AppxPackagePayload)" Condition="$([System.String]::new('%(AppxPackagePayload.FileName)%(AppxPackagePayload.Extension)').EndsWith('.xr.xml', System.StringComparison.OrdinalIgnoreCase))" />
    </ItemGroup>
  </Target>
  <!-- The ILC input folder is created when .Net Native compilation is enabled, and when it isn't but we're running Gatekeeper.
       This ensures Gatekeeper is run on the same set of inputs as if .Net Native were enabled -->
  <Target Name="PrepareILCInputFolder" AfterTargets="CheckForUnsupportedScenarios" DependsOnTargets="ComputeIlcParameters;ComputeNativePackageInputsAndOutputs" Condition="'$(ProjectNProfileEnabled)' == 'true' and ('$(_ProjectNToolchainEnabled)' == 'true')">
    <!-- Deploy managed appx package layout to _IlcInputPath -->
    <!-- We have had to disable an optimization that was previously here. We can maybe enable it in the future -->
    <ItemGroup>
      <_IlcInputPayload Include="@(BuildNativePackagesInputs)" KeepDuplicates="false" />
      <_IlcInputPayload Include="@(AppxPackagePayload)" KeepDuplicates="false" />
      <_IlcInputPayload Include="@(ExtensionSDKReferenceWinmds)" KeepDuplicates="false" />
      <_IlcInputPayload Include="@(FinalAppxManifest)" KeepDuplicates="false">
        <TargetPath>AppxManifest.xml</TargetPath>
      </_IlcInputPayload>
    </ItemGroup>
    <ItemGroup>
      <_IlcInputFolderContents Include="@(_IlcInputPayload->'$(_IlcInputPath)%(TargetPath)')" />
    </ItemGroup>
    <!-- 
         Sanitizing ILC input folder:
         When .net native is disabled (i.e. the default debug configuration), gatekeeper will populate this folder with CoreCLR related libraries.
         If user switches the configuration and enables .net native, the very same folder will be used as input to ILC.
         Then when user builds without doing a clean first, 
            - if there happens to be a file in AppxPackagePayload that already exists in this directory it'll be overwritten. However,
            - those files in this directory that doesn't exist in the AppxPackagePayload, such as CoreCLR specific files, will just stay. 
         The later will cause a failure in ILC later on.
         To prevent that we're removing any file from this directory that doesn't exist in AppxPackagePayload
    -->
    <ItemGroup>
      <_ResidualFilesInIlcInputPath Include="$(_IlcInputPath)**\*" />
      <_ResidualFilesInIlcInputPath Remove="@(_IlcInputFolderContents)" />
    </ItemGroup>
    <Delete Files="@(_ResidualFilesInIlcInputPath)" />
    <!-- Find app-local Windows.winmd if it exists -->
    <ItemGroup>
      <AppLocalMetadataFile Include="@(_IlcInputPayload)" Condition="'%(TargetPath)' == 'WinMetadata\Windows.winmd'" />
    </ItemGroup>
    <PropertyGroup>
      <AppLocalMetadataPath>%(AppLocalMetadataFile.RootDir)%(AppLocalMetadataFile.Directory)</AppLocalMetadataPath>
    </PropertyGroup>
    <Copy SourceFiles="@(_IlcInputPayload)" DestinationFiles="@(_IlcInputFolderContents)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" UseHardlinksIfPossible="true">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- If an app-local Windows.winmd was found, we want to defer to it for platform metadata -->
    <PropertyGroup Condition="Exists('$(_IlcInputPath)WinMetadata\Windows.winmd')">
      <_TargetPlatformMetadataPath>$(_IlcInputPath)WinMetadata</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('@(UnionWinmdPath)')">
      <_TargetPlatformMetadataPath>$([System.IO.Path]::GetDirectoryName('%(UnionWinmdPath.FullPath)'))</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetPlatformMetadataPath)' == '' and Exists('$(TargetPlatformWinMDLocation)')">
      <_TargetPlatformMetadataPath>$(TargetPlatformWinMDLocation)</_TargetPlatformMetadataPath>
    </PropertyGroup>
    <Error Condition="'$(_TargetPlatformMetadataPath)' == ''" Text="Could not find an existing platform WinMD location" />
  </Target>
  <Target Name="ComputeNativePackageInputsAndOutputs" DependsOnTargets="ComputeIlcParameters;_CalculateInputsForGenerateAppxPackageRecipe" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and Exists('$(IlcToolPath)$(PlatformTarget)\ilc')">
    <!-- 
      Inputs and outputs to ILC:

        Inputs:
          - Managed binaries (*.exe / *.dll / *.winmd)
          - Metadata directives (*.rd.xml)
          - Xaml roots logs (*.xr.xml)
          - Appxmanifest.xml

        Outputs:
          - Compiled native binaries
            - For managed apps: exename.exe, exename.dll
            - For hybrid apps: <PackageIdGuid>.exe, <PackageIdGuid>.dll
    -->
    <ItemGroup>
      <ManagedAppxPackagePayloadCandidates Include="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.Extension)' == '.exe'" />
      <ManagedAppxPackagePayloadCandidates Include="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.Extension)' == '.dll'" />
      <ManagedAppxPackagePayloadCandidates Include="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.Extension)' == '.winmd'" />
    </ItemGroup>
    <ComputeManagedBinaries InputFiles="@(ManagedAppxPackagePayloadCandidates)" AppxManifest="$(FinalAppxManifestName)" OutputPath="$(_IlcOutputPath)">
      <Output TaskParameter="ManagedFiles" ItemName="ManagedAppxPackagePayload" />
      <Output TaskParameter="OutputDotNetNativeFiles" ItemName="BuildNativePackageOutputs" />
    </ComputeManagedBinaries>
    <ItemGroup>
      <!-- Runtime reflection directives affect types / metadata retained in compilation -->
      <BuildNativePackagesInputs Include="@(_IlcInputRdXmlFiles)" />
      <!-- Xaml roots are entrypoints into managed code and affect types / methods retained in compilation -->
      <BuildNativePackagesInputs Include="@(_IlcInputXrXmlFiles)" />
      <!-- ILC modifies the appx manifest -->
      <BuildNativePackagesInputs Include="$(FinalAppxManifestName)">
        <TargetPath>AppxManifest.xml</TargetPath>
      </BuildNativePackagesInputs>
      <!-- Symbols -->
      <BuildNativePackagesInputs Include="@(PdbPayload)" />
      <!-- Include winmds and managed binaries -->
      <BuildNativePackagesInputs Include="@(ManagedAppxPackagePayload)" />
      <!-- Resources -->
      <BuildNativePackagesInputs Include="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.Extension)' == '.pri'" />
    </ItemGroup>
  </Target>
  <!-- 
    This target detects whether compilation of IL is required as part of BuildNativePackage.
    If all managed input assemblies are up to date with respect to output native binaries,
    this target will be skipped since it's up to date.  That allows ILC to run in a
    pass-through mode that copies all the non-code artifacts through to the output folder.
  -->
  <Target Name="BuildNativePackageCompilationRequired" AfterTargets="CheckForUnsupportedScenarios" Condition="'$(_ProjectNToolchainEnabled)' == 'true'" DependsOnTargets="CheckForAnyCPU;ComputeNativePackageInputsAndOutputs" Inputs="@(BuildNativePackagesInputs)" Outputs="@(BuildNativePackageOutputs)">
    <CreateProperty Value="false">
      <Output PropertyName="SkipILCompilation" TaskParameter="ValueSetByTask" />
    </CreateProperty>
  </Target>
  <Target Name="CreateOnlyAppxUploadPackagePayload" AfterTargets="CheckForUnsupportedScenarios" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and ('$(_ProjectNAppxPayloadBuildMode)' == 'UploadPayload')" DependsOnTargets="CheckForAnyCPU;ComputeIlcParameters;AddSDKReferences">
    <PropertyGroup>
      <!-- Name of manifest file is predefined -->
      <_AppxManifestXmlFileName>AppxManifest.xml</_AppxManifestXmlFileName>
      <!-- Expected location of result manifest file where it supposed to be dropped by ILC -->
      <_TransformedAppxManifestXmlFile>$(_IlcOutputPath)$(_AppxManifestXmlFileName)</_TransformedAppxManifestXmlFile>
    </PropertyGroup>
    <ItemGroup>
      <FrameworkDependencyList Include="%(FrameworkPackagesForTargetArchitecture.Name)">
        <Version>%(FrameworkPackagesForTargetArchitecture.Version)</Version>
        <Publisher>%(FrameworkPackagesForTargetArchitecture.Publisher)</Publisher>
      </FrameworkDependencyList>
    </ItemGroup>
    <MakeDir Directories="$(_IlcOutputPath)" />
    <InjectFrameworkDependenciesTask InputFile="@(FinalAppxManifest)" OutputFile="$(_TransformedAppxManifestXmlFile)" FrameworkDependencies="@(FrameworkDependencyList)" />
    <ItemGroup>
      <AppxUploadPackagePayload Include="@(AppxPackagePayload)" />
      <PDBUploadPayload Include="@(_IlcInputPayload)" Condition="'%(_IlcInputPayload.Extension)' == '.pdb'" />
      <FinalAppxUploadManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxUploadManifest Include="$(_TransformedAppxManifestXmlFile)" />
    </ItemGroup>
  </Target>
  <!-- Build native appx package. Runs after managed appx package payload is computed. -->
  <Target Name="BuildNativePackage" AfterTargets="CheckForUnsupportedScenarios;BuildNativePackageCompilationRequired" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and '$(_ProjectNAppxPayloadBuildMode)' == 'SideloadAndUploadPayloads'" DependsOnTargets="CheckForAnyCPU;ComputeIlcParameters;PrepareILCInputFolder;VerifySharedAssemblyApplicability">
    <PropertyGroup>
      <!-- Name of manifest file is predefined -->
      <_AppxManifestXmlFileName>AppxManifest.xml</_AppxManifestXmlFileName>
      <!-- Expected location of result manifest file where it supposed to be dropped by ILC -->
      <_TransformedAppxManifestXmlFile>$(_IlcOutputPath)$(_AppxManifestXmlFileName)</_TransformedAppxManifestXmlFile>
      <!-- ILC hardcodes resources.pri as the file name so we do the same here -->
      <_ProjectPriFileName>resources.pri</_ProjectPriFileName>
      <_TransformedProjectPriFullPath>$(_IlcOutputPath)$(_ProjectPriFileName)</_TransformedProjectPriFullPath>
    </PropertyGroup>
    <!-- Delete existing transformed file -->
    <Delete Condition="'$(SkipILCompilation)' != 'true'" Files="$(_TransformedAppxManifestXmlFile)" />
    <PropertyGroup>
      <GeneratedIlcParameters>@(_GeneratedIlcParameters -> '%(Identity)', ' ')</GeneratedIlcParameters>
    </PropertyGroup>
    <!-- Invoke ilc. -->
    <PropertyGroup>
      <_IlcResponseFile>$(IntermediateOutputPath.TrimEnd('\'))\ilc.$(MSBuildProjectName).rsp</_IlcResponseFile>
      <_IlcParameters>/in:"$(_IlcInputPath.TrimEnd('\'))"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /out:"$(_IlcOutputPath.TrimEnd('\'))"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /intermediatespath:"$(_IlcIntermediatePath.TrimEnd('\'))"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /v:$(_IlcVerbosity)</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /keepintermediates:$(_IlcKeepIntermediates)</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /buildtype:$(_IlcBuildType)</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /exename:"$(TargetFileName)"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /rcpath:"$(_RcExeFullPath)"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /targetplatformsdklibpath:"$(_IlcTargetPlatformSdkLibPath)"</_IlcParameters>
      <_IlcParameters Condition="'$(_WindowsSDK_SupportedAPIs)' != ''">$(_IlcParameters) /WindowsSdkApiXml:"$(_WindowsSDK_SupportedAPIs)"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /targetplatformsdkmetadatapath:"$(_TargetPlatformMetadataPath)"</_IlcParameters>
      <_IlcParameters Condition="'$(ProjectNVSTelemetrySession)' != ''">$(_IlcParameters) /VSTelemetrySessionSettings:$(ProjectNVSTelemetrySession)</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /RdXmlPath:"$(MSBuildThisFileDirectory)LibraryXML"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /CscPath:"$(MSBuildThisFileDirectory)csc\csc.exe"</_IlcParameters>
      <_IlcParameters Condition="'$(_IlcSuppressPDBWarnings)'=='true'">$(_IlcParameters) /suppressPDBWarnings:$(_IlcSuppressPDBWarnings)</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /AllowNoManagedCode</_IlcParameters>
      <_IlcParameters Condition="'$(SkipILCompilation)' == 'true'">$(_IlcParameters) /SkipILCompilation:$(SkipILCompilation)</_IlcParameters>
      <_IlcParameters Condition="'$(NetNativeReproPath)' != ''">$(_IlcParameters) /PackRepro:"$(NetNativeReproPath.TrimEnd('\'))"</_IlcParameters>
      <_IlcParameters Condition="'$(NetNativePdbPath)' != ''">$(_IlcParameters) /PdbPath:"$(NetNativePdbPath.TrimEnd('\'))"</_IlcParameters>
      <_IlcParameters Condition="'$(EnableNetNativeDeveloperExperienceMode)'!=''">$(_IlcParameters) /developerExperience:$(EnableNetNativeDeveloperExperienceMode)</_IlcParameters>
      <_IlcParameters Condition="'$(_IlcFrameworkDependencies)' != ''">$(_IlcParameters) $(_IlcFrameworkDependencies)</_IlcParameters>
      <_IlcParameters Condition="'$(UseDotNetNativeSharedAssemblyFrameworkPackage)' == 'true'">$(_IlcParameters) /UseSharedAssemblies</_IlcParameters>
      <_IlcParameters Condition="'$(UseDotNetNativeSharedAssemblyFrameworkPackage)' == 'true'">$(_IlcParameters) /InSharedAssemblyPath:"$(_IlcSharedAssemblyRootPath)"</_IlcParameters>
      <_IlcParameters Condition="'$(EnableGateKeeperAnalysis)' == 'true'">$(_IlcParameters) /EnableGatekeeperAnalysis</_IlcParameters>
      <_IlcParameters Condition="'$(UseDotNetNativeIncremental)' == 'true'">$(_IlcParameters) /incremental</_IlcParameters>
      <_IlcParameters Condition="'$(PureNative)' == 'true'">$(_IlcParameters) /LinkPath:"$(_IlcRootPath)\tools\link"</_IlcParameters>
      <_IlcParameters Condition="'$(PureNative)' == 'true'">$(_IlcParameters) /NativeLibPath:"$(_IlcRootPath)\tools\link"</_IlcParameters>
      <_IlcParameters Condition="'$(PureNative)' == 'true'">$(_IlcParameters) /PureNative</_IlcParameters>
      <_IlcParameters Condition="'$(UseAppLocalCrt)' == 'true'">$(_IlcParameters) /AppLocalCrtPath:"$(_IlcRootPath)\tools\MSCRT"</_IlcParameters>
      <_IlcParameters>$(_IlcParameters) /TargetPlatform:$(_PlatformTargetForIlcVersion)</_IlcParameters>
      <!-- The IlcParameters property allows for debug scenarios where overriding one of the built-in switches
           might be desirable. It should always come last, since ILC treats command line parameters at the end
           of its command line as having higher precedence -->
      <_IlcParameters Condition="'$(IlcParameters)' != ''">$(_IlcParameters) $(IlcParameters)</_IlcParameters>
      <_IlcInvocationParameters>@"$(_IlcResponseFile)"</_IlcInvocationParameters>
    </PropertyGroup>
    <ItemGroup>
      <_IlcMessageParameters Include="$(_IlcResponseFile)" />
      <_IlcMessageParameters Include="$(_IlcParameters)" />
    </ItemGroup>
    <IlcMessageTask Importance="Normal" ResourceName="Message_IlcResponseFileContents" Parameters="@(_IlcMessageParameters)" />
    <WriteLinesToFile File="$(_IlcResponseFile)" Lines="$(_IlcParameters)" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(_IlcResponseFile)" />
    </ItemGroup>
    <!-- UseDotNetNativeLogger allows for disabling the LoggerBasedExecTask which has been shown to have
         unknown issues under stress in some customer's build labs. Additional logging of failure modes
         of the logger have been added, but the UseDotNetNativeLogger variable can also be used to disable
         use of the logger task and replace it with the standard msbuild one which is not known to experience
         the same kind of failure. -->
    <LoggerBasedExecTask Condition="'$(UseDotNetNativeLogger)'=='true'" Application="$(_IlcExePath)" Parameters="$(_IlcInvocationParameters)" MessageLog="$(_IlcIntermediateRootPath)ilclog.csv" UseCommandProcessor="false">
      <Output TaskParameter="ExitCode" PropertyName="_IlcExitCode" />
    </LoggerBasedExecTask>
    <Exec Condition="'$(UseDotNetNativeLogger)'!='true'" Command="&quot;$(_IlcExePath)&quot; $(_IlcInvocationParameters) /v:diag" UseCommandProcessor="false">
      <Output TaskParameter="ExitCode" PropertyName="_IlcExitCode" />
    </Exec>
    <!--
      This processing is only applicable for debugging with a NuGet-installed toolchain.
      The debugger needs to know where several toolchain dll's and pdb's are in order to
      correctly initialize the debugger for .Net Native builds. We provide that information
      into a JSON document that is placed alongside the app pdb, which follows an agreed-upon
      document format between the VS debugger team and the .Net Native team.
    -->
    <PropertyGroup>
      <_DebuggerServicesFileName>DotNetNative.debugger-services-def.json</_DebuggerServicesFileName>
      <_DebuggerServicesPath>$([System.IO.Path]::GetFullPath('$(IlcToolPath)\Runtime\$(PlatformTarget)'))</_DebuggerServicesPath>
      <_SharedLibrarySymbolPath>$([System.IO.Path]::GetFullPath('$(_IlcSharedAssemblyRootPath)\$(_IlcBuildType)\Native\SharedLibrary.pdb'))</_SharedLibrarySymbolPath>
    </PropertyGroup>
    <JSONEscapeStringTask InputString="$(_DebuggerServicesPath)">
      <Output TaskParameter="EscapedString" PropertyName="_JSONEncodedDebuggerServicesPath" />
    </JSONEscapeStringTask>
    <JSONEscapeStringTask InputString="$(_SharedLibrarySymbolPath)">
      <Output TaskParameter="EscapedString" PropertyName="_JSONEncodedSharedLibrarySymbolPath" />
    </JSONEscapeStringTask>
    <PropertyGroup>
      <_MSBuildUnescapedDebuggerServicesPath>$([MSBuild]::Unescape("$(_JSONEncodedDebuggerServicesPath)"))</_MSBuildUnescapedDebuggerServicesPath>
      <_MSBuildUnescapedSharedLibrarySymbolPath>$([MSBuild]::Unescape("$(_JSONEncodedSharedLibrarySymbolPath)"))</_MSBuildUnescapedSharedLibrarySymbolPath>
      <_DebuggingText>{ "DebuggerServicesPath": "$(_MSBuildUnescapedDebuggerServicesPath)", "SharedLibrarySymbolPath":"$(_MSBuildUnescapedSharedLibrarySymbolPath)" }</_DebuggingText>
      <_IntermediateDebuggerFolder>$(_IlcIntermediatePath.TrimEnd('\'))\Native</_IntermediateDebuggerFolder>
    </PropertyGroup>
    <WriteLinesToFile Condition="'$(UseNugetInstall)' == 'true' and Exists($(_IntermediateDebuggerFolder))" File="$(_IntermediateDebuggerFolder)\$(_DebuggerServicesFileName)" Lines="$(_DebuggingText)" Overwrite="true" />
    <WriteLinesToFile Condition="'$(UseNugetInstall)' == 'true'" File="$(_IlcOutputPath)\$(_DebuggerServicesFileName)" Lines="$(_DebuggingText)" Overwrite="true" />
    <!-- Preserve generated C# files in the ilc package output -->
    <ItemGroup>
      <_IlcGeneratedSource Include="$(_IlcIntermediatePath)**\*.g.cs" />
    </ItemGroup>
    <Copy SourceFiles="@(_IlcGeneratedSource)" DestinationFolder="$(_IlcOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" />
    <!-- Record intermediate and output files as file writes. -->
    <ItemGroup>
      <_IlcIntermediatePayload Include="$(_IlcIntermediatePath)**\*" />
      <_IlcOutputPayload Include="$(_IlcOutputPath)**\*" />
      <!-- Do not include manifest file in the payload -->
      <_IlcOutputPayload Remove="@(_IlcOutputPayload)" Condition="'%(Filename)%(Extension)' == '$(_AppxManifestXmlFileName)'" />
      <FileWrites Include="@(_IlcIntermediatePayload)" />
      <FileWrites Include="@(_IlcOutputPayload)" />
    </ItemGroup>
    <!-- 
      Modify appx package payload so that the native package layout produced by ilc is used for deployment,
      and produce the payload for the appxupload so that Store can compile it. 
    -->
    <ItemGroup>
      <AppxUploadPackagePayload Include="@(AppxPackagePayload)" />
      <PDBUploadPayload Include="@(_IlcInputPayload)" Condition="'%(_IlcInputPayload.Extension)' == '.pdb'" />
      <FinalAppxUploadManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxUploadManifest Include="$(_TransformedAppxManifestXmlFile)" />
      <AppxPackagePayload Remove="@(_IlcInputPayload)" />
      <AppxPackagePayload Include="@(_IlcOutputPayload)">
        <TargetPath>%(RecursiveDir)%(Filename)%(Extension)</TargetPath>
      </AppxPackagePayload>
      <AppxPackagePayload Remove="$(_IlcOutputPath)**\*.g.cs" />
      <AppxPackagePayload Remove="$(_IlcOutputPath)**\*.xr.xml" />
      <AppxPackagePayload Remove="@(_IlcOutputPayload)" Condition="'%(Filename)%(Extension)' == '$(_DebuggerServicesFileName)'" />
      <!-- Make sure we get the right PDB for sideloading -->
      <PdbPayload Remove="@(PdbPayload)" />
      <PdbPayload Include="@(_IlcOutputPayload)" Condition="'%(_IlcOutputPayload.Extension)' == '.pdb'" />
    </ItemGroup>
    <PropertyGroup>
      <ProjectPriUploadFullPath>$(ProjectPriFullPath)</ProjectPriUploadFullPath>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_TransformedAppxManifestXmlFile)')">
      <FinalAppxManifest Remove="@(FinalAppxManifest)" />
      <FinalAppxManifest Include="$(_TransformedAppxManifestXmlFile)" />
    </ItemGroup>
    <!-- 
      AppxPackage targets depend on ProjectPriFullPath being correctly set. In particular for AppxBundles 
      the _CreatePackageLayout_CalculateInputsAndOutputs target expects this property to be set to exactly what
      is contained in the AppxPackagePayload because it removes it and if the path doesn't exactly match it fails.
    -->
    <PropertyGroup Condition="Exists('$(_TransformedProjectPriFullPath)')">
      <ProjectPriFullPath>$(_TransformedProjectPriFullPath)</ProjectPriFullPath>
    </PropertyGroup>
    <OnError ExecuteTargets="LogIlcBehavioralDifference" />
  </Target>
  <Target Name="LogIlcBehavioralDifference">
    <PropertyGroup>
      <_IlcMinBehavioralExitCode>1400</_IlcMinBehavioralExitCode>
    </PropertyGroup>
    <IlcErrorTask Condition="'$(_IlcExitCode)' != '' and '$(_IlcExitCode)' &gt;= '$(_IlcMinBehavioralExitCode)'" ResourceName="Error_IlcBehavioralDifferences" />
  </Target>
  <Target Name="VerifySharedAssemblyApplicability" BeforeTargets="PrepareILCInputFolder;BeforeGenerateAppxManifest;SetIlcOptions" DependsOnTargets="ResolveNuGetPackageAssets;InjectNetCoreFramework;QueryDotNetNativeDependencySDKs;CheckForOptionalComponent" Condition="'$(_ProjectNToolchainEnabled)' == 'true' and '$(UseDotNetNativeSharedAssemblyFrameworkPackage)' == 'true'">
    <Warning Text="Warning, could not locate SharedAssemblyList.txt file @ $(_IlcSharedAssemblyDefinitionFile), and @(ILCSharedLibraryFiles) was not specified.  Defaulting to replace all assemblies." Condition="'@(ILCSharedLibraryFiles)' == '' AND !Exists('$(_IlcSharedAssemblyDefinitionFile)')" />
    <!-- Determine subset of libraries to include in shared lib -->
    <ParseILMergeInfoTask SharedAssemblyILMergeInfoFilePath="$(_IlcSharedAssemblyDefinitionFile)">
      <Output TaskParameter="SharedAssemblyComponents" ItemName="ILCSharedLibraryComponents" />
    </ParseILMergeInfoTask>
    <ItemGroup>
      <_referenceCopyLocalPathsAsFileName Include="@(AppxPackagePayload->'%(FileName)')" Condition="'%(AppxPackagePayload.OutputGroup)' == 'CopyLocalFilesOutputGroup' and '%(AppxPackagePayload.NuGetPackageId)' != ''">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </_referenceCopyLocalPathsAsFileName>
      <!-- Perform the intersection and transform back to path -->
      <_libsToReplace Include="@(_referenceCopyLocalPathsAsFileName)" Condition="'@(_referenceCopyLocalPathsAsFileName)' == '@(ILCSharedLibraryComponents)' AND '%(Identity)' != ''" />
    </ItemGroup>
    <!-- get version information from ReferenceCopyLocalPath libs -->
    <GetAssemblyIdentity AssemblyFiles="@(_libsToReplace->'%(OriginalItemSpec)')">
      <Output TaskParameter="Assemblies" ItemName="_libsToReplaceWithVersion" />
    </GetAssemblyIdentity>
    <SharedAssemblyApplicabilityVerifierTask ProjectDependencies="@(_libsToReplaceWithVersion)" SharedAssemblyContracts="@(ILCSharedLibraryComponents)">
      <Output TaskParameter="IsSharedAssemblyValid" PropertyName="UseDotNetNativeSharedAssemblyFrameworkPackage" />
    </SharedAssemblyApplicabilityVerifierTask>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NetNative.ImportAfter.targets
============================================================================================================================================
-->
  <!--<Import Project="$(DotNetNativeSharedLibraryarmProps)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeSharedLibraryarmProps)')" />-->
  <!--<Import Project="$(DotNetNativeSharedLibraryx64Props)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeSharedLibraryx64Props)')" />-->
  <!--<Import Project="$(DotNetNativeSharedLibraryx86Props)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeSharedLibraryx86Props)')" />-->
  <!--<Import Project="$(DotNetNativeSharedLibraryarmTargets)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeSharedLibraryarmTargets)')" />-->
  <!--<Import Project="$(DotNetNativeSharedLibraryx64Targets)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeSharedLibraryx64Targets)')" />-->
  <!--<Import Project="$(DotNetNativeSharedLibraryx86Targets)" Condition="'$(ProjectNProfileEnabled)' == 'true' and exists('$(DotNetNativeSharedLibraryx86Targets)')" />-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NuGet.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NuGet.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
  <PropertyGroup>
    <NuGetTargets Condition="'$(NuGetTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\NuGet\$(VisualStudioVersion)\Microsoft.NuGet.targets</NuGetTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetTargets)" Condition="Exists('$(NuGetTargets)') and '$(SkipImportNuGetBuildTargets)' != 'true'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\NuGet\17.0\Microsoft.NuGet.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NuGet.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.NuGet.Build.Tasks.ResolveNuGetPackageAssets" AssemblyFile="Microsoft.NuGet.Build.Tasks.dll" />
  <!--
  Identify the project asset/lock file in following order:
  1. If ProjectAssetsFile exists, then simply use it since it means project uses PackageReference
  2. If ProjectLockFile already defined, then use it instead of constructing our own
  3. Construct our own project lock file for that first check for <ProjectName>.project.json file
  4. And lastly check for project.json file existence, and use project.lock.json file

  If none of these conditions satisfy then these NuGet build targets will not be executed.
  -->
  <Choose>
    <When Condition="'$(ProjectAssetsFile)' != ''">
      <!-- The ProjectAssetsFile has been specified which means it uses PackageReference, so use that. -->
      <PropertyGroup>
        <ProjectLockFile>$(ProjectAssetsFile)</ProjectLockFile>
      </PropertyGroup>
    </When>
    <When Condition="'$(RestoreProjectStyle)' == 'PackageReference'">
      <!-- The RestoreProjectStyle property has been specified to PackageReference, so use that. -->
      <PropertyGroup>
        <ProjectLockFile>$(MSBuildProjectExtensionsPath)project.assets.json</ProjectLockFile>
      </PropertyGroup>
    </When>
    <When Condition="'$(ProjectLockFile)' != ''">
      <!-- The ProjectLockFile has been specified; don't compute it. -->
    </When>
    <When Condition="Exists('$(MSBuildProjectName).project.json')">
      <!-- There's a MyProj.project.json file, so use MyProj.project.lock.json. -->
      <PropertyGroup>
        <ProjectLockFile>$(MSBuildProjectName).project.lock.json</ProjectLockFile>
      </PropertyGroup>
    </When>
    <When Condition="Exists('project.json')">
      <!-- There's a project.json file, so use project.lock.json. -->
      <PropertyGroup>
        <ProjectLockFile>project.lock.json</ProjectLockFile>
      </PropertyGroup>
    </When>
    <Otherwise>
      <!-- No assets or lock file provided at all, so fallback to project.assets.json file.-->
      <PropertyGroup>
        <ProjectLockFile>$(MSBuildProjectExtensionsPath)project.assets.json</ProjectLockFile>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <!--
  The project system would prefer this to be a path relative to the project. Consider what
  happens when the user creates a new project from a template: the project is first created
  in a temporary location, and then moved to the final location. If the project system asks
  for the property between those two steps and we give it an absolute path it will end up
  watching the wrong location for updates to the lock file. However, if we give it a path
  relative to the project file then that will still be correct after the move.
  -->
  <PropertyGroup>
    <ProjectLockFile>$([MSBuild]::MakeRelative($(MSBuildProjectDirectory), $(ProjectLockFile)))</ProjectLockFile>
  </PropertyGroup>
  <!-- Add to MSBuildAllProjects in order to better support incremental builds. -->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <ResolveNuGetPackages Condition="'$(ResolveNuGetPackages)' == '' and '$(MSBuildProjectExtension)' != '.xproj'">true</ResolveNuGetPackages>
    <!-- 
    if BaseNuGetRuntimeIdentifier is defined then simply use it as RuntimeIdentifier, otherwise
    we'll set RuntimeIdentifiers to default value later on.
    -->
    <RuntimeIdentifier Condition="'$(BaseNuGetRuntimeIdentifier)' != ''">$(BaseNuGetRuntimeIdentifier)</RuntimeIdentifier>
    <BaseNuGetRuntimeIdentifier Condition="'$(BaseNuGetRuntimeIdentifier)' == '' and '$(TargetPlatformIdentifier)' == 'UAP'">win10</BaseNuGetRuntimeIdentifier>
    <BaseNuGetRuntimeIdentifier Condition="'$(BaseNuGetRuntimeIdentifier)' == ''">win</BaseNuGetRuntimeIdentifier>
    <UseTargetPlatformAsNuGetTargetMoniker Condition="'$(UseTargetPlatformAsNuGetTargetMoniker)' == '' AND '$(TargetFrameworkMoniker)' == '.NETCore,Version=v5.0'">true</UseTargetPlatformAsNuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' == 'true'">$(TargetPlatformIdentifier),Version=v$([System.Version]::Parse('$(TargetPlatformMinVersion)').ToString(3))</NuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' != 'true'">$(TargetFrameworkMoniker)</NuGetTargetMoniker>
    <CopyNuGetImplementations Condition="'$(CopyNuGetImplementations)' == '' and (('$(OutputType)' != 'library' and '$(OutputType)' != 'winmdobj') or ('$(AppxPackage)' == 'true') or '$(TargetFrameworkIdentifier)' == '.NETFramework')">true</CopyNuGetImplementations>
    <IncludeFrameworkReferencesFromNuGet Condition="'$(IncludeFrameworkReferencesFromNuGet)' == ''">true</IncludeFrameworkReferencesFromNuGet>
    <_NuGetRuntimeIdentifierPlatformTargetSuffix Condition="'$(PlatformTarget)' != '' and '$(PlatformTarget)' != 'AnyCPU'">-$(PlatformTarget.ToLower())</_NuGetRuntimeIdentifierPlatformTargetSuffix>
    <_NuGetRuntimeIdentifierWithoutAot>$(BaseNuGetRuntimeIdentifier)$(_NuGetRuntimeIdentifierPlatformTargetSuffix)</_NuGetRuntimeIdentifierWithoutAot>
  </PropertyGroup>
  <!-- If a NuGetRuntimeIdentifier wasn't already specified, let's go generate it -->
  <PropertyGroup Condition="'$(NuGetRuntimeIdentifier)' == '' and '$(CopyNuGetImplementations)' == 'true'">
    <NuGetRuntimeIdentifier>$(_NuGetRuntimeIdentifierWithoutAot)</NuGetRuntimeIdentifier>
    <NuGetRuntimeIdentifier Condition="'$(UseDotNetNativeToolchain)' == 'true'">$(_NuGetRuntimeIdentifierWithoutAot)-aot</NuGetRuntimeIdentifier>
  </PropertyGroup>
  <!-- If RuntimeIdentifiers weren't already specified for non-UAP projects, then generate it -->
  <PropertyGroup Condition="'$(BaseNuGetRuntimeIdentifier)' == 'win' and '$(NuGetRuntimeIdentifier)' != '' and '$(RuntimeIdentifiers)' == '' and '$(RuntimeIdentifier)' == ''">
    <RuntimeIdentifiers>win;win-x86;win-x64;win-arm64</RuntimeIdentifiers>
  </PropertyGroup>
  <ItemGroup>
    <!-- If we are resolving from project.lock.json, we need to consider any edit to it as something that forces a rebuild -->
    <CustomAdditionalCompileInputs Include="$(ProjectLockFile)" Condition="'$(ResolveNuGetPackages)' == 'true' and Exists('$(ProjectLockFile)')" />
  </ItemGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP'">
    <_NuGetTargetFallbackMoniker>UAP,Version=v10.0</_NuGetTargetFallbackMoniker>
    <ImplicitlyExpandTargetFramework>false</ImplicitlyExpandTargetFramework>
    <EnableAppLocalFXWorkaround>false</EnableAppLocalFXWorkaround>
    <UseNetNativeCustomFramework>true</UseNetNativeCustomFramework>
  </PropertyGroup>
  <!--
    ============================================================
                                        GetProjectsReferencingProjectJsonFiles
    ============================================================
  -->
  <Target Name="GetProjectsReferencingProjectJson" DependsOnTargets="_SplitProjectReferencesByFileExistence" Returns="@(_ProjectReferencingProjectJsonFile)">
    <ItemGroup Condition="'$(ResolveNuGetPackages)' == 'true'">
      <_ProjectReferencingProjectJsonFile Include="$(MSBuildProjectFullPath)">
        <ProjectReferences>@(ProjectReference)</ProjectReferences>
        <ProjectJson>$(MSBuildProjectDirectory)\project.json</ProjectJson>
      </_ProjectReferencingProjectJsonFile>
    </ItemGroup>
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetProjectsReferencingProjectJson" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferencingProjectJsonFile" />
    </MSBuild>
  </Target>
  <ItemGroup>
    <NuGetPreprocessorValue Include="rootnamespace">
      <Value>$(RootNamespace)</Value>
    </NuGetPreprocessorValue>
    <NuGetPreprocessorValue Include="assemblyname">
      <Value>$(AssemblyName)</Value>
    </NuGetPreprocessorValue>
    <NuGetPreprocessorValue Include="fullpath">
      <Value>$(MSBuildProjectDirectory)</Value>
    </NuGetPreprocessorValue>
    <NuGetPreprocessorValue Include="outputfilename">
      <Value>$(TargetFileName)</Value>
    </NuGetPreprocessorValue>
    <NuGetPreprocessorValue Include="filename">
      <Value>$(MSBuildProjectFile)</Value>
    </NuGetPreprocessorValue>
  </ItemGroup>
  <!--
    ============================================================
                                        ResolveNuGetPackageAssets

    Resolve assets from consumed NuGet packages listed in the project.lock.json.

    Any changes made here must also be made to ResolveNuGetPackageAssetsNonAOT, below.

        [OUT]
        @(Analyzer) - Paths to build-time diagnostic analyzers
        @(Reference) - Paths to build-time NuGet dependencies
        @(ReferenceCopyLocalPaths) - Paths to run-time dependencies to copy
    ============================================================
  -->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>$(ResolveAssemblyReferencesDependsOn);ResolveNuGetPackageAssets</ResolveAssemblyReferencesDependsOn>
    <PrepareResourcesDependsOn>ResolveNuGetPackageAssets;$(PrepareResourcesDependsOn)</PrepareResourcesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <ResolveNuGetPackageAssetsDependsOn>ResolveProjectReferences</ResolveNuGetPackageAssetsDependsOn>
    <ResolveNuGetPackageAssetsDependsOn Condition="'$(ImplicitlyExpandTargetFramework)' == 'true'">$(ResolveNuGetPackageAssetsDependsOn);ImplicitlyExpandTargetFramework</ResolveNuGetPackageAssetsDependsOn>
  </PropertyGroup>
  <Target Name="ResolveNuGetPackageAssets" DependsOnTargets="$(ResolveNuGetPackageAssetsDependsOn)" Condition="'$(ResolveNuGetPackages)' == 'true' and exists('$(ProjectLockFile)')">
    <ResolveNuGetPackageAssets AllowFallbackOnTargetSelection="$(DesignTimeBuild)" ContinueOnError="$(ContinueOnError)" IncludeFrameworkReferences="$(IncludeFrameworkReferencesFromNuGet)" NuGetPackagesDirectory="$(NuGetPackagesDirectory)" RuntimeIdentifier="$(NuGetRuntimeIdentifier)" ProjectLanguage="$(Language)" ProjectLockFile="$(ProjectLockFile)" ContentPreprocessorValues="@(NuGetPreprocessorValue)" ContentPreprocessorOutputDirectory="$(IntermediateOutputPath)\NuGet" TargetMonikers="$(NuGetTargetMoniker);$(_NuGetTargetFallbackMoniker)">
      <Output TaskParameter="ResolvedAnalyzers" ItemName="Analyzer" />
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="ResolvedReferences" ItemName="_ReferencesFromNuGetPackages" />
      <Output TaskParameter="ReferencedPackages" ItemName="ReferencedNuGetPackages" />
      <Output TaskParameter="ContentItems" ItemName="_NuGetContentItems" />
      <Output TaskParameter="FileWrites" ItemName="FileWrites" />
    </ResolveNuGetPackageAssets>
    <ItemGroup>
      <!-- Remove exact references, such as if a package had a framework reference to 'System' that we already have -->
      <Reference Remove="@(_ReferencesFromNuGetPackages)" />
      <!-- Remove simple name references that are already implicitly added -->
      <_ReferencesFromNuGetPackages Remove="%(ReferencePath.FileName)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
      <!-- Include NuGet references in the proper groups. Project-to-project references must go in the
           _ResolvedProjectReferencePaths group which matches the behavior of the ResolveProjectReferences
           target. This ensures that even if the assembly is missing on disk, it still makes it to the compiler. -->
      <Reference Include="@(_ReferencesFromNuGetPackages)" Condition="'%(_ReferencesFromNuGetPackages.NuGetSourceType)' != 'Project'" />
      <_ResolvedProjectReferencePaths Include="@(_ReferencesFromNuGetPackages)" Condition="'%(_ReferencesFromNuGetPackages.NuGetSourceType)' == 'Project'" />
      <!-- Remove simple name references if we're directly providing a reference assembly to the compiler. For example,
           consider a project with an Reference Include="System", and some NuGet package is providing System.dll -->
      <Reference Remove="%(_ReferencesFromNuGetPackages.FileName)" Condition="'%(_ReferencesFromNuGetPackages.NuGetIsFrameworkReference)' == 'false'" />
    </ItemGroup>
    <PropertyGroup Condition=" '$(AutoUnifyAssemblyReferences)' == 'true' ">
      <!-- Normally Design Time Assembly Resolution (DTAR) won't consider these references.
           Put DTAR in a mode where it will prefer the output of RAR and unify. -->
      <DTARUseReferencesFromProject>true</DTARUseReferencesFromProject>
    </PropertyGroup>
    <!-- The items in _NuGetContentItems need to go into the appropriately-named item group, but the names depend upon the items
         themselves. Split it apart. -->
    <CreateItem Include="@(_NuGetContentItems)" Condition="'@(_NuGetContentItems)' != ''">
      <Output TaskParameter="Include" ItemName="%(_NuGetContentItems.NuGetItemType)" />
    </CreateItem>
  </Target>
  <!--
    ============================================================
                                        ResolveNuGetPackageAssetsNonAOT

    Resolve assets from consumed NuGet packages listed in the project.lock.json.

    To support scenarios involving the XAML designer, always uses the non-AOT
    version of the RuntimeIdentifier.

    Any changes made here must also be made to ResolveNuGetPackageAssets, above.

        [OUT]
        @(Analyzer) - Paths to build-time diagnostic analyzers
        @(Reference) - Paths to build-time NuGet dependencies
        @(ReferenceCopyLocalPaths) - Paths to run-time dependencies to copy
    ============================================================
  -->
  <PropertyGroup>
    <_HandlePackageFileConflictsAfter>$(_HandlePackageFileConflictsAfter);ResolveNuGetPackageAssetsNonAOT</_HandlePackageFileConflictsAfter>
  </PropertyGroup>
  <Target Name="ResolveNuGetPackageAssetsNonAOT" DependsOnTargets="$(ResolveNuGetPackageAssetsDependsOn)" Condition="'$(ResolveNuGetPackages)' == 'true' and exists('$(ProjectLockFile)')">
    <ResolveNuGetPackageAssets AllowFallbackOnTargetSelection="$(DesignTimeBuild)" ContinueOnError="$(ContinueOnError)" IncludeFrameworkReferences="$(IncludeFrameworkReferencesFromNuGet)" NuGetPackagesDirectory="$(NuGetPackagesDirectory)" RuntimeIdentifier="$(_NuGetRuntimeIdentifierWithoutAot)" ProjectLanguage="$(Language)" ProjectLockFile="$(ProjectLockFile)" ContentPreprocessorValues="@(NuGetPreprocessorValue)" ContentPreprocessorOutputDirectory="$(IntermediateOutputPath)\NuGet" TargetMonikers="$(NuGetTargetMoniker);$(_NuGetTargetFallbackMoniker)">
      <Output TaskParameter="ResolvedAnalyzers" ItemName="Analyzer" />
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="ResolvedReferences" ItemName="_ReferencesFromNuGetPackages" />
      <Output TaskParameter="ReferencedPackages" ItemName="ReferencedNuGetPackages" />
      <Output TaskParameter="ContentItems" ItemName="_NuGetContentItems" />
      <Output TaskParameter="FileWrites" ItemName="FileWrites" />
    </ResolveNuGetPackageAssets>
    <ItemGroup>
      <!-- Remove exact references, such as if a package had a framework reference to 'System' that we already have -->
      <Reference Remove="@(_ReferencesFromNuGetPackages)" />
      <!-- Remove simple name references that are already implicitly added -->
      <_ReferencesFromNuGetPackages Remove="%(ReferencePath.FileName)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
      <!-- Include NuGet references in the proper groups. Project-to-project references must go in the
           _ResolvedProjectReferencePaths group which matches the behavior of the ResolveProjectReferences
           target. This ensures that even if the assembly is missing on disk, it still makes it to the compiler. -->
      <Reference Include="@(_ReferencesFromNuGetPackages)" Condition="'%(_ReferencesFromNuGetPackages.NuGetSourceType)' != 'Project'" />
      <_ResolvedProjectReferencePaths Include="@(_ReferencesFromNuGetPackages)" Condition="'%(_ReferencesFromNuGetPackages.NuGetSourceType)' == 'Project'" />
      <!-- Remove simple name references if we're directly providing a reference assembly to the compiler. For example,
           consider a project with an Reference Include="System", and some NuGet package is providing System.dll -->
      <Reference Remove="%(_ReferencesFromNuGetPackages.FileName)" Condition="'%(_ReferencesFromNuGetPackages.NuGetIsFrameworkReference)' == 'false'" />
    </ItemGroup>
    <PropertyGroup Condition=" '$(AutoUnifyAssemblyReferences)' == 'true' ">
      <!-- Normally Design Time Assembly Resolution (DTAR) won't consider these references.
           Put DTAR in a mode where it will prefer the output of RAR and unify. -->
      <DTARUseReferencesFromProject>true</DTARUseReferencesFromProject>
    </PropertyGroup>
    <!-- The items in _NuGetContentItems need to go into the appropriately-named item group, but the names depend upon the items
         themselves. Split it apart. -->
    <CreateItem Include="@(_NuGetContentItems)" Condition="'@(_NuGetContentItems)' != ''">
      <Output TaskParameter="Include" ItemName="%(_NuGetContentItems.NuGetItemType)" />
    </CreateItem>
  </Target>
  <Target Name="RuntimeImplementationProjectOutputGroup" Returns="@(RuntimeImplementationProjectOutputGroupOutput)" Condition="'$(ResolveNuGetPackages)' == 'true' and exists('$(ProjectLockFile)')" DependsOnTargets="ResolveNuGetPackageAssetsNonAOT">
    <ItemGroup>
      <RuntimeImplementationProjectOutputGroupOutput Include="%(ReferenceCopyLocalPaths.Identity)">
        <FinalOutputPath>%(ReferenceCopyLocalPaths.FullPath)</FinalOutputPath>
        <TargetPath>%(ReferenceCopyLocalPaths.FullPath)</TargetPath>
      </RuntimeImplementationProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
            Framework injection into mixed-target applications
    ============================================================
  -->
  <PropertyGroup>
    <NuGetTargetFrameworkMonikerToInject Condition="'$(NuGetTargetFrameworkMonikerToInject)' == ''">.NETCore,Version=v5.0</NuGetTargetFrameworkMonikerToInject>
    <NuGetTargetMonikerToInject Condition="$(DotNetNativeVersion.StartsWith('2.')) and '$(NuGetTargetMonikerToInject)' == ''">UAP,Version=v10.0.15138</NuGetTargetMonikerToInject>
    <NuGetTargetMonikerToInject Condition="'$(NuGetTargetMonikerToInject)' == ''">.NETCore,Version=v5.0</NuGetTargetMonikerToInject>
    <_ComputeNetCoreFrameworkInjectionParametersBeforeTargets Condition="'$(AppxPackage)' == 'true' and '$(TargetPlatformIdentifier)' == 'UAP'">BeforeGenerateProjectPriFile</_ComputeNetCoreFrameworkInjectionParametersBeforeTargets>
  </PropertyGroup>
  <Target Name="ComputeNetCoreFrameworkInjectionParameters" BeforeTargets="$(_ComputeNetCoreFrameworkInjectionParametersBeforeTargets)" DependsOnTargets="_AddUnionWinmd" Condition="'$(_ComputeNetCoreFrameworkInjectionParametersBeforeTargets)' != ''">
    <PropertyGroup>
      <_PackagingOutputsIncludesFramework Condition="'%(PackagingOutputs.FileName)%(PackagingOutputs.Extension)' == 'System.Runtime.dll'">true</_PackagingOutputsIncludesFramework>
      <_AppContainsManagedCodeForInjection Condition="'%(PackagingOutputs.Identity)' == '$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd'">true</_AppContainsManagedCodeForInjection>
      <_AppContainsManagedCodeForInjection Condition="'%(PackagingOutputs.Identity)' == '$(WindowsSDK_UnionMetadataPath)\Windows.winmd'">true</_AppContainsManagedCodeForInjection>
      <!-- In some scenarios (e.g. JavaScript UWP apps) the WindowsSDK_UnionMetadataPath may not be set. Check the target for completeness. -->
      <_AppContainsManagedCodeForInjection Condition="'%(PackagingOutputs.TargetPath)' == '$(WinMetadataDir)\Windows.winmd'">true</_AppContainsManagedCodeForInjection>
    </PropertyGroup>
    <PropertyGroup>
      <_NetCoreFrameworkInjectionNeeded Condition="'$(_PackagingOutputsIncludesFramework)' != 'true' and '$(_AppContainsManagedCodeForInjection)' == 'true'">true</_NetCoreFrameworkInjectionNeeded>
    </PropertyGroup>
  </Target>
  <Target Name="InjectNetCoreFrameworkBlockIfLockFileExists" AfterTargets="ComputeNetCoreFrameworkInjectionParameters" Condition="'$(_NetCoreFrameworkInjectionNeeded)' == 'true' and '$(ResolveNuGetPackages)' == 'true' and exists('$(ProjectLockFile)')">
    <Error Text="One of your dependencies requires the .NET Framework, but the .NET Framework could not be found in the NuGet packages installed in this project.  Please install the appropriate .NET Framework packages required by your dependency." />
  </Target>
  <Target Name="InjectNetCoreFramework" AfterTargets="ComputeNetCoreFrameworkInjectionParameters" Condition="'$(_NetCoreFrameworkInjectionNeeded)' == 'true' and ('$(ResolveNuGetPackages)' != 'true' or !Exists('$(ProjectLockFile)'))">
    <GetReferenceAssemblyPaths TargetFrameworkMoniker="$(NuGetTargetFrameworkMonikerToInject)" Condition="'$(FrameworkInjectionLockFile)' == ''">
      <Output TaskParameter="ReferenceAssemblyPaths" ItemName="_NuGetInjectionSourceDirectories" />
    </GetReferenceAssemblyPaths>
    <PropertyGroup>
      <FrameworkInjectionLockFile Condition="'$(FrameworkInjectionLockFile)' == '' and $(DotNetNativeVersion.StartsWith('1.7'))">@(_NuGetInjectionSourceDirectories->'%(Identity)\RS2.project.lock.json')</FrameworkInjectionLockFile>
      <FrameworkInjectionLockFile Condition="'$(FrameworkInjectionLockFile)' == '' and $(DotNetNativeVersion.StartsWith('2.'))">@(_NuGetInjectionSourceDirectories->'%(Identity)\RS3.project.lock.json')</FrameworkInjectionLockFile>
      <FrameworkInjectionLockFile Condition="'$(FrameworkInjectionLockFile)' == ''">@(_NuGetInjectionSourceDirectories->'%(Identity)\project.lock.json')</FrameworkInjectionLockFile>
      <!-- If the file doesn't exist try to fall back to 5.2.2 file -->
      <NuGetTargetMonikerToInject Condition="!Exists('$(FrameworkInjectionLockFile)')">.NETCore,Version=v5.0</NuGetTargetMonikerToInject>
      <FrameworkInjectionLockFile Condition="!Exists('$(FrameworkInjectionLockFile)')">@(_NuGetInjectionSourceDirectories->'%(Identity)\project.lock.json')</FrameworkInjectionLockFile>
      <FrameworkInjectionPackagesDirectory Condition="'$(FrameworkInjectionPackagesDirectory)' == '' and ($(DotNetNativeVersion.StartsWith('1.7')) or $(DotNetNativeVersion.StartsWith('2.')))">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\NuGet\Repository', 'UWPNugetPackages', null, RegistryView.Registry32, RegistryView.Default))</FrameworkInjectionPackagesDirectory>
      <FrameworkInjectionPackagesDirectory Condition="'$(FrameworkInjectionPackagesDirectory)' == ''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\NuGet\Repository', 'NetCoreSDK', null, RegistryView.Registry32, RegistryView.Default))</FrameworkInjectionPackagesDirectory>
    </PropertyGroup>
    <ResolveNuGetPackageAssets Condition="Exists('$(FrameworkInjectionLockFile)')" NuGetPackagesDirectory="$(FrameworkInjectionPackagesDirectory)" RuntimeIdentifier="$(NuGetRuntimeIdentifier)" TargetMonikers="$(NuGetTargetMonikerToInject)" ProjectLockFile="$(FrameworkInjectionLockFile)">
      <Output TaskParameter="ResolvedCopyLocalItems" ItemName="_InjectNetCoreFrameworkPayload" />
    </ResolveNuGetPackageAssets>
    <PropertyGroup>
      <_CoreRuntimePackageId Condition="'%(_InjectNetCoreFrameworkPayload.FileName)%(_InjectNetCoreFrameworkPayload.Extension)' == 'mscorlib.dll' OR '%(_InjectNetCoreFrameworkPayload.FileName)%(_InjectNetCoreFrameworkPayload.Extension)' == 'mscorlib.ni.dll'">%(_InjectNetCoreFrameworkPayload.NuGetPackageId)</_CoreRuntimePackageId>
      <!-- When restoring the framework for .NET Native 2.x, all of the assemblies are gathered and placed in the runtime package, so do not identify a package to exclude -->
      <_CoreRuntimePackageId Condition="$(DotNetNativeVersion.StartsWith('2.'))" />
    </PropertyGroup>
    <ItemGroup>
      <PackagingOutputs Include="@(_InjectNetCoreFrameworkPayload)" Condition="'%(_InjectNetCoreFrameworkPayload.NuGetPackageId)' != '$(_CoreRuntimePackageId)' or '$(UseDotNetNativeToolchain)' == 'true'">
        <TargetPath>%(Filename)%(Extension)</TargetPath>
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
      </PackagingOutputs>
    </ItemGroup>
  </Target>
  <!--<Import Project="$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.targets" Condition="Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).nuget.targets') AND '$(IncludeNuGetImports)' != 'false'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.NuGet.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.Web.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Web.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed.Web\Microsoft.Web.IISSupport.targets" Condition="('$(MvcRazorCompileOnPublish)' != '' or '$(UsingMicrosoftNETSdkWeb)' != '') and Exists('$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed.Web\Microsoft.Web.IISSupport.targets')" />-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.WebTools.Aspire.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.WebTools.Aspire.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\Microsoft\VisualStudio\WebTools.Aspire\Microsoft.WebTools.Aspire.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VisualStudio\WebTools.Aspire\Microsoft.WebTools.Aspire.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.WebTools.Aspire.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.WebTools.Aspire.MSBuild.GenerateCombinedComponentSchema" AssemblyFile="Microsoft.WebTools.Aspire.MSBuild.dll" />
  <UsingTask TaskName="Microsoft.WebTools.Aspire.MSBuild.GenerateCombinedAppSettingsSchema" AssemblyFile="Microsoft.WebTools.Aspire.MSBuild.dll" />
  <PropertyGroup>
    <JsonSchemaCombinedFilePath>$(IntermediateOutputPath)\CombinedComponentSchema.json</JsonSchemaCombinedFilePath>
    <JsonSchemaCombinedFilePath>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(JsonSchemaCombinedFilePath)))</JsonSchemaCombinedFilePath>
    <AppSettingsJsonSchemaCombinedFilePath>$(IntermediateOutputPath)\AppSettingsSchema.json</AppSettingsJsonSchemaCombinedFilePath>
    <AppSettingsJsonSchemaCombinedFilePath>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(AppSettingsJsonSchemaCombinedFilePath)))</AppSettingsJsonSchemaCombinedFilePath>
    <SchemaGenIncrementalBuildInputs>@(JsonSchemaSegment);$(ProjectAssetsFile)</SchemaGenIncrementalBuildInputs>
  </PropertyGroup>
  <Target Name="GenerateCombinedComponentSchemaTarget" Condition=" '@(JsonSchemaSegment)' != '' " Inputs="$(SchemaGenIncrementalBuildInputs)" Outputs="$(JsonSchemaCombinedFilePath)">
    <GenerateCombinedComponentSchema JsonSchemaSegmentFiles="@(JsonSchemaSegment)" JsonSchemaCombinedFilePath="$(JsonSchemaCombinedFilePath)" />
  </Target>
  <Target Name="GenerateCombinedAppSettingsSchemaTarget" DependsOnTargets="GenerateCombinedComponentSchemaTarget" Condition=" '@(JsonSchemaSegment)' != '' " BeforeTargets="CompileDesignTime" Inputs="$(SchemaGenIncrementalBuildInputs);$(JsonSchemaCombinedFilePath)" Outputs="$(AppSettingsJsonSchemaCombinedFilePath)">
    <GenerateCombinedAppSettingsSchema AppSettingJsonSchemaFilePath="$(AppSettingJsonSchemaLoadFilePath)" ComponentJsonSchemaCombinedFilePath="$(JsonSchemaCombinedFilePath)" AppSettingsJsonSchemaCombinedFilePath="$(AppSettingsJsonSchemaCombinedFilePath)" />
    <Message Text="Generating appsettingsschema" />
  </Target>
  <Target Name="CleanupCombinedAppSettingsSchemaTarget" Condition=" '@(JsonSchemaSegment)' == '' " BeforeTargets="CompileDesignTime">
    <Delete Files="$(AppSettingsJsonSchemaCombinedFilePath)" />
    <Message Text="Deleting appsettingsschema" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.WebTools.Aspire.ImportAfter.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Microsoft.Common.targets\ImportAfter\Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.CSharp.ModernNET.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
    This .targets imports the XAML compiler .targets for UWP XAML apps using modern .NET. On legacy UWP, the default UWP XAML
    template project had an 'Import' directive at the end of the .csproj file that would pull in those .targets. For apps on
    modern .NET, which use the SDK-style .csproj, we want this to be done automatically when 'UseUwpTools' is set. This property
    is the same one that controls several other opt-in features for UWP XAML apps on modern .NET (eg. single-project MSIX support).
  -->
  <PropertyGroup>
    <UwpToolsMicrosoftWindowsUIXamlCSharpTargets Condition="'$(UwpToolsMicrosoftWindowsUIXamlCSharpTargets)' == ''">$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v$(VisualStudioVersion)\8.21\Microsoft.Windows.UI.Xaml.CSharp.ModernNET.targets</UwpToolsMicrosoftWindowsUIXamlCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(UwpToolsMicrosoftWindowsUIXamlCSharpTargets)" Condition="'$(UseUwpTools)' == 'true' AND Exists('$(UwpToolsMicrosoftWindowsUIXamlCSharpTargets)') AND '$(SkipImportUwpToolsMicrosoftWindowsUIXamlCSharpTargets)' != 'true'" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.Targets
============================================================================================================================================
-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
          $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.targets

        Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
        management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup xmlns="">
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionTargets
    -->
    <ImportProjectExtensionTargets Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionTargets)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionTargets>
    <ImportProjectExtensionTargets Condition="'$(ImportProjectExtensionTargets)' == ''">true</ImportProjectExtensionTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.targets" Condition="'$(ImportProjectExtensionTargets)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.windows.cppwinrt\2.0.211028.7\build\native\Microsoft.Windows.CppWinRT.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.windows.cppwinrt\2.0.211028.7\build\native\Microsoft.Windows.CppWinRT.targets')">

C:\Users\tubbeTEC\.nuget\packages\microsoft.windows.cppwinrt\2.0.211028.7\build\native\Microsoft.Windows.CppWinRT.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Only do this for MSBuild versions below 16.0
             as it is since done automatically, see https://github.com/microsoft/msbuild/pull/3605-->
    <MSBuildAllProjects Condition="'$(MSBuildToolsVersion)'  &lt;= '15'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <CppWinRTVerbosity Condition="'$(CppWinRTVerbosity)' == ''">normal</CppWinRTVerbosity>
    <CppWinRTCommandVerbosity Condition="'$(CppWinRTVerbosity)' == 'high'">-verbose</CppWinRTCommandVerbosity>
    <CppWinRTProjectWinMD>$(OutDir)$(RootNamespace).winmd</CppWinRTProjectWinMD>
    <CppWinRTMergedDir>$(IntDir)Merged\</CppWinRTMergedDir>
    <CppWinRTUnmergedDir>$(IntDir)Unmerged\</CppWinRTUnmergedDir>
    <CppWinRTSkipUnchangedFiles Condition="'$(CppWinRTSkipUnchangedFiles)' == ''">true</CppWinRTSkipUnchangedFiles>
    <CppWinRTUseHardlinksIfPossible Condition="'$(CppWinRTUseHardlinksIfPossible)' == ''">false</CppWinRTUseHardlinksIfPossible>
    <CppWinRTWriteOnlyWhenDifferent Condition="('$(CppWinRTWriteOnlyWhenDifferent)' == '') And (('$(MSBuildToolsVersion)' == 'Current') Or ('$(MSBuildToolsVersion)' &gt;= '15'))">true</CppWinRTWriteOnlyWhenDifferent>
    <CppWinRTWriteOnlyWhenDifferent Condition="'$(CppWinRTWriteOnlyWhenDifferent)' != 'true'">false</CppWinRTWriteOnlyWhenDifferent>
    <CppWinRTHasHashTask Condition="('$(CppWinRTHasHashTask)' == '') And (('$(MSBuildToolsVersion)' == 'Current'))">true</CppWinRTHasHashTask>
    <CppWinRTHasHashTask Condition="'$(CppWinRTHasHashTask)' != 'true'">false</CppWinRTHasHashTask>
    <CppWinRTPackageDir Condition="'$(CppWinRTPackage)' == 'true' and '$(CppWinRTPackageDir)'==''">$([System.IO.Path]::GetFullPath($(MSBuildThisFileDirectory)))..\..\</CppWinRTPackageDir>
    <CppWinRTPackageDir Condition="'$(CppWinRTPackage)' != 'true' and '$(CppWinRTPackageDir)'==''">$([System.IO.Path]::GetFullPath($(MSBuildThisFileDirectory)))</CppWinRTPackageDir>
    <CppWinRTParameters Condition="'$(CppWinRTFastAbi)'=='true'">$(CppWinRTParameters) -fastabi</CppWinRTParameters>
    <CppWinRTPath Condition="'$(CppWinRTPackage)' == 'true' and '$(CppWinRTPath)'==''">"$(CppWinRTPackageDir)bin\"</CppWinRTPath>
    <CppWinRTPath Condition="'$(CppWinRTPackage)' != 'true' and '$(CppWinRTPath)'==''">"$(CppWinRTPackageDir)"</CppWinRTPath>
    <!-- By default enable C++/WinRT to include target platform winmds if we didn't overide sdk references and the C++ Project system isn't already adding them -->
    <!-- _PrepareForReferenceResolution adds the references if TargetPlatformIdentifier is UAP -->
    <CppWinRTImplicitlyExpandTargetPlatform Condition="'$(CppWinRTImplicitlyExpandTargetPlatform)' == '' and '$(CppWinRTOverrideSDKReferences)' != 'true' and '$(TargetPlatformIdentifier)' != 'UAP'">true</CppWinRTImplicitlyExpandTargetPlatform>
    <XamlLanguage Condition="'$(CppWinRTProjectLanguage)' == 'C++/CX'">C++</XamlLanguage>
    <XamlNamespace Condition="'$(XamlNamespace)' == ''">Windows.UI.Xaml</XamlNamespace>
    <XamlMetaDataProviderIdl Condition="'$(XamlMetaDataProviderIdl)'== ''">$(GeneratedFilesDir)XamlMetaDataProvider.idl</XamlMetaDataProviderIdl>
    <XamlMetaDataProviderCpp Condition="'$(XamlMetaDataProviderCpp)'== ''">$(GeneratedFilesDir)XamlMetaDataProvider.cpp</XamlMetaDataProviderCpp>
    <CppWinRTMdMergeResponseFile Condition="'$(CppWinRTMdMergeResponseFile)'==''">$(IntDir)$(MSBuildProjectFile).mdmerge.rsp</CppWinRTMdMergeResponseFile>
    <CppWinRTMidlResponseFile Condition="'$(CppWinRTMidlResponseFile)'==''">$(IntDir)$(MSBuildProjectFile).midlrt.rsp</CppWinRTMidlResponseFile>
    <CppWinRTPlatformProjectionResponseFile Condition="'$(CppWinRTPlatformProjectionResponseFile)'==''">$(IntDir)$(MSBuildProjectFile).cppwinrt_plat.rsp</CppWinRTPlatformProjectionResponseFile>
    <CppWinRTReferenceProjectionResponseFile Condition="'$(CppWinRTReferenceProjectionResponseFile)'==''">$(IntDir)$(MSBuildProjectFile).cppwinrt_ref.rsp</CppWinRTReferenceProjectionResponseFile>
    <CppWinRTComponentProjectionResponseFile Condition="'$(CppWinRTComponentProjectionResponseFile)'==''">$(IntDir)$(MSBuildProjectFile).cppwinrt_comp.rsp</CppWinRTComponentProjectionResponseFile>
    <!-- For CX projects, CppWinRT will never output a winmd-->
    <!-- NOTE: We don't set a default here as the default requires evaluation of project references
             and this is done by the CppWinRTComputeGenerateWindowsMetadata target. -->
    <CppWinRTGenerateWindowsMetadata Condition="'$(CppWinRTGenerateWindowsMetadata)' == '' AND '$(XamlLanguage)' == 'C++' ">false</CppWinRTGenerateWindowsMetadata>
    <!-- For CX projects, turn off the component projection generation-->
    <CppWinRTEnableComponentProjection Condition="'$(CppWinRTEnableComponentProjection)' == '' AND '$(XamlLanguage)' == 'C++' ">false</CppWinRTEnableComponentProjection>
    <CppWinRTEnableComponentProjection Condition="'$(CppWinRTEnableComponentProjection)' == ''">true</CppWinRTEnableComponentProjection>
    <CppWinRTEnablePlatformProjection Condition="'$(CppWinRTEnablePlatformProjection)' == ''">true</CppWinRTEnablePlatformProjection>
    <CppWinRTEnableReferenceProjection Condition="'$(CppWinRTEnableReferenceProjection)' == ''">true</CppWinRTEnableReferenceProjection>
    <GeneratedFilesDir Condition="'$(GeneratedFilesDir)' == ''">$(IntDir)Generated Files\</GeneratedFilesDir>
    <!--Override SDK's uap.props setting to ensure version-matched headers-->
    <CppWinRT_IncludePath>$(GeneratedFilesDir)</CppWinRT_IncludePath>
    <!--TEMP: Override NuGet SDK's erroneous setting in uap.props -->
    <WindowsSDK_MetadataFoundationPath Condition="('$(WindowsSDK_MetadataFoundationPath)'!='') And !Exists($(WindowsSDK_MetadataFoundationPath))">$(WindowsSDK_MetadataPathVersioned)</WindowsSDK_MetadataFoundationPath>
    <!-- CAExcludePath is used to set an environment variable, so make sure this is defined on a single line. -->
    <CAExcludePath>$(GeneratedFilesDir);$(CAExcludePath)</CAExcludePath>
    <PrepareForBuildDependsOn>
            $(PrepareForBuildDependsOn);
            CppWinRTVerifyKitVersion;
        </PrepareForBuildDependsOn>
    <!-- Note: Before* targets run before Compute* targets. -->
    <BeforeMidlCompileTargets>
            $(BeforeMidlCompileTargets);CppWinRTAddXamlMetaDataProviderIdl;
        </BeforeMidlCompileTargets>
    <ComputeMidlInputsTargets>
            $(ComputeMidlInputsTargets);CppWinRTComputeXamlGeneratedMidlInputs;CppWinRTSetMidlReferences;
        </ComputeMidlInputsTargets>
    <AfterMidlTargets>
            $(AfterMidlTargets);
            GetCppWinRTMdMergeInputs;
            CppWinRTMergeProjectWinMDInputs;
            CppWinRTGetResolvedWinMD;
            CppWinRTCopyWinMDToOutputDirectory;
        </AfterMidlTargets>
    <ResolveReferencesDependsOn>
            $(ResolveReferencesDependsOn);
            CppWinRTImplicitlyExpandTargetPlatform
        </ResolveReferencesDependsOn>
    <ResolveAssemblyReferencesDependsOn>
            $(ResolveAssemblyReferencesDependsOn);GetCppWinRTProjectWinMDReferences;CppWinRTMarkStaticLibrariesPrivate;
        </ResolveAssemblyReferencesDependsOn>
    <!-- Note: Before* targets run before Compute* targets. -->
    <BeforeClCompileTargets>
            $(BeforeClCompileTargets);CppWinRTAddXamlMetaDataProviderCpp;CppWinRTMakeProjections;
        </BeforeClCompileTargets>
    <!-- Ensure ComputeCompileInputsTargets runs at the end so that FixupCLCompileOptions is the last to run -->
    <ComputeCompileInputsTargets>
            CppWinRTComputeXamlGeneratedCompileInputs;$(ComputeCompileInputsTargets);CppWinRTHeapEnforcementOptOut;
        </ComputeCompileInputsTargets>
    <MarkupCompilePass1DependsOn>
            $(MarkupCompilePass1DependsOn);CppWinRTAddXamlReferences
        </MarkupCompilePass1DependsOn>
    <MarkupCompilePass2DependsOn>
            $(MarkupCompilePass2DependsOn);CppWinRTSetXamlLocalAssembly
        </MarkupCompilePass2DependsOn>
    <CleanDependsOn>
            $(CleanDependsOn);CppWinRTClean
        </CleanDependsOn>
    <GetTargetPathDependsOn>
            $(GetTargetPathDependsOn);CppWinRTGetResolvedWinMD
        </GetTargetPathDependsOn>
    <GetPackagingOutputsDependsOn>
            $(GetPackagingOutputsDependsOn);CppWinRTGetResolvedWinMD
        </GetPackagingOutputsDependsOn>
  </PropertyGroup>
  <!-- For a static library we don't want the winmd/lib/pdb to be packaged -->
  <PropertyGroup Condition="'$(ConfigurationType)' == 'StaticLibrary'">
    <IncludeCopyWinMDArtifactsOutputGroup>false</IncludeCopyWinMDArtifactsOutputGroup>
  </PropertyGroup>
  <Target Name="CppWinRTVerifyKitVersion" Condition="'$(CppWinRTOverrideSDKReferences)' != 'true'">
    <PropertyGroup>
      <_CppWinRT_RS4OrGreater>false</_CppWinRT_RS4OrGreater>
      <_CppWinRT_RS4OrGreater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.17134.0'">true</_CppWinRT_RS4OrGreater>
    </PropertyGroup>
    <VCMessage Code="MSB8036" Type="Error" Arguments="10.0.17134.0 (or later)" Condition="$(_CppWinRT_RS4OrGreater) != 'true'" />
  </Target>
  <Target Name="CppWinRTClean">
    <ItemGroup>
      <_FilesToDelete Remove="@(_FilesToDelete)" />
      <_FilesToDelete Include="$(GeneratedFilesDir)**" />
      <_FilesToDelete Include="$(CppWinRTMergedDir)**" />
      <_FilesToDelete Include="$(CppWinRTUnmergedDir)**" />
      <_FilesToDelete Include="$(CppWinRTProjectWinMD)" />
    </ItemGroup>
    <Delete Files="@(_FilesToDelete)" />
  </Target>
  <Target Name="CppWinRTHeapEnforcementOptOut" Condition="'@(ClCompile)' != ''">
    <ItemGroup Condition="'$(CppWinRTHeapEnforcement)'=='' and ('@(Page)' != '' Or '@(ApplicationDefinition)' != '')">
      <ClCompile>
        <AdditionalOptions>%(ClCompile.AdditionalOptions) /DWINRT_NO_MAKE_DETECTION</AdditionalOptions>
      </ClCompile>
    </ItemGroup>
  </Target>
  <!--
      The CppWinRTImplicitlyExpandTargetPlatform target will find the 
      appropriate platform in the requested SDK, gather the 
      list of references for that platform, and add them to the
      ReferencePath item which is the ItemGroup which contains
      resolved paths to pass to e.g. the compiler. 
      Xaml targets do this for UWP but for desktop,
      apps can't opt-in to WinRT doing it for them.
    -->
  <Target Name="CppWinRTImplicitlyExpandTargetPlatform" Condition="'$(CppWinRTImplicitlyExpandTargetPlatform)' == 'true'">
    <ItemGroup>
      <_TargetPlatformWinMDs Condition="'$(TargetPlatformSdkRootOverride)' != ''" Include="$(TargetPlatformSdkRootOverride)\References\$(XeWin10TargetVersion)\**\*.winmd">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>CppWinRTImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </_TargetPlatformWinMDs>
      <_TargetPlatformWinMDs Condition="'$(TargetPlatformSdkRootOverride)' == ''" Include="$(WindowsSDK_MetadataPathVersioned)\**\*.winmd">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>CppWinRTImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </_TargetPlatformWinMDs>
    </ItemGroup>
    <Warning Condition="'@(_TargetPlatformWinMDs)' == ''" Text="Could not find target platform winmds for the SDK specified by [$(SDKIdentifier), $(SDKVersion), $(TargetPlatformIdentifier), $(TargetPlatformMinVersion), $(TargetPlatformVersion)]" />
    <Message Importance="Low" Text="Including @(_TargetPlatformWinMDs)" />
    <ItemGroup>
      <ReferencePath Include="@(_TargetPlatformWinMDs)" />
      <_ResolveAssemblyReferenceResolvedFiles Include="@(_TargetPlatformWinMDs)" />
      <!-- Clear out 'temporary' variable -->
      <_TargetPlatformWinMDs Remove="@(_TargetPlatformWinMDs)" />
    </ItemGroup>
  </Target>
  <!-- Target used only to evaluate CppWinRTGenerateWindowsMetadata if it doesn't already have a value -->
  <Target Name="CppWinRTComputeGenerateWindowsMetadata" DependsOnTargets="GetCppWinRTProjectWinMDReferences;CppWinRTComputeXamlGeneratedMidlInputs;$(CppWinRTComputeGenerateWindowsMetadataDependsOn)">
    <ItemGroup>
      <_IncludedIdlForComputeGenerateWindowsMetadata Remove="@(_IncludedIdlForComputeGenerateWindowsMetadata)" />
      <_IncludedIdlForComputeGenerateWindowsMetadata Include="@(Midl)" Condition="'%(Midl.ExcludedFromBuild)' != 'true'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- For static libraries, only idl causes a winmd to be generated. 
                 For exe/dll, static libraries that produce a WinMD will be merged, 
                 so they also cause a WinMD to be generated-->
      <CppWinRTGenerateWindowsMetadata Condition="'$(ConfigurationType)' != 'StaticLibrary' AND '@(CppWinRTStaticProjectWinMDReferences)@(_IncludedIdlForComputeGenerateWindowsMetadata)'!= ''">true</CppWinRTGenerateWindowsMetadata>
      <CppWinRTGenerateWindowsMetadata Condition="'$(ConfigurationType)' == 'StaticLibrary' AND '@(_IncludedIdlForComputeGenerateWindowsMetadata)'!= ''">true</CppWinRTGenerateWindowsMetadata>
      <!-- At this point we checked all cases where we do generate a WinMD.
                 The remaining option is no WinMD. -->
      <CppWinRTGenerateWindowsMetadata Condition="'$(CppWinRTGenerateWindowsMetadata)'== ''">false</CppWinRTGenerateWindowsMetadata>
    </PropertyGroup>
  </Target>
  <Target Name="CppWinRTComputeGetResolvedWinMD" Condition="'$(CppWinRTGenerateWindowsMetadata)' == ''">
    <!-- If CppWinRTGenerateWindowsMetadata is not defined, compute it.-->
    <!-- We use Calltarget, so we don't run anything including DependsOnTargets
             targets if $(CppWinRTGenerateWindowsMetadata) already has a value.-->
    <CallTarget Targets="CppWinRTComputeGenerateWindowsMetadata" />
  </Target>
  <!-- This target hooks into the GetResolvedWinMD target used to resolve the WinMD for native projects
         so it is aware of the C++/WinRT generated WinMD.
         There is no good way to hook GetResolvedWinMD so we use BeforeTargets. -->
  <Target Name="CppWinRTGetResolvedWinMD" DependsOnTargets="CppWinRTComputeGetResolvedWinMD" BeforeTargets="GetResolvedWinMD" Returns="@(WinMDFullPath)">
    <!-- Add C++/WinRT primary WinMD to the WinMDFullPath if CppWinRTGenerateWindowsMetadata is true -->
    <ItemGroup>
      <!-- Create ItemGroup to evaluate FullPath -->
      <_CppWinRTProjectWinMDItems Include="$(CppWinRTProjectWinMD)" />
      <WinMDFullPath Include="@(_CppWinRTProjectWinMDItems-&gt;FullPath()-&gt;Distinct()-&gt;ClearMetadata())" Condition="'$(CppWinRTGenerateWindowsMetadata)' == 'true'">
        <TargetPath>$([System.IO.Path]::GetFileName('$(CppWinRTProjectWinMD)'))</TargetPath>
        <Primary>true</Primary>
        <Implementation Condition="'$(TargetExt)' == '.dll' or '$(TargetExt)' == '.exe'">$(WinMDImplementationPath)$(TargetName)$(TargetExt)</Implementation>
        <FileType>winmd</FileType>
        <WinMDFile>true</WinMDFile>
        <ProjectName>$(MSBuildProjectName)</ProjectName>
        <ProjectType>$(ConfigurationType)</ProjectType>
      </WinMDFullPath>
      <_CppWinRTProjectWinMDItems Remove="$(CppWinRTProjectWinMD)" />
    </ItemGroup>
    <Message Text="GetResolvedWinMD: @(WinMDFullPath->'%(FullPath)')" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <!-- Static library reference WinMDs are merged into the project WinMD that
         references it and might have the same name because they often share namespace. 
         Therefore they shouldn't be copied to the output folder
         because they might override files in the output folder with the
         same name, causing missing types. -->
  <Target Name="CppWinRTMarkStaticLibrariesPrivate" DependsOnTargets="ResolveProjectReferences" Returns="@(_ResolvedProjectReferencePaths)">
    <ItemGroup>
      <_ResolvedProjectReferencePaths Condition="'%(_ResolvedProjectReferencePaths.ProjectType)' == 'StaticLibrary'">
        <Private>false</Private>
      </_ResolvedProjectReferencePaths>
    </ItemGroup>
  </Target>
  <!--Define platform projection WinMD inputs-->
  <Target Name="GetCppWinRTPlatformWinMDInputs" DependsOnTargets="ResolveAssemblyReferences;GetCppWinRTPlatformWinMDReferences" Returns="@(CppWinRTPlatformWinMDInputs)">
    <ItemGroup>
      <_CppWinRTPlatformWinMDInputs Remove="@(_CppWinRTPlatformWinMDInputs)" />
      <_CppWinRTPlatformWinMDInputs Include="@(CppWinRTPlatformWinMDReferences)" />
      <CppWinRTPlatformWinMDInputs Include="@(_CppWinRTPlatformWinMDInputs)">
        <WinMDPath>%(FullPath)</WinMDPath>
      </CppWinRTPlatformWinMDInputs>
    </ItemGroup>
    <Message Text="CppWinRTPlatformWinMDInputs: @(CppWinRTPlatformWinMDInputs->'%(WinMDPath)')" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <!--Define platform WinMD references for modern IDL compilation-->
  <Target Name="GetCppWinRTPlatformWinMDReferences" DependsOnTargets="ResolveAssemblyReferences;$(GetCppWinRTPlatformWinMDReferencesDependsOn)" Returns="@(CppWinRTPlatformWinMDReferences)">
    <ItemGroup>
      <_CppWinRTPlatformWinMDReferences Remove="@(_CppWinRTPlatformWinMDReferences)" />
      <_CppWinRTPlatformWinMDReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.IsSystemReference)' == 'true' and '%(ReferencePath.WinMDFile)' == 'true' and '%(ReferencePath.ReferenceSourceTarget)' == 'ResolveAssemblyReference'" />
      <!-- Also include the winmds from the ImplicitlyExpandTargetPlatform target if it is enabled. -->
      <_CppWinRTPlatformWinMDReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.IsSystemReference)' == 'true' and '%(ReferencePath.WinMDFile)' == 'true' and '%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetPlatform'" />
      <!-- Also include the winmds from the CppWinRTImplicitlyExpandTargetPlatform target if it is enabled. -->
      <_CppWinRTPlatformWinMDReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.IsSystemReference)' == 'true' and '%(ReferencePath.WinMDFile)' == 'true' and '%(ReferencePath.ResolvedFrom)' == 'CppWinRTImplicitlyExpandTargetPlatform'" />
      <_CppWinRTPlatformWinMDReferences Include="$(CppWinRTSDKReferences)" />
      <CppWinRTPlatformWinMDReferences Remove="@(CppWinRTPlatformWinMDReferences)" />
      <CppWinRTPlatformWinMDReferences Include="@(_CppWinRTPlatformWinMDReferences-&gt;'%(FullPath)'-&gt;Distinct())">
        <WinMDPath>%(FullPath)</WinMDPath>
      </CppWinRTPlatformWinMDReferences>
    </ItemGroup>
    <Message Text="CppWinRTPlatformWinMDReferences: @(CppWinRTPlatformWinMDReferences->'%(WinMDPath)')" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <!--Get direct WinMD references (including Nuget packages) for projections, IDL processing, and AppX packaging-->
  <Target Name="GetCppWinRTDirectWinMDReferences" DependsOnTargets="ExpandSDKReferences;ResolveAssemblyReferences;$(GetCppWinRTDirectWinMDReferencesDependsOn)" Returns="@(CppWinRTDirectWinMDReferences)">
    <ItemGroup>
      <_CppWinRTDirectWinMDReferences Remove="@(_CppWinRTDirectWinMDReferences)" />
      <_CppWinRTDirectWinMDReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.IsSystemReference)' != 'true' and '%(ReferencePath.WinMDFile)' == 'true' and '%(ReferencePath.ReferenceSourceTarget)' == 'ResolveAssemblyReference'" />
      <_CppWinRTDirectWinMDReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.WinMDFile)' == 'true' and '%(ReferencePath.ReferenceSourceTarget)' == 'ExpandSDKReference'" />
      <CppWinRTDirectWinMDReferences Remove="@(CppWinRTDirectWinMDReferences)" />
      <CppWinRTDirectWinMDReferences Include="@(_CppWinRTDirectWinMDReferences)">
        <WinMDPath>%(FullPath)</WinMDPath>
      </CppWinRTDirectWinMDReferences>
    </ItemGroup>
    <Message Text="CppWinRTDirectWinMDReferences: @(CppWinRTDirectWinMDReferences->'%(WinMDPath)')" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <!--Get direct WinMD project references for projections, IDL processing, and AppX packaging-->
  <Target Name="GetCppWinRTProjectWinMDReferences" DependsOnTargets="ResolveProjectReferences;$(GetCppWinRTProjectWinMDReferencesDependsOn)" Returns="@(CppWinRTStaticProjectWinMDReferences);@(CppWinRTDynamicProjectWinMDReferences)">
    <ItemGroup>
      <!-- Get static library project references -->
      <_CppWinRTStaticProjectReferences Remove="@(_CppWinRTStaticProjectReferences)" />
      <_CppWinRTStaticProjectReferences Include="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.ProjectType)'=='StaticLibrary' AND &#xA;                    '%(_ResolvedProjectReferencePaths.WinMDFile)' == 'true'" />
      <!--Get dynamic library project references-->
      <_CppWinRTDynamicProjectReferences Remove="@(_CppWinRTDynamicProjectReferences)" />
      <_CppWinRTDynamicProjectReferences Include="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.ProjectType)'!='StaticLibrary' AND &#xA;                ('%(_ResolvedProjectReferencePaths.WinMDFile)' == 'true' OR&#xA;                    ('%(_ResolvedProjectReferencePaths.WinMDFile)' == '' AND '%(_ResolvedProjectReferencePaths.Extension)' == '.winmd'))" />
    </ItemGroup>
    <ItemGroup>
      <CppWinRTStaticProjectWinMDReferences Remove="@(CppWinRTStaticProjectWinMDReferences)" />
      <CppWinRTStaticProjectWinMDReferences Include="@(_CppWinRTStaticProjectReferences)">
        <WinMDPath>%(FullPath)</WinMDPath>
      </CppWinRTStaticProjectWinMDReferences>
      <CppWinRTDynamicProjectWinMDReferences Remove="@(CppWinRTDynamicProjectWinMDReferences)" />
      <CppWinRTDynamicProjectWinMDReferences Include="@(_CppWinRTDynamicProjectReferences)">
        <WinMDPath>%(FullPath)</WinMDPath>
      </CppWinRTDynamicProjectWinMDReferences>
    </ItemGroup>
    <Message Text="CppWinRTStaticProjectWinMDReferences: @(CppWinRTStaticProjectWinMDReferences->'%(WinMDPath)')" Importance="$(CppWinRTVerbosity)" />
    <Message Text="CppWinRTDynamicProjectWinMDReferences: @(CppWinRTDynamicProjectWinMDReferences->'%(WinMDPath)')" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <Target Name="CppWinRTResolveReferences" DependsOnTargets="GetCppWinRTPlatformWinMDReferences;GetCppWinRTDirectWinMDReferences;GetCppWinRTProjectWinMDReferences;$(CppWinRTResolveReferencesDependsOn)" />
  <!-- Calculates the input files and metadata directories to be passed to MdMerge -->
  <Target Name="GetCppWinRTMdMergeInputs" DependsOnTargets="CppWinRTResolveReferences" Returns="@(CppWinRTMdMergeMetadataDirectories);@(CppWinRTMdMergeInputs)">
    <ItemGroup>
      <_MdMergeInputs Remove="@(_MdMergeInputs)" />
      <_MdMergeInputs Include="@(Midl)" Condition="'%(Midl.ExcludedFromBuild)' != 'true'">
        <WinMDPath>%(Midl.OutputDirectory)%(Midl.MetadataFileName)</WinMDPath>
        <MdMergeOutputFile>$(CppWinRTProjectWinMD)</MdMergeOutputFile>
      </_MdMergeInputs>
      <!-- Static libraries don't mdmerge other static libraries.
                 Instead they are passed as independent inputs for the component projection. -->
      <_MdMergeInputs Include="@(CppWinRTStaticProjectWinMDReferences)" Condition="'$(ConfigurationType)' != 'StaticLibrary'">
        <MdMergeOutputFile>$(CppWinRTProjectWinMD)</MdMergeOutputFile>
      </_MdMergeInputs>
      <_MdMergeReferences Remove="@(_MdMergeReferences)" />
      <!-- Static libraries don't mdmerge other static libraries.
                 They are however used as references so idl can reference classes from other libs. -->
      <_MdMergeReferences Include="@(CppWinRTStaticProjectWinMDReferences)" Condition="'$(ConfigurationType)' == 'StaticLibrary'" />
      <_MdMergeReferences Include="@(CppWinRTDirectWinMDReferences)" />
      <_MdMergeReferences Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <_MdMergeReferences Include="@(CppWinRTPlatformWinMDReferences)" />
      <CppWinRTMdMergeMetadataDirectories Remove="@(CppWinRTMdMergeMetadataDirectories)" />
      <CppWinRTMdMergeMetadataDirectories Include="@(_MdMergeReferences-&gt;'%(RelativeDir)'-&gt;Distinct())" />
      <CppWinRTMdMergeInputs Remove="@(CppWinRTMdMergeInputs)" />
      <CppWinRTMdMergeInputs Include="@(_MdMergeInputs-&gt;'%(WinMDPath)'-&gt;Distinct())" />
    </ItemGroup>
    <Message Text="CppWinRTMdMergeInputs: @(CppWinRTMdMergeInputs)" Importance="$(CppWinRTVerbosity)" />
    <Message Text="CppWinRTMdMergeMetadataDirectories: @(CppWinRTMdMergeMetadataDirectories)" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <!-- Adds the XamlMetadataProvider idl to the Midl itemgroup, if building any xaml content -->
  <!-- Note that Condition is evaluated before DependsOnTargets are run -->
  <Target Name="CppWinRTComputeXamlGeneratedMidlInputs" DependsOnTargets="$(CppWinRTComputeXamlGeneratedMidlInputsDependsOn)" Condition="'@(Page)@(ApplicationDefinition)' != '' and '$(XamlLanguage)' == 'CppWinRT' and '$(CppWinRTAddXamlMetaDataProviderIdl)' == 'true'">
    <PropertyGroup>
      <_DisableReferences>false</_DisableReferences>
      <_DisableReferences Condition="('$(CppWinRTOverrideSDKReferences)' != 'true') and ('$(TargetPlatformVersion)' &lt; '10.0.18310.0')">true</_DisableReferences>
    </PropertyGroup>
    <ItemGroup>
      <Midl Remove="$(XamlMetaDataProviderIdl)" />
      <Midl Include="$(XamlMetaDataProviderIdl)">
        <DisableReferences Condition="$(_DisableReferences)">true</DisableReferences>
      </Midl>
    </ItemGroup>
  </Target>
  <!-- Adds the XamlMetadataProvider cpp to the ClCompile itemgroup, if building any xaml content -->
  <!-- Note that Condition is evaluated before DependsOnTargets are run -->
  <Target Name="CppWinRTComputeXamlGeneratedCompileInputs" DependsOnTargets="$(CppWinRTComputeXamlGeneratedCompileInputsDependsOn)" Condition="'@(Page)@(ApplicationDefinition)' != '' and '$(XamlLanguage)' == 'CppWinRT' and '$(CppWinRTAddXamlMetaDataProviderIdl)' == 'true'">
    <ItemGroup>
      <ClCompile Remove="$(XamlMetaDataProviderCpp)" />
      <ClCompile Include="$(XamlMetaDataProviderCpp)" Condition="'$(CppWinRTOptimized)'=='true'">
        <CompilerIteration>XamlGenerated</CompilerIteration>
      </ClCompile>
    </ItemGroup>
  </Target>
  <!--If building any Xaml content, write XamlMetaDataProvider idl file -->
  <Target Name="CppWinRTAddXamlMetaDataProviderIdl" Condition="'@(Page)@(ApplicationDefinition)' != '' and '$(XamlLanguage)' == 'CppWinRT' and '$(CppWinRTAddXamlMetaDataProviderIdl)' == 'true'">
    <PropertyGroup>
      <_DisableReferences>false</_DisableReferences>
      <_DisableReferences Condition="('$(CppWinRTOverrideSDKReferences)' != 'true') and ('$(TargetPlatformVersion)' &lt; '10.0.18310.0')">true</_DisableReferences>
      <FullXamlMetadataProviderAttribute Condition="$(XamlCodeGenerationControlFlags.Contains('FullXamlMetadataProvider'))">[$(XamlNamespace).Markup.FullXamlMetadataProvider] </FullXamlMetadataProviderAttribute>
      <XamlMarkupIdlImport Condition="$(_DisableReferences)">import "$(XamlNamespace).Markup.idl"%3b</XamlMarkupIdlImport>
      <XamlMetaDataProviderIdlLines>
// This file is generated by the build to support Xaml apps
$(XamlMarkupIdlImport)
namespace $(RootNamespace)
{
    $(FullXamlMetadataProviderAttribute)runtimeclass XamlMetaDataProvider : [default] $(XamlNamespace).Markup.IXamlMetadataProvider
    {
        XamlMetaDataProvider()%3b
    }
}
</XamlMetaDataProviderIdlLines>
    </PropertyGroup>
    <WriteLinesToFile Condition="!$(CppWinRTWriteOnlyWhenDifferent)" File="$(XamlMetaDataProviderIdl)" Lines="$(XamlMetaDataProviderIdlLines)" Overwrite="true" />
    <WriteLinesToFile Condition="$(CppWinRTWriteOnlyWhenDifferent)" File="$(XamlMetaDataProviderIdl)" Lines="$(XamlMetaDataProviderIdlLines)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <!--If building any Xaml content, write XamlMetaDataProvider cpp file -->
  <Target Name="CppWinRTAddXamlMetaDataProviderCpp" Condition="'@(Page)@(ApplicationDefinition)' != '' and '$(XamlLanguage)' == 'CppWinRT' and '$(CppWinRTAddXamlMetaDataProviderIdl)' == 'true'">
    <PropertyGroup>
      <_PCH>@(ClCompile-&gt;Metadata('PrecompiledHeaderFile')-&gt;Distinct())</_PCH>
      <XamlMetaDataProviderPch Condition="'$(_PCH)'!=''">#include "$(_PCH)"</XamlMetaDataProviderPch>
      <XamlMetaDataProviderCppLines>
// This file is generated by the build to support Xaml apps
$(XamlMetaDataProviderPch)
#include "XamlMetaDataProvider.h"
#include "XamlMetaDataProvider.g.cpp"
</XamlMetaDataProviderCppLines>
    </PropertyGroup>
    <WriteLinesToFile Condition="!$(CppWinRTWriteOnlyWhenDifferent)" File="$(XamlMetaDataProviderCpp)" Lines="$(XamlMetaDataProviderCppLines)" Overwrite="true" />
    <WriteLinesToFile Condition="$(CppWinRTWriteOnlyWhenDifferent)" File="$(XamlMetaDataProviderCpp)" Lines="$(XamlMetaDataProviderCppLines)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <!--Insert Midl /references to Platform WinMDs, library reference WinMDs, and direct reference WinMDs-->
  <Target Name="CppWinRTSetMidlReferences" Condition="'$(CppWinRTModernIDL)' != 'false'" DependsOnTargets="GetCppWinRTPlatformWinMDReferences;GetCppWinRTDirectWinMDReferences;GetCppWinRTProjectWinMDReferences;$(CppWinRTSetMidlReferencesDependsOn)" Inputs="$(MSBuildAllProjects);@(CppWinRTDirectWinMDReferences);@(CppWinRTStaticProjectWinMDReferences);@(CppWinRTDynamicProjectWinMDReferences);@(CppWinRTPlatformWinMDReferences)" Outputs="$(CppWinRTMidlResponseFile)">
    <ItemGroup>
      <_MidlReferences Remove="@(_MidlReferences)" />
      <_MidlReferences Include="@(CppWinRTDirectWinMDReferences)" />
      <_MidlReferences Include="@(CppWinRTStaticProjectWinMDReferences)" />
      <_MidlReferences Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <_MidlReferences Include="@(CppWinRTPlatformWinMDReferences)" />
      <_MidlReferencesDistinct Remove="@(_MidlReferencesDistinct)" />
      <_MidlReferencesDistinct Include="@(_MidlReferences-&gt;'%(WinMDPath)'-&gt;Distinct())" />
      <Midl Condition="'%(Midl.DisableReferences)'==''">
        <AdditionalOptions>%(Midl.AdditionalOptions) %40"$(CppWinRTMidlResponseFile)"</AdditionalOptions>
      </Midl>
    </ItemGroup>
    <PropertyGroup>
      <_MidlrtParameters>@(_MidlReferencesDistinct->'/reference "%(WinMDPath)"','
')</_MidlrtParameters>
    </PropertyGroup>
    <!-- Always write the midlrt.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(CppWinRTMidlResponseFile)" Lines="$(_MidlrtParameters)" Overwrite="true" />
    <Message Text="CppWinRTMidlReferences: @(_MidlReferences->'%(WinMDPath)')" Importance="$(CppWinRTVerbosity)" />
  </Target>
  <!--Ctrl+F7 (selected file) midl compilation support-->
  <Target Name="CppWinRTSetSelectMidlReferences" BeforeTargets="SelectMidl" DependsOnTargets="CppWinRTSetMidlReferences" />
  <!--
    ============================================================
    Generate a file used to track MdMerge dependencies between incremental build
    executions. This handles cases where items are added or removed and can't 
    otherwise be detected with timestamp comparisons. The file contains a hash of 
    MdMerge inputs that are known to contribute to incremental build inconsistencies.
    NOTE: this is not used when building with older MSBuild versions.
    ============================================================
    -->
  <Target Name="_CppWinRTGenerateMergeProjectWinMDDependencyCache" Condition="'$(CppWinRTHasHashTask)' == 'true'" DependsOnTargets="Midl;GetCppWinRTMdMergeInputs">
    <ItemGroup>
      <CustomAdditionalMdMergeInputs Include="$(IntermediateOutputPath)$(MSBuildProjectFile).MdMergeInputs.cache" />
      <MdMergeCache Include="@(CppWinRTMdMergeInputs)" />
      <MdMergeCache Include="@(Page)" />
      <MdMergeCache Include="@(ApplicationDefinition)" />
      <!-- No need to include properties here as those should be caught by having $(MSBuildAllProjects) as input to the target-->
    </ItemGroup>
    <Hash ItemsToHash="@(MdMergeCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(MdMergeCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="MdMergeDependencyHash" />
    </Hash>
    <WriteLinesToFile Condition="!$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).MdMergeInputs.cache" Lines="$(MdMergeDependencyHash)" Overwrite="true" />
    <WriteLinesToFile Condition="$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).MdMergeInputs.cache" Lines="$(MdMergeDependencyHash)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntDir)$(MSBuildProjectFile).MdMergeInputs.cache" />
    </ItemGroup>
  </Target>
  <Target Name="_CppWinRTCleanMdMergeOutputs">
    <Delete Files="$(CppWinRTMdMergeResponseFile)" />
  </Target>
  <!--Merge project-generated WinMDs and project-referenced static library WinMDs into project WinMD-->
  <Target Name="CppWinRTMergeProjectWinMDInputs" DependsOnTargets="Midl;GetCppWinRTMdMergeInputs;_CppWinRTGenerateMergeProjectWinMDDependencyCache;$(CppWinRTMergeProjectWinMDInputsDependsOn)" Inputs="$(MSBuildAllProjects);@(CppWinRTMdMergeInputs);@(CustomAdditionalMdMergeInputs)" Outputs="@(_MdMergedOutput);$(CppWinRTMdMergeResponseFile)">
    <PropertyGroup>
      <!--Note: CppWinRTNamespaceMergeDepth supersedes CppWinRTMergeDepth-->
      <_MdMergeDepth Condition="'$(CppWinRTNamespaceMergeDepth)' != ''">-n:$(CppWinRTNamespaceMergeDepth)</_MdMergeDepth>
      <_MdMergeDepth Condition="'$(_MdMergeDepth)' == ''">$(CppWinRTMergeDepth)</_MdMergeDepth>
      <_MdMergeDepth Condition="'$(_MdMergeDepth)' == '' And '$(CppWinRTRootNamespaceAutoMerge)' == 'true'">-n:$(RootNamespace.Split('.').length)</_MdMergeDepth>
      <_MdMergeDepth Condition="'$(_MdMergeDepth)' == '' And ('@(Page)' != '' Or '@(ApplicationDefinition)' != '')">-n:1</_MdMergeDepth>
      <_MdMergeCommand>$(MdMergePath)mdmerge %40"$(CppWinRTMdMergeResponseFile)"</_MdMergeCommand>
    </PropertyGroup>
    <PropertyGroup>
      <!-- mdmerge.exe wants the folders to not have a trailing \ -->
      <_MdMergeParameters Condition="'$(CppWinRTMergeNoValidate)'!='true'">-v</_MdMergeParameters>
      <_MdMergeParameters>$(_MdMergeParameters) @(CppWinRTMdMergeMetadataDirectories->'-metadata_dir "%(RelativeDir)."', '
')</_MdMergeParameters>
      <_MdMergeParameters>$(_MdMergeParameters) @(CppWinRTMdMergeInputs->'-i "%(Identity)"', '
')</_MdMergeParameters>
      <_MdMergeParameters>$(_MdMergeParameters) -o "$(CppWinRTMergedDir.TrimEnd('\'))" -partial $(_MdMergeDepth)</_MdMergeParameters>
    </PropertyGroup>
    <!-- Always write the mdmerge.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(CppWinRTMdMergeResponseFile)" Lines="$(_MdMergeParameters)" Overwrite="true" />
    <MakeDir Directories="$(CppWinRTUnmergedDir);$(CppWinRTMergedDir)" />
    <Message Text="$(_MdMergeCommand)" Importance="$(CppWinRTVerbosity)" Condition="'@(CppWinRTMdMergeInputs)' != ''" />
    <!-- Only run mdmerge.exe when we actually have inputs -->
    <Exec Command="$(_MdMergeCommand)" Condition="'@(CppWinRTMdMergeInputs)' != ''" />
    <ItemGroup>
      <_MdMergedOutput Remove="@(_MdMergedOutput)" />
      <_MdMergedOutput Include="$(CppWinRTMergedDir)*.winmd" />
    </ItemGroup>
    <Message Text="CppWinRTMdMerge output: @(MdMergeOutput)" Importance="$(CppWinRTVerbosity)" />
    <!-- Clean the output file if the target failed to indicate it needs to be rebuild -->
    <OnError ExecuteTargets="_CppWinRTCleanMdMergeOutputs" />
  </Target>
  <!-- Only copy winmd to output folder if CppWinRTGenerateWindowsMetadata is true -->
  <!-- Note that Condition is evaluated before DependsOnTargets are run -->
  <Target Name="CppWinRTCopyWinMDToOutputDirectory" Condition="'$(CppWinRTGenerateWindowsMetadata)' == 'true'" DependsOnTargets="CppWinRTMergeProjectWinMDInputs;$(CppWinRTCopyWinMDToOutputDirectoryDependsOn)" Inputs="@(_MdMergedOutput)" Outputs="$(CppWinRTProjectWinMD)">
    <Copy UseHardlinksIfPossible="$(CppWinRTUseHardlinksIfPossible)" SkipUnchangedFiles="$(CppWinRTSkipUnchangedFiles)" SourceFiles="@(_MdMergedOutput)" DestinationFiles="@(_MdMergedOutput->'$(OutDir)%(Filename)%(Extension)')" />
    <ItemGroup>
      <FileWrites Include="$(CppWinRTProjectWinMD)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Generate a file used to track C++/WinRT platform WinMD input dependencies between incremental build
    executions. This handles cases where items are added or removed and can't 
    otherwise be detected with timestamp comparisons. The file contains a hash of 
    the platform winmd inputs that are known to contribute to incremental build inconsistencies.
    NOTE: this is not used when building with older MSBuild versions.
    ============================================================
    -->
  <Target Name="_CppWinRTMakePlatformProjectionDependencyCache" Condition="'$(CppWinRTHasHashTask)' == 'true'" DependsOnTargets="CppWinRTResolveReferences;GetCppWinRTPlatformWinMDInputs">
    <ItemGroup>
      <CustomAdditionalPlatformWinMDInputs Include="$(IntDir)$(MSBuildProjectFile).cppwinrt_plat.cache" />
      <CppWinRTPlatformProjectionCache Include="@(CppWinRTPlatformWinMDInputs)" />
      <!-- No need to include properties here as those should be caught by having $(MSBuildAllProjects) as input to the target-->
    </ItemGroup>
    <Hash ItemsToHash="@(CppWinRTPlatformProjectionCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CppWinRTPlatformProjectionCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CppWinRTPlatformProjectionDependencyHash" />
    </Hash>
    <WriteLinesToFile Condition="!$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntDir)$(MSBuildProjectFile).cppwinrt_plat.cache" Lines="$(CppWinRTPlatformProjectionDependencyHash)" Overwrite="true" />
    <WriteLinesToFile Condition="$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntDir)$(MSBuildProjectFile).cppwinrt_plat.cache" Lines="$(CppWinRTPlatformProjectionDependencyHash)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntDir)$(MSBuildProjectFile).cppwinrt_plat.cache" />
    </ItemGroup>
  </Target>
  <Target Name="_CppWinRTCleanMakePlatformProjectionOutputs">
    <Delete Files="$(CppWinRTPlatformProjectionResponseFile)" />
  </Target>
  <!-- Build the platform projection from the winmds that ship with the platform in the Windows SDK -->
  <!-- Note that Condition is evaluated before DependsOnTargets are run -->
  <Target Name="CppWinRTMakePlatformProjection" Condition="'$(CppWinRTEnablePlatformProjection)' == 'true' AND '$(CppWinRTOverrideSDKReferences)' != 'true'" DependsOnTargets="CppWinRTResolveReferences;GetCppWinRTPlatformWinMDInputs;_CppWinRTMakePlatformProjectionDependencyCache;$(CppWinRTMakePlatformProjectionDependsOn)" Inputs="$(MSBuildAllProjects);@(CppWinRTPlatformWinMDInputs);@(CustomAdditionalPlatformWinMDInputs)" Outputs="$(CppWinRTPlatformProjectionResponseFile)">
    <PropertyGroup>
      <CppWinRTCommand>$(CppWinRTPath)cppwinrt %40"$(CppWinRTPlatformProjectionResponseFile)"</CppWinRTCommand>
    </PropertyGroup>
    <ItemGroup>
      <_CppwinrtInputs Remove="@(_CppwinrtInputs)" />
      <_CppwinrtInputs Include="@(CppWinRTPlatformWinMDInputs)" />
    </ItemGroup>
    <PropertyGroup>
      <_CppwinrtParameters>$(CppWinRTCommandVerbosity) $(CppWinRTParameters)</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) @(_CppwinrtInputs->'-in "%(WinMDPath)"', '
')</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) -out "$(GeneratedFilesDir)."</_CppwinrtParameters>
    </PropertyGroup>
    <!-- Always write the cppwinrt_plat.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(CppWinRTPlatformProjectionResponseFile)" Lines="$(_CppwinrtParameters)" Overwrite="true" />
    <Message Text="$(CppWinRTCommand)" Importance="$(CppWinRTVerbosity)" Condition="'@(_CppwinrtInputs)' != ''" />
    <Exec Command="$(CppWinRTCommand)" Condition="'@(_CppwinrtInputs)' != ''" />
    <!-- Clean the output file if the target failed to indicate it needs to be rebuild -->
    <OnError ExecuteTargets="_CppWinRTCleanMakePlatformProjectionOutputs" />
  </Target>
  <!--
    ============================================================
    Generate a file used to track C++/WinRT reference WinMD input dependencies between incremental build
    executions. This handles cases where items are added or removed and can't 
    otherwise be detected with timestamp comparisons. The file contains a hash of 
    the reference winmd inputs that are known to contribute to incremental build inconsistencies.
    NOTE: this is not used when building with older MSBuild versions.
    ============================================================
    -->
  <Target Name="_CppWinRTMakeReferenceProjectionDependencyCache" Condition="'$(CppWinRTHasHashTask)' == 'true'" DependsOnTargets="CppWinRTResolveReferences">
    <ItemGroup>
      <CustomAdditionalReferenceWinMDInputs Include="$(IntDir)$(MSBuildProjectFile).cppwinrt_ref.cache" />
      <CppWinRTReferenceProjectionCache Include="@(CppWinRTDirectWinMDReferences)" />
      <CppWinRTReferenceProjectionCache Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <CppWinRTReferenceProjectionCache Include="@(CppWinRTPlatformWinMDReferences)" />
      <!-- No need to include properties here as those should be caught by having $(MSBuildAllProjects) as input to the target-->
    </ItemGroup>
    <Hash ItemsToHash="@(CppWinRTReferenceProjectionCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CppWinRTReferenceProjectionCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CppWinRTReferenceProjectionDependencyHash" />
    </Hash>
    <WriteLinesToFile Condition="!$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntDir)$(MSBuildProjectFile).cppwinrt_ref.cache" Lines="$(CppWinRTReferenceProjectionDependencyHash)" Overwrite="true" />
    <WriteLinesToFile Condition="$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntDir)$(MSBuildProjectFile).cppwinrt_ref.cache" Lines="$(CppWinRTReferenceProjectionDependencyHash)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntDir)$(MSBuildProjectFile).cppwinrt_ref.cache" />
    </ItemGroup>
  </Target>
  <Target Name="_CppWinRTCleanMakeReferenceProjectionOutputs">
    <Delete Files="$(CppWinRTReferenceProjectionResponseFile)" />
  </Target>
  <!--Build reference projection from WinMD project references and dynamic library project references-->
  <!-- Note that Condition is evaluated before DependsOnTargets are run -->
  <Target Name="CppWinRTMakeReferenceProjection" Condition="'@(CppWinRTDirectWinMDReferences)@(CppWinRTDynamicProjectWinMDReferences)' != '' AND '$(CppWinRTEnableReferenceProjection)' == 'true'" DependsOnTargets="CppWinRTResolveReferences;_CppWinRTMakeReferenceProjectionDependencyCache;$(CppWinRTMakeReferenceProjectionDependsOn)" Inputs="$(MSBuildAllProjects);@(CppWinRTDirectWinMDReferences);@(CppWinRTDynamicProjectWinMDReferences);@(CppWinRTPlatformWinMDReferences);@(CustomAdditionalReferenceWinMDInputs)" Outputs="$(CppWinRTReferenceProjectionResponseFile)">
    <PropertyGroup>
      <CppWinRTCommand>$(CppWinRTPath)cppwinrt %40"$(CppWinRTReferenceProjectionResponseFile)"</CppWinRTCommand>
    </PropertyGroup>
    <ItemGroup>
      <_CppwinrtRefInputs Remove="@(_CppwinrtRefInputs)" />
      <_CppwinrtRefInputs Include="@(CppWinRTDirectWinMDReferences)" />
      <_CppwinrtRefInputs Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <_CppwinrtRefRefs Remove="@(_CppwinrtRefRefs)" />
      <_CppwinrtRefRefs Include="@(CppWinRTPlatformWinMDReferences)" />
    </ItemGroup>
    <PropertyGroup>
      <_CppwinrtParameters>$(CppWinRTCommandVerbosity) $(CppWinRTParameters)</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) @(_CppwinrtRefInputs->'-in "%(WinMDPath)"', '
')</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) @(_CppwinrtRefRefs->'-ref "%(WinMDPath)"', '
')</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) -out "$(GeneratedFilesDir)."</_CppwinrtParameters>
    </PropertyGroup>
    <!-- Always write the cppwinrt_ref.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(CppWinRTReferenceProjectionResponseFile)" Lines="$(_CppwinrtParameters)" Overwrite="true" />
    <Message Text="$(CppWinRTCommand)" Importance="$(CppWinRTVerbosity)" Condition="'@(_CppwinrtRefInputs)' != ''" />
    <Exec Command="$(CppWinRTCommand)" Condition="'@(_CppwinrtRefInputs)' != ''" />
    <!-- Clean the output file if the target failed to indicate it needs to be rebuild -->
    <OnError ExecuteTargets="_CppWinRTCleanMakeReferenceProjectionOutputs" />
  </Target>
  <!--
    ============================================================
    Generate a file used to track C++/WinRT reference WinMD input dependencies between incremental build
    executions. This handles cases where items are added or removed and can't 
    otherwise be detected with timestamp comparisons. The file contains a hash of 
    the reference winmd inputs that are known to contribute to incremental build inconsistencies.
    NOTE: this is not used when building with older MSBuild versions.
    ============================================================
    -->
  <Target Name="_CppWinRTMakeComponentProjectionDependencyCache" Condition="'$(CppWinRTHasHashTask)' == 'true'" DependsOnTargets="CppWinRTResolveReferences">
    <ItemGroup>
      <CustomAdditionalComponentWinMDInputs Include="$(IntDir)$(MSBuildProjectFile).cppwinrt_comp.cache" />
      <CppWinRTComponentProjectionCache Include="@(CppWinRTMdMergeInputs)" />
      <CppWinRTComponentProjectionCache Include="@(CppWinRTStaticProjectWinMDReferences)" />
      <CppWinRTComponentProjectionCache Include="@(CppWinRTDirectWinMDReferences)" />
      <CppWinRTComponentProjectionCache Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <CppWinRTComponentProjectionCache Include="@(CppWinRTPlatformWinMDReferences)" />
      <!-- No need to include properties here as those should be caught by having $(MSBuildAllProjects) as input to the target-->
    </ItemGroup>
    <Hash ItemsToHash="@(CppWinRTComponentProjectionCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CppWinRTComponentProjectionCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CppWinRTComponentProjectionDependencyHash" />
    </Hash>
    <WriteLinesToFile Condition="!$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntDir)$(MSBuildProjectFile).cppwinrt_comp.cache" Lines="$(CppWinRTComponentProjectionDependencyHash)" Overwrite="true" />
    <WriteLinesToFile Condition="$(CppWinRTWriteOnlyWhenDifferent)" File="$(IntDir)$(MSBuildProjectFile).cppwinrt_comp.cache" Lines="$(CppWinRTComponentProjectionDependencyHash)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntDir)$(MSBuildProjectFile).cppwinrt_comp.cache" />
    </ItemGroup>
  </Target>
  <Target Name="_CppWinRTCleanMakeComponentProjectionOutputs">
    <Delete Files="$(CppWinRTComponentProjectionResponseFile)" />
  </Target>
  <!--Build component projection from project WinMD file and static library project references-->
  <!-- Note that Condition is evaluated before DependsOnTargets are run -->
  <Target Name="CppWinRTMakeComponentProjection" Condition="'$(CppWinRTEnableComponentProjection)' == 'true'" DependsOnTargets="CppWinRTResolveReferences;GetCppWinRTMdMergeInputs;_CppWinRTMakeComponentProjectionDependencyCache;$(CppWinRTMakeComponentProjectionDependsOn)" Inputs="$(MSBuildAllProjects);@(CppWinRTMdMergeInputs);@(CppWinRTStaticProjectWinMDReferences);@(CustomAdditionalComponentWinMDInputs)" Outputs="$(CppWinRTComponentProjectionResponseFile)">
    <PropertyGroup>
      <_PCH>@(ClCompile-&gt;Metadata('PrecompiledHeaderFile')-&gt;Distinct())</_PCH>
    </PropertyGroup>
    <Error Condition="('$(CppWinRTOverrideSDKReferences)' != 'true') and ('$(TargetPlatformVersion)' &lt; '10.0.17709.0') and ('$(_PCH)' != 'pch.h')" Text="Please retarget to 10.0.17709.0 or later, or rename your PCH to 'pch.h'." />
    <PropertyGroup Condition="('$(CppWinRTOverrideSDKReferences)' == 'true') or ('$(TargetPlatformVersion)' &gt; '10.0.17708.0')">
      <CppWinRTUsePrefixes Condition="'$(CppWinRTUsePrefixes)' == ''">true</CppWinRTUsePrefixes>
      <CppWinRTPrecompiledHeader Condition="'$(CppWinRTPrecompiledHeader)' == ''">$(_PCH)</CppWinRTPrecompiledHeader>
    </PropertyGroup>
    <PropertyGroup>
      <CppWinRTCommandUsePrefixes Condition="'$(CppWinRTUsePrefixes)' == 'true'">-prefix</CppWinRTCommandUsePrefixes>
      <CppWinRTCommandPrecompiledHeader Condition="'$(CppWinRTPrecompiledHeader)' != ''">-pch $(CppWinRTPrecompiledHeader)</CppWinRTCommandPrecompiledHeader>
      <CppWinRTCommand>$(CppWinRTPath)cppwinrt %40"$(CppWinRTComponentProjectionResponseFile)"</CppWinRTCommand>
    </PropertyGroup>
    <ItemGroup>
      <!-- use the output from MdMerge directly to generate the component projection. -->
      <_MdMergedOutput Remove="@(_MdMergedOutput)" />
      <_MdMergedOutput Include="$(CppWinRTMergedDir)*.winmd" />
      <_CppwinrtCompInputs Remove="@(_CppwinrtCompInputs)" />
      <_CppwinrtCompInputs Include="@(_MdMergedOutput)">
        <WinMDPath>%(_MdMergedOutput.FullPath)</WinMDPath>
      </_CppwinrtCompInputs>
      <!-- If this is a static library with static library references,
                 pass the individual static library references to cppwinrt.exe 
                 for the component projection as they are not merged.-->
      <_CppwinrtCompInputs Include="@(CppWinRTStaticProjectWinMDReferences)" Condition="'$(ConfigurationType)' == 'StaticLibrary'">
        <WinMDPath>%(CppWinRTStaticProjectWinMDReferences.FullPath)</WinMDPath>
      </_CppwinrtCompInputs>
      <_CppwinrtCompRefs Remove="@(_CppwinrtCompRefs)" />
      <_CppwinrtCompRefs Include="@(CppWinRTDirectWinMDReferences)" />
      <_CppwinrtCompRefs Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <_CppwinrtCompRefs Include="@(CppWinRTPlatformWinMDReferences)" />
    </ItemGroup>
    <PropertyGroup>
      <_CppwinrtParameters>$(CppWinRTCommandVerbosity) $(CppWinRTParameters) -overwrite -name $(RootNamespace) $(CppWinRTCommandPrecompiledHeader) $(CppWinRTCommandUsePrefixes) -comp "$(GeneratedFilesDir)sources"</_CppwinrtParameters>
      <_CppwinrtParameters Condition="'$(CppWinRTOptimized)'=='true'">$(_CppwinrtParameters) -opt</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) @(_CppwinrtCompInputs->'-in "%(WinMDPath)"', '
')</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) @(_CppwinrtCompRefs->'-ref "%(WinMDPath)"', '
')</_CppwinrtParameters>
      <_CppwinrtParameters>$(_CppwinrtParameters) -out "$(GeneratedFilesDir)."</_CppwinrtParameters>
    </PropertyGroup>
    <!-- Always write the cppwinrt_comp.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(CppWinRTComponentProjectionResponseFile)" Lines="$(_CppwinrtParameters)" Overwrite="true" />
    <Message Text="$(CppWinRTCommand)" Importance="$(CppWinRTVerbosity)" Condition="'@(_CppwinrtCompInputs)' != ''" />
    <Exec Command="$(CppWinRTCommand)" Condition="'@(_CppwinrtCompInputs)' != ''" />
    <!-- Clean the output file if the target failed to indicate it needs to be rebuild -->
    <OnError ExecuteTargets="_CppWinRTCleanMakeComponentProjectionOutputs" />
  </Target>
  <Target Name="CppWinRTMakeProjections" DependsOnTargets="CppWinRTResolveReferences;CppWinRTMakePlatformProjection;CppWinRTMakeReferenceProjection;CppWinRTMakeComponentProjection;$(CppWinRTMakeProjectionsDependsOn)" />
  <!--Add references to all merged project WinMD files for Xaml Compiler-->
  <Target Name="CppWinRTAddXamlReferences" Condition="'@(Page)@(ApplicationDefinition)' != '' and '$(XamlLanguage)' == 'CppWinRT'" DependsOnTargets="$(CppWinRTAddXamlReferencesDependsOn)">
    <ItemGroup>
      <XamlReferencesToCompile Include="$(OutDir)*.winmd" />
    </ItemGroup>
  </Target>
  <!--Clear merged assembly and set local assembly for Xaml Compiler.
        (Note: this can be removed when CppWinRT references are removed from the Xaml targets file.)-->
  <Target Name="CppWinRTSetXamlLocalAssembly" Condition="'@(Page)@(ApplicationDefinition)' != '' and '$(XamlLanguage)' == 'CppWinRT'" DependsOnTargets="$(CppWinRTSetXamlLocalAssemblyDependsOn)">
    <PropertyGroup>
      <CppWinRTMetadataAssembly />
      <XamlLocalAssembly>$(CppWinRTProjectWinMD)</XamlLocalAssembly>
    </PropertyGroup>
  </Target>
  <!--Append any additional item metadata after all default and project settings have been applied-->
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalOptions>%(AdditionalOptions) /bigobj</AdditionalOptions>
      <AdditionalOptions Condition="'%(ClCompile.LanguageStandard)' == 'stdcpp17' And '$(CppWinRTEnableLegacyCoroutines)' != 'false'">%(AdditionalOptions) /await</AdditionalOptions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(GeneratedFilesDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Midl Condition="'$(CppWinRTModernIDL)' != 'false'">
      <AdditionalMetadataDirectories Condition="'%(AdditionalMetadataDirectories)' == '' And '$(WindowsSDK_MetadataFoundationPath)' != ''">$(WindowsSDK_MetadataFoundationPath);%(AdditionalMetadataDirectories)</AdditionalMetadataDirectories>
      <AdditionalMetadataDirectories Condition="'%(AdditionalMetadataDirectories)' == '' And '$(WindowsSDK_MetadataFoundationPath)' == ''">$(WindowsSDK_MetadataPath);%(AdditionalMetadataDirectories)</AdditionalMetadataDirectories>
      <AdditionalOptions>%(AdditionalOptions) /nomidl</AdditionalOptions>
    </Midl>
    <Link>
      <AdditionalDependencies Condition="'$(CppWinRTLibs)' != 'false'">%(AdditionalDependencies);WindowsApp.lib</AdditionalDependencies>
      <AdditionalDependencies Condition="'$(CppWinRTFastAbi)'=='true'">%(AdditionalDependencies);$(CppWinRTPackageDir)build\native\lib\$(Platform)\cppwinrt_fast_forwarder.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.web.webview2\1.0.1264.42\build\native\Microsoft.Web.WebView2.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.web.webview2\1.0.1264.42\build\native\Microsoft.Web.WebView2.targets')">

C:\Users\tubbeTEC\.nuget\packages\microsoft.web.webview2\1.0.1264.42\build\native\Microsoft.Web.WebView2.targets
============================================================================================================================================
-->
  <!-- This build\native\.targets file is used by native (C++) VS projects including win32 and UWP. -->
  <PropertyGroup>
    <WebView2ProjectKind>native</WebView2ProjectKind>
  </PropertyGroup>
  <PropertyGroup>
    <!-- The native targets file is under build\native
      so the root is two path segments up. -->
    <NugetRoot>$(MSBuildThisFileDirectory)..\..\</NugetRoot>
  </PropertyGroup>
  <!-- Example logging
  <Target Name="WebView2NativeEntryLog" BeforeTargets="Build">
    <Message Text="WebView2 native .targets file. $(NugetRoot)" Importance="high"/>
  </Target>
  -->
  <!--
============================================================================================================================================
  <Import Project="$(NugetRoot)\build\Common.targets">

C:\Users\tubbeTEC\.nuget\packages\microsoft.web.webview2\1.0.1264.42\build\Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Copyright (C) Microsoft Corporation. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Only do this for MSBuild versions below 16.0
      as it is since done automatically, see https://github.com/microsoft/msbuild/pull/3605
    -->
    <MSBuildAllProjects Condition="'$(MSBuildToolsVersion)' &lt;= '15'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <ItemGroup>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)\WebView2Rules.Project.xml" Condition="'$(VisualStudioVersion)' &gt;= '17.0' or '$(WebView2ProjectKind)' == 'native'" />
  </ItemGroup>
  <!-- The Platform property is Win32 or x64 for C++ projects. Convert from Win32 to x86 to match our directory structure.
    If PlatformTarget property is set, then use that to determine EffectivePlatform for .NET projects.
    See conditions: https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-conditions?view=vs-2019
    and PropertyGroup: https://docs.microsoft.com/en-us/visualstudio/msbuild/propertygroup-element-msbuild?view=vs-2019
  -->
  <PropertyGroup>
    <EffectivePlatform>$(Platform)</EffectivePlatform>
    <EffectivePlatform Condition="'$(Platform)' == 'Win32'">x86</EffectivePlatform>
    <EffectivePlatform Condition="'$(Platform)' == 'Any CPU'">x86</EffectivePlatform>
    <EffectivePlatform Condition="'$(Platform)' == 'AnyCPU'">x86</EffectivePlatform>
    <EffectivePlatform Condition="'$(NETCoreSdkRuntimeIdentifier)' == 'win-x86'">x86</EffectivePlatform>
    <EffectivePlatform Condition="'$(NETCoreSdkRuntimeIdentifier)' == 'win-x64'">x64</EffectivePlatform>
    <EffectivePlatform Condition="'$(PlatformTarget)' == 'x64'">x64</EffectivePlatform>
    <EffectivePlatform Condition="'$(PlatformTarget)' == 'x86'">x86</EffectivePlatform>
    <EffectivePlatform Condition="'$(PlatformTarget)' == 'Any CPU' And '$(WebView2ProjectKind)' == 'managed'">anycpu</EffectivePlatform>
    <EffectivePlatform Condition="'$(PlatformTarget)' == 'AnyCPU' And '$(WebView2ProjectKind)' == 'managed'">anycpu</EffectivePlatform>
    <!-- Some .NET projects created from Visual Studio's New Project templates don't always specify PlatformTarget (mostly library projects).
      When PlatformTarget isn't specified, the C# compiler (and presumably other .NET compilers) targets AnyCPU by default.
      However, without the line below we would end up with an EffectivePlatform of x86.
      The result was that the project's output contained an exe targeting AnyCPU, but only an x86 WebView2Loader.dll.
      Therefore, trying to run the built project on x64 or ARM64 would fail due to lack of matching WebView2Loader.dll.
      The below line fixes that problem by setting EffectivePlatform to AnyCPU if PlatformTarget isn't defined.
      I had expected that solution to break C++ projects, however, because I thought that PlatformTarget was only ever used in .NET projects.
      That prompted me to add the extra check for WebView2ProjectKind being 'managed', to limit the scope to .NET projects.
      Interestingly, testing has determined that the extra check isn't actually necessary.
      C++ projects will build successfully without that extra check, so apparently they also define/use PlatformTarget.
      I still felt safer leaving the extra check in, though, because it never makes sense for a native project to attempt to target AnyCPU.
      For the same reason, I also added the extra check to existing lines above this one which target AnyCPU.
    -->
    <EffectivePlatform Condition="'$(PlatformTarget)' == '' And '$(WebView2ProjectKind)' == 'managed'">anycpu</EffectivePlatform>
  </PropertyGroup>
  <!-- Define custom properties to provide the ability to change default WebView2 build behaviors.
    See MSBuild properties: https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties?view=vs-2019
  -->
  <PropertyGroup>
    <!-- For cases where it's non-obvious that we need to expose the WinMD (such as in a C++ non-UAP app) the dev can
      set the WebView2UseWinRT property to 'true'.
    -->
    <WebView2UseWinRT Condition="'$(WebView2UseWinRT)' == '' And '$(TargetPlatformIdentifier)' == 'UAP'">true</WebView2UseWinRT>
    <!-- Switch between using a static library or a dll for the WebView2Loader.
      'Dynamic' value to use the WebView2Loader.dll, 'Static' value to static lib.
      For WinRT, use 'None' and skip copy/link of the loader as it's already linked
      to the WebView2 WinRT component.
      For wv2winrt, if the project is running the tool, it's either:
        1. Using WebView2 WinRT, and does not need the loader
        2. Using WebView2 Win32, and needs the loader. Defaulting to include will break case below.
        3. Not using WebView2 APIs at all, and doesn't need the loader.
      We're choosing the most common scenario from (2), (3) above and defaulting to not including the loader.
    -->
    <WebView2LoaderPreference Condition="'$(WebView2LoaderPreference)' == '' And ('$(WebView2UseWinRT)' == 'true' Or '$(WebView2UseDispatchAdapter)' == 'true')">None</WebView2LoaderPreference>
    <WebView2LoaderPreference Condition="'$(WebView2LoaderPreference)' == ''">Dynamic</WebView2LoaderPreference>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NugetRoot)\build\wv2winrt.targets">

C:\Users\tubbeTEC\.nuget\packages\microsoft.web.webview2\1.0.1264.42\build\wv2winrt.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Copyright (C) Microsoft Corporation. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
***********************************************************************************************
-->
  <!-- This file contains the targets properties and such related to the wv2winrt tool. -->
  <PropertyGroup>
    <!-- Only do this for MSBuild versions below 16.0
      as it is since done automatically, see https://github.com/microsoft/msbuild/pull/3605
    -->
    <MSBuildAllProjects Condition="'$(MSBuildToolsVersion)' &lt;= '15'">$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup>
    <GeneratedFilesDir Condition="'$(GeneratedFilesDir)' == ''">$(IntDir)Generated Files\</GeneratedFilesDir>
    <WV2WinRTVerbosity Condition="'$(WV2WinRTVerbosity)' == ''">normal</WV2WinRTVerbosity>
    <WV2WinRTPath Condition="'$(WV2WinRTPath)' == ''">$([MSBuild]::NormalizeDirectory('$(MSBuildThisFileDirectory)', '..\tools\wv2winrt'))</WV2WinRTPath>
    <WV2WinRTExe Condition="'$(WV2WinRTExe)' == ''">$(WV2WinRTPath)wv2winrt.exe</WV2WinRTExe>
    <WV2WinRTWinMDInputsResponseFile Condition="'$(WV2WinRTWinMDInputsResponseFile)' == ''">$(IntDir)wv2winrt_inputs.rsp</WV2WinRTWinMDInputsResponseFile>
    <WV2WinRTParametersResponseFile Condition="'$(WV2WinRTParametersResponseFile)' == ''">$(IntDir)wv2winrt_params.rsp</WV2WinRTParametersResponseFile>
    <WV2WinRTSkipMakeProjections Condition="'$(WV2WinRTSkipMakeProjections)' == ''">false</WV2WinRTSkipMakeProjections>
    <!-- If WebView2UseWinRT is enabled, we assume the generated classes are being used in this project and put them under wv2winrt default namespace. -->
    <WebView2DispatchAdapterNamespace Condition="'$(WebView2DispatchAdapterNamespace)' == '' and '$(WebView2UseWinRT)' == 'true'">WinRTAdapter</WebView2DispatchAdapterNamespace>
    <!-- Otherwise, we assume the project will be consumed from a separate project. We put generated code under RootNamespace in this case as that's the namespace that will be automatically available when the project is referenced. -->
    <WebView2DispatchAdapterNamespace Condition="'$(WebView2DispatchAdapterNamespace)' == ''">$(RootNamespace)</WebView2DispatchAdapterNamespace>
    <WebView2DispatchAdapterOutputDir Condition="'$(WebView2DispatchAdapterOutputDir)' == ''">$(GeneratedFilesDir)</WebView2DispatchAdapterOutputDir>
    <WebView2DispatchAdapterOutputDir>$([MSBuild]::EnsureTrailingSlash('$(WebView2DispatchAdapterOutputDir)'))</WebView2DispatchAdapterOutputDir>
    <WV2WinRTDisallowEmptyAdapter Condition="'$(WV2WinRTDisallowEmptyAdapter)' == ''">true</WV2WinRTDisallowEmptyAdapter>
    <WebView2WinRTWrapSystemTypes Condition="'$(WebView2WinRTWrapSystemTypes)' == ''">true</WebView2WinRTWrapSystemTypes>
    <WV2WinRTPlatformReferencesLevel Condition="'$(WV2WinRTPlatformReferencesLevel)' == ''">match</WV2WinRTPlatformReferencesLevel>
    <!-- Note: Before* targets run before Compute* targets. -->
    <BeforeMidlCompileTargets Condition="'$(WebView2UseDispatchAdapter)' == 'true'">
        $(BeforeMidlCompileTargets);WV2WinRTAddDispatchAdapterIdl;
    </BeforeMidlCompileTargets>
    <BeforeClCompileTargets Condition="'$(WebView2UseDispatchAdapter)' == 'true'">
      $(BeforeClCompileTargets);WV2WinRTAddGeneratedFiles;
    </BeforeClCompileTargets>
  </PropertyGroup>
  <Target Name="GetWV2WinRTPlatformWinMDReferences" DependsOnTargets="ResolveAssemblyReferences;CppWinRTImplicitlyExpandTargetPlatform;GetCppWinRTPlatformWinMDReferences;$(GetWV2WinRTPlatformWinMDReferencesDependsOn)" Returns="@(WV2WinRTPlatformWinMDReferences)">
    <ItemGroup>
      <_WV2WinRTPlatformWinMDReferences Remove="@(_WV2WinRTPlatformWinMDReferences)" />
      <!-- Project platform references -->
      <_WV2WinRTPlatformWinMDReferences Include="@(ReferencePath)" Condition="('$(WV2WinRTPlatformReferencesLevel)' == 'explicit' or '$(WV2WinRTPlatformReferencesLevel)' == 'foundation') and '%(ReferencePath.IsSystemReference)' == 'true' and '%(ReferencePath.WinMDFile)' == 'true' and '%(ReferencePath.ReferenceSourceTarget)' == 'ResolveAssemblyReference'" />
      <!-- Foundation contracts -->
      <_WV2WinRTPlatformWinMDReferences Include="$(WindowsSDK_MetadataPathVersioned)\**\Windows.Foundation.FoundationContract.winmd" Condition="'$(WV2WinRTPlatformReferencesLevel)' == 'foundation'" />
      <_WV2WinRTPlatformWinMDReferences Include="$(WindowsSDK_MetadataPathVersioned)\**\Windows.Foundation.UniversalApiContract.winmd" Condition="'$(WV2WinRTPlatformReferencesLevel)' == 'foundation'" />
      <_WV2WinRTPlatformWinMDReferences Include="$(WindowsSDK_MetadataPathVersioned)\**\Windows.Networking.Connectivity.WwanContract.winmd" Condition="'$(WV2WinRTPlatformReferencesLevel)' == 'foundation'" />
      <!-- C++/WinRT -->
      <_WV2WinRTPlatformWinMDReferences Include="@(CppWinRTPlatformWinMDReferences)" Condition="'$(WV2WinRTPlatformReferencesLevel)' == 'match'" />
      <WV2WinRTPlatformWinMDReferences Remove="@(WV2WinRTPlatformWinMDReferences)" />
      <WV2WinRTPlatformWinMDReferences Include="@(_WV2WinRTPlatformWinMDReferences-&gt;'%(FullPath)'-&gt;Distinct())" />
    </ItemGroup>
    <Message Text="WV2WinRTPlatformWinMDReferences: &#xA;@(WV2WinRTPlatformWinMDReferences->'%(FullPath)', '&#xA;')" Importance="$(WV2WinRTVerbosity)" />
  </Target>
  <Target Name="GetWV2WinRTDirectWinMDReferences" DependsOnTargets="ResolveAssemblyReferences;GetCppWinRTDirectWinMDReferences;$(GetWV2WinRTDirectWinMDReferencesDependsOn)" Returns="@(WV2WinRTDirectWinMDReferences)">
    <ItemGroup>
      <_WV2WinRTDirectWinMDReferences Remove="@(_WV2WinRTDirectWinMDReferences)" />
      <_WV2WinRTDirectWinMDReferences Include="@(CppWinRTDirectWinMDReferences)" Condition="'%(Filename)' != 'Microsoft.Web.WebView2.Core'" />
      <_WV2WinRTDirectWinMDReferences Include="@(CppWinRTDirectWinMDReferences)" Condition="'%(Filename)' == 'Microsoft.Web.WebView2.Core' And '$(WV2WinRTWrapWebViewTypes)' == 'true'" />
      <WV2WinRTDirectWinMDReferences Remove="@(WV2WinRTDirectWinMDReferences)" />
      <WV2WinRTDirectWinMDReferences Include="@(_WV2WinRTDirectWinMDReferences)" />
    </ItemGroup>
    <Message Text="WV2WinRTDirectWinMDReferences: &#xA;@(WV2WinRTDirectWinMDReferences->'%(FullPath)', '&#xA;')" Importance="$(WV2WinRTVerbosity)" />
  </Target>
  <Target Name="GetWV2WinRTProjectWinMDReferences" DependsOnTargets="GetCppWinRTProjectWinMDReferences;$(GetWV2WinRTProjectWinMDReferencesDependsOn)" Returns="@(WV2WinRTProjectWinMDReferences)">
    <ItemGroup>
      <_WV2WinRTStaticProjectWinMDReferences Remove="@(_WV2WinRTStaticProjectWinMDReferences)" />
      <_WV2WinRTStaticProjectWinMDReferences Include="@(CppWinRTStaticProjectWinMDReferences)" />
      <WV2WinRTStaticProjectWinMDReferences Remove="@(WV2WinRTStaticProjectWinMDReferences)" />
      <WV2WinRTStaticProjectWinMDReferences Include="@(_WV2WinRTStaticProjectWinMDReferences)" />
    </ItemGroup>
    <ItemGroup>
      <_WV2WinRTDynamicProjectWinMDReferences Remove="@(_WV2WinRTDynamicProjectWinMDReferences)" />
      <_WV2WinRTDynamicProjectWinMDReferences Include="@(CppWinRTDynamicProjectWinMDReferences)" />
      <WV2WinRTDynamicProjectWinMDReferences Remove="@(WV2WinRTDynamicProjectWinMDReferences)" />
      <WV2WinRTDynamicProjectWinMDReferences Include="@(_WV2WinRTDynamicProjectWinMDReferences)" />
    </ItemGroup>
    <ItemGroup>
      <WV2WinRTProjectWinMDReferences Remove="@(WV2WinRTProjectWinMDReferences)" />
      <WV2WinRTProjectWinMDReferences Include="@(WV2WinRTStaticProjectWinMDReferences)" />
      <WV2WinRTProjectWinMDReferences Include="@(WV2WinRTDynamicProjectWinMDReferences)" />
    </ItemGroup>
    <Message Text="WV2WinRTStaticProjectWinMDReferences: &#xA;@(WV2WinRTStaticProjectWinMDReferences->'%(FullPath)', '&#xA;')" Condition="'$(WV2WinRTLogIntermediateWinMDReferences)' == 'true'" Importance="$(WV2WinRTVerbosity)" />
    <Message Text="WV2WinRTDynamicProjectWinMDReferences: &#xA;@(WV2WinRTDynamicProjectWinMDReferences->'%(FullPath)', '&#xA;')" Condition="'$(WV2WinRTLogIntermediateWinMDReferences)' == 'true'" Importance="$(WV2WinRTVerbosity)" />
    <Message Text="WV2WinRTProjectWinMDReferences: &#xA;@(WV2WinRTProjectWinMDReferences->'%(FullPath)', '&#xA;')" Importance="$(WV2WinRTVerbosity)" />
  </Target>
  <Target Name="GetWV2WinRTAdditionalWinMDReferences" DependsOnTargets="$(GetWV2WinRTAdditionalWinMDReferencesDependsOn)" Returns="@(WV2WinRTAdditionalWinMDReferences)">
    <ItemGroup>
      <WebView2WinRTAdditionalWinMDReferences Include="$(WebView2WinRTAdditionalWinMDReferences)" />
    </ItemGroup>
    <ItemGroup>
      <_WV2WinRTAdditionalWinMDReferences Remove="@(_WV2WinRTAdditionalWinMDReferences)" />
      <_WV2WinRTAdditionalWinMDReferences Include="@(WebView2WinRTAdditionalWinMDReferences)" />
      <WV2WinRTAdditionalWinMDReferences Remove="@(WV2WinRTAdditionalWinMDReferences)" />
      <WV2WinRTAdditionalWinMDReferences Include="@(_WV2WinRTAdditionalWinMDReferences)" />
    </ItemGroup>
    <Message Text="WV2WinRTAdditionalWinMDReferences: &#xA;@(WV2WinRTAdditionalWinMDReferences->'%(FullPath)', '&#xA;')" Importance="$(WV2WinRTVerbosity)" />
  </Target>
  <Target Name="GetWV2WinRTInputs" DependsOnTargets="GetWV2WinRTPlatformWinMDReferences;GetWV2WinRTDirectWinMDReferences;GetWV2WinRTProjectWinMDReferences;GetWV2WinRTAdditionalWinMDReferences;CppWinRTMakeComponentProjection" Outputs="$(WV2WinRTWinMDInputsResponseFile)">
    <ItemGroup>
      <_WV2WinRTInputs Remove="@(_WV2WinRTInputs)" />
      <_WV2WinRTInputs Include="@(WV2WinRTDirectWinMDReferences)" />
      <_WV2WinRTInputs Include="@(WV2WinRTPlatformWinMDReferences)" Condition="'$(WebView2WinRTWrapSystemTypes)' == 'true'" />
      <_WV2WinRTInputs Include="@(WV2WinRTProjectWinMDReferences)" />
      <_WV2WinRTInputs Include="@(WV2WinRTAdditionalWinMDReferences)" />
      <_WV2WinRTInputs Include="@(_CppwinrtCompInputs)" />
      <WV2WinRTInputs Remove="@(WV2WinRTInputs)" />
      <WV2WinRTInputs Include="@(_WV2WinRTInputs-&gt;'%(FullPath)'-&gt;Distinct())">
        <WinMDPath>%(FullPath)</WinMDPath>
      </WV2WinRTInputs>
    </ItemGroup>
    <Error Condition="'@(_WV2WinRTInputs)' == '' And '$(WV2WinRTDisallowEmptyAdapter)' == 'true'" Text="No winmd inputs for WebView2 WinRT Projection" />
    <!-- Always write the wv2winrt_inputs.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(WV2WinRTWinMDInputsResponseFile)" Lines="@(WV2WinRTInputs)" ContinueOnError="true" Overwrite="true" />
    <Message Text="WV2WinRTInputs: &#xA;@(WV2WinRTInputs->'%(WinMDPath)', '&#xA;')" Importance="$(WV2WinRTVerbosity)" />
  </Target>
  <Target Name="WV2WinRTComputeIdlParameters">
    <PropertyGroup>
      <WV2WinRTIdlParameters>--idl</WV2WinRTIdlParameters>
      <WV2WinRTIdlParameters Condition="'$(WebView2DispatchAdapterOutputDir)' != ''">$(WV2WinRTIdlParameters) --output-path "$(WebView2DispatchAdapterOutputDir.TrimEnd('\'))"</WV2WinRTIdlParameters>
      <WV2WinRTIdlParameters Condition="'$(WebView2DispatchAdapterNamespace)' != ''">$(WV2WinRTIdlParameters) --output-namespace $(WebView2DispatchAdapterNamespace)</WV2WinRTIdlParameters>
    </PropertyGroup>
  </Target>
  <Target Name="WV2WinRTGenerateDispatchAdapterIdl" DependsOnTargets="WV2WinRTComputeIdlParameters" Inputs="$(WV2WinRTExe)" Outputs="$(WebView2DispatchAdapterOutputDir)wv2winrt\DispatchAdapter.idl">
    <PropertyGroup>
      <WV2WinRTIdlCommand>"$(WV2WinRTExe)" $(WV2WinRTIdlParameters)</WV2WinRTIdlCommand>
    </PropertyGroup>
    <Message Text="$(WV2WinRTIdlCommand)" Importance="$(WV2WinRTVerbosity)" />
    <Exec Command="$(WV2WinRTIdlCommand)" />
  </Target>
  <Target Name="WV2WinRTAddDispatchAdapterIdl" DependsOnTargets="WV2WinRTGenerateDispatchAdapterIdl">
    <ItemGroup>
      <Midl Include="$(WebView2DispatchAdapterOutputDir)wv2winrt\DispatchAdapter.idl" />
    </ItemGroup>
  </Target>
  <Target Name="WV2WinRTComputeParameters" DependsOnTargets="GetWV2WinRTInputs" Inputs="$(WV2WinRTWinMDInputsResponseFile)" Outputs="$(IntDir)wv2winrt.rsp">
    <ItemGroup>
      <WV2WinRTIncludeFilters Remove="@(WV2WinRTIncludeFilters)" />
      <WV2WinRTIncludeFilters Include="$(WebView2DispatchAdapterIncludeFilters)" />
      <WV2WinRTIncludeFilters Include="@(WebView2DispatchAdapterIncludeFilters)" />
      <WV2WinRTExcludeFilters Remove="@(WV2WinRTExcludeFilters)" />
      <WV2WinRTExcludeFilters Include="$(WebView2DispatchAdapterExcludeFilters)" />
      <WV2WinRTExcludeFilters Include="@(WebView2DispatchAdapterExcludeFilters)" />
    </ItemGroup>
    <ItemGroup>
      <_PCH Include="@(ClCompile-&gt;Metadata('PrecompiledHeaderFile')-&gt;Distinct())" />
    </ItemGroup>
    <Error Condition="'@(_PCH-&gt;Count())' &gt; '1'" Text="wv2winrt only supports a single PCH." />
    <PropertyGroup>
      <_PCH>@(_PCH-&gt;Distinct())</_PCH>
    </PropertyGroup>
    <PropertyGroup>
      <WV2WinRTParameters Condition="'$(WebView2DispatchAdapterOutputDir)' != ''">--output-path "$(WebView2DispatchAdapterOutputDir.TrimEnd('\'))"</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'$(WebView2DispatchAdapterNamespace)' != ''">$(WV2WinRTParameters) --output-namespace $(WebView2DispatchAdapterNamespace)</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'$(WebView2DispatchAdapterNamespace)' != '$(RootNamespace)'">$(WV2WinRTParameters) --use-full-namespace</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'$(WebView2DispatchAdapterUseJavaScriptCase)' == 'true'">$(WV2WinRTParameters) --use-javascript-case</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'$(WV2WinRTExplicitIncludesOnly)' == 'true'">$(WV2WinRTParameters) --explicit-includes-only</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'@(WV2WinRTIncludeFilters)' != ''">$(WV2WinRTParameters) --include @(WV2WinRTIncludeFilters, ' ')</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'@(WV2WinRTExcludeFilters)' != ''">$(WV2WinRTParameters) --exclude @(WV2WinRTExcludeFilters, ' ')</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'@(WV2WinRTInputs)' != ''">$(WV2WinRTParameters) --winmd-paths @(WV2WinRTInputs->'"%(WinMDPath)"', ' ')</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'$(_PCH)' != ''">$(WV2WinRTParameters) --pch "$(_PCH)"</WV2WinRTParameters>
      <WV2WinRTParameters Condition="'$(WV2WinRTAdditionalParameters)' != ''">$(WV2WinRTParameters) $(WV2WinRTAdditionalParameters)</WV2WinRTParameters>
    </PropertyGroup>
    <!-- Always write the wv2winrt.rsp file when the target runs, because the file is used as the output of this target. -->
    <WriteLinesToFile File="$(IntDir)wv2winrt.rsp" Lines="$(WV2WinRTParameters)" ContinueOnError="true" Overwrite="true" />
  </Target>
  <Target Name="WV2WinRTMakeProjections" Condition="'$(WV2WinRTSkipMakeProjections)' != 'true'" DependsOnTargets="WV2WinRTComputeParameters" Inputs="$(IntDir)wv2winrt.rsp" Outputs="$(WebView2DispatchAdapterOutputDir)wv2winrt\**">
    <PropertyGroup>
      <WV2WinRTCommand>"$(WV2WinRTExe)" $(WV2WinRTParameters)</WV2WinRTCommand>
    </PropertyGroup>
    <Message Text="$(WV2WinRTCommand)" Importance="$(WV2WinRTVerbosity)" />
    <Exec Command="$(WV2WinRTCommand)" />
  </Target>
  <Target Name="WV2WinRTAddGeneratedFiles" DependsOnTargets="WV2WinRTMakeProjections">
    <ItemGroup>
      <_WV2WinRTFilesToBuild Remove="@(_WV2WinRTFilesToBuild)" />
      <_WV2WinRTFilesToBuild Include="$(WebView2DispatchAdapterOutputDir)wv2winrt\*.cpp" />
      <_WV2WinRTFilesToClean Include="$(WebView2DispatchAdapterOutputDir)wv2winrt\*.*" />
    </ItemGroup>
    <ItemGroup>
      <ClCompile Include="@(_WV2WinRTFilesToBuild)">
        <ObjectFileName>$(IntDir)wv2winrt\</ObjectFileName>
      </ClCompile>
      <FileWrites Include="@(_WV2WinRTFilesToClean)" Condition="'$(WV2WinRTSkipMakeProjections)' != 'true'" />
    </ItemGroup>
    <Message Text="GeneratedCppFiles: &#xA;@(_WV2WinRTFilesToBuild, '&#xA;')" Importance="$(WV2WinRTVerbosity)" />
  </Target>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(WebView2DispatchAdapterOutputDir)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.web.webview2\1.0.1264.42\build\Common.targets
============================================================================================================================================
-->
  <!-- Make our header path available in the include path.
    See CL task: https://docs.microsoft.com/en-us/visualstudio/msbuild/cl-task?view=vs-2019
  -->
  <ItemDefinitionGroup>
    <ClCompile>
      <!-- MSBuildThisFileDirectory is the path containing this targets file.
    See well-known properties: https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2019
  -->
      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)native\include\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Update link path to include appropriate arch directory and link against our lib.
    See Link task: https://docs.microsoft.com/en-us/visualstudio/msbuild/link-task?view=vs-2019
  -->
  <ItemDefinitionGroup>
    <Link Condition="'$(EffectivePlatform)' != 'ARM'">
      <WebView2LoaderLib Condition="'$(WebView2LoaderPreference)' == 'Static'">WebView2LoaderStatic.lib;version.lib</WebView2LoaderLib>
      <AdditionalDependencies>%(WebView2LoaderLib);WebView2Loader.dll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(MSBuildThisFileDirectory)native\$(EffectivePlatform);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <!-- Copy DLL to the output path.
    Only Copy DLL to the output path when project is C++ and WebView2LoaderPreference is set to Dynamic.
    .NET will pick DLL at runtime from runtime folder or processor bit folder base on Core or Framework.
    See Content: https://docs.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2019
    See Architecture-specific folders for .NET:
    https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks#architecture-specific-folders
  -->
  <ItemGroup Condition="'$(WebView2LoaderPreference)' == 'Dynamic' And '$(WebView2ProjectKind)' == 'native' And '$(EffectivePlatform)' != 'ARM'">
    <Content Include="$(MSBuildThisFileDirectory)native\$(EffectivePlatform)\WebView2Loader.dll">
      <Link>%(Filename)%(Extension)</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
      <Pack>false</Pack>
    </Content>
  </ItemGroup>
  <!-- Copy x64, x86 and arm64 WebView2Loader.dlls to sub folders in the output path. For .NET Framework we match
    the folder convention used by .NET Core for consistency.
    Microsoft.Web.WebView2.Core.dll handles loading the right DLL at runtime for Any CPU under those sub folders.
    For SDK style project, check for TargetFramework. For msbuild style, check to make sure project is not C++ and TargetFrameworkVersion equal to v after trimming all numbers and dots.
    When using WinRT, the loader is statically linked into the Microsoft.Web.WebView2.Core.dll.
    https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-target-framework-and-target-platform?view=vs-2019#target-framework-and-profile
  -->
  <ItemGroup Condition="'$(WebView2ProjectKind)' == 'managed' And '$(WebView2UseWinRT)' != 'true'">
    <Content Include="$(MSBuildThisFileDirectory)\..\runtimes\win-x86\native\WebView2Loader.dll" Condition="'$(EffectivePlatform)' == 'x86' Or '$(EffectivePlatform)' == 'anycpu'">
      <Link>runtimes\win-x86\native\WebView2Loader.dll</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Include="$(MSBuildThisFileDirectory)\..\runtimes\win-x64\native\WebView2Loader.dll" Condition="'$(EffectivePlatform)' == 'x64' Or '$(EffectivePlatform)' == 'anycpu'">
      <Link>runtimes\win-x64\native\WebView2Loader.dll</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
    <Content Include="$(MSBuildThisFileDirectory)\..\runtimes\win-arm64\native\WebView2Loader.dll" Condition="'$(EffectivePlatform)' == 'arm64' Or '$(EffectivePlatform)' == 'anycpu'">
      <Link>runtimes\win-arm64\native\WebView2Loader.dll</Link>
      <PublishState>Included</PublishState>
      <Visible>False</Visible>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <IncludeInVsix>true</IncludeInVsix>
      <Pack>false</Pack>
    </Content>
  </ItemGroup>
  <!-- Setup WinRT DLLs.
    See: https://docs.microsoft.com/en-us/nuget/guides/create-uwp-packages
  -->
  <ItemDefinitionGroup Condition="'$(WebView2UseWinRT)' == 'true'">
    <ClCompile>
      <!-- MSBuildThisFileDirectory is the path containing this targets file.
        See well-known properties: https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2019
      -->
      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)native\include-winrt\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <Choose>
    <!-- We are using a Choose/When here instead of a condition directly on the ItemGroup to workaround a VS file inclusion issue that was causing false warnings. -->
    <When Condition="'$(WebView2UseWinRT)' == 'true'">
      <ItemGroup>
        <Reference Include="$(MSBuildThisFileDirectory)..\lib\Microsoft.Web.WebView2.Core.winmd" Condition="'$(EffectivePlatform)' != 'ARM'">
          <Implementation>Microsoft.Web.WebView2.Core.dll</Implementation>
        </Reference>
        <Reference Include="$(MSBuildThisFileDirectory)..\lib\Microsoft.Web.WebView2.Core.winmd" Condition="'$(EffectivePlatform)' == 'ARM'">
          <!-- We don't support ARM, but to support builds we allow access to the winmd without specifying the implementing dll -->
        </Reference>
        <ReferenceCopyLocalPaths Include="$(MSBuildThisFileDirectory)..\runtimes\win-$(EffectivePlatform)\native_uap\Microsoft.Web.WebView2.Core.dll" Condition="'$(EffectivePlatform)' != 'ARM'" />
        <!-- We limit the SDKReference to 'UAP' because it targets 'UAP' as well, and would conflict if used in an app targeting 'Windows' -->
        <SDKReference Include="Microsoft.VCLibs.Desktop, Version=14.0" Condition="'$(TargetPlatformIdentifier)' == 'UAP'" />
      </ItemGroup>
    </When>
  </Choose>
  <!-- Cleanup our copied files when cleaning.
    See Delete: https://docs.microsoft.com/en-us/visualstudio/msbuild/delete-task?view=vs-2019
    See AfterTargets: https://docs.microsoft.com/en-us/visualstudio/msbuild/target-build-order?view=vs-2019
  -->
  <Target Name="CleanDownloadContentFiles" AfterTargets="Clean">
    <Delete Files="$(OutputPath)\WebView2Loader.dll" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.web.webview2\1.0.1264.42\build\native\Microsoft.Web.WebView2.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.ui.xaml\2.8.0\build\native\Microsoft.UI.Xaml.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.ui.xaml\2.8.0\build\native\Microsoft.UI.Xaml.targets')">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\native\Microsoft.UI.Xaml.targets
============================================================================================================================================
-->
  <!-- Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License. See LICENSE in the project root for license information. -->
  <PropertyGroup>
    <Native-Platform Condition="'$(Platform)' == 'Win32'">x86</Native-Platform>
    <Native-Platform Condition="'$(Platform)' != 'Win32'">$(Platform)</Native-Platform>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="$(MSBuildThisFileDirectory)..\..\lib\uap10.0\Microsoft.UI.Xaml.winmd" />
  </ItemGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\Microsoft.UI.Xaml.props">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\Microsoft.UI.Xaml.props
============================================================================================================================================
-->
  <!-- Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License. See LICENSE in the project root for license information. -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\MicrosoftUIXamlVersion.props">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\MicrosoftUIXamlVersion.props
============================================================================================================================================
-->
  <PropertyGroup>
    <MicrosoftUIXamlAppxVersion>8.2207.14002.0</MicrosoftUIXamlAppxVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\Microsoft.UI.Xaml.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Common.targets">

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\Common.targets
============================================================================================================================================
-->
  <!-- Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License. See LICENSE in the project root for license information. -->
  <!-- Check TargetPlatformMinVersion during build to block unsupported configurations. -->
  <Target Name="MicrosoftUIXamlCheckTargetPlatformVersion" BeforeTargets="PrepareForBuild" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetPlatformMinVersion)' != '' and '$(SkipMicrosoftUIXamlCheckTargetPlatformVersion)'==''">
    <PropertyGroup>
      <MicrosoftUIXamlTargetPlatformMinCheckValue>$([System.Version]::Parse('$(TargetPlatformMinVersion)').Build)</MicrosoftUIXamlTargetPlatformMinCheckValue>
    </PropertyGroup>
    <Error Text="Microsoft.UI.Xaml nuget package requires TargetPlatformMinVersion &gt;= 10.0.17763.0 (current project is $(MicrosoftUIXamlTargetPlatformMinCheckValue))" Condition="$(MicrosoftUIXamlTargetPlatformMinCheckValue) &lt; 17763" />
    <PropertyGroup>
      <MicrosoftUIXamlTargetPlatformCheckValue>$([System.Version]::Parse('$(TargetPlatformVersion)').Build)</MicrosoftUIXamlTargetPlatformCheckValue>
    </PropertyGroup>
    <Error Text="Microsoft.UI.Xaml nuget package requires TargetPlatformVersion &gt;= 10.0.18362.0 (current project is $(MicrosoftUIXamlTargetPlatformCheckValue))" Condition="$(MicrosoftUIXamlTargetPlatformCheckValue) &lt; 18362" />
  </Target>
  <!-- WACK certification requires that types referenced by dependent packages exist in WinMD files in the root of the AppX.
       However, the BuildNativePackage target requires that it *not* be in that location, or else that target will return an error.
       In order to enable apps to pass WACK certification that reference packages that reference us, we'll add it to the package payload
       after that target has completed. -->
  <ItemGroup>
    <XamlWinmd Include="$(MSBuildThisFileDirectory)..\lib\uap10.0\Microsoft.UI.Xaml.winmd">
      <SkipHarvestingWinmdRegistration Condition="'$(MicrosoftUIXamlAppxVersion)' != ''">true</SkipHarvestingWinmdRegistration>
      <TargetPath>Microsoft.UI.Xaml.winmd</TargetPath>
      <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
      <ProjectName>$(ProjectName)</ProjectName>
      <Implementation Condition="'$(MicrosoftUIXamlAppxVersion)' == ''">Microsoft.UI.Xaml.dll</Implementation>
    </XamlWinmd>
  </ItemGroup>
  <PropertyGroup>
    <XamlWinmdName>Microsoft.UI.Xaml.winmd</XamlWinmdName>
    <XamlCompactXbfName>Microsoft.UI.Xaml\DensityStyles\Compact.xbf</XamlCompactXbfName>
    <WebView2UseWinRT Condition="'$(WebView2UseWinRT)' ==''">true</WebView2UseWinRT>
  </PropertyGroup>
  <Target Name="_FixWinmdCopyLocal" AfterTargets="ResolveNuGetPackageAssets">
    <ItemGroup>
      <XamlWinMdCopyLocal Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)' == '$(XamlWinmdName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinMdCopyLocal)' != ''">
      <ReferenceCopyLocalPaths Remove="@(XamlWinMdCopyLocal)" />
    </ItemGroup>
  </Target>
  <Target Name="_FixWinmdPackaging" BeforeTargets="_ComputeAppxPackagePayload">
    <ItemGroup>
      <XamlWinmdPackagingOutput Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Filename)%(PackagingOutputs.Extension)' == '$(XamlWinmdName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinmdPackagingOutput)' != ''">
      <PackagingOutputs Remove="@(XamlWinmdPackagingOutput)" />
    </ItemGroup>
    <ItemGroup>
      <PackagingOutputs Include="@(XamlWinmd)" />
    </ItemGroup>
  </Target>
  <Target Name="_RemoveXamlWinmdFromWinMetadataFolder" AfterTargets="BuildNativePackage" BeforeTargets="_AddXamlWinmdToPackageLayoutRoot">
    <ItemGroup>
      <XamlWinmdAppxPackagePayload Include="@(AppxPackagePayload)" Condition="'%(AppxPackagePayload.TargetPath)' == '$(WinMetadataDir)\$(XamlWinmdName)'" />
      <XamlWinmdAppxUploadPackagePayload Include="@(AppxUploadPackagePayload)" Condition="'%(AppxUploadPackagePayload.TargetPath)' == '$(WinMetadataDir)\$(XamlWinmdName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinmdAppxPackagePayload)' != ''">
      <AppxPackagePayload Remove="@(XamlWinmdAppxPackagePayload)" />
    </ItemGroup>
    <ItemGroup Condition="'@(XamlWinmdAppxUploadPackagePayload)' != ''">
      <AppxUploadPackagePayload Remove="@(XamlWinmdAppxUploadPackagePayload)" />
    </ItemGroup>
  </Target>
  <Target Name="_AddXamlWinmdToPackageLayoutRoot" AfterTargets="BuildNativePackage">
    <ItemGroup>
      <AppxPackagePayload Include="@(XamlWinmd)">
        <TargetPath>Microsoft.UI.Xaml.winmd</TargetPath>
      </AppxPackagePayload>
      <AppxUploadPackagePayload Include="@(XamlWinmd)">
        <TargetPath>Microsoft.UI.Xaml.winmd</TargetPath>
      </AppxUploadPackagePayload>
    </ItemGroup>
    <Copy SourceFiles="@(XamlWinmd)" DestinationFiles="@(XamlWinmd -> '$(OutDir)\%(Filename)%(Extension)')" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\Microsoft.UI.Xaml.props
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\x86\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>x86</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <!-- Some C++/CX projects use Platform=Win32 instead of Platform=x86 -->
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\x86\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>Win32</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\x64\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>x64</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\arm\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>arm</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\AppX\arm64\Release\Microsoft.UI.Xaml.2.8.appx">
      <Architecture>arm64</Architecture>
      <Version>$(MicrosoftUIXamlAppxVersion)</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!-- Add a dependency for the app against VCLibs since we need it but the consuming app might be .NET only. -->
  <ItemGroup Condition="('$(OutputType)' == 'AppContainerExe')">
    <SDKReference Include="Microsoft.VCLibs, Version=14.0" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\.nuget\packages\microsoft.ui.xaml\2.8.0\build\native\Microsoft.UI.Xaml.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.javascript.hermes\0.1.27\build\native\Microsoft.JavaScript.Hermes.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.javascript.hermes\0.1.27\build\native\Microsoft.JavaScript.Hermes.targets')">

C:\Users\tubbeTEC\.nuget\packages\microsoft.javascript.hermes\0.1.27\build\native\Microsoft.JavaScript.Hermes.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <HermesPlatform Condition="'$(HermesPlatform)' == ''">$(Platform)</HermesPlatform>
    <!-- Fix platform name (win32 should be x86) -->
    <HermesPlatform Condition="'$(HermesPlatform)' == 'Win32'">x86</HermesPlatform>
    <HermesAppPlatform Condition="'$(HermesAppPlatform)' == '' and '$(AppContainerApplication)' == 'true'">uwp</HermesAppPlatform>
    <HermesAppPlatform Condition="'$(HermesAppPlatform)' == ''">win32</HermesAppPlatform>
    <NugetRoot>$(MSBuildThisFileDirectory)..\..\</NugetRoot>
    <PackageRoot>$(NugetRoot)</PackageRoot>
    <PackageRoot Condition="'$(NugetRootOverride)' != ''">$(NugetRootOverride)</PackageRoot>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(PackageRoot)\build\native\include</AdditionalIncludeDirectories>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup Condition="'$(HermesNoDLLCopy)' == ''">
    <ReferenceCopyLocalPaths Include="$(PackageRoot)build\native\$(HermesAppPlatform)\$(HermesPlatform)\hermes.dll" />
    <None Include="$(PackageRoot)build\native\$(HermesAppPlatform)\$(HermesPlatform)\hermes.dll" CopyToOutputDirectory="PreserveNewest" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\obj\anamnese-mobile.vcxproj.nuget.g.targets
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.Targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
  </PropertyGroup>
  <!--
      Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
      they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''" xmlns="">
    <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
    <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildTargets)" Condition="'$(CustomBeforeDirectoryBuildTargets)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\Directory.Build.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="">
    <!-- Some C++/RNW targets re-assign WindowsTargetPlatformVersion after Directory.Build.props.
         Enforce the installed SDK version late in evaluation. -->
    <WindowsTargetPlatformVersion>10.0.26100.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <!-- Legacy UWP C# projects use TargetPlatformVersion (not WindowsTargetPlatformVersion).
       Only set this for UAP projects to avoid breaking SDK-style .NET projects. -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP'" xmlns="">
    <TargetPlatformVersion>10.0.26100.0</TargetPlatformVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\Microsoft.Common.Targets
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterDirectoryBuildTargets)" Condition="'$(CustomAfterDirectoryBuildTargets)' != ''" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.BuildSteps.Targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Restore the property in case it is used by some extensons -->
    <DebugType>$(_DebugTypeOld)</DebugType>
  </PropertyGroup>
  <!--
    ============================================================
                                        GenerateTargetFrameworkMonikerAttribute

    Emit any specified code fragments into a temporary source file for the compiler.
    Overridden for C++ special care is needed when using precompiled headers.
    ============================================================
    -->
  <Target Name="GenerateTargetFrameworkMonikerAttribute" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildThisFileFullPath)" Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)" Condition="'$(GenerateTargetFrameworkAttribute)' == 'true'">
    <PropertyGroup>
      <!-- This attribute is only available in mscorlib v4 and later -->
      <AdditionalSourcesText Condition="'$(GenerateTargetFrameworkAttribute)' == 'true' and '$(TargetingClr2Framework)' != 'true'">
            $(AdditionalSourcesText)
#using &lt;mscorlib.dll&gt;
[assembly: System::Runtime::Versioning::TargetFrameworkAttribute(L"$(TargetFrameworkMoniker)", FrameworkDisplayName=L"$(TargetFrameworkMonikerDisplayName)")]%3b
          </AdditionalSourcesText>
    </PropertyGroup>
    <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
             and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
    <WriteLinesToFile File="$(TargetFrameworkMonikerAssemblyAttributesPath)" Lines="$(AdditionalSourcesText)" Condition="'$(AdditionalSourcesText)' != ''" ContinueOnError="true" Overwrite="true" />
    <ItemGroup>
      <ClCompile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" Condition="'@(ClCompile)' != '' and '$(AdditionalSourcesText)' != ''">
        <!-- Since we didn't emit any necessary #include "stdafx.h" or similar -->
        <PrecompiledHeader>NotUsing</PrecompiledHeader>
        <!-- Cleanup ForcedIncludeFiles as PrecompiledHeader might be using /FI and we don't want to pick up any random temp files -->
        <ForcedIncludeFiles />
        <!-- The appropriate CompileAsManaged setting will automatically be set depending on the current CLRSupport value -->
        <IncludeInUnityFile>false</IncludeInUnityFile>
      </ClCompile>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeCompileInputsTargets>
      $(ComputeCompileInputsTargets);
      GenerateTargetFrameworkMonikerAttribute;
    </ComputeCompileInputsTargets>
  </PropertyGroup>
  <!-- CPP build is done in 3 steps:
          1. Generate sources (BuildGenerateSources)
          2. Compile          (BuildCompile)
          3. Link             (BuildLink)
       Each step can be executed separately. Populate BuildSteps with one or more steps
       before importing this project to build only particular steps. -->
  <PropertyGroup>
    <EnableBuildPassesInParallel Condition="'$(EnableBuildPassesInParallel)' == '' and ('$(BuildPassReferences)' == 'true' or '$(AllowParallelCompileInReferencedProjects)' == 'true')">true</EnableBuildPassesInParallel>
    <!-- Due to circular dependency, "Build" target can't depend on "BuildGenerateSources;BuildCompile;BuildLink". -->
    <BuildSteps Condition="'$(BuildSteps)' == '' and '$(EnableBuildPassesInParallel)' == 'true'">
      ResolveReferences;
      PrepareForBuild;
      InitializeBuildStatus;
      _BuildGenerateSourcesAction;
      _BuildCompileAction;
      _BuildLinkAction;
    </BuildSteps>
    <BuildSteps Condition="'$(BuildSteps)' == ''">
      ResolveReferences;
      PrepareForBuild;
      InitializeBuildStatus;
      BuildGenerateSources;
      BuildCompile;
      BuildLink;
    </BuildSteps>
    <BuildDependsOn>
      _PrepareForBuild;
      $(BuildSteps);
      AfterBuild;
      IncrementalClean;
      TlogCleanup;
      FinalizeBuildStatus;
    </BuildDependsOn>
    <RebuildDependsOn>
      _PrepareForRebuild;
      $(RebuildDependsOn);
    </RebuildDependsOn>
    <CleanDependsOn>
      _PrepareForClean;
      $(CleanDependsOn);
    </CleanDependsOn>
  </PropertyGroup>
  <Target Name="Build" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(BuildDependsOn)" Returns="@(ManagedTargetPath);@(WinMDFullPath)">
    <ItemGroup>
      <ManagedTargetPath Include="$(TargetPath)" Condition="'$(ManagedAssembly)' == 'true' and '$(ConfigurationType)' != 'StaticLibrary'" />
    </ItemGroup>
  </Target>
  <Target Name="Rebuild" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(RebuildDependsOn)" Returns="@(ManagedTargetPath);@(WinMDFullPath)">
    <ItemGroup>
      <ManagedTargetPath Include="$(TargetPath)" Condition="'$(ManagedAssembly)' == 'true' and '$(ConfigurationType)' != 'StaticLibrary'" />
    </ItemGroup>
  </Target>
  <Target Name="_PrepareForBuild">
    <PropertyGroup>
      <BuildType Condition="'$(BuildType)' == ''">Build</BuildType>
      <_BuildActionType>Build</_BuildActionType>
    </PropertyGroup>
    <ItemGroup>
      <CustomBuild Condition="'%(CustomBuild.ExcludedFromBuild)'!='true' and '%(CustomBuild.IncludeFileToTool)'==''and '%(CustomBuild.LinkObjects)'=='true' and ('%(Extension)'=='.obj' or '%(Extension)'=='.res' or '%(Extension)'=='.rsc' or '%(Extension)'=='.lib')">
        <IncludeFileToTool Condition="'$(ConfigurationType)'=='StaticLibrary'">Lib</IncludeFileToTool>
        <IncludeFileToTool Condition="'$(ConfigurationType)'!='StaticLibrary'">Link</IncludeFileToTool>
      </CustomBuild>
    </ItemGroup>
    <!-- Add CustomBuild inputs to lib, link, or other tools. -->
    <CreateItem Include="@(CustomBuild)" Condition="'%(CustomBuild.IncludeFileToTool)'!=''">
      <Output TaskParameter="Include" ItemName="%(CustomBuild.IncludeFileToTool)" />
    </CreateItem>
    <ItemGroup>
      <!-- Remove CustomBuild ItemGroup that doesn't meet the condition. This prevents showing "Skipping target "CustomBuild" because it has no outputs. -->
      <CustomBuildStep Remove="@(CustomBuildStep)" Condition="'%(CustomBuildStep.Command)' == ''" />
      <CustomBuild Remove="@(CustomBuild)" Condition="'%(CustomBuild.Command)' == '' or '%(CustomBuild.ExcludedFromBuild)'=='true'" />
    </ItemGroup>
  </Target>
  <Target Name="_PrepareForRebuild">
    <PropertyGroup>
      <BuildType Condition="'$(BuildType)' == ''">Rebuild</BuildType>
      <_BuildActionType>Rebuild</_BuildActionType>
      <_ClCompileGenerateXMLDocumentationFiles Condition="%(ClCompile.GenerateXMLDocumentationFiles) == 'true'">true</_ClCompileGenerateXMLDocumentationFiles>
    </PropertyGroup>
    <ItemGroup>
      <CustomBuildStep Remove="@(CustomBuildStep)" Condition="'%(CustomBuildStep.Command)' == ''" />
      <CustomBuild Remove="@(CustomBuild)" Condition="'%(CustomBuild.Command)' == '' or '%(CustomBuild.ExcludedFromBuild)'=='true'" />
    </ItemGroup>
  </Target>
  <Target Name="_PrepareForClean">
    <PropertyGroup>
      <BuildType Condition="'$(BuildType)' == ''">Clean</BuildType>
      <_BuildActionType>Clean</_BuildActionType>
    </PropertyGroup>
    <Delete Files="$(LastBuildState)" Condition="Exists($(LastBuildState))" />
  </Target>
  <Target Name="AfterBuild" />
  <PropertyGroup>
    <!-- TLogLocation requires trailing slash. -->
    <_TLogProjectName>$(ProjectName)</_TLogProjectName>
    <_TLogProjectName Condition="'$(ProjectName)' != '' and '$(ProjectGuid)' != '' and '$(ProjectName.Length)' &gt; '16'">$(ProjectName.Substring(0,8)).$(ProjectGuid.Substring(1,8))</_TLogProjectName>
    <TLogLocation Condition="'$(TLogLocation)' == ''">$(IntDir)$(_TLogProjectName).tlog\</TLogLocation>
    <TLogLocation_ModuleDependencies Condition="'$(TLogLocation_ModuleDependencies)' == ''">$(IntDir)$(_TLogProjectName)_MD.tlog\</TLogLocation_ModuleDependencies>
    <LastBuildUnsuccessful>$(TLogLocation)unsuccessfulbuild</LastBuildUnsuccessful>
    <LastBuildState>$(TLogLocation)$(ProjectName).lastbuildstate</LastBuildState>
  </PropertyGroup>
  <!-- *******************************************************************************************
        BeforeBuildGenerateSources
       ******************************************************************************************* -->
  <!-- Redefine this target in your project in order to run tasks just before BuildGenerateSources -->
  <Target Name="BeforeBuildGenerateSources" />
  <PropertyGroup>
    <BeforeBuildGenerateSourcesTargets>
      $(BeforeBuildGenerateSourcesTargets);
      BeforeBuildGenerateSources;
    </BeforeBuildGenerateSourcesTargets>
    <AfterBuildGenerateSourcesTargets>
      $(AfterBuildGenerateSourcesTargets);
      AfterBuildGenerateSources;
    </AfterBuildGenerateSourcesTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        AfterBuildGenerateSources
       ******************************************************************************************* -->
  <!-- Redefine this target in your project in order to run tasks just after BuildGenerateSources -->
  <Target Name="AfterBuildGenerateSources" />
  <!-- *******************************************************************************************
        BeforeBuildCompile
       ******************************************************************************************* -->
  <!-- Redefine this target in your project in order to run tasks just before BuildCompile -->
  <Target Name="BeforeBuildCompile" />
  <!-- *******************************************************************************************
        AfterBuildCompile
       ******************************************************************************************* -->
  <!-- Redefine this target in your project in order to run tasks just after BuildCompile -->
  <Target Name="AfterBuildCompile" />
  <Target Name="LibLinkOnly" DependsOnTargets="$(CommonBuildOnlyTargets)$(BeforeBuildLinkTargets);$(BuildLibTargets);$(BuildLinkTargets);$(AfterBuildLinkTargets)" />
  <!-- *******************************************************************************************
          Utility targets to get files from project from another project using the MSBuild task
       ******************************************************************************************* -->
  <Target Name="GetClCompile" Returns="@(ClCompile)" />
  <Target Name="GetResourceCompile" Returns="@(ResourceCompile)" />
  <Target Name="GetMidl" Returns="@(Midl)" />
  <Target Name="GetImpLib" Returns="@(ImpLib)" />
  <Target Name="GetLib" Returns="@(Lib)" />
  <Target Name="GetLink" Returns="@(Link)" />
  <Target Name="GetCustomBuild" Returns="@(CustomBuild)" />
  <Target Name="GetXsd" Returns="@(Xsd)" />
  <Target Name="GetXdcMake" Returns="@(XdcMake)" />
  <Target Name="GetBscMake" Returns="@(BscMake)" />
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppBuild.targets
============================================================================================================================================
-->
  <!-- Global up-to-date check support -->
  <PropertyGroup Condition="'$(UseSolutionDirInProjectEvaluationFingerprint)' != 'false'">
    <ProjectEvaluationFingerprint>$(Configuration)|$(Platform)|$(SolutionDir)|$(ProjectEvaluationFingerprint)</ProjectEvaluationFingerprint>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseSolutionDirInProjectEvaluationFingerprint)' == 'false'">
    <ProjectEvaluationFingerprint>$(Configuration)|$(Platform)|$(ProjectEvaluationFingerprint)</ProjectEvaluationFingerprint>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Build order
       ******************************************************************************************* -->
  <PropertyGroup>
    <CommonBuildOnlyTargets>
      PrepareForBuild;
      ResolveReferences;
    </CommonBuildOnlyTargets>
    <BeforeBuildGenerateSourcesTargets>
      $(BeforeBuildGenerateSourcesTargets);
    </BeforeBuildGenerateSourcesTargets>
    <BuildGenerateSourcesTargets>
      $(BuildGenerateSourcesTargets);
      PreBuildEvent;
      _Xsd;
      _Midl;
    </BuildGenerateSourcesTargets>
    <AfterBuildGenerateSourcesTargets>
      $(AfterBuildGenerateSourcesTargets);
      AfterBuildGenerateSourcesEvent;
    </AfterBuildGenerateSourcesTargets>
    <BeforeBuildCompileTargets Condition="'$(ConfigurationType)'!='Utility'">
      $(BeforeBuildCompileTargets);
    </BeforeBuildCompileTargets>
    <BuildLibTargets Condition="'$(ConfigurationType)'!='Utility'">
      $(BuildLibTargets);
      _ImpLib;
      _Lib;
    </BuildLibTargets>
    <BuildCompileTargets Condition="'$(ConfigurationType)'!='Utility'">
      $(BuildCompileTargets);
      _ClCompile;
      _ResGen;
      _ResourceCompile;
      $(BuildLibTargets);
    </BuildCompileTargets>
    <AfterBuildCompileTargets Condition="'$(ConfigurationType)'!='Utility'">
      $(AfterBuildCompileTargets);
      AfterBuildCompileEvent;
    </AfterBuildCompileTargets>
    <BuildLinkTargets Condition="'$(ConfigurationType)'!='Utility'">
      $(BuildLinkTargets);
      ComputeLegacyManifestEmbedding;
      _Link;
      _ALink;
      _Manifest;
      RegisterOutput;
      _XdcMake;
      _BscMake;
    </BuildLinkTargets>
    <BuildLinkTargets Condition="'$(CreateFullDebugSymbols)' == 'true'">
      $(BuildLinkTargets);
      CreateFullDebugSymbols;
    </BuildLinkTargets>
    <AfterBuildLinkTargets Condition="'$(ConfigurationType)'!='Utility'">
      $(AfterBuildLinkTargets);
      CreateRecipeFile;
      CreateSatelliteAssemblies;
      CopyLocalNativeReference;
      _Appverifier;
      _Deploy;
      PrepareForRun;
      PostBuildEvent;
    </AfterBuildLinkTargets>
    <AfterBuildLinkTargets Condition="'$(ConfigurationType)'=='Utility'">
      $(AfterBuildLinkTargets);
      CreateRecipeFile;
      PostBuildEvent
    </AfterBuildLinkTargets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(EnableBuildPassesInParallel)' == 'true' and '$(CanBuildProjectInPasses)' == ''">
    <!-- Utility, CLR, WinMD Projects are not possible to participate in BuildPass. -->
    <CanBuildProjectInPasses Condition="'$(ConfigurationType)'!='Utility' and '$(ManagedAssembly)'!='true' and '$(WindowsStoreApp)'!='true'">true</CanBuildProjectInPasses>
  </PropertyGroup>
  <!-- Have to override the following properties in msbuild common targets to avoid cyclic target dependencies when building all build steps (passes) together -->
  <PropertyGroup Condition="'$(EnableBuildPassesInParallel)' != 'true' or '$(CanBuildProjectInPasses)' == 'true'">
    <BuildGenerateSourcesAction>_BuildGenerateSourcesAction</BuildGenerateSourcesAction>
    <BuildCompileAction>_BuildCompileAction</BuildCompileAction>
    <BuildLinkAction>_BuildLinkAction</BuildLinkAction>
  </PropertyGroup>
  <!-- this ensures that we are initializing project type and disabling ref resolution when not needed -->
  <PropertyGroup>
    <GetReferenceAssemblyPathsDependsOn>_PrepareForReferenceResolution;$(GetReferenceAssemblyPathsDependsOn)</GetReferenceAssemblyPathsDependsOn>
  </PropertyGroup>
  <Target Name="_BuildGenerateSourcesAction" DependsOnTargets="$(CommonBuildOnlyTargets);$(BeforeBuildGenerateSourcesTargets);$(BuildGenerateSourcesTargets);$(AfterBuildGenerateSourcesTargets)" />
  <Target Name="_BuildCompileAction" DependsOnTargets="$(CommonBuildOnlyTargets);$(BeforeBuildCompileTargets);$(BuildCompileTargets);$(AfterBuildCompileTargets)" />
  <Target Name="_BuildLinkAction" DependsOnTargets="$(CommonBuildOnlyTargets);$(BeforeBuildLinkTargets);$(BuildLinkTargets);$(AfterBuildLinkTargets)" />
  <!--<Import Project="Microsoft.Cpp.BuildPass.targets" Condition="'$(AllowParallelCompileInReferencedProjects)'=='true' and '$(CanBuildProjectInPasses)' == 'true'" />-->
  <!-- *******************************************************************************************
        Selective Build
       ******************************************************************************************* -->
  <!-- The following targets removes build items form the project. For selective build work, only
       the specific targets should run, e.g. ClCompile, ResourceCompile -->
  <Target Name="_SelectedFiles" DependsOnTargets="PrepareForBuild;InitializeBuildStatus;SetBuildDefaultEnvironmentVariables;SetUserMacroEnvironmentVariables">
    <ItemGroup>
      <SelectedFiles Include="$(SelectedFiles)" />
    </ItemGroup>
    <PropertyGroup>
      <BuildType Condition="'$(BuildType)' == ''">Build</BuildType>
      <_BuildActionType Condition="'$(_BuildActionType)' == ''">Build</_BuildActionType>
    </PropertyGroup>
  </Target>
  <!-- ComputeReferenceCLInput is needed to complete the ForceUsing switch for managed projects.
       The BuildProjectReferences (see below in PrepareForBuild) is false to prevent building reference projects. -->
  <Target Name="SelectClCompile" DependsOnTargets="_SelectedFiles;$(ComputeCompileInputsTargets);SelectCustomBuild;SetModuleDependencies">
    <ItemGroup>
      <_SelectedClCompile Include="@(ClCompile)" Condition="'%(Identity)' == '@(SelectedFiles)'">
        <MinimalRebuildFromTracking>false</MinimalRebuildFromTracking>
      </_SelectedClCompile>
    </ItemGroup>
    <!-- Add the PCH to the list of files to be compiled. -->
    <ItemGroup Condition="'@(SelectedFiles)'!='' and '$(SelectedFilesBuildPCH)' != 'false'">
      <_SelectedClCompile Include="@(ClCompile)" Condition="'%(ClCompile.PrecompiledHeader)' == 'Create'" />
    </ItemGroup>
    <!-- Add module interface and header unit files to the list of files to be compiled -->
    <ItemGroup Condition="'@(SelectedFiles)'!='' and '$(SelectedFilesBuildModules)' != 'false'">
      <_SelectedClCompile Include="@(ClCompile)" Condition="'%(ClCompile.ModulesSupported)' == 'true' and&#xD;&#xA;                                                            '%(ClCompile.ModuleOrHeaderUnit)' == 'true'" />
    </ItemGroup>
    <ItemGroup Condition="'@(_SelectedClCompile)'!=''">
      <ClCompile Remove="@(ClCompile)" />
      <ClCompile Include="@(_SelectedClCompile-&gt;Metadata('Identity')-&gt;Distinct())" />
      <_SelectedClCompile Remove="@(_SelectedClCompile)" />
    </ItemGroup>
  </Target>
  <Target Name="SelectMidl" DependsOnTargets="_SelectedFiles;SelectCustomBuild">
    <ItemGroup Condition="'@(SelectedFiles)'!=''">
      <Midl Remove="@(Midl)" Condition="'%(Identity)'!='@(SelectedFiles)'" />
      <Midl>
        <MinimalRebuildFromTracking>false</MinimalRebuildFromTracking>
      </Midl>
    </ItemGroup>
  </Target>
  <Target Name="SelectXsd" DependsOnTargets="_SelectedFiles;SelectCustomBuild">
    <ItemGroup Condition="'@(SelectedFiles)'!=''">
      <Xsd Remove="@(Xsd)" Condition="'%(Identity)'!='@(SelectedFiles)'" />
      <Xsd>
        <MinimalRebuildFromTracking>false</MinimalRebuildFromTracking>
      </Xsd>
    </ItemGroup>
  </Target>
  <Target Name="SelectResourceCompile" DependsOnTargets="_SelectedFiles;SelectCustomBuild">
    <ItemGroup Condition="'@(SelectedFiles)'!=''">
      <ResourceCompile Remove="@(ResourceCompile)" Condition="'%(Identity)'!='@(SelectedFiles)'" />
      <ResourceCompile>
        <MinimalRebuildFromTracking>false</MinimalRebuildFromTracking>
      </ResourceCompile>
    </ItemGroup>
  </Target>
  <Target Name="SelectCustomBuild" DependsOnTargets="_SelectedFiles">
    <ItemGroup Condition="'@(SelectedFiles)'!=''">
      <CustomBuild Remove="@(CustomBuild)" Condition="'%(Identity)'!='@(SelectedFiles)'" />
      <CustomBuild>
        <MinimalRebuildFromTracking>false</MinimalRebuildFromTracking>
      </CustomBuild>
    </ItemGroup>
  </Target>
  <Target Name="SelectResGen" DependsOnTargets="_SelectedFiles;ResolveReferences;SelectCustomBuild">
    <ItemGroup Condition="'@(SelectedFiles)'!=''">
      <EmbeddedResource Remove="@(EmbeddedResource)" Condition="'%(Identity)'!='@(SelectedFiles)'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <DetermineProjectTypeTargets>_PrepareForReferenceResolution;$(DetermineProjectTypeTargets)</DetermineProjectTypeTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Properties to set before reference resolution
       ******************************************************************************************* -->
  <Target Name="_PrepareForReferenceResolution">
    <PropertyGroup>
      <!-- Do note that there is no seni-colon between @(ClCompile)@(Midl).  This will allow it correctly compare to an empty string.  -->
      <WinMDAssembly Condition="'$(ApplicationType)' != '' and ('$(TargetPlatformIdentifier)' == 'Windows' or '$(TargetPlatformIdentifier)' == 'UAP') and '$(TargetPlatformVersion)' != '7.0' and ('@(ClCompile-&gt;WithMetadataValue('CompileAsWinRT', 'true'))@(Midl-&gt;WithMetadataValue('EnableWindowsRuntime', 'true'))' != '' or ('@(ClCompile)@(Midl)' == '' and '$(WindowsAppContainer)' == 'true'))">true</WinMDAssembly>
      <WarnAboutIndividualManagedFiles Condition="'$(WarnAboutIndividualManagedFiles)' == '' and '$(ManagedAssembly)' != 'true' and '%(ClCompile.CompileAsManaged)' != 'false' and '%(ClCompile.CompileAsManaged)' != ''">true</WarnAboutIndividualManagedFiles>
    </PropertyGroup>
    <!-- Warn if some files are set to compile as managed, but ManagedAssembly property is not defined -->
    <VCMessage Code="MSB8077" Type="Warning" Condition="'$(WarnAboutIndividualManagedFiles)' == 'true'" />
    <!-- Warn if dynamic debugging is turned on that whole program optimization is turned off -->
    <VCMessage Code="MSB8088" Type="Warning" Condition="'$(UseDynamicDebugging)' == 'true' and '$(WholeProgramOptimization)' == 'true'" />
    <PropertyGroup>
      <!-- Managed and UWP projects will copy references by default in msbuild common targets.
           Disable copy targets that are specific to native projects -->
      <CopyLocalProjectReference Condition="'$(ManagedAssembly)'=='true' or '$(WinMDAssembly)'=='true'">false</CopyLocalProjectReference>
      <!-- Managed and UWP projects always copy content, naive projects only if CopyLocalDeploymentContent is true -->
      <CopyDeploymentContent Condition="'$(CopyLocalDeploymentContent)' == 'true' or '$(ManagedAssembly)'=='true' or '$(WinMDAssembly)'=='true'">true</CopyDeploymentContent>
    </PropertyGroup>
    <!-- Clear the target framework for Native projects -->
    <PropertyGroup>
      <TargetFrameworkMoniker Condition="'$(ManagedAssembly)' != 'true'" />
      <!-- Setting _FindDependencies to false will disable ResolveAssemblyReference from searching for managed dependencies.
        ResolveAssemblyReference is used to resolve both WinMD and managed components and without this flag, RAR will parse
        the WinMD for managed components.  -->
      <_FindDependencies Condition="'$(ManagedAssembly)' != 'true'">false</_FindDependencies>
    </PropertyGroup>
    <!-- Add/remove additional implict references for reference resolution -->
    <PropertyGroup>
      <AdditionalExplicitAssemblyReferences Condition="'$(ManagedAssembly)' == 'true' and '$(CLRSupport)' != 'NetCore'">mscorlib</AdditionalExplicitAssemblyReferences>
      <!-- Filter out System.Core added by: Microsoft.NETFramework.props  -->
      <AdditionalExplicitAssemblyReferences Condition="'$(ManagedAssembly)' != 'true' or '$(CLRSupport)' == 'NetCore'" />
    </PropertyGroup>
    <!-- Add all windowsSDK's winmd files to the references -->
    <ItemGroup Condition="'$(WinMDAssembly)' == 'true' and '$(TargetPlatformWinMDLocation)' != ''">
      <Reference Include="$([Microsoft.Build.Utilities.ToolLocationHelper]::GetTargetPlatformReferences($(SDKIdentifier), $(SDKVersion), $(TargetPlatformIdentifier), $(TargetPlatformMinVersion), $(TargetPlatformVersion)))">
        <IsWinMDFile>true</IsWinMDFile>
        <CopyLocal>false</CopyLocal>
        <IsSystemReference>True</IsSystemReference>
        <Implicit>true</Implicit>
      </Reference>
    </ItemGroup>
    <!-- Add implicit to all references coming from a .targets file, post resolution -->
    <ItemGroup>
      <Reference>
        <Implicit Condition="'%(Reference.DefiningProjectExtension)' == '.targets'">true</Implicit>
      </Reference>
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)'=='true'" Importance="High" Text="ReferencePath=@(ReferencePath)" />
  </Target>
  <PropertyGroup>
    <ResolveReferencesDependsOn>_PrepareForReferenceResolution;ComputeCrtSDKReference;$(ResolveReferencesDependsOn)</ResolveReferencesDependsOn>
    <ResolveAssemblyReferencesDependsOn>_PrepareForReferenceResolution;$(ResolveAssemblyReferencesDependsOn)</ResolveAssemblyReferencesDependsOn>
    <ResolveSDKReferencesDependsOn>_PrepareForReferenceResolution;ComputeCrtSDKReference;$(ResolveSDKReferencesDependsOn)</ResolveSDKReferencesDependsOn>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Imports PGO property sheets to overwrite any user settings.
       ******************************************************************************************* -->
  <!--<Import Project="$(VCTargetsPath)\microsoft.Cpp.WholeProgramOptimization.props" Condition="'$(WholeProgramOptimizationDelayImport)' == 'true' and '$(WholeProgramOptimization)' == 'true'" />-->
  <!--<Import Project="$(VCTargetsPath)\microsoft.Cpp.pginstrument.props" Condition="'$(WholeProgramOptimizationDelayImport)' == 'true' and '$(WholeProgramOptimization)' == 'PGInstrument'" />-->
  <!--<Import Project="$(VCTargetsPath)\microsoft.Cpp.pgoptimize.props" Condition="'$(WholeProgramOptimizationDelayImport)' == 'true' and '$(WholeProgramOptimization)' == 'PGOptimize'" />-->
  <!--<Import Project="$(VCTargetsPath)\microsoft.Cpp.pgupdate.props" Condition="'$(WholeProgramOptimizationDelayImport)' == 'true' and '$(WholeProgramOptimization)' == 'PGUpdate'" />-->
  <!-- *******************************************************************************************
        Non-target-specific files whose directories need to be made
       ******************************************************************************************* -->
  <!--PropertyGroup>
          <TempProjectDir>"$([System.IO.Path]::GetDirectoryName('$(ProjectDir)'))"</TempProjectDir>
  </PropertyGroup-->
  <ItemGroup>
    <GeneralDirsToMake Include="$(IntDir)" />
    <GeneralDirsToMake Include="$(OutDir)" />
    <GeneralDirsToMake Include="$(TLogLocation)" />
    <GeneralDirsToMake Condition="'$(GeneratedFilesDir)' != ''" Include="$(GeneratedFilesDir)" />
  </ItemGroup>
  <!-- *******************************************************************************************
        InitializeBuildStatus target
       ******************************************************************************************* -->
  <Target Name="InitializeBuildStatus" DependsOnTargets="PrepareForBuild" Condition="'$(DesignTimeBuild)' != 'true'">
    <!-- Read the state of the project that was last built.  If the file doesn't exist, then perform a normal build. -->
    <ReadLinesFromFile File="$(LastBuildState)">
      <Output TaskParameter="Lines" ItemName="_ReadProjectStateLine" />
    </ReadLinesFromFile>
    <!--
    ProjectStateLine represents the important states of the project during the build.
    The ProjectStateLine is a single line, no semi-colon, string that is compared to the previous build's ProjectStateLine that is saved to a file.
    A change from the last states will trigger rebuild of the entire build.
    Rebuilds are needed for switches that alter the tools used during the build.  Ie.  PlatformToolset.
    -->
    <PropertyGroup>
      <ProjectStateLine Condition="'$(CLRSupport)' == 'NetCore'">TargetFramework=$(TargetFramework):$(ProjectStateLine)</ProjectStateLine>
      <ProjectStateLine Condition="'$(CLRSupport)' != 'NetCore' and '$(ManagedAssembly)' == 'true'">TargetFrameworkVersion=$(TargetFrameworkVersion)::EnableManagedIncrementalBuild=$(EnableManagedIncrementalBuild):$(ProjectStateLine)</ProjectStateLine>
      <ProjectStateLine Condition="'$(TargetPlatformVersion)' != ''">TargetPlatformVersion=$(TargetPlatformVersion):$(ProjectStateLine)</ProjectStateLine>
    </PropertyGroup>
    <PropertyGroup Condition="'$(VCToolsVersion)' != '' and '$(ForceRebuildWhenVCToolsVersionChanges)' != 'false'">
      <ProjectStateLine Condition="'$(VCServicingVersionCompilers)' != '' and '$(VCServicingVersionCompilers)' != '$(VCToolsVersion)'">VCServicingVersionCompilers=$(VCServicingVersionCompilers):$(ProjectStateLine)</ProjectStateLine>
      <ProjectStateLine Condition="'$(VCServicingVersionCrtHeaders)' != '' and '$(VCServicingVersionCrtHeaders)' != '$(VCToolsVersion)'">VCServicingVersionCrtHeaders=$(VCServicingVersionCrtHeaders):$(ProjectStateLine)</ProjectStateLine>
      <ProjectStateLine Condition="'$(VCServicingVersionATL)' != '' and '$(VCServicingVersionATL)' != '$(VCToolsVersion)'">VCServicingVersionATL=$(VCServicingVersionATL):$(ProjectStateLine)</ProjectStateLine>
      <ProjectStateLine Condition="('$(UseOfMFC)' != 'static' or '$(UseOfMFC)' != 'dynamic') and '$(VCServicingVersionMFC)' != '' and '$(VCServicingVersionMFC)' != '$(VCToolsVersion)'">VCServicingVersionMFC=$(VCServicingVersionMFC):$(ProjectStateLine)</ProjectStateLine>
      <ProjectStateLine>VCToolsVersion=$(VCToolsVersion):$(ProjectStateLine)</ProjectStateLine>
    </PropertyGroup>
    <PropertyGroup>
      <ProjectStateLine>PlatformToolSet=$(PlatformToolSet):VCToolArchitecture=$(VCToolArchitecture):$(ProjectStateLine)</ProjectStateLine>
    </PropertyGroup>
    <PropertyGroup>
      <StateBuildType Condition="'$(StateBuildType)' == '' and '@(_ReadProjectStateLine)' != '' and '%(_ReadProjectStateLine.Identity)' == '$(ProjectStateLine)'">Build</StateBuildType>
      <StateBuildType Condition="'$(StateBuildType)' == '' and '@(_ReadProjectStateLine)' != '' ">Rebuild</StateBuildType>
      <StateBuildType Condition="'$(StateBuildType)' == ''">Build</StateBuildType>
      <BuildType Condition="'$(StateBuildType)' == 'Rebuild' and '$(BuildType)' == '' ">$(StateBuildType)</BuildType>
      <_BuildActionType Condition="'$(StateBuildType)' == 'Rebuild'">Rebuild</_BuildActionType>
    </PropertyGroup>
    <WriteLinesToFile Overwrite="true" File="$(LastBuildState)" Lines="$(ProjectStateLine);$(ProjectEvaluationFingerprint)" />
    <!-- Touch and create this file to indicate that the build has start.
    In case of an error, this will remain on disk as quick indication to the IDE that the project still needs building. -->
    <Touch AlwaysCreate="true" Files="$(LastBuildUnsuccessful)" />
  </Target>
  <!-- Remove tlogs records for cl items that used to be compiled, but not anymore -->
  <Target Name="TlogCleanup" DependsOnTargets="$(TlogCleanupDependsOn)" Condition="'$(CleanupTlogItems)' != 'false' and '$(DesigntimeBuild)' != 'true' and '$(SelectedFiles)' == ''">
    <CleanupStaleTlogItems Sources="@(ClCompile)" ItemOutputMetadataName="ObjectFileName" OutputExtension="obj" TLogDirectory="$(TLogLocation)" TLogNamePrefix="Cl" TrackFileAccess="$(TrackFileAccess)" DynamicDebugging="%(ClCompile.UseDynamicDebugging)" />
  </Target>
  <!-- *******************************************************************************************
        FinalizeBuildStatus target
       ******************************************************************************************* -->
  <Target Name="FinalizeBuildStatus">
    <!-- Delete the incomplete build indicator.
    Touch the last build state file to indicate no inputs should be newer than this point.  -->
    <Delete Files="$(LastBuildUnsuccessful)" Condition="Exists($(LastBuildUnsuccessful))" />
    <Touch Files="$(LastBuildState)" Condition="Exists($(LastBuildState))" />
  </Target>
  <!-- *******************************************************************************************
        PrepareForBuild target
       ******************************************************************************************* -->
  <Target Name="PrepareForBuild" DependsOnTargets="SetBuildDefaultEnvironmentVariables;SetUserMacroEnvironmentVariables;_PrepareForReferenceResolution;GetResolvedWinMD;$(PrepareForBuildDependsOn)">
    <!-- These PropertyGroups are required because TargetPath and others are defined
       to contain an item list. We want that item list to be expanded so that it can be used
       as a regular property value and not as an item-list-with-transform. -->
    <PropertyGroup>
      <TargetDir>$(TargetDir)</TargetDir>
      <LocalDebuggerCommand>$(LocalDebuggerCommand)</LocalDebuggerCommand>
      <!-- Prevent building project reference once starting to build this project, unless $(AllowBuldingProjectReferencesDuringBuild) is set -->
      <BuildProjectReferences Condition="'$(AllowBuldingProjectReferencesDuringBuild)' != 'true'">false</BuildProjectReferences>
    </PropertyGroup>
    <PropertyGroup>
      <ConfigurationPlatformExists Condition="'%(ProjectConfiguration.Identity)' == '$(Configuration)|$(Platform)'">true</ConfigurationPlatformExists>
    </PropertyGroup>
    <PropertyGroup Condition="'$(DesignTimeBuild)' != 'true' and '$(_ToolsetFound)' != 'true' and '$(_PlatformToolsetShortName)' == ''">
      <!-- Current toolset short name -->
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v143'">$(_PlatformToolsetShortNameFor_v143)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v142'">$(_PlatformToolsetShortNameFor_v142)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v141_xp'">$(_PlatformToolsetShortNameFor_v141_xp)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v141'">$(_PlatformToolsetShortNameFor_v141)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v140_xp'">$(_PlatformToolsetShortNameFor_v140_xp)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v140'">$(_PlatformToolsetShortNameFor_v140)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v120_xp'">$(_PlatformToolsetShortNameFor_v120_xp)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v120'">$(_PlatformToolsetShortNameFor_v120)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v110_xp'">$(_PlatformToolsetShortNameFor_v110_xp)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v110'">$(_PlatformToolsetShortNameFor_v110)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v100'">$(_PlatformToolsetShortNameFor_v100)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(PlatformToolset)' == 'v90'">$(_PlatformToolsetShortNameFor_v90)</_PlatformToolsetShortName>
      <_PlatformToolsetShortName Condition="'$(_PlatformToolsetShortName)' == ''">$(PlatformToolset)</_PlatformToolsetShortName>
      <_ApplicationTypeShortName Condition="'$(_ApplicationTypeShortName)' == ''">$(ApplicationType)</_ApplicationTypeShortName>
    </PropertyGroup>
    <!-- Error if platform toolset not defined -->
    <VCMessage Code="MSB8003" Type="Error" Arguments="PlatformToolset" Condition="'$(PlatformToolset)' == '' and '$(DesignTimeBuild)' != 'true' and '$(_ToolsetFound)' != 'true'" />
    <!-- Error now before creating any directories. -->
    <VCMessage Code="MSB8013" Type="Error" Arguments="$(Configuration)|$(Platform)" Condition="'$(DesignTimeBuild)' != 'true' and '$(ConfigurationPlatformExists)' != 'true'" />
    <!-- Error if toolset not found -->
    <VCMessage Code="MSB8020" Type="Error" Arguments="$(_PlatformToolsetShortName);$(PlatformToolset)" Condition="'$(ApplicationType)' == '' and '$(DesignTimeBuild)' != 'true' and '$(_ToolsetFound)' != 'true'" />
    <VCMessage Code="MSB8020_AppType" Type="Error" Arguments="$(_ApplicationTypeShortName);$(_PlatformToolsetShortName);$(PlatformToolset)" Condition="'$(ApplicationType)' != '' and '$(DesignTimeBuild)' != 'true' and '$(_ToolsetFound)' != 'true'" />
    <MakeDir Directories="$(IntDir)" Condition="'$(DesignTimeBuild)' != 'true'" />
    <PropertyGroup>
      <_ClCompileGenerateXMLDocumentationFiles Condition="'%(ClCompile.GenerateXMLDocumentationFiles)' == 'true'">true</_ClCompileGenerateXMLDocumentationFiles>
    </PropertyGroup>
    <!-- Error out if Windows Store app projects has an unsupported Configuration Type -->
    <VCMessage Code="MSB8016" Type="Error" Arguments="$(ConfigurationType)" Condition="'$(DesignTimeBuild)'!='true' and '$(WindowsAppContainer)'=='true' and '$(ConfigurationType)'!='Application' and '$(ConfigurationType)'!='DynamicLibrary' and '$(ConfigurationType)'!='StaticLibrary'" />
    <!-- Error out if the user tried to use the v90 toolset but doesn't have 2008 installed -->
    <VCMessage Code="MSB8009" Type="Error" Condition="'$(DesignTimeBuild)'!='true' and '$(VCToolsInstallDir)'=='' and '$(UseEnv)' != 'true' and ('$(TargetFrameworkVersion)'=='v3.5' or '$(TargetFrameworkVersion)'=='v3.0' or '$(TargetFrameworkVersion)'=='v2.0' )" />
    <VCMessage Code="MSB8010" Type="Error" Condition="'$(DesignTimeBuild)'!='true' and '$(VCToolsInstallDir)'=='' and '$(UseEnv)' != 'true' and '$(PlatformToolset)'=='v90'" />
    <!-- Error out VCToolsVersion does not match MSVC PlatformToolset -->
    <CheckVCToolsetVersion Condition="'$(DesignTimeBuild)'!='true' and '$(CheckMSVCComponents)'=='true'" VCToolsVersion="$(VCToolsVersion)" PlatformToolset="$(PlatformToolset)" VCToolsInstallDir="$(VCToolsInstallDir)" />
    <ItemGroup Condition="'$(DesignTimeBuild)' != 'true' and '$(UseEnv)' != 'true' and '$(CheckMSVCComponents)'=='true' ">
      <Link Include="__Tempfile__">
        <Temp>true</Temp>
      </Link>
    </ItemGroup>
    <PropertyGroup Condition="'$(DesignTimeBuild)' != 'true' and '$(UseEnv)' != 'true' and '$(CheckMSVCComponents)'=='true'">
      <CheckMFCInstalled Condition="('$(UseOfMFC)' == 'static' or '$(UseOfMFC)' == 'dynamic') and '$(MFC_KeyFile)' != '' ">true</CheckMFCInstalled>
      <CheckATLInstalled Condition="'$(ATL_KeyFile)' != '' and ('$(ConfigurationType)' == 'Application' or '$(ConfigurationType)' == 'DynamicLibrary')&#xD;&#xA;                         and %(Link.AdditionalDependencies) != '' and  $([System.String]::new('%(Link.AdditionalDependencies)').Contains('atls.lib'))">true</CheckATLInstalled>
      <SpectreLibs Condition="'$(SpectreMitigation)' != 'false'">$(SpectreMitigation)</SpectreLibs>
    </PropertyGroup>
    <ItemGroup>
      <Link Remove="@(Link)" Condition="'%(Link.Temp)' == 'true'" />
    </ItemGroup>
    <!-- Error out if required optional components are not installed -->
    <!-- MFC -->
    <VCMessage Code="MSB8041" Type="Error" Arguments="MFC" Condition="'$(CheckMFCInstalled)' == 'true' and !Exists($(MFC_KeyFile)) and '$(SpectreLibs)' == ''" />
    <VCMessage Code="MSB8042" Type="Error" Arguments="MFC" Condition="'$(CheckMFCInstalled)' == 'true' and !Exists($(MFC_KeyFile)) and '$(SpectreLibs)' != ''" />
    <!-- ATL -->
    <VCMessage Code="MSB8041" Type="Error" Arguments="ATL" Condition="'$(CheckATLInstalled)' == 'true' and !Exists($(ATL_KeyFile)) and '$(SpectreLibs)' == ''" />
    <VCMessage Code="MSB8042" Type="Error" Arguments="ATL" Condition="'$(CheckATLInstalled)' == 'true' and !Exists($(ATL_KeyFile)) and '$(SpectreLibs)' != ''" />
    <!-- Error out if Spectre libraries are not installed. See https://aka.ms/Ofhn4c for more information. -->
    <VCMessage Code="MSB8040" Type="Error" Condition="'$(DesignTimeBuild)' != 'true' and&#xD;&#xA;                                                        '$(CheckMSVCComponents)'=='true' and&#xD;&#xA;                                                        '$(SpectreMitigation)' != '' and&#xD;&#xA;                                                        '$(SpectreMitigation)' != 'false' and&#xD;&#xA;                                                        (('$(VC_Target_Library_Platform)' == 'OneCore' and !Exists('$(VC_LibraryPath_VC_OneCore_CurrentPlatform_spectre)')) or&#xD;&#xA;                                                         ('$(VC_Target_Library_Platform)' == 'Desktop' and !Exists('$(VC_LibraryPath_VC_Desktop_CurrentPlatform_spectre)')))" />
    <!-- Warn the user that about the missing environment variable -->
    <VCMessage Code="MSB8003" Type="Warning" Arguments="VCToolsInstallDir" Condition="'$(DesignTimeBuild)'!='true' and '$(VCToolsInstallDir)'=='' and '$(UseEnv)' != 'true'  and '$(CheckMSVCComponents)'=='true'" />
    <VCMessage Code="MSB8003" Type="Warning" Arguments="WindowsSDKDir" Condition="'$(DesignTimeBuild)'!='true' and '$(WindowsSDKDir)'=='' and '$(UseEnv)' != 'true'" />
    <VCMessage Code="MSB8004" Type="Warning" Arguments="Intermediate;Intermediate" Condition="'$(DesignTimeBuild)'!='true' and '$(IntDirTrailingSlashWarning)'=='true'" />
    <VCMessage Code="MSB8004" Type="Warning" Arguments="Output;Output" Condition="'$(DesignTimeBuild)'!='true' and '$(OutDirTrailingSlashWarning)'=='true'" />
    <VCMessage Code="MSB8021" Type="%(CompatibilityIssues.Type)" Arguments="%(CompatibilityIssues.FirstValue);%(CompatibilityIssues.FirstName);%(CompatibilityIssues.SecondValue);%(CompatibilityIssues.SecondName)" Condition="'%(CompatibilityIssues.Identity)' != '' and '$(DesignTimeBuild)'!='true'" />
    <!-- lastbuildstate is a unique file writen to by each build. Multiple of this file can mean that the IntDir is shared by more the one project. -->
    <ItemGroup>
      <AllTlogLocation Include="$(IntDir)*.tlog\*.lastbuildstate" Exclude="$(LastBuildState)" Condition="'$(IntDirSharingDetected)' == ''" />
    </ItemGroup>
    <PropertyGroup>
      <IntDirSharingDetected Condition="'@(AllTlogLocation)' != ''">true</IntDirSharingDetected>
      <IntDirSharingProjects Condition="'@(AllTlogLocation)' != ''">@(AllTlogLocation->'%(Filename).vcxproj', ', ')</IntDirSharingProjects>
    </PropertyGroup>
    <VCMessage Code="MSB8028" Type="Warning" Arguments="$(IntDirSharingProjects);$(IntDir)" Condition="'$(IgnoreWarnIntDirSharingDetected)' != 'true' and '$(IntDirSharingDetected)' == 'true'" />
    <!-- Warn if IntDir or OutDir is a subfolder of the Temp -->
    <PropertyGroup>
      <_Tmp>$(TMP)</_Tmp>
      <_Temp>$(TEMP)</_Temp>
      <_Tmp Condition="'$(_Tmp)' != '' and !HasTrailingSlash('$(_Tmp)')">$(_Tmp)\</_Tmp>
      <_Temp Condition="'$(_Temp)' != '' and !HasTrailingSlash('$(_Temp)')">$(_Temp)\</_Temp>
    </PropertyGroup>
    <VCMessage Code="MSB8029" Type="Warning" Condition="'$(DesignTimeBuild)'!='true' and '$(IgnoreWarnIntDirInTempDetected)' != 'true' and ('$(IntDirFullPath.StartsWith($(_Tmp), true, null))' == 'true' or '$(IntDirFullPath.StartsWith($(_Temp), true, null))' == 'true' or '$(OutDirFullPath.StartsWith($(_Tmp), true, null))' == 'true' or '$(OutDirFullPath.StartsWith($(_Temp), true, null))' == 'true')" />
    <!-- add a message about structured output if enabled -->
    <VCMessage Code="MSB8085" Type="Message" Importance="Normal" Condition="'$(DesignTimeBuild)'!='true' and '$(UseClStructuredOutput)' == 'true' and '$(LogStructuredOutputMessage)' != 'false'" />
    <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
    <MakeDir Directories="@(GeneralDirsToMake)" Condition="'$(DesignTimeBuild)' != 'true'" />
  </Target>
  <!-- *******************************************************************************************
        BuildGenerateSources step
       ******************************************************************************************* -->
  <!-- *******************************************************************************************
        XSD targets
       ******************************************************************************************* -->
  <Target Name="_Xsd" DependsOnTargets="$(BeforeXsdTargets);Xsd;$(AfterXsdTargets)" />
  <!-- *******************************************************************************************
        MIDL targets
       ******************************************************************************************* -->
  <Target Name="_Midl" DependsOnTargets="$(BeforeMidlCompileTargets);$(ComputeMidlInputsTargets);MakeDirsForMidl;Midl;ComputeMIDLGeneratedCompileInputs;$(AfterMidlTargets)" />
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeMidlTargets>
      $(BeforeMidlTargets);
      BeforeMidl;
    </BeforeMidlTargets>
    <AfterMidlTargets>
      $(AfterMidlTargets);
      AfterMidl;
    </AfterMidlTargets>
  </PropertyGroup>
  <Target Name="BeforeMidl" />
  <Target Name="AfterMidl" />
  <!-- Uses outputs for the purposes of batching. -->
  <Target Name="MakeDirsForMidl" Outputs="%(Midl.OutputDirectory)">
    <!-- List of directories and files whose directories should be made prior to IDL -->
    <PropertyGroup>
      <Midl_OutputDir>%(Midl.OutputDirectory)</Midl_OutputDir>
    </PropertyGroup>
    <ItemGroup Condition="'@(Midl)'!=''">
      <MidlDirsToMake Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.DllDataFileName)'))" Condition="'%(Midl.DllDataFileName)'!=''" />
      <MidlDirsToMake Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.TypeLibraryName)'))" Condition="'%(Midl.TypeLibraryName)'!=''" />
      <MidlDirsToMake Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.HeaderFileName)'))" Condition="'%(Midl.HeaderFileName)'!=''" />
      <MidlDirsToMake Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.ProxyFileName)'))" Condition="'%(Midl.ProxyFileName)'!=''" />
      <MidlDirsToMake Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.InterfaceIdentifierFileName)'))" Condition="'%(Midl.InterfaceIdentifierFileName)'!=''" />
      <MidlDirsToMake Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.MetadataFileName)'))" Condition="'%(Midl.MetadataFileName)'!=''" />
    </ItemGroup>
    <Makedir Directories="@(MidlDirsToMake-&gt;DirectoryName()-&gt;Distinct())" />
    <ItemGroup>
      <MidlDirsToMake Remove="@(MidlDirsToMake)" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        Compute Midl Outputs targets
       ******************************************************************************************* -->
  <!-- Add MIDL generates .c files to Compile item group -->
  <!-- Uses outputs for the purposes of batching. -->
  <Target Name="ComputeMIDLGeneratedCompileInputs" DependsOnTargets="$(ComputeMIDLGeneratedCompileInputsDependsOn)" Outputs="%(Midl.OutputDirectory)">
    <PropertyGroup>
      <Midl_OutputDir>%(Midl.OutputDirectory)</Midl_OutputDir>
    </PropertyGroup>
    <ItemGroup Condition="'@(Midl)' != ''">
      <ClCompile Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.InterfaceIdentifierFileName)'))" Condition="'%(Midl.CompileInterface)' == 'true' and '%(Midl.ExcludedFromBuild)'!='true'">
        <!-- Translate Midl specific metadata to Compile one -->
        <LinkCompiled Condition="'%(Midl.LinkCompiled)'   == '' and '%(Midl.LinkCompiledInterface)'   != ''">%(Midl.LinkCompiledInterface)</LinkCompiled>
        <LibCompiled Condition="'%(Midl.LibCompiled)'    == '' and '%(Midl.LibCompiledInterface)'    != ''">%(Midl.LibCompiledInterface)</LibCompiled>
        <ImpLibCompiled Condition="'%(Midl.ImpLibCompiled)' == '' and '%(Midl.ImpLibCompiledInterface)' != ''">%(Midl.ImpLibCompiledInterface)</ImpLibCompiled>
      </ClCompile>
      <ClCompile Include="$([System.IO.Path]::Combine('$(Midl_OutputDir)','%(Midl.ProxyFileName)'))" Condition="'%(Midl.CompileProxy)' == 'true'  and '%(Midl.ExcludedFromBuild)'!='true'">
        <!-- Translate Midl specific metadata to Compile one -->
        <LinkCompiled Condition="'%(Midl.LinkCompiled)'   == '' and '%(Midl.LinkCompiledProxy)'   != ''">%(Midl.LinkCompiledProxy)</LinkCompiled>
        <LibCompiled Condition="'%(Midl.LibCompiled)'    == '' and '%(Midl.LibCompiledProxy)'    != ''">%(Midl.LibCompiledProxy)</LibCompiled>
        <ImpLibCompiled Condition="'%(Midl.ImpLibCompiled)' == '' and '%(Midl.ImpLibCompiledProxy)' != ''">%(Midl.ImpLibCompiledProxy)</ImpLibCompiled>
      </ClCompile>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeCompileInputsTargets>
      $(ComputeCompileInputsTargets);
      ComputeMIDLGeneratedCompileInputs;
    </ComputeCompileInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        FXC targets
       ******************************************************************************************* -->
  <Target Name="MakeDirsForFxc">
    <ItemGroup Condition="'@(FxCompile)'!=''">
      <_FxCompile Include="@(FxCompile)" Condition="'%(FxCompile.ExcludedFromBuild)'!='true'" />
    </ItemGroup>
    <ItemGroup Condition="'@(_FxCompile)'!=''">
      <FxcOutputs Include="@(_FxCompile-&gt;Metadata('HeaderFileOutput')-&gt;Distinct())" />
      <FxcOutputs Include="@(_FxCompile-&gt;Metadata('ObjectFileOutput')-&gt;Distinct())">
        <DeploymentContent>True</DeploymentContent>
      </FxcOutputs>
      <FxcOutputs Include="@(_FxCompile-&gt;Metadata('AssemblerOutputFile')-&gt;Distinct())" />
      <FxcDirsToMake Include="@(FxcOutputs-&gt;DirectoryName())" />
      <FxcOutputs>
        <Link Condition="'%(FxcOutputs.DeploymentContent)'=='True'">$([MSBuild]::MakeRelative($(TargetDir), %(FullPath)))</Link>
      </FxcOutputs>
    </ItemGroup>
    <MakeDir Directories="@(FxcDirsToMake)" />
    <ItemGroup>
      <_FxCompile Remove="@(_FxCompile)" />
      <FxcDirsToMake Remove="@(FxcDirsToMake)" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        RC targets
       ******************************************************************************************* -->
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeResourceCompileTargets>
      $(BeforeResourceCompileTargets);
      BeforeResourceCompile;
    </BeforeResourceCompileTargets>
    <AfterResourceCompileTargets>
      $(AfterResourceCompileTargets);
      AfterResourceCompile;
    </AfterResourceCompileTargets>
  </PropertyGroup>
  <Target Name="_ResourceCompile" DependsOnTargets="$(BeforeResourceCompileTargets);$(ComputeResourceCompileInputsTargets);MakeDirsForResourceCompile;ResourceCompile;$(AfterResourceCompileTargets)" />
  <!-- Makes the the directories that ResourceCompile uses -->
  <Target Name="MakeDirsForResourceCompile">
    <!-- List of directories and files whose directories should be made prior to running ResourceCompile -->
    <ItemGroup>
      <RcDirsToMake Include="@(ResourceCompile-&gt;Metadata('ResourceOutputFileName')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetaData())" />
      <RcDirsToMake Include="@(ManifestResourceCompile-&gt;Metadata('ResourceOutputFileName')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetaData())" />
    </ItemGroup>
    <MakeDir Directories="@(RcDirsToMake)" />
    <ItemGroup>
      <RcDirsToMake Remove="@(RcDirsToMake)" />
    </ItemGroup>
  </Target>
  <Target Name="BeforeResourceCompile" />
  <Target Name="AfterResourceCompile" />
  <!-- *******************************************************************************************
        Compute RC Outputs targets
       ******************************************************************************************* -->
  <ItemDefinitionGroup>
    <ResourceCompile>
      <LinkCompiled>$(LinkCompiled)</LinkCompiled>
      <LibCompiled>$(LibCompiled)</LibCompiled>
      <ImpLibCompiled>$(ImpLibCompiled)</ImpLibCompiled>
    </ResourceCompile>
    <ManifestResourceCompile>
      <LinkCompiled>$(LinkCompiled)</LinkCompiled>
      <LibCompiled>$(LibCompiled)</LibCompiled>
      <ImpLibCompiled>$(ImpLibCompiled)</ImpLibCompiled>
      <MinimalRebuildFromTracking Condition="'%(ManifestResourceCompile.MinimalRebuildFromTracking)' == ''">true</MinimalRebuildFromTracking>
    </ManifestResourceCompile>
  </ItemDefinitionGroup>
  <!-- Add RC generated .res files to Res item group, it will be used by lib or link -->
  <Target Name="ComputeRCOutputs" DependsOnTargets="$(ComputeResourceCompileInputsTargets)">
    <ItemGroup Condition="'@(ResourceCompile)' != ''">
      <!-- No object file name defined: filename.obj -->
      <ResObj Condition="'%(ResourceCompile.ResourceOutputFileName)' == '' and '%(ResourceCompile.ExcludedFromBuild)'!='true'" Include="@(ResourceOutputFileName->'%(Filename).res')">
        <LinkCompiled>%(ResourceCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ResourceCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ResourceCompile.ImpLibCompiled)</ImpLibCompiled>
        <ResourceCompileFilePath>%(ResourceCompile.FullPath)</ResourceCompileFilePath>
      </ResObj>
      <!-- Object file name is a directory (has trailing slash): ofn\filename.obj -->
      <ResObj Condition="HasTrailingSlash('%(ResourceCompile.ResourceOutputFileName)') and '%(ResourceCompile.ExcludedFromBuild)'!='true'" Include="@(ResourceCompile->'%(ResourceOutputFileName)%(Filename).res')">
        <LinkCompiled>%(ResourceCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ResourceCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ResourceCompile.ImpLibCompiled)</ImpLibCompiled>
        <ResourceCompileFilePath>%(ResourceCompile.FullPath)</ResourceCompileFilePath>
      </ResObj>
      <!-- Object file name is a file (does not has trailing slash): ofn -->
      <ResObj Condition="!HasTrailingSlash('%(ResourceCompile.ResourceOutputFileName)')  and '%(ResourceCompile.ExcludedFromBuild)'!='true'" Include="@(ResourceCompile->'%(ResourceOutputFileName)')">
        <LinkCompiled>%(ResourceCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ResourceCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ResourceCompile.ImpLibCompiled)</ImpLibCompiled>
        <ResourceCompileFilePath>%(ResourceCompile.FullPath)</ResourceCompileFilePath>
      </ResObj>
    </ItemGroup>
    <ItemGroup Condition="'@(ManifestResourceCompile)' != '' and '$(EmbedManifestBy)'=='LINK' and '$(LegacyManifestEmbedding)' == 'true'">
      <ResObjMt Include="%(ManifestResourceCompile.ResourceOutputFileName)">
        <LinkCompiled>%(ManifestResourceCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ManifestResourceCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ManifestResourceCompile.ImpLibCompiled)</ImpLibCompiled>
      </ResObjMt>
    </ItemGroup>
  </Target>
  <Target Name="ComputeRCGeneratedLinkInputs" DependsOnTargets="ComputeRCOutputs">
    <ItemGroup>
      <Link Include="@(ResObj-&gt;WithMetadataValue('LinkCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeRCGeneratedLinkInputs;
    </ComputeLinkInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeRCGeneratedLibInputs" DependsOnTargets="ComputeRCOutputs">
    <ItemGroup Condition="'@(ResObj)' != ''">
      <Lib Include="@(ResObj-&gt;WithMetadataValue('LibCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeRCGeneratedLibInputs;
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeRCGeneratedImpLibInputs" DependsOnTargets="ComputeRCOutputs">
    <ItemGroup Condition="'@(ResObj)' != ''">
      <ImpLib Include="@(ResObj-&gt;WithMetadataValue('ImpLibCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeImpLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeRCGeneratedImpLibInputs;
    </ComputeImpLibInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        ComputeLegacyManifestEmbedding target
        This target will detect if the build is using any manifest switches that is not supported.
        If so, then the build will revert to the legacy embedding of the manifest.
       ******************************************************************************************* -->
  <Target Name="ComputeLegacyManifestEmbedding" Condition="'$(LegacyManifestEmbedding)' != 'true'">
    <ItemGroup>
      <Manifest Include="temp" Condition="'@(Manifest)' == ''">
        <_LocalVariable>true</_LocalVariable>
      </Manifest>
    </ItemGroup>
    <PropertyGroup>
      <_NotSupportedManifestSwitches Condition="'$(GenerateManifest)' != 'true'">$(_NotSupportedManifestSwitches) GenerateManifest</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'$(EmbedManifest)' != 'true'">$(_NotSupportedManifestSwitches) EmbedManifest</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.UpdateFileHashes)' == 'true'">$(_NotSupportedManifestSwitches) UpdateFileHashes</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.TypeLibraryFile)' != ''">$(_NotSupportedManifestSwitches) TypeLibraryFile</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.AssemblyIdentity)' != ''">$(_NotSupportedManifestSwitches) AssemblyIdentity</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.ComponentFileName)' != ''">$(_NotSupportedManifestSwitches) ComponentFileName</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.GenerateCatalogFiles)' == 'true'">$(_NotSupportedManifestSwitches) GenerateCatalogFiles</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.GenerateCategoryTags)' == 'true'">$(_NotSupportedManifestSwitches) GenerateCategoryTags</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.ManifestFromManagedAssembly)' != ''">$(_NotSupportedManifestSwitches) ManifestFromManagedAssembly</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.RegistrarScriptFile)' != ''">$(_NotSupportedManifestSwitches) RegistrarScriptFile</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.ReplacementsFile)' != ''">$(_NotSupportedManifestSwitches) ReplacementsFile</_NotSupportedManifestSwitches>
      <_NotSupportedManifestSwitches Condition="'%(Manifest.SuppressDependencyElement)' == 'true'">$(_NotSupportedManifestSwitches) SuppressDependencyElement</_NotSupportedManifestSwitches>
      <RevertManifestEmbedding Condition="'$(_NotSupportedManifestSwitches)' != '' and '$(RevertManifestEmbedding)' == ''">true</RevertManifestEmbedding>
      <LegacyManifestEmbedding Condition="'$(RevertManifestEmbedding)' == 'true'">true</LegacyManifestEmbedding>
    </PropertyGroup>
    <VCMessage Condition="'$(RevertManifestEmbedding)' == 'true' and '$(_LegacyManifestEmbeddingDebug)' == 'true'" Code="MSB8025" Type="Warning" Arguments="$(_NotSupportedManifestSwitches)" />
    <ItemGroup>
      <Manifest Remove="@(Manifest)" Condition="'%(Manifest._LocalVariable)' == 'true'" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        Manifest targets
       ******************************************************************************************* -->
  <Target Name="ComputeManifestInputsTargets" Condition="'@(Link)' != ''">
    <ItemGroup>
      <Manifest Include="%(Link.ManifestFile)" Condition="'$(GenerateManifest)' == 'true' and '$(LegacyManifestEmbedding)' == 'true'" />
      <Manifest Include="temp" Condition="'@(Manifest)' == ''">
        <_LocalVariable>true</_LocalVariable>
      </Manifest>
    </ItemGroup>
    <PropertyGroup>
      <_ManifestToIgnore Condition="'$(GenerateManifest)' == 'true'">%(Link.ManifestFile)</_ManifestToIgnore>
      <VCManifestDir Condition="'$(VCManifestDir)' == ''">$(VCToolsInstallDir)Include\Manifest\</VCManifestDir>
      <ManifestAdditionalManifestFiles Condition="'%(Manifest.AdditionalManifestFiles)'!=''">%(Manifest.AdditionalManifestFiles)</ManifestAdditionalManifestFiles>
      <ManifestAdditionalManifestFiles Condition="'%(Manifest.EnableDPIAwareness)'=='true'">$(ManifestAdditionalManifestFiles);$(VCManifestDir)dpiaware.manifest</ManifestAdditionalManifestFiles>
      <ManifestAdditionalManifestFiles Condition="'%(Manifest.EnableDPIAwareness)'=='PerMonitorHighDPIAware'">$(ManifestAdditionalManifestFiles);$(VCManifestDir)PerMonitorHighDPIAware.manifest</ManifestAdditionalManifestFiles>
    </PropertyGroup>
    <ItemGroup>
      <Manifest Remove="@(Manifest)" Condition="'%(Manifest._LocalVariable)' == 'true'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeManifestInputsTargets>
      $(ComputeManifestInputsTargets);
      ComputeManifestInputsTargets;
    </ComputeManifestInputsTargets>
  </PropertyGroup>
  <PropertyGroup>
    <_ManifestDependsOn Condition="'$(GenerateManifest)'=='true' AND ('$(EmbedManifest)'!='true' OR '$(EmbedManifestBy)'=='MT')">
      $(BeforeManifestCompileTargets);
      $(ComputeManifestInputsTargets);
      Manifest;
      ComputeManifestGeneratedLinkerInputs;
    </_ManifestDependsOn>
    <_ManifestDependsOn Condition="'$(GenerateManifest)'=='true' AND '$(EmbedManifest)'=='true' AND '$(EmbedManifestBy)'=='LINK'">
      $(BeforeManifestCompileTargets);
      $(ComputeManifestInputsTargets);
      Manifest;
      ComputeManifestGeneratedLinkerInputs;
      LinkEmbedManifest;
    </_ManifestDependsOn>
    <_ManifestDependsOn Condition="'$(AfterManifestTargets)' != ''">
      $(_ManifestDependsOn);
      $(AfterManifestTargets);
    </_ManifestDependsOn>
  </PropertyGroup>
  <Target Name="_Manifest" DependsOnTargets="ComputeLegacyManifestEmbedding">
    <CallTarget Targets="$(_ManifestDependsOn)" Condition="'$(LegacyManifestEmbedding)' == 'true'" />
  </Target>
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeManifestTargets>
      $(BeforeManifestTargets);
      BeforeManifest;
    </BeforeManifestTargets>
    <AfterManifestTargets>
      $(AfterManifestTargets);
      AfterManifest;
    </AfterManifestTargets>
  </PropertyGroup>
  <Target Name="BeforeManifest" />
  <Target Name="AfterManifest" />
  <!-- Item props defining default processing for Mt outputs -->
  <ItemDefinitionGroup>
    <Manifest>
      <LinkCompiledInterface>false</LinkCompiledInterface>
    </Manifest>
  </ItemDefinitionGroup>
  <!-- *******************************************************************************************
        Compute Manifest Outputs targets
       ******************************************************************************************* -->
  <!-- Add Manifest (Mt) generates .manifest files to Link item group -->
  <Target Name="ComputeManifestGeneratedLinkerInputs" DependsOnTargets="$(ComputeManifestGeneratedLinkerInputs)">
    <ItemGroup Condition="'@(Manifest)' != ''">
      <ClCompile Include="@(Manifest->'$(IntDir)%(InterfaceIdentifierFileName)')" Condition="'%(Manifest.CompileInterface)' == 'true'">
        <!-- Translate Manifest specific metadata to Compile one -->
        <LinkCompiled Condition="'%(Manifest.LinkCompiled)'=='' and '%(Manifest.LinkCompiledInterface)'!=''">%(Manifest.LinkCompiledInterface)</LinkCompiled>
        <LibCompiled Condition="'%(Manifest.LibCompiled)'=='' and '%(Manifest.LibCompiledInterface)'!=''">%(Manifest.LibCompiledInterface)</LibCompiled>
        <ImpLibCompiled Condition="'%(Manifest.ImpLibCompiled)'=='' and '%(Manifest.ImpLibCompiledInterface)'!=''">%(Manifest.ImpLibCompiledInterface)</ImpLibCompiled>
      </ClCompile>
      <ClCompile Include="@(Manifest->'$(IntDir)%(ProxyFileName)')" Condition="'%(Manifest.CompileProxy)' == 'true'">
        <!-- Translate Manifest specific metadata to Compile one -->
        <LinkCompiled Condition="'%(Manifest.LinkCompiled)'=='' and '%(Manifest.LinkCompiledProxy)'!=''">%(Manifest.LinkCompiledProxy)</LinkCompiled>
        <LibCompiled Condition="'%(Manifest.LibCompiled)'==''  and '%(Manifest.LibCompiledProxy)'!=''">%(Manifest.LibCompiledProxy)</LibCompiled>
        <ImpLibCompiled Condition="'%(Manifest.ImpLibCompiled)'=='' and '%(Manifest.ImpLibCompiledProxy)'!=''">%(Manifest.ImpLibCompiledProxy)</ImpLibCompiled>
      </ClCompile>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeManifestGeneratedLinkerInputs;
    </ComputeLinkInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        CL targets
       ******************************************************************************************* -->
  <Target Name="_ClCompile" DependsOnTargets="$(BeforeClCompileTargets);$(ComputeCompileInputsTargets);MakeDirsForCl;ClCompile;$(AfterClCompileTargets)" />
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeClCompileTargets>
      $(BeforeClCompileTargets);
      BeforeClCompile;
    </BeforeClCompileTargets>
    <AfterClCompileTargets>
      $(AfterClCompileTargets);
      AfterClCompile;
    </AfterClCompileTargets>
  </PropertyGroup>
  <!--Moved here to filter out the unset values-->
  <ItemDefinitionGroup>
    <Link>
      <EntryPointSymbol Condition="'%(Link.EntryPointSymbol)'            == '' and&#xD;&#xA;                                                '$(ConfigurationType)'                != 'DynamicLibrary' and&#xD;&#xA;                                                '$(CharacterSet)'                     == 'Unicode' and&#xD;&#xA;                                                '%(Link.SubSystem)'                   != 'Console' and&#xD;&#xA;                                                '$(UseOfMFC)'                         != 'false' and&#xD;&#xA;                                                '$(UseOfMFC)'                         != ''">wWinMainCRTStartup</EntryPointSymbol>
      <!-- Add delayimp.lib when Delay Loaded Dlls isn't empty.  Change the property $(DelayImplib) to load a different library or not one at all. -->
      <AdditionalDependencies Condition="'%(Link.DelayLoadDLLs)' != '' and '$(DelayImplib)' != ''">%(AdditionalDependencies);$(DelayImplib)</AdditionalDependencies>
      <ManifestFile Condition="'$(GenerateManifest)' != 'true'" />
      <EnableUAC Condition="'$(GenerateManifest)' != 'true'" />
      <ImportLibrary Condition="'%(Link.ImportLibrary)' == '' and '$(IgnoreImportLibrary)' == 'false'">$(OutDir)$(TargetName).lib</ImportLibrary>
    </Link>
  </ItemDefinitionGroup>
  <Target Name="ComputeCLInputPDBName">
    <ItemGroup Condition="'$(DesignTimeBuild)' != 'true'">
      <ClCompile Condition="HasTrailingSlash('%(ClCompile.ProgramDataBaseFileName)') and '%(ClCompile.DebugInformationFormat)' != ''">
        <ProgramDataBaseFileName Condition="'$(ConfigurationType)' != 'StaticLibrary'">%(ProgramDataBaseFileName)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
        <ProgramDataBaseFileName Condition="'$(ConfigurationType)' == 'StaticLibrary'">%(ProgramDataBaseFileName)$(TargetName).pdb</ProgramDataBaseFileName>
      </ClCompile>
    </ItemGroup>
  </Target>
  <!-- List of directories and files whose directories should be made prior to running CL -->
  <!-- Makes the the directories that CL uses -->
  <Target Name="MakeDirsForCl">
    <ItemGroup Condition="'@(CLCompile)'!=''">
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('PrecompiledHeaderOutputFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('AssemblerListingLocation')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('ObjectFileName')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('ProgramDataBaseFileName')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('XMLDocumentationFileName')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('BrowseInformationFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('PreprocessOutputPath')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <ClDirsToMake Include="@(CLCompile-&gt;Metadata('ModuleOutputFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
    </ItemGroup>
    <MakeDir Directories="@(ClDirsToMake)" />
    <ItemGroup>
      <ClDirsToMake Remove="@(ClDirsToMake)" />
    </ItemGroup>
  </Target>
  <Target Name="BeforeClCompile" />
  <Target Name="AfterClCompile" />
  <!-- *******************************************************************************************
        Compute Reference CL Inputs
       ******************************************************************************************* -->
  <!-- This will compute the references for the /FU switch on compiler. -->
  <Target Name="ComputeReferenceCLInput" Condition="'$(ReferenceResolutionDisabled)' != 'true' and '$(ComputeReferenceCLInputDisabled)' != 'true'" DependsOnTargets="FindReferenceAssembliesForReferences;GetReferencedVCProjectsInfo" Returns="@(ReferencePath)">
    <ItemGroup Condition="'@(ReferencedVCProjectsInfo)' != ''">
       <ReferencedProjectsPublicModules Include="@(ReferencedVCProjectsInfo)" Condition="'%(ReferencedVCProjectsInfo.FileType)' == 'Module'" /><ReferencedProjectsPublicHeaderUnits Include="@(ReferencedVCProjectsInfo)" Condition="'%(ReferencedVCProjectsInfo.FileType)' == 'HeaderUnit'" /><_ReferencedPublicIncludeDirectories Include="@(ReferencedVCProjectsInfo)" Condition="'%(ReferencedVCProjectsInfo.FileType)' == 'IncludeDirectory'" /><ReferencedLibraryManifests Include="@(ReferencedVCProjectsInfo)" Condition="'%(ReferencedVCProjectsInfo.FileType)' == 'LibraryManifest'" /></ItemGroup>
    <ItemGroup Condition="'@(_ReferencedPublicIncludeDirectories)' != ''">
      <ClCompile>
        <AdditionalIncludeDirectories>%(ClCompile.AdditionalIncludeDirectories);@(_ReferencedPublicIncludeDirectories-&gt;Metadata('Identity')-&gt;Distinct())</AdditionalIncludeDirectories>
      </ClCompile>
    </ItemGroup>
    <ItemGroup>
      <_ReferencedPublicIncludeDirectories Remove="@(_ReferencedPublicIncludeDirectories)" />
    </ItemGroup>
    <!-- C++/CLI project -->
    <ItemGroup>
      <ClCompile Condition="'@(ClCompile)' != '' and '%(ClCompile.CompileAsManaged)' != 'false' and '%(ClCompile.CompileAsManaged)' != '' and '%(ClCompile.CompileAsManaged)' != 'NetCore'">
        <AdditionalUsingDirectories>$(TargetFrameworkDirectory);%(ClCompile.AdditionalUsingDirectories)</AdditionalUsingDirectories>
        <AdditionalOptions Condition="('$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v2.0')">/d1clr:nostdlib %(ClCompile.AdditionalOptions)</AdditionalOptions>
        <AdditionalOptions Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5'">/clr:nostdlib %(ClCompile.AdditionalOptions)</AdditionalOptions>
      </ClCompile>
      <ClCompile Condition="'@(ClCompile)' != '' and '%(ClCompile.CompileAsManaged)' == 'NetCore'">
        <AdditionalOptions>/clr:nostdlib %(ClCompile.AdditionalOptions)</AdditionalOptions>
      </ClCompile>
    </ItemGroup>
    <!-- Add the results to the ReferencePath and to Compiler /FU switch -->
    <ItemGroup Condition="'@(ReferencePathWithRefAssemblies)' != ''">
      <AssemblyReferenceToCompile Condition="'%(ReferencePathWithRefAssemblies.ReferenceOutputAssembly)' != 'false' and '%(ReferencePathWithRefAssemblies.WinMDFile)' != 'true'" Include="@(ReferencePathWithRefAssemblies)" />
      <WinMDReferenceToCompile Condition="'%(ReferencePathWithRefAssemblies.ReferenceOutputAssembly)' != 'false' and '%(ReferencePathWithRefAssemblies.WinMDFile)' == 'true'" Include="@(ReferencePathWithRefAssemblies)" />
      <ClCompile>
        <ForcedUsingFiles Condition="'%(ClCompile.CompileAsManaged)' != 'false' and '%(ClCompile.CompileAsManaged)' != ''">%(ClCompile.ForcedUsingFiles);@(AssemblyReferenceToCompile)</ForcedUsingFiles>
        <ForcedUsingFiles Condition="'%(ClCompile.CompileAsWinRT)' == 'true' and '@(WinMDReferenceToCompile)' != ''">%(ClCompile.ForcedUsingFiles);@(WinMDReferenceToCompile)</ForcedUsingFiles>
      </ClCompile>
    </ItemGroup>
    <!-- Add CRT files to copy if requested -->
    <ItemGroup Condition="'$(CopyCppRuntimeToOutputDir)' == 'true' and '$(ApplicationType)' == ''">
      <_CppRuntimeFilesDirs Include="$(DebugCppRuntimeFilesPath)" Condition="'$(UseDebugLibraries)' == 'true' and '$(DebugCppRuntimeFilesPath)' != ''" />
      <_CppRuntimeFilesDirs Include="$(CppRuntimeFilesPath)" Condition="'$(UseDebugLibraries)' != 'true' and '$(CppRuntimeFilesPath)' != ''" />
      <_CppRuntimeFiles Include="%(_CppRuntimeFilesDirs.Identity)\**\*.dll" />
      <ReferenceCopyLocalPaths Include="@(_CppRuntimeFiles)" Condition="'@(_CppRuntimeFiles)' != ''" />
    </ItemGroup>
    <ItemGroup Condition="'$(DesignTimeBuild)' != 'true'">
      <_ReferenceOutputsToCopyLocally Include="%(ReferenceCopyLocalPaths.FullPath)">
        <FullDestinationPath>$(OutDirFullPath)%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</FullDestinationPath>
      </_ReferenceOutputsToCopyLocally>
      <!-- Remove files that did not needed copying-->
      <_ReferenceOutputsToCopyLocally Remove="%(_ReferenceOutputsToCopyLocally.FullDestinationPath)" />
    </ItemGroup>
    <!-- Write tlogs for copied references -->
    <WriteLinesToFile Condition="'@(_ReferenceOutputsToCopyLocally)'!='' and '$(DesignTimeBuild)' != 'true' and '$(TrackFileAccess)' == 'true'" File="$(TLogLocation)CopyLocal.read.1u.tlog" Lines="^$(ProjectPath);@(_ReferenceOutputsToCopyLocally)" Encoding="Unicode" Overwrite="true" />
    <WriteLinesToFile Condition="'@(_ReferenceOutputsToCopyLocally)'!='' and '$(DesignTimeBuild)' != 'true' and '$(TrackFileAccess)' == 'true'" File="$(TLogLocation)CopyLocal.write.1u.tlog" Lines="^$(ProjectPath);@(_ReferenceOutputsToCopyLocally->'%(FullDestinationPath)')" Encoding="Unicode" Overwrite="true" />
    <Message Condition="'$(_REFERENCE_DEBUG)'=='true'" Text="ReferencePath=@(ReferencePath)" Importance="high" />
    <ItemGroup>
      <_ReferenceOutputsToCopyLocally Remove="@(_ReferenceOutputsToCopyLocally)" />
      <_CppRuntimeFilesDirs Remove="@(_CppRuntimeFilesDirs)" />
      <_CppRuntimeFiles Remove="@(_CppRuntimeFiles)" />
    </ItemGroup>
  </Target>
  <Target Name="WarnCompileDuplicatedFilename" Condition="'$(IgnoreWarnCompileDuplicatedFilename)' != 'true' and '$(DesignTimeBuild)' != 'true'">
    <!-- This conditions follow this logic:  Giving a filename, there should only be one number file in ClCompile that has the same filename with a unique ObjectFileName.
         ObjectFilename determines the output location for the OBJ. -->
    <VCMessage Code="MSB8027" Type="Warning" Arguments="%(Filename)%(Extension);@(ClCompile, ', ')" Condition="'%(ClCompile.ExcludedFromBuild)' != 'true' and '%(Filename)%(Extension)' != '@(ClCompile->'%(Filename)%(Extension)')' and '%(ObjectFileName)' == '@(ClCompile-&gt;Metadata(ObjectFileName)-&gt;Distinct())'" />
  </Target>
  <PropertyGroup>
    <GetTargetPathDependsOn>_PrepareForReferenceResolution;GetResolvedWinMD;$(GetTargetPathDependsOn)</GetTargetPathDependsOn>
  </PropertyGroup>
  <Target Name="GetTargetPath" DependsOnTargets="$(GetTargetPathDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)">
    <ItemGroup>
      <TargetPathWithTargetPlatformMoniker Include="@(WinMDFullPath)" />
      <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)" Condition="'@(TargetPathWithTargetPlatformMoniker)' == ''">
        <ResolveableAssembly Condition="'$(ConfigurationType)' != 'StaticLibrary'">$(ManagedAssembly)</ResolveableAssembly>
        <ResolveableAssembly Condition="'$(ConfigurationType)' == 'StaticLibrary'">false</ResolveableAssembly>
      </TargetPathWithTargetPlatformMoniker>
      <TargetPathWithTargetPlatformMoniker>
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
  </Target>
  <Target Name="GetNativeTargetPath" DependsOnTargets="_PrepareForReferenceResolution" Returns="@(NativeTargetPath)">
    <ItemGroup>
      <NativeTargetPath Include="$(TargetPath)" Condition="('$(ConfigurationType)' == 'StaticLibrary' or '$(ManagedAssembly)' != 'true') and !HasTrailingSlash('$(TargetPath)')" />
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)'=='true'" Importance="High" Text="NativeTargetPath=@(NativeTargetPath)" />
  </Target>
  <PropertyGroup>
    <ComputeCompileInputsTargets>
      $(ComputeCompileInputsTargets);
      ComputeCLInputPDBName;
      ComputeReferenceCLInput;
      WarnCompileDuplicatedFilename
    </ComputeCompileInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Compute Custom Build Output
       ******************************************************************************************* -->
  <Target Name="ComputeCustomBuildOutput">
    <ItemGroup>
      <CustomBuildOutputs Include="@(CustomBuild-&gt;Metadata('Outputs'))" Condition="'@(CustomBuild)' != ''" />
      <!-- legacy support for LinkObjects -->
      <CustomBuildOutputs Condition="'%(CustomBuildOutputs.ExcludedFromBuild)'!='true'&#xD;&#xA;                                 and '%(CustomBuildOutputs.OutputItemType)'==''&#xD;&#xA;                                 and '%(CustomBuildOutputs.LinkObjects)'=='true'&#xD;&#xA;                                 and ('%(Extension)'=='.obj' or '%(Extension)'=='.res' or '%(Extension)'=='.rsc' or '%(Extension)'=='.lib')">
        <OutputItemType Condition="'$(ConfigurationType)'=='StaticLibrary'">Lib</OutputItemType>
        <OutputItemType Condition="'$(ConfigurationType)'!='StaticLibrary'">Link</OutputItemType>
      </CustomBuildOutputs>
    </ItemGroup>
    <!-- Add CustomBuild Outputs to lib, link or other tools -->
    <CreateItem Include="@(CustomBuildOutputs)" Condition="'%(CustomBuildOutputs.OutputItemType)'!=''">
      <Output TaskParameter="Include" ItemName="%(CustomBuildOutputs.OutputItemType)" />
      <Output TaskParameter="Include" Condition="'%(CustomBuildOutputs.OutputItemType)' == 'Link' and '$(GenerateImportLib)'=='true'" ItemName="ImpLib" />
    </CreateItem>
    <!-- Include outputs from Custom Build Step -->
    <ItemGroup>
      <CustomBuildOutputs Include="@(CustomBuildStep-&gt;Metadata('Outputs')-&gt;Distinct()-&gt;ClearMetadata())" Condition="'%(CustomBuildStep.Command)' != ''" />
    </ItemGroup>
    <MakeDir Directories="@(CustomBuildOutputs->'%(RootDir)%(Directory)')" />
    <!-- Cleanup -->
    <ItemGroup>
      <CustomBuildOutputs Remove="@(CustomBuildOutputs)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeCustomBuildOutput;
    </ComputeLinkInputsTargets>
  </PropertyGroup>
  <PropertyGroup>
    <ComputeLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeCustomBuildOutput;
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <PropertyGroup>
    <ComputeImpLibInputsTargets>
      $(ComputeImpLibInputsTargets);
      ComputeCustomBuildOutput;
    </ComputeImpLibInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Compute CL Outputs  targets
       ******************************************************************************************* -->
  <ItemDefinitionGroup>
    <ClCompile>
      <LinkCompiled>$(LinkCompiled)</LinkCompiled>
      <LibCompiled>$(LibCompiled)</LibCompiled>
      <ImpLibCompiled>$(ImpLibCompiled)</ImpLibCompiled>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Add CL generates .obj files to Obj item group, it will be used by lib or link -->
  <Target Name="ComputeCLOutputs" DependsOnTargets="$(ComputeCompileInputsTargets);SetModuleDependencies" Condition="'@(ClCompile)' != ''">
    <ItemGroup>
      <!-- No object file name defined: filename.obj -->
      <Obj Condition="'%(ClCompile.ObjectFileName)'=='' and '%(ClCompile.ExcludedFromBuild)'!='true' and ('%(ClCompile.CompilerIteration)' == '' or '%(ClCompile.CompilerIteration)' == 'Modules')" Include="@(ClCompile->'%(Filename).obj')">
        <LinkCompiled>%(ClCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ClCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ClCompile.ImpLibCompiled)</ImpLibCompiled>
      </Obj>
      <!-- Object file name is a directory (has trailing slash): ofn\filename.obj -->
      <Obj Condition="HasTrailingSlash('%(ClCompile.ObjectFileName)') and '%(ClCompile.ExcludedFromBuild)'!='true' and ('%(ClCompile.CompilerIteration)' == '' or '%(ClCompile.CompilerIteration)' == 'Modules')" Include="@(ClCompile->'%(ObjectFileName)%(Filename).obj')">
        <LinkCompiled>%(ClCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ClCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ClCompile.ImpLibCompiled)</ImpLibCompiled>
      </Obj>
      <!-- Object file name is a file (does not has trailing slash): ofn -->
      <Obj Condition="'%(ClCompile.ObjectFileName)' != '' and !HasTrailingSlash('%(ClCompile.ObjectFileName)') and '%(ClCompile.ExcludedFromBuild)'!='true' and ('%(ClCompile.CompilerIteration)' == '' or '%(ClCompile.CompilerIteration)' == 'Modules')" Include="@(ClCompile->'%(ObjectFileName)')">
        <LinkCompiled>%(ClCompile.LinkCompiled)</LinkCompiled>
        <LibCompiled>%(ClCompile.LibCompiled)</LibCompiled>
        <ImpLibCompiled>%(ClCompile.ImpLibCompiled)</ImpLibCompiled>
      </Obj>
    </ItemGroup>
  </Target>
  <Target Name="ComputeCLGeneratedLinkInputs" DependsOnTargets="ComputeCLOutputs">
    <ItemGroup>
      <Link Include="@(Obj-&gt;WithMetadataValue('LinkCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
    <!-- ManagedAssembly property defined as false by default for VC projects
         so we need to set it to true when needed here -->
    <PropertyGroup>
      <ManagedAssembly Condition="'%(Obj.CompileAsManaged)' != '' and '%(Obj.CompileAsManaged)' != 'false'">true</ManagedAssembly>
      <TargetRuntime Condition="'$(ManagedAssembly)' == 'true'">Managed</TargetRuntime>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeCLGeneratedLinkInputs;
    </ComputeLinkInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeCLGeneratedLibInputs" DependsOnTargets="ComputeCLOutputs">
    <ItemGroup>
      <Lib Include="@(Obj-&gt;WithMetadataValue('LibCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeCLGeneratedLibInputs;
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeCLGeneratedImpLibInputs" DependsOnTargets="ComputeCLOutputs">
    <ItemGroup>
      <ImpLib Include="@(Obj-&gt;WithMetadataValue('ImpLibCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeImpLibInputsTargets>
      $(ComputeImpLibInputsTargets);
      ComputeCLGeneratedImpLibInputs;
    </ComputeImpLibInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Compute project file link or lib inputs
       ******************************************************************************************* -->
  <Target Name="ComputeLinkInputsFromProject">
    <ItemGroup>
      <Object Remove="@(Object)" Condition="'%(Object.ExcludedFromBuild)'=='true'" />
      <Library Remove="@(Library)" Condition="'%(Library.ExcludedFromBuild)'=='true'" />
      <Resource Remove="@(Resource)" Condition="'%(Resource.ExcludedFromBuild)'=='true'" />
      <Natvis Remove="@(Natvis)" Condition="'%(Natvis.ExcludedFromBuild)'=='true'" />
      <Link Include="@(Object-&gt;ClearMetadata())" />
      <Link Include="@(Library-&gt;ClearMetadata())" />
      <Link Include="@(Resource-&gt;ClearMetadata())" />
    </ItemGroup>
    <!-- The build only wants to generate winmd once, either during Link target or Createwinmd target, not both.
      Link and Createwinmd targets will execute link.exe, so it is best to run link.exe only once.
      However, there are two cases where that isn't possible.
      1) when build is building XAML and
      2) when building in passes.  -->
    <PropertyGroup>
      <GenerateBuildCompilePassWinMD Condition="'$(GenerateBuildCompilePassWinMD)' == '' and '$(ImpLibCompiled)' == 'true'">true</GenerateBuildCompilePassWinMD>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeLinkInputsFromProject;
    </ComputeLinkInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeLibInputsFromProject">
    <ItemGroup>
      <Object Remove="@(Object)" Condition="'%(Object.ExcludedFromBuild)'=='true'" />
      <Library Remove="@(Library)" Condition="'%(Library.ExcludedFromBuild)'=='true'" />
      <Resource Remove="@(Resource)" Condition="'%(Resource.ExcludedFromBuild)'=='true'" />
      <Lib Include="@(Object-&gt;ClearMetadata())" />
      <Lib Include="@(Library-&gt;ClearMetadata())" />
      <Lib Include="@(Resource-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeLibInputsFromProject;
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeImpLibInputsFromProject">
    <ItemGroup>
      <Object Remove="@(Object)" Condition="'%(Object.ExcludedFromBuild)'=='true'" />
      <Library Remove="@(Library)" Condition="'%(Library.ExcludedFromBuild)'=='true'" />
      <Resource Remove="@(Resource)" Condition="'%(Resource.ExcludedFromBuild)'=='true'" />
      <ImpLib Include="@(Object-&gt;ClearMetadata())" />
      <ImpLib Include="@(Library-&gt;ClearMetadata())" />
      <ImpLib Include="@(Resource-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ComputeImpLibInputsTargets>
      $(ComputeImpLibInputsTargets);
      ComputeImpLibInputsFromProject;
    </ComputeImpLibInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Link targets
       ******************************************************************************************* -->
  <Target Name="_Link" DependsOnTargets="$(BeforeLinkTargets);$(ComputeLinkInputsTargets);ComputeManifestInputsTargets;ManifestResourceCompile;PrepareResourceNames;MakeDirsForLink;DoLinkOutputFilesMatch;PreLinkEvent;Link;$(AfterLinkTargets)" Condition="'$(LinkCompiled)' == 'true'" />
  <Target Name="DoLinkOutputFilesMatch" Condition="'@(Link)' != ''">
    <ItemGroup>
      <_OutputFileFromLink Include="%(Link.OutputFile)" />
    </ItemGroup>
    <VCMessage Condition="'@(_OutputFileFromLink)' == ''" Code="MSB8012" Type="Warning" Arguments="TargetPath;$(TargetPath);Linker;;Link" />
    <VCMessage Condition="'@(_OutputFileFromLink)' != '' and '%(_OutputFileFromLink.FullPath)' != '$([System.IO.Path]::GetFullPath($(TargetPath)))'" Code="MSB8012" Type="Warning" Arguments="TargetPath;$(TargetPath);Linker;%(_OutputFileFromLink.FullPath);Link" />
    <VCMessage Condition="'@(_OutputFileFromLink)' != '' and '%(_OutputFileFromLink.Extension)' != '' and '%(_OutputFileFromLink.Extension)' != '$(TargetExt)'" Code="MSB8012" Type="Warning" Arguments="TargetExt;$(TargetExt);Linker;%(_OutputFileFromLink.Extension);Link" />
    <VCMessage Condition="'@(_OutputFileFromLink)' != '' and '%(_OutputFileFromLink.Filename)' != '' and '%(_OutputFileFromLink.Filename)' != '$(TargetName)'" Code="MSB8012" Type="Warning" Arguments="TargetName;$(TargetName);Linker;%(_OutputFileFromLink.Filename);Link" />
    <VCMessage Condition="'%(Link.MinimumRequiredVersion)' != '' and ('%(Link.Subsystem)' == '' or '%(Link.Subsystem)' == 'NotSet')" Code="MSB8030" Type="Warning" />
  </Target>
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeLinkTargets>
      $(BeforeLinkTargets);
      BeforeLink;
    </BeforeLinkTargets>
    <AfterLinkTargets>
      $(AfterLinkTargets);
      AfterLink;
    </AfterLinkTargets>
  </PropertyGroup>
  <!-- Makes the the directories that Link uses -->
  <Target Name="MakeDirsForLink">
    <!-- List of directories and files whose directories should be made prior to running Link -->
    <!-- Because the import library metadata contains an item expression, we need to
         force a scalar expansion here -->
    <PropertyGroup>
      <_LinkImportLibrary>%(Link.ImportLibrary)</_LinkImportLibrary>
    </PropertyGroup>
    <ItemGroup>
      <_LinkImportLibraryFile Include="$(_LinkImportLibrary)" />
    </ItemGroup>
    <ItemGroup Condition="'@(Link)' != ''">
      <LinkDirsToMake Include="@(Link-&gt;Metadata('MapFileName')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <LinkDirsToMake Include="@(Link-&gt;Metadata('OutputFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <LinkDirsToMake Include="@(Link-&gt;Metadata('ManifestFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <LinkDirsToMake Include="@(Link-&gt;Metadata('ProgramDatabaseFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <LinkDirsToMake Include="@(Link-&gt;Metadata('WindowsMetadataFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
      <LinkDirsToMake Include="@(_LinkImportLibraryFile->'%(RootDir)%(Directory)')" />
    </ItemGroup>
    <MakeDir Directories="@(LinkDirsToMake)" />
    <ItemGroup>
      <LinkDirsToMake Remove="@(LinkDirsToMake)" />
      <_LinkImportLibraryFile Remove="@(_LinkImportLibraryFile)" />
    </ItemGroup>
  </Target>
  <Target Name="BeforeLink" />
  <Target Name="AfterLink" />
  <!-- *******************************************************************************************
        Compute Reference Link Inputs
       ******************************************************************************************* -->
  <Target Name="_RemoveNameMetadataFromProjectReferenceItems" Condition="'@(ProjectReference)'!=''" BeforeTargets="ResolveProjectReferences">
    <!-- ProjectReference items often have metadata called 'Name' on them, which is also
             used for a different purpose by tasks like Lib. So, clear it out -->
    <ItemGroup>
      <ProjectReference>
        <_ReferencedProjectName>%(ProjectReference.Name)</_ReferencedProjectName>
        <Name />
      </ProjectReference>
    </ItemGroup>
  </Target>
  <Target Name="ComputeResolveLinkObj" Condition="'@(ProjectReference)'!=''">
    <CallTarget Targets="ResolvedLinkObjs" Condition="'%(_MSBuildProjectReferenceExistent.UseLibraryDependencyInputs)'=='true'" />
  </Target>
  <Target Name="ComputeReferenceLinkInputs" DependsOnTargets="ResolvedLinkLib;ComputeResolveLinkObj" Returns="@(ProjectReferenceToLink)" Condition="@(ProjectReference) != ''">
    <ItemGroup Condition="'@(_ResolvedNativeProjectReferencePaths)' != ''">
      <ProjectReferenceToLink Condition=" '%(_ResolvedNativeProjectReferencePaths.FileType)'=='lib'&#xD;&#xA;                                      and  '%(_ResolvedNativeProjectReferencePaths.LinkLibraryDependencies)'!='false'&#xD;&#xA;                                      and ('%(_ResolvedNativeProjectReferencePaths.UseLibraryDependencyInputs)'!='true' or '%(_ResolvedNativeProjectReferencePaths.ProjectType)'!='StaticLibrary')" Include="@(_ResolvedNativeProjectReferencePaths)" />
      <ProjectReferenceToLink Condition="'%(_ResolvedNativeProjectReferencePaths.FileType)'=='obj'&#xD;&#xA;                                      and '%(_ResolvedNativeProjectReferencePaths.LinkLibraryDependencies)'!='false'&#xD;&#xA;                                      and '%(_ResolvedNativeProjectReferencePaths.UseLibraryDependencyInputs)'=='true'&#xD;&#xA;                                      and '%(_ResolvedNativeProjectReferencePaths.ProjectType)'=='StaticLibrary'" Include="@(_ResolvedNativeProjectReferencePaths)" />
      <ProjectReferenceToLink>
        <CopyLocal Condition="'%(ProjectReferenceToLink.CopyLocal)'==''">%(ProjectReferenceToLink.Private)</CopyLocal>
      </ProjectReferenceToLink>
      <Link Condition="'@(ProjectReferenceToLink)'!='' and '$(GetResolvedLinkLibs_Order)' != 'BreadthFirst'" Include="@(ProjectReferenceToLink-&gt;ClearMetadata()-&gt;Distinct())">
        <TimestampSurrogate>%(ProjectReferenceToLink.TimestampSurrogate)</TimestampSurrogate>
      </Link>
      <Link Condition="'@(ProjectReferenceToLink)'!='' and '$(GetResolvedLinkLibs_Order)' == 'BreadthFirst'" Include="@(ProjectReferenceToLink-&gt;ClearMetadata()-&gt;Reverse()-&gt;Distinct()-&gt;Reverse())">
        <TimestampSurrogate>%(ProjectReferenceToLink.TimestampSurrogate)</TimestampSurrogate>
      </Link>
    </ItemGroup>
    <VCMessage Condition="'%(ProjectReferenceToLink.ProjectType)' == 'DynamicLibrary' and '$(WindowsAppContainer)' == 'true' and '%(ProjectReferenceToLink.WindowsAppContainer)' != 'true'" Code="MSB8019" Type="Warning" Arguments="@(ProjectReferenceToLink);%(ProjectReferenceToLink.MSBuildSourceProjectFile)" />
    <Message Condition="'$(_REFERENCE_DEBUG)'=='true'" Text="ProjectReferenceToLink=@(ProjectReferenceToLink)" Importance="high" />
  </Target>
  <PropertyGroup>
    <ComputeLinkInputsTargets>
      $(ComputeLinkInputsTargets);
      ComputeReferenceLinkInputs;
    </ComputeLinkInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Compute Reference Lib Inputs
       ******************************************************************************************* -->
  <Target Name="ComputeReferenceLibInputs" DependsOnTargets="ResolvedLinkLib" Returns="@(ProjectReferenceToLink)" Condition="@(ProjectReference) != ''">
    <ItemGroup Condition="'@(_ResolvedNativeProjectReferencePaths)' != ''">
      <ProjectReferenceToLink Condition=" '%(_ResolvedNativeProjectReferencePaths.FileType)'=='lib'&#xD;&#xA;                                      and  '%(_ResolvedNativeProjectReferencePaths.LinkLibraryDependencies)'!='false'&#xD;&#xA;                                      and ('%(_ResolvedNativeProjectReferencePaths.UseLibraryDependencyInputs)'=='false' or '%(_ResolvedNativeProjectReferencePaths.ProjectType)'!='StaticLibrary')" Include="@(_ResolvedNativeProjectReferencePaths)" />
      <ProjectReferenceToLink Condition="'%(_ResolvedNativeProjectReferencePaths.FileType)'=='obj'&#xD;&#xA;                                      and '%(_ResolvedNativeProjectReferencePaths.LinkLibraryDependencies)'!='false'&#xD;&#xA;                                      and '%(_ResolvedNativeProjectReferencePaths.UseLibraryDependencyInputs)'=='true'&#xD;&#xA;                                      and '%(_ResolvedNativeProjectReferencePaths.ProjectType)'=='StaticLibrary'" Include="@(_ResolvedNativeProjectReferencePaths)" />
      <ProjectReferenceToLink>
        <CopyLocal Condition="'%(ProjectReferenceToLink.CopyLocal)'==''">%(ProjectReferenceToLink.Private)</CopyLocal>
      </ProjectReferenceToLink>
      <Lib Condition="'@(ProjectReferenceToLink)'!='' and '$(GetResolvedLinkLibs_Order)' != 'BreadthFirst'" Include="@(ProjectReferenceToLink-&gt;ClearMetadata()-&gt;Distinct())">
        <TimestampSurrogate>%(ProjectReferenceToLink.TimestampSurrogate)</TimestampSurrogate>
      </Lib>
      <Lib Condition="'@(ProjectReferenceToLink)'!='' and '$(GetResolvedLinkLibs_Order)' == 'BreadthFirst'" Include="@(ProjectReferenceToLink-&gt;ClearMetadata()-&gt;Reverse()-&gt;Distinct()-&gt;Reverse())">
        <TimestampSurrogate>%(ProjectReferenceToLink.TimestampSurrogate)</TimestampSurrogate>
      </Lib>
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)'=='true'" Text="ProjectReferenceToLink=@(ProjectReferenceToLink)" Importance="high" />
  </Target>
  <PropertyGroup>
    <ComputeLibInputsTargets>
      $(ComputeLibInputsTargets);
      ComputeReferenceLibInputs;
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <!-- *******************************************************************************************
        Lib targets
       ******************************************************************************************* -->
  <Target Name="_Lib" DependsOnTargets="$(BeforeLibTargets);$(ComputeLibInputsTargets);MakeDirsForLib;DoLibOutputFilesMatch;PreLinkEvent;Lib;$(AfterLibTargets);" Condition="'$(LibCompiled)' == 'true'" />
  <Target Name="DoLibOutputFilesMatch" Condition="'@(Lib)' != ''">
    <ItemGroup>
      <_OutputFileFromLib Include="%(Lib.OutputFile)" />
    </ItemGroup>
    <VCMessage Condition="'@(_OutputFileFromLib)' == ''" Code="MSB8012" Type="Warning" Arguments="TargetPath;$(TargetPath);Library;;Lib" />
    <VCMessage Condition="'@(_OutputFileFromLib)' != '' and '%(_OutputFileFromLib.FullPath)' != '$([System.IO.Path]::GetFullPath($(TargetPath)))'" Code="MSB8012" Type="Warning" Arguments="TargetPath;$(TargetPath);Library;%(_OutputFileFromLib.FullPath);Lib" />
    <VCMessage Condition="'@(_OutputFileFromLib)' != '' and '%(_OutputFileFromLib.Extension)' != '' and '%(_OutputFileFromLib.Extension)' != '$(TargetExt)'" Code="MSB8012" Type="Warning" Arguments="TargetExt;$(TargetExt);Library;%(_OutputFileFromLib.Extension);Lib" />
    <VCMessage Condition="'@(_OutputFileFromLib)' != '' and '%(_OutputFileFromLib.Filename)' !=  '' and '%(_OutputFileFromLib.Filename)' != '$(TargetName)'" Code="MSB8012" Type="Warning" Arguments="TargetName;$(TargetName);Library;%(_OutputFileFromLib.Filename);Lib" />
  </Target>
  <!-- Makes the the directories that Lib uses -->
  <Target Name="MakeDirsForLib">
    <!-- List of directories and files whose directories should be made prior to running Lib -->
    <ItemGroup Condition="'@(Lib)' != ''">
      <LibDirsToMake Include="@(Lib-&gt;Metadata('OutputFile')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" />
    </ItemGroup>
    <MakeDir Directories="@(LibDirsToMake)" />
    <ItemGroup>
      <LibDirsToMake Remove="@(LibDirsToMake)" />
    </ItemGroup>
  </Target>
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeLibTargets>
      $(BeforeLibTargets);
      BeforeLib;
    </BeforeLibTargets>
    <AfterLibTargets>
      $(AfterLibTargets);
      AfterLib;
    </AfterLibTargets>
  </PropertyGroup>
  <Target Name="BeforeLib" />
  <Target Name="AfterLib" />
  <!-- *******************************************************************************************
        UNDONE: Compute Lib AdditionalOptions
       ******************************************************************************************* -->
  <PropertyGroup>
    <ComputeLibInputsTargets>
      ComputeLibAdditionalOptions;
      $(ComputeLibInputsTargets)
    </ComputeLibInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeLibAdditionalOptions">
    <ItemGroup>
      <Lib Include="captureLibAdditionalOptions" />
    </ItemGroup>
    <PropertyGroup>
      <LibAdditionalOptions>%(Lib.AdditionalOptions)</LibAdditionalOptions>
    </PropertyGroup>
    <ItemGroup>
      <Lib Remove="captureLibAdditionalOptions" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        ImpLib targets
       ******************************************************************************************* -->
  <Target Name="_ImpLib" DependsOnTargets="$(BeforeImpLibTargets);$(ComputeImpLibInputsTargets);PreLinkEvent;ImpLib;$(AfterImpLibTargets);" Condition="'$(ImpLibCompiled)' == 'true'" />
  <!-- Easy to override before/after targets -->
  <PropertyGroup>
    <BeforeImpLibTargets>
      $(BeforeImpLibTargets);
      BeforeImpLib;
    </BeforeImpLibTargets>
    <AfterImpLibTargets>
      $(AfterImpLibTargets);
      AfterImpLib;
    </AfterImpLibTargets>
  </PropertyGroup>
  <Target Name="BeforeImpLib" />
  <Target Name="AfterImpLib" />
  <!-- *******************************************************************************************
        XDCMake targets
      ******************************************************************************************* -->
  <!-- Add ClCompile generates .xdc files to XdcMake item group -->
  <Target Name="ComputeCLCompileGeneratedXDCFiles" DependsOnTargets="$(ComputeCLCompileGeneratedXDCFilesDependsOn)">
    <ItemGroup Condition="'@(ClCompile)' != ''">
      <XdcMake Include="@(ClCompile-&gt;'%(XMLDocumentationFileName)'-&gt;ClearMetadata())" Condition="'%(ClCompile.GenerateXMLDocumentationFiles)' == 'true' and '%(ClCompile.XMLDocumentationFileName)' != '' and !HasTrailingSlash(%(ClCompile.XMLDocumentationFileName)) and '%(ClCompile.ExcludedFromBuild)'!='true'" />
      <XdcMake Include="@(ClCompile-&gt;'%(XMLDocumentationFileName)%(FileName).xdc'-&gt;ClearMetadata())" Condition="'%(ClCompile.GenerateXMLDocumentationFiles)' == 'true' and '%(ClCompile.XMLDocumentationFileName)' != '' and HasTrailingSlash(%(ClCompile.XMLDocumentationFileName)) and '%(ClCompile.ExcludedFromBuild)'!='true'" />
      <XdcMake Include="@(ClCompile-&gt;'$(IntDir)%(FileName).xdc'-&gt;ClearMetadata())" Condition="'%(ClCompile.GenerateXMLDocumentationFiles)' == 'true' and '%(ClCompile.XMLDocumentationFileName)' == '' and '%(ClCompile.ExcludedFromBuild)'!='true'" />
      <XdcMake Include="temp" Condition="'@(XdcMake)' == ''">
        <Local>true</Local>
      </XdcMake>
    </ItemGroup>
    <PropertyGroup>
      <XdcMakeDocumentLibraryDependencies Condition="'%(XdcMake.DocumentLibraryDependencies)'=='true'">true</XdcMakeDocumentLibraryDependencies>
      <XdcMakeAdditionalDocumentFile>%(XdcMake.AdditionalDocumentFile)</XdcMakeAdditionalDocumentFile>
    </PropertyGroup>
    <ItemGroup>
      <!-- Also consider project reference if DocumentLibraryDependencies is set to true. -->
      <XdcMake Include="@(_ResolvedNativeProjectReferencePaths)" Condition="'$(XdcMakeDocumentLibraryDependencies)'=='true' and '%(_ResolvedNativeProjectReferencePaths.FileType)'=='xdc'" />
      <!-- Add additional xdc files -->
      <XdcMake Include="$(XdcMakeAdditionalDocumentFile)" Condition="'$(XdcMakeAdditionalDocumentFile)' != ''" />
      <XdcMake Remove="@(XdcMake)" Condition="'%(XdcMake.Local)' == true" />
    </ItemGroup>
  </Target>
  <Target Name="_XdcMake" DependsOnTargets="$(BeforeXdcMakeTargets);ResolvedXDCMake;ComputeCLCompileGeneratedXDCFiles;MakeDirsForXdcMake;XdcMake;$(AfterXdcMakeTargets)" />
  <!-- Makes the the directories that XdcMake uses -->
  <Target Name="MakeDirsForXdcMake">
    <!-- List of directories and files whose directories should be made prior to running XdcMake -->
    <ItemGroup Condition="'@(XdcMake)'!=''">
      <XdcDirsToMake Include="@(XdcMake->'%(OutputFile)')" />
    </ItemGroup>
    <MakeDir Directories="@(XdcDirsToMake->'%(RootDir)%(Directory)')" />
    <ItemGroup>
      <XdcDirsToMake Remove="@(XdcDirsToMake)" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        BSCMake targets
       ******************************************************************************************* -->
  <!-- Add ClCompile generates .sbr files to BscMake item group -->
  <Target Name="ComputeCLCompileGeneratedSbrFiles" DependsOnTargets="$(ComputeCLCompileGeneratedSbrFilesDependsOn)">
    <ItemGroup Condition="'@(ClCompile)' != '' and '@(ClCompile-&gt;AnyHaveMetadataValue('BrowseInformation', 'true'))' == 'true'">
      <BscMake Include="@(ClCompile-&gt;'%(BrowseInformationFile)'-&gt;ClearMetadata())" Condition="'%(ClCompile.BrowseInformation)' == 'true' and '%(ClCompile.BrowseInformationFile)'!='' and !HasTrailingSlash(%(ClCompile.BrowseInformationFile)) and '%(ClCompile.ExcludedFromBuild)'!='true'" />
      <BscMake Include="@(ClCompile-&gt;'%(BrowseInformationFile)%(FileName).sbr'-&gt;ClearMetadata())" Condition="'%(ClCompile.BrowseInformation)' == 'true' and ('%(ClCompile.BrowseInformationFile)'!='' and HasTrailingSlash(%(ClCompile.BrowseInformationFile))) and '%(ClCompile.ExcludedFromBuild)'!='true'" />
      <BscMake Include="@(ClCompile-&gt;'$(IntDir)%(FileName).sbr'-&gt;ClearMetadata())" Condition="'%(ClCompile.BrowseInformation)' == 'true' and '%(ClCompile.BrowseInformationFile)'=='' and '%(ClCompile.ExcludedFromBuild)'!='true'" />
    </ItemGroup>
  </Target>
  <Target Name="_BscMake" DependsOnTargets="$(BeforeBscMakeTargets);ComputeCLCompileGeneratedSbrFiles;MakeDirsForBscMake;BscMake;$(AfterBscMakeTargets)" />
  <!-- Makes the the directories that BscMake uses -->
  <Target Name="MakeDirsForBscMake">
    <!-- List of directories and files whose directories should be made prior to running BscMake -->
    <ItemGroup Condition="'@(BscMake)'!=''">
      <BscDirsToMake Include="@(BscMake->'%(OutputFile)')" />
    </ItemGroup>
    <MakeDir Directories="@(BscDirsToMake->'%(RootDir)%(Directory)')" />
    <ItemGroup>
      <BscDirsToMake Remove="@(BscDirsToMake)" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        ComputeIntermediateSatelliteAssemblies
       ******************************************************************************************* -->
  <!-- Compute the paths to the satellite assemblies,
       with subfolder attributes so we can copy them to the right place. -->
  <PropertyGroup>
    <ComputeIntermediateSatelliteAssembliesDependsOn>
      CreateManifestResourceNames
    </ComputeIntermediateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="ComputeIntermediateSatelliteAssemblies" Condition="@(ReferenceSatellitePaths->'%(DestinationSubDirectory)') != ''" DependsOnTargets="$(ComputeIntermediateSatelliteAssembliesDependsOn)">
    <ItemGroup>
      <ReferenceCopyLocalPaths Include="@(ReferenceSatellitePaths)" Condition="'%(ReferenceSatellitePaths.DestinationSubDirectory)' != '' and '%(ReferenceSatellitePaths.CopyLocalSatelliteAssemblies)' == 'true' and '%(ReferenceSatellitePaths.Private)' == 'true'" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        GetResolved Native Targets
        These targets are for Project to Project references.
       ******************************************************************************************* -->
  <!-- Needed to add this after common.targets -->
  <!-- Using ItemDefinitionGroup group here is incorrect as it ignores the individual item settings, but using just ItemGroup can be a breaking change for existing projects, so we'll keep both for now -->
  <ItemDefinitionGroup>
    <ProjectReference>
      <OutputItemType Condition="'%(ProjectReference.LinkLibraryDependencies)' == 'true' or ('$(ConfigurationType)' == 'StaticLibrary' and '$(DesignTimeBuild)' == 'true')">_ResolvedNativeProjectReferencePaths</OutputItemType>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemGroup Condition="'$(LegacyNativeReferenceResolution)' != 'true'">
    <ProjectReference Update="@(ProjectReference)">
      <OutputItemType Condition="'%(ProjectReference.OutputItemType)' == '' and&#xD;&#xA;                      ('%(ProjectReference.LinkLibraryDependencies)' == 'true' or ('$(ConfigurationType)' == 'StaticLibrary' and '$(DesignTimeBuild)' == 'true'))">_ResolvedNativeProjectReferencePaths</OutputItemType>
    </ProjectReference>
  </ItemGroup>
  <!-- Gets info from referenced vc projects
       Populates ReferencedVCProjectsInfo item group with various types of files and directories from referenced projects
       Currently includes libs, recipe, modules, header units and public include directories. -->
  <Target Name="GetReferencedVCProjectsInfo" DependsOnTargets="$(GetReferencedVCProjectsInfoDependsOn)">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetProjectInfoForReference" BuildInParallel="true" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.Extension)' == '.vcxproj' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="ReferencedVCProjectsInfo" />
    </MSBuild>
  </Target>
  <!-- used in designtime builds-->
  <PropertyGroup>
    <GetClCommandLineForReferenceDependsOn>
      GetPublicIncludeDirectories;
      $(GetClCommandLineForReferenceDependsOn);
    </GetClCommandLineForReferenceDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <GetProjectInfoForReferenceDependsOn>
      $(GetProjectInfoForReferenceDependsOn);
      AddPublicIncludeDirectoriesToProjectsInfoForReference;
    </GetProjectInfoForReferenceDependsOn>
    <GetProjectInfoForReferenceDependsOn Condition="'$(DesignTimeBuild)' != 'true'">
      $(GetProjectInfoForReferenceDependsOn);
      AddPublicBMIsToProjectsInfoForReference;
      AddDeployRecipeFileToProjectsInfoForReference;
      AddLibrariesToProjectsInfoForReference;
    </GetProjectInfoForReferenceDependsOn>
  </PropertyGroup>
  <!-- We don't want to go to referenced projects when this projects is asked for its info -->
  <Target Name="DisableProjectReferenceRecursionForClInputs">
    <PropertyGroup>
      <ComputeReferenceCLInputDisabled>true</ComputeReferenceCLInputDisabled>
    </PropertyGroup>
  </Target>
  <Target Name="GetProjectInfoForReference" Returns="@(ProjectInfoForReference)" DependsOnTargets="DisableProjectReferenceRecursionForClInputs;PrepareForBuild;$(GetProjectInfoForReferenceDependsOn)" />
  <!-- Gets objs from referenced static libraries projects -->
  <Target Name="ResolvedLinkObjs" DependsOnTargets="$(CommonBuildOnlyTargets)">
    <!-- Make sure that called GetResolvedLinkObjs of child projects-->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetResolvedLinkObjs" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.Extension)' == '.vcxproj' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedNativeProjectReferencePaths" />
    </MSBuild>
  </Target>
  <Target Name="GetResolvedLinkObjs" Returns="@(ObjFullPath)" DependsOnTargets="$(CommonBuildOnlyTargets);ComputeCLOutputs;ResolvedLinkObjs" Condition="'$(ConfigurationType)'=='StaticLibrary'">
    <!-- Make sure that recurse into ResolvedLinkObjs of child projects-->
    <PropertyGroup>
      <_ObjFullPath Condition="'@(Obj)'!=''">@(Obj->'%(fullpath)')</_ObjFullPath>
    </PropertyGroup>
    <ItemGroup>
      <ObjFullPath Include="$(_ObjFullPath);@(_ResolvedNativeProjectReferencePaths-&gt;WithMetadataValue('FileType', 'obj')-&gt;ClearMetadata()-&gt;Distinct());@(Object-&gt;ClearMetadata()-&gt;Distinct())">
        <FileType>obj</FileType>
        <ProjectType>$(ConfigurationType)</ProjectType>
      </ObjFullPath>
    </ItemGroup>
  </Target>
  <Target Name="ResolvedLinkLib" DependsOnTargets="GetReferencedVCProjectsInfo">
    <ItemGroup>
      <_ResolvedNativeProjectReferencePaths Include="@(ReferencedVCProjectsInfo)" Condition="'%(ReferencedVCProjectsInfo.FileType)' == 'lib'" />
    </ItemGroup>
  </Target>
  <!-- We only want to recursively call ResolvedLinkLib if this project is a static lib.  Skip recursive resolution for designtimebuild -->
  <PropertyGroup>
    <StaticLibraryResolveLinkLib Condition="'$(StaticLibraryResolveLinkLib)' == '' and '$(ConfigurationType)' == 'StaticLibrary' and '$(DesignTimeBuild)' != 'true'">$(CommonBuildOnlyTargets);ResolvedLinkLib</StaticLibraryResolveLinkLib>
  </PropertyGroup>
  <Target Name="GetResolvedLinkLibs" Returns="@(LibFullPath)" DependsOnTargets="$(StaticLibraryResolveLinkLib)">
    <!--  Add a tmp Link incase it doesn't exist.-->
    <ItemGroup>
      <Link Include="tmp" Condition="'@(Link)'==''">
        <DeleteSoon>true</DeleteSoon>
      </Link>
      <Lib Include="tmp" Condition="'@(Lib)'==''">
        <DeleteSoon>true</DeleteSoon>
      </Lib>
      <ImpLib Include="tmp" Condition="'@(ImpLib)'==''">
        <DeleteSoon>true</DeleteSoon>
      </ImpLib>
    </ItemGroup>
    <PropertyGroup>
      <_LinkImportLibraryTemp Condition="'$(GenerateImportLib)' == 'true' and '$(EnableBuildPassesInParallel)' == 'true'">%(ImpLib.OutputFile)</_LinkImportLibraryTemp>
      <_LinkImportLibraryTemp Condition="'$(_LinkImportLibraryTemp)' == ''">%(Link.ImportLibrary)</_LinkImportLibraryTemp>
      <_LibFullPath Condition="'$(ConfigurationType)'=='StaticLibrary' and '%(_ResolvedNativeProjectReferencePaths.FileType)' =='lib'">@(_ResolvedNativeProjectReferencePaths->'%(fullpath)')</_LibFullPath>
      <_LibFullPath Condition="'$(ConfigurationType)'=='DynamicLibrary' and '$(IgnoreImportLibrary)'!='true' and '$(_LinkImportLibraryTemp)' != ''">$([System.IO.Path]::GetFullPath($(_LinkImportLibraryTemp)))</_LibFullPath>
      <_LibFullPath Condition="'$(ConfigurationType)'=='StaticLibrary' and '$(GetResolvedLinkLibs_Order)' == 'BreadthFirst'">@(Lib-&gt;MetaData('OutputFile')-&gt;FullPath()-&gt;Distinct());$(_LibFullPath)</_LibFullPath>
      <_LibFullPath Condition="'$(ConfigurationType)'=='StaticLibrary' and '$(GetResolvedLinkLibs_Order)' != 'BreadthFirst'">$(_LibFullPath);@(Lib-&gt;MetaData('OutputFile')-&gt;FullPath()-&gt;Distinct())</_LibFullPath>
    </PropertyGroup>
    <ItemGroup>
      <LibFullPathTemp Include="$(_LibFullPath)">
        <ProjectType>$(ConfigurationType)</ProjectType>
        <FileType>lib</FileType>
        <ResolveableAssembly>false</ResolveableAssembly>
        <WindowsAppContainer Condition="'$(ConfigurationType)' == 'DynamicLibrary'">$(WindowsAppContainer)</WindowsAppContainer>
      </LibFullPathTemp>
      <LibFullPath Condition="'$(ConfigurationType)'!='StaticLibrary' or '$(GetResolvedLinkLibs_Order)' != 'BreadthFirst'" Include="@(LibFullPathTemp)" />
      <LibFullPath Condition="'$(ConfigurationType)'=='StaticLibrary' and '$(GetResolvedLinkLibs_Order)' == 'BreadthFirst'" Include="@(LibFullPathTemp-&gt;Reverse()-&gt;Distinct()-&gt;Reverse())" />
      <Link Remove="@(Link)" Condition="'%(Link.DeleteSoon)'=='true'" />
      <Lib Remove="@(Lib)" Condition="'%(Lib.DeleteSoon)'=='true'" />
      <ImpLib Remove="@(ImpLib)" Condition="'%(ImpLib.DeleteSoon)'=='true'" />
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)'=='true'" Importance="High" Text="LibFullPath=@(LibFullPath)" />
  </Target>
  <Target Name="AddLibrariesToProjectsInfoForReference" DependsOnTargets="GetResolvedLinkLibs">
    <ItemGroup>
      <ProjectInfoForReference Include="@(LibFullPath)" />
    </ItemGroup>
  </Target>
  <Target Name="AddDeployRecipeFileToProjectsInfoForReference">
    <ItemGroup>
      <ProjectInfoForReference Condition="'$(DesktopDeployRecipeFile)' != ''" Include="$(DesktopDeployRecipeFile)">
        <ProjectType>$(ConfigurationType)</ProjectType>
        <FileType>recipe</FileType>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
      </ProjectInfoForReference>
    </ItemGroup>
  </Target>
  <!-- public include directories -->
  <Target Name="GetPublicIncludeDirectories" DependsOnTargets="$(GetPublicIncludeDirectoriesDependsOn)">
    <ItemGroup>
      <_PublicIncludeDeirectories Include="$(PublicIncludeDirectories)" />
      <_PublicIncludeDeirectories Include="@(CLInclude-&gt;Metadata('FullPath')-&gt;DirectoryName()-&gt;Distinct()-&gt;ClearMetadata())" Condition="'$(AllProjectIncludesArePublic)' == 'true'" />
    </ItemGroup>
    <ItemGroup>
      <PublicIncludeDirectories Condition="'@(_PublicIncludeDeirectories)' != ''" Include="@(_PublicIncludeDeirectories-&gt;Metadata('FullPath')-&gt;Distinct())" />
    </ItemGroup>
    <ItemGroup>
      <_PublicIncludeDeirectories Remove="@(_PublicIncludeDeirectories)" />
    </ItemGroup>
  </Target>
  <Target Name="AddPublicIncludeDirectoriesToProjectsInfoForReference" DependsOnTargets="GetPublicIncludeDirectories">
    <ItemGroup>
      <ProjectInfoForReference Include="@(PublicIncludeDirectories)">
        <FileType>IncludeDirectory</FileType>
      </ProjectInfoForReference>
    </ItemGroup>
  </Target>
  <!-- public modules and header units-->
  <Target Name="AddPublicBMIsToProjectsInfoForReference" DependsOnTargets="$(ComputeCompileInputsTargets);SetModuleDependencies;GetPublicIncludeDirectories">
    <PropertyGroup>
      <_UseOnlySourcesInPublicDirectories Condition="$(AllProjectBMIsArePublic) != 'true'">true</_UseOnlySourcesInPublicDirectories>
    </PropertyGroup>
    <ItemGroup Condition="'@(LibraryManifests)' != ''">
      <ProjectInfoForReference Include="@(LibraryManifests)">
        <FileType>LibraryManifest</FileType>
      </ProjectInfoForReference>
    </ItemGroup>
    <!-- public modules -->
    <ItemGroup>
      <_Modules Include="@(ClCompile)" Condition="'%(ClCompile.CompileAs)' == 'CompileAsCppModule'" />
    </ItemGroup>
    <GetOutputFileNameItems Condition="'@(_Modules)' != ''" Sources="@(_Modules)" UseOnlySourcesInPublicDirectories="$(_UseOnlySourcesInPublicDirectories)" PublicDirectories="$(PublicModuleDirectories)" OutputMetadataName="ModuleOutputFile" OutputExtension="%(_Modules.Extension).ifc">
      <Output TaskParameter="OutputFiles" ItemName="PublicModuleBmis" />
    </GetOutputFileNameItems>
    <ItemGroup>
      <ProjectInfoForReference Include="@(PublicModuleBmis)">
        <FileType>Module</FileType>
      </ProjectInfoForReference>
    </ItemGroup>
    <ItemGroup>
      <_Modules Remove="@(_Modules)" />
    </ItemGroup>
    <!-- header units -->
    <ItemGroup>
      <_HeaderUnits Include="@(ClCompile)" Condition="'%(ClCompile.CompileAs)' == 'CompileAsHeaderUnit'" />
    </ItemGroup>
    <PropertyGroup>
      <_UseOnlySourcesInPublicDirectories Condition="$(AllProjectBMIsArePublic) != 'true'">true</_UseOnlySourcesInPublicDirectories>
    </PropertyGroup>
    <GetOutputFileNameItems Condition="'@(_HeaderUnits)' != ''" Sources="@(_HeaderUnits)" UseOnlySourcesInPublicDirectories="$(_UseOnlySourcesInPublicDirectories)" PublicDirectories="$(PublicModuleDirectories);@(PublicIncludeDirectories)" OutputMetadataName="ModuleOutputFile" OutputExtension="%(_HeaderUnits.Extension).ifc">
      <Output TaskParameter="OutputFiles" ItemName="PublicHeaderUnitBmis" />
    </GetOutputFileNameItems>
    <ItemGroup>
      <ProjectInfoForReference Include="%(PublicHeaderUnitBmis.FullPath)">
        <FileType>HeaderUnit</FileType>
      </ProjectInfoForReference>
    </ItemGroup>
    <ItemGroup>
      <_HeaderUnits Remove="@(_HeaderUnits)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolvedXDCMake" DependsOnTargets="$(CommonBuildOnlyTargets)" Condition="'$(DocumentLibraryDependencies)'=='true'">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetResolvedXDCMake" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.Extension)' == '.vcxproj' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '$(_ClCompileGenerateXMLDocumentationFiles)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedNativeProjectReferencePaths" />
    </MSBuild>
  </Target>
  <Target Name="GetResolvedXDCMake" Returns="@(XDCMakeFullPath)" DependsOnTargets="$(CommonBuildOnlyTargets);ComputeCLCompileGeneratedXDCFiles;ResolvedXDCMake">
    <ItemGroup>
      <XDCMakeFullPath Condition="'$(ConfigurationType)'=='StaticLibrary' and '@(XDCMake)'!=''" Include="@(XdcMake->'%(Fullpath)')">
        <FileType>xdc</FileType>
      </XDCMakeFullPath>
      <XDCMakeFullPath>
        <ProjectType>$(ConfigurationType)</ProjectType>
      </XDCMakeFullPath>
    </ItemGroup>
  </Target>
  <Target Name="GetResolvedWinMD" Returns="@(WinMDFullPath)">
    <ItemGroup>
      <Link Include="tmp" Condition="'@(Link)'==''">
        <DeleteSoon>true</DeleteSoon>
      </Link>
      <WinMDFullPath Condition="'%(Link.GenerateWindowsMetadata)' == 'true'" Include="@(Link-&gt;Metadata('WindowsMetadataFile')-&gt;FullPath()-&gt;Distinct()-&gt;ClearMetadata())">
        <TargetPath>$([System.IO.Path]::GetFileName('%(Link.WindowsMetadataFile)'))</TargetPath>
        <Primary>true</Primary>
      </WinMDFullPath>
      <WinMDFullPath>
        <Implementation>$(WinMDImplementationPath)$(TargetName)$(TargetExt)</Implementation>
        <FileType>winmd</FileType>
        <WinMDFile>true</WinMDFile>
        <ProjectType>$(ConfigurationType)</ProjectType>
      </WinMDFullPath>
      <Link Remove="@(Link)" Condition="'%(Link.DeleteSoon)' == 'true'" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
      Compute CRT SDK Reference
     ******************************************************************************************* -->
  <Target Name="ComputeCrtSDKReference" Condition="'@(ClCompile)'!='' and '$(WindowsAppContainer)'=='true' and '$(UseCrtSDKReference)' != 'false'">
    <PropertyGroup Condition="'$(UseCrtSDKReferenceConfig)'==''">
      <UseCrtSDKReferenceConfig Condition="'%(Clcompile.RuntimeLibrary)'=='MultiThreadedDll'">Retail</UseCrtSDKReferenceConfig>
      <UseCrtSDKReferenceConfig Condition="'%(Clcompile.RuntimeLibrary)'=='MultiThreadedDebugDLL'">Debug</UseCrtSDKReferenceConfig>
      <UseCrtSDKReferenceStaticWarning Condition="'$(UseCrtSDKReferenceStaticWarning)' == '' and ('%(Clcompile.RuntimeLibrary)'=='MultiThreaded' or '%(Clcompile.RuntimeLibrary)'=='MultiThreadedDebug')">true</UseCrtSDKReferenceStaticWarning>
    </PropertyGroup>
    <VCMessage Code="MSB8024" Type="Error" Condition="'$(DesignTimeBuild)'!='true' and '$(UseCrtSDKReferenceStaticWarning)'=='true'" />
    <ItemGroup>
      <SDKReference Include="$(CrtSDKReferenceInclude)" Condition="'$(UseCrtSDKReferenceConfig)' != ''">
        <TargetedSDKConfiguration>$(UseCrtSDKReferenceConfig)</TargetedSDKConfiguration>
        <TargetedSDKArchitecture>$(PlatformShortName)</TargetedSDKArchitecture>
        <Implicit>true</Implicit>
      </SDKReference>
    </ItemGroup>
  </Target>
  <Target Name="_ALink" />
  <Target Name="_Appverifier" />
  <Target Name="_Deploy" />
  <!-- Platform targets will override -->
  <Target Name="Midl" />
  <Target Name="ClCompile" />
  <Target Name="ResourceCompile" />
  <Target Name="Link" />
  <Target Name="Lib" />
  <Target Name="ImpLib" />
  <Target Name="AfterBuildGenerateSourcesEvent" />
  <Target Name="ClCompile" />
  <Target Name="ResourceCompile" />
  <Target Name="AfterBuildCompileEvent" />
  <Target Name="Lib" />
  <Target Name="Link" />
  <Target Name="ALink" />
  <Target Name="Manifest" />
  <Target Name="XdcMake" />
  <Target Name="BscMake" />
  <Target Name="CustomBuildProj" />
  <Target Name="FxCop" />
  <Target Name="Appverifier" />
  <!-- *******************************************************************************************
        AllProjectOutputGroups
        AllProjectOutputGroups returns specific files for needed for deployment.
        Primary output, Debug Symbols, Content Files, Source Files, Documentation Files, etc
       ******************************************************************************************* -->
  <PropertyGroup>
    <AllProjectOutputGroupsDependsOn>
      $(AllProjectOutputGroupsDependsOn);
      BuiltProjectOutputGroup;
      DebugSymbolsProjectOutputGroup;
      DocumentationProjectOutputGroup;
      SatelliteDllsProjectOutputGroup;
      SourceFilesProjectOutputGroup;
      ContentFilesProjectOutputGroup;
      SGenFilesOutputGroup
    </AllProjectOutputGroupsDependsOn>
  </PropertyGroup>
  <Target Name="AllProjectOutputGroups" DependsOnTargets="$(AllProjectOutputGroupsDependsOn)" />
  <!-- *************************BuiltProjectOutputGroup****************************************** -->
  <PropertyGroup>
    <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
    <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library')">true</AddAppConfigToBuildOutputs>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroup" Returns="@(BuiltProjectOutputGroupOutput)" DependsOnTargets="$(BuiltProjectOutputGroupDependsOn)">
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(TargetPath)">
        <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- This item represents the app.config file -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(AppConfig)" Condition="'$(AddAppConfigToBuildOutputs)'=='true'">
        <FinalOutputPath>$(TargetDir)$(TargetFileName).config</FinalOutputPath>
        <TargetPath>$(TargetFileName).config</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(AppConfig)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <ItemGroup>
      <_IsolatedComReference Include="@(COMReference)" Condition=" '%(COMReference.Isolated)' == 'true' " />
      <_IsolatedComReference Include="@(COMFileReference)" Condition=" '%(COMFileReference.Isolated)' == 'true' " />
    </ItemGroup>
    <ItemGroup Condition="'@(Link)' == ''">
      <Link Include="__Tempfile__">
        <Temp>true</Temp>
        <UseDynamicDebugging Condition="'%(Link.UseDynamicDebugging)' == ''">$(UseDynamicDebugging)</UseDynamicDebugging>
      </Link>
    </ItemGroup>
    <PropertyGroup>
      <AltSuffix Condition="'%(Link.DynamicDebuggingSuffix)' == ''">.alt</AltSuffix>
      <AltSuffix Condition="'%(Link.DynamicDebuggingSuffix)' != ''">%(Link.DynamicDebuggingSuffix)</AltSuffix>
    </PropertyGroup>
    <!--This item represents the alternate binary generated when building with /dynamicdeopt, example: WindowsApplication1.alt.exe-->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(TargetName)$(AltSuffix).exe" Condition="'%(Link.UseDynamicDebugging)' == 'true'">
        <FinalOutputPath>$(TargetDir)$(TargetName)$(AltSuffix).exe</FinalOutputPath>
        <TargetPath>$(TargetName)$(AltSuffix).exe</TargetPath>
        <OriginalItemSpec>$(OutDir)$(TargetName)$(AltSuffix).exe</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <ItemGroup>
      <Link Remove="@(Link)" Condition="'%(Link.Temp)' == 'true'" />
    </ItemGroup>
    <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="'@(NativeReference)'!='' or '@(_IsolatedComReference)'!=''">
        <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="@(_BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')" Condition="$(ConfigurationType) != 'StaticLibrary'">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec Condition="'%(_BuiltProjectOutputGroupOutputIntermediate.OriginalItemSpec)' == ''">%(_BuiltProjectOutputGroupOutputIntermediate.FullPath)</OriginalItemSpec>
      </BuiltProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- *************************DebugSymbolsProjectOutputGroup****************************************** -->
  <PropertyGroup>
    <DebugSymbolsProjectOutputGroupDependsOn>$(DebugSymbolsProjectOutputGroupDependsOn)</DebugSymbolsProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DebugSymbolsProjectOutputGroup" Returns="@(DebugSymbolsProjectOutputGroupOutput)" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependsOn)">
    <ItemGroup>
      <!--  Remove values defined from Microsoft.Common.targets  -->
      <DebugSymbolsProjectOutputGroupOutput Remove="@(DebugSymbolsProjectOutputGroupOutput)" />
    </ItemGroup>
    <ItemGroup Condition="$(ConfigurationType) != 'StaticLibrary'">
      <Link Condition="'@(Link)' == ''" Include="Temp">
        <localtemp>true</localtemp>
      </Link>
      <DebugSymbolsProjectOutputGroupOutput Include="@(Link-&gt;MetaData('ProgramDatabaseFile')-&gt;FullPath()-&gt;Distinct()-&gt;ClearMetaData())" />
      <DebugSymbolsProjectOutputGroupOutput Remove="@(DebugSymbolsProjectOutputGroupOutput)" Condition="!Exists(%(DebugSymbolsProjectOutputGroupOutput.Identity))" />
      <DebugSymbolsProjectOutputGroupOutput>
        <FinalOutputPath>%(FullPath)</FinalOutputPath>
        <TargetPath>%(Filename)%(Extension)</TargetPath>
      </DebugSymbolsProjectOutputGroupOutput>
      <Link Condition="'%(Link.localtemp)' == 'true'" Remove="@(Link)" />
    </ItemGroup>
  </Target>
  <!-- *************************DocumentationProjectOutputGroup****************************************** -->
  <PropertyGroup>
    <DocumentationProjectOutputGroupDependsOn>$(DocumentationProjectOutputGroupDependsOn)ResolvedXDCMake;ComputeCLCompileGeneratedXDCFiles</DocumentationProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DocumentationProjectOutputGroup" Returns="@(DocumentationProjectOutputGroupOutput)" DependsOnTargets="$(DocumentationProjectOutputGroupDependsOn)">
    <ItemGroup>
      <XDCMake Condition="'@(XDCMake)' == ''" Include="Temp">
        <localtemp>true</localtemp>
      </XDCMake>
      <DocumentationProjectOutputGroupOutput Include="@(XDCMake-&gt;MetaData('OutputFile')-&gt;FullPath()-&gt;Distinct()-&gt;ClearMetaData())" />
      <DocumentationProjectOutputGroupOutput Remove="@(DocumentationProjectOutputGroupOutput)" Condition="!Exists(%(DocumentationProjectOutputGroupOutput.Identity))" />
      <XDCMake Condition="'%(XDCMake.localtemp)' == 'true'" Remove="@(XDCMake)" />
    </ItemGroup>
  </Target>
  <!-- *************************SourceFilesProjectOutputGroup****************************************** -->
  <PropertyGroup>
    <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SourceFilesProjectOutputGroup" Returns="@(SourceFilesProjectOutputGroupOutput)" DependsOnTargets="$(SourceFilesProjectOutputGroupDependsOn)">
    <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
      <SourceFilesProjectOutputGroupOutput Include="@(ClCompile->'%(FullPath)');&#xD;&#xA;                @(EmbeddedResource->'%(FullPath)');&#xD;&#xA;                @(LicxCompiler->'%(FullPath)');&#xD;&#xA;                @(MASM->'%(FullPath)');&#xD;&#xA;                @(ClInclude->'%(FullPath)');&#xD;&#xA;                @(Midl->'%(FullPath)');&#xD;&#xA;                @(ResourceCompile->'%(FullPath)');&#xD;&#xA;                @(Xsd->'%(FullPath)');&#xD;&#xA;                @(CustomBuild->'%(FullPath)');&#xD;&#xA;                @(Resource->'%(FullPath)');&#xD;&#xA;                @(Object->'%(FullPath)');&#xD;&#xA;                @(Library->'%(FullPath)');&#xD;&#xA;                @(Manifest->'%(FullPath)');&#xD;&#xA;                @(Image->'%(FullPath)');&#xD;&#xA;                @(Media->'%(FullPath)');&#xD;&#xA;                @(Font->'%(FullPath)');&#xD;&#xA;                @(_EmbedManagedResourceFile->'%(FullPath)');&#xD;&#xA;                @(AppConfigWithTargetPath->'%(FullPath)');&#xD;&#xA;                $(AdditionalSourceFiles)" />
      <!-- Include the project file -->
      <SourceFilesProjectOutputGroupOutput Include="$(MSBuildProjectFullPath)">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(MSBuildProjectFullPath)</OriginalItemSpec>
        <TargetPath>$(ProjectFileName)</TargetPath>
      </SourceFilesProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- *************************ContentFilesProjectOutputGroup****************************************** -->
  <PropertyGroup>
    <ContentFilesProjectOutputGroupDependsOn>$(ContentFilesProjectOutputGroupDependsOn);PrepareForBuild;AssignTargetPaths;MakeDirsForFxc</ContentFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ContentFilesProjectOutputGroup" Returns="@(ContentFilesProjectOutputGroupOutput)" DependsOnTargets="$(ContentFilesProjectOutputGroupDependsOn)">
    <ItemGroup>
      <_ContentFilesProjectOutputGroupOutput Include="@(ClCompile)" Condition="'%(ClCompile.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(_LicxFile)" Condition="'%(_LicxFile.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(ClInclude)" Condition="'%(ClInclude.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Midl)" Condition="'%(Midl.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(FxcOutputs)" Condition="'%(FxcOutputs.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(ResourceCompile)" Condition="'%(ResourceCompile.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Xsd)" Condition="'%(Xsd.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Xml)" Condition="'%(Xml.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Text)" Condition="'%(Text.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Font)" Condition="'%(Font.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(CustomBuild)" Condition="'%(CustomBuild.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Resource)" Condition="'%(Resource.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Object)" Condition="'%(Object.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Library)" Condition="'%(Library.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Manifest)" Condition="'%(Manifest.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Image)" Condition="'%(Image.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(Media)" Condition="'%(Media.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(_EmbedManagedResourceFile)" Condition="'%(_EmbedManagedResourceFile.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(AppConfigWithTargetPath)" Condition="'%(AppConfigWithTargetPath.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="@(None)" Condition="'%(None.DeploymentContent)'=='true'">
        <_RootFolder>%(DefiningProjectDirectory)</_RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput>
        <RootFolder Condition="'%(_ContentFilesProjectOutputGroupOutput.RootFolder)' == ''">%(_RootFolder)</RootFolder>
      </_ContentFilesProjectOutputGroupOutput>
      <_ContentFilesProjectOutputGroupOutput Include="$(AdditionalContentFiles)">
        <DeploymentContent>true</DeploymentContent>
      </_ContentFilesProjectOutputGroupOutput>
      <!-- Add CustomBuild->Outputs since the output is different than the initial include -->
      <_ContentFilesProjectOutputGroupOutput Include="@(CustomBuild-&gt;WithMetadataValue('TreatOutputAsContent', 'true')-&gt;Metadata('Outputs'))">
        <Link>%(CustomBuild.OutputLink)</Link>
        <DeploymentContent>true</DeploymentContent>
      </_ContentFilesProjectOutputGroupOutput>
      <!-- Add CustomBuild->Outputs since the output is different than the initial include -->
      <_ContentFilesProjectOutputGroupOutput Include="@(CustomBuildStep-&gt;WithMetadataValue('TreatOutputAsContent', 'true')-&gt;Metadata('Outputs'))">
        <Link>%(CustomBuildStep.OutputLink)</Link>
        <DeploymentContent>true</DeploymentContent>
      </_ContentFilesProjectOutputGroupOutput>
      <!-- Add copies files marked as content -->
      <_ContentFilesProjectOutputGroupOutput Include="@(_CopyFile-&gt;WithMetadataValue('TreatOutputAsContent', 'true')-&gt;Metadata('FullDestinationPath'))">
        <DeploymentContent>true</DeploymentContent>
      </_ContentFilesProjectOutputGroupOutput>
      <ContentFilesProjectOutputGroupOutputFullPath Include="@(_ContentFilesProjectOutputGroupOutput->'%(FullPath)')" Condition="'%(_ContentFilesProjectOutputGroupOutput.DeploymentContent)'=='true'" />
      <_ContentFilesProjectOutputGroupOutput Remove="@(_ContentFilesProjectOutputGroupOutput)" />
    </ItemGroup>
    <!-- AssignTargetPath uses the metadata "link" to override assigning TargetPath -->
    <AssignTargetPath Condition="'@(ContentFilesProjectOutputGroupOutputFullPath)' != '' and '%(ContentFilesProjectOutputGroupOutputFullPath.RootFolder)' != ''" Files="@(ContentFilesProjectOutputGroupOutputFullPath)" RootFolder="%(ContentFilesProjectOutputGroupOutputFullPath.RootFolder)">
      <Output TaskParameter="AssignedFiles" ItemName="ContentFilesProjectOutputGroupOutput" />
    </AssignTargetPath>
    <AssignTargetPath Condition="'@(ContentFilesProjectOutputGroupOutputFullPath)' != '' and '%(ContentFilesProjectOutputGroupOutputFullPath.RootFolder)' == ''" Files="@(ContentFilesProjectOutputGroupOutputFullPath)" RootFolder="$(ProjectDir)">
      <Output TaskParameter="AssignedFiles" ItemName="ContentFilesProjectOutputGroupOutput" />
    </AssignTargetPath>
    <ItemGroup>
      <ContentFilesProjectOutputGroupOutputFullPath Remove="@(ContentFilesProjectOutputGroupOutputFullPath)" />
      <!-- Add items to ContentWithTargetPath so the project export these content. -->
      <ContentWithTargetPath Condition="'$(CopyDeploymentContent)' == 'true'" Include="@(ContentFilesProjectOutputGroupOutput)">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </ContentWithTargetPath>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <GetCopyToOutputDirectoryItemsDependsOn Condition="'$(CopyLocalDeploymentContent)' == 'true'">ContentFilesProjectOutputGroup;$(GetCopyToOutputDirectoryItemsDependsOn)</GetCopyToOutputDirectoryItemsDependsOn>
  </PropertyGroup>
  <!--
  ============================================================
  CopyWinMDArtifactsOutputGroup
  ============================================================
  -->
  <Target Name="WinMDArtifactsProjectOutputGroup" DependsOnTargets="GetResolvedWinMD" Returns="@(WinMDFullPath)" />
  <Target Name="CopyWinMDArtifactsOutputGroup" DependsOnTargets="GetResolvedWinMD" Returns="@(CopyWinMDArtifactsOutputGroupOutput)">
    <ItemGroup>
      <CopyWinMDArtifactsOutputGroupOutput Include="@(WinMDFullPath)" />
    </ItemGroup>
  </Target>
  <Target Name="PrimaryWinMDOutputGroup" DependsOnTargets="GetResolvedWinMD" Returns="@(PrimaryWinMDFullPath)">
    <ItemGroup>
      <PrimaryWinMDFullPath Include="@(WinMDFullPath)" Condition="'%(WinMDFullPath.Primary)' == 'true'" />
    </ItemGroup>
  </Target>
  <Target Name="GeneratedFilesOutputGroup" Returns="@(GeneratedFilesOutputGroup)" DependsOnTargets="$(GeneratedFilesOutputGroupDependsOn)" />
  <!-- *************************VCRuntimeProjectOutputGroup****************************************** -->
  <PropertyGroup>
    <CRTDefinitionalFile Condition="'$(CRTDefinitionalFile)' == ''">$(VCToolsInstallDir)VCProjectDefault\Microsoft.AppX.VCFrameworkReferences.xml</CRTDefinitionalFile>
  </PropertyGroup>
  <!--<Import Project="$(CRTDefinitionalFile)" Condition="Exists('$(CRTDefinitionalFile)')" />-->
  <Target Name="GetCRTInformation" Returns="CRTInformation">
    <Exec ConsoleToMSBuild="true" EchoOff="true" StandardOutputImportance="low" Command="link /dump /Dependents &quot;$(TargetPath)&quot; | findstr /i .dll">
      <Output TaskParameter="ConsoleOutput" ItemName="RTDependents" />
    </Exec>
    <ItemGroup>
      <_RTDependents Include="@(RTDependents)">
        <ComponentName>%(Identity)</ComponentName>
      </_RTDependents>
      <CRTInformation Include="@(VCRuntimeFramework)" Condition="'@(_RTDependents)' == '%(ComponentName)'  " />
      <CRTInformation Remove="@(CRTInformation)" Condition="'$(PlatformShortName)' != '%(FrameworkArchitecture)'" />
      <_RTDependents Remove="@(_RTDependents)" />
      <RTDependents Remove="@(RTDependents)" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        AllProjectOutputGroupsDependencies
       ******************************************************************************************* -->
  <Target Name="AllProjectOutputGroupsDependencies" DependsOnTargets="&#xD;&#xA;            BuiltProjectOutputGroupDependencies;&#xD;&#xA;            DebugSymbolsProjectOutputGroupDependencies;&#xD;&#xA;            SatelliteDllsProjectOutputGroupDependencies;&#xD;&#xA;            DocumentationProjectOutputGroupDependencies;&#xD;&#xA;            SGenFilesOutputGroupDependencies" />
  <!-- *************************BuiltProjectOutputGroupDependencies****************************************** -->
  <Target Name="BuiltProjectOutputGroupDependencies" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(BuiltProjectOutputGroupDependency)">
    <!-- Include both native and managed dlls -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuiltProjectOutputGroup;BuiltProjectOutputGroupDependencies" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.Extension)' == '.vcxproj' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="BuiltProjectOutputGroupDependency" />
    </MSBuild>
    <ItemGroup>
      <BuiltProjectOutputGroupDependency Include="@(ReferencePath->'%(FullPath)');&#xD;&#xA;                                                   @(ReferenceDependencyPaths->'%(FullPath)');&#xD;&#xA;                                                   @(NativeReferenceFile->'%(FullPath)');&#xD;&#xA;                                                   @(_DeploymentLooseManifestFile->'%(FullPath)');&#xD;&#xA;                                                   @(ResolvedIsolatedComModules->'%(FullPath)')" />
    </ItemGroup>
    <ItemGroup>
      <NativeReferenceCopyLocalPaths Condition="'$(CopyLocalProjectReference)' == 'true' and '%(BuiltProjectOutputGroupDependency.Private)' == 'true'" Include="@(BuiltProjectOutputGroupDependency)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <CopyLocalNativeReferenceDependsOn>$(CopyLocalNativeReferenceDependsOn);BuiltProjectOutputGroupDependencies;DebugSymbolsProjectOutputGroupDependencies</CopyLocalNativeReferenceDependsOn>
  </PropertyGroup>
  <!-- *************************DebugSymbolsProjectOutputGroupDependencies****************************************** -->
  <Target Name="DebugSymbolsProjectOutputGroupDependencies" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(DebugSymbolsProjectOutputGroupDependency)">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="DebugSymbolsProjectOutputGroup;DebugSymbolsProjectOutputGroupDependencies" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" Condition="'%(_MSBuildProjectReferenceExistent.Extension)' == '.vcxproj' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
      <Output TaskParameter="TargetOutputs" ItemName="DebugSymbolsProjectOutputGroupDependency" />
    </MSBuild>
    <!-- This item represents dependent PDB's -->
    <ItemGroup>
      <DebugSymbolsProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
    <ItemGroup Condition="'$(CopyLocalDebugSymbols)' == 'true'">
      <NativeReferenceCopyLocalPaths Include="@(DebugSymbolsProjectOutputGroupDependency)" />
    </ItemGroup>
  </Target>
  <!-- *************************DocumentationProjectOutputGroupDependencies****************************************** -->
  <Target Name="DocumentationProjectOutputGroupDependencies">
    <!--  XDCMake already traverse project reference during build. -->
  </Target>
  <!-- ************************* Copy dependencies to this project output directory support ****************************************** -->
  <Target Name="CopyLocalNativeReference" DependsOnTargets="$(CopyLocalNativeReferenceDependsOn)" Condition="'$(CopyLocalProjectReference)' == 'true'">
    <ItemGroup>
      <NativeReferenceCopyLocalPaths>
        <FullDestinationPath>$(OutDir)%(NativeReferenceCopyLocalPaths.DestinationSubDirectory)%(Filename)%(Extension)</FullDestinationPath>
      </NativeReferenceCopyLocalPaths>
    </ItemGroup>
    <GetOutOfDateItems Sources="@(NativeReferenceCopyLocalPaths)" OutputsMetadataName="FullDestinationPath" CommandMetadataName="FullDestinationPath" TLogDirectory="$(TLogLocation)" TLogNamePrefix="CopyRefs" TrackFileAccess="$(TrackFileAccess)">
      <Output TaskParameter="OutOfDateSources" ItemName="_OutOfDateNativeReference" />
    </GetOutOfDateItems>
    <!-- FileWritesShareable items are recorded for incremental clean in msbuild common targets, so it needs to be called with all inputs,
         not just out of date ones to avoid cleaning up-to-date files
         We still need to call GetOutOfDateItems for tlog creation -->
    <Copy SourceFiles="@(NativeReferenceCopyLocalPaths)" DestinationFiles="@(NativeReferenceCopyLocalPaths->'%(FullDestinationPath)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="'@(NativeReferenceCopyLocalPaths)'!=''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
    </Copy>
  </Target>
  <!-- ************************* Recipe file containing outputs of this project, as well as referenced projects  ****************************************** -->
  <PropertyGroup>
    <CreateRecipeFileDependsOn>BuiltProjectOutputGroup;SatelliteDllsProjectOutputGroup;ContentFilesProjectOutputGroup;GetReferencedVCProjectsInfo</CreateRecipeFileDependsOn>
  </PropertyGroup>
  <Target Name="CreateRecipeFile" DependsOnTargets="$(CreateRecipeFileDependsOn)" Condition="'$(GenerateDesktopDeployRecipeFile)' == 'true' and '$(DesignTimeBuild)' != 'true'">
    <ItemGroup>
      <_ReferencedProjectsRecipeFiles Include="@(ReferencedVCProjectsInfo)" Condition="'%(ReferencedVCProjectsInfo.FileType)' == 'recipe'" /></ItemGroup>
    <GenerateDesktopDeployRecipe RecipeFiles="@(_ReferencedProjectsRecipeFiles)" OutputFile="$(DesktopDeployRecipeFile)" BuiltProjectOutputs="@(BuiltProjectOutputGroupOutput)" ContentFiles="@(ContentFilesProjectOutputGroupOutput)" SatelliteDlls="@(SatelliteDllsProjectOutputGroupOutput)" ProjectReferences="@(_MSBuildProjectReferenceExistent)" ProjectDir="$(ProjectDir)" />
  </Target>
  <!-- *******************************************************************************************
        Property pages
       ******************************************************************************************* -->
  <!-- default debuggers -->
  <PropertyGroup Condition="'$(_ApplicableDebuggers)' == ''">
    <_ApplicableDebuggers Condition="'$(AppxPackage)' == 'true'">AppHost</_ApplicableDebuggers>
    <_ApplicableDebuggers Condition="'$(_ApplicableDebuggers)'=='' and '$(WindowsAppContainer)' != 'true'">Desktop</_ApplicableDebuggers>
  </PropertyGroup>
  <ItemGroup Condition="'$(UseDefaultPropertyPageSchemas)' != 'false' and '$(UseDefaultDebuggersPropertyPageSchemas)' != 'false'">
    <DesktopDebuggerPages Include="$(VCTargetsPath)$(LangID)\debugger_*.xml" Exclude="$(VCTargetsPath)$(LangID)\debugger_smartdevice_native.xml" />
    <!-- Make sure the following debugger schemas are explicitly included, to allow CPS to search for them
         in the alternative locations. To avoid duplicate schemas, we don't include them
         if they already exist in $(VCTargetsPath)$(LangID)\debugger_*.xml -->
    <DesktopDebuggerPages Condition="!Exists('$(VCTargetsPath)$(LangID)\debugger_local_windows.xml')" Include="$(VCTargetsPath)$(LangID)\debugger_local_windows.xml" />
    <DesktopDebuggerPages Condition="!Exists('$(VCTargetsPath)$(LangID)\debugger_remote_windows.xml')" Include="$(VCTargetsPath)$(LangID)\debugger_remote_windows.xml" />
    <DesktopDebuggerPages Condition="!Exists('$(VCTargetsPath)$(LangID)\debugger_web_browser.xml')" Include="$(VCTargetsPath)$(LangID)\debugger_web_browser.xml" />
    <DesktopDebuggerPages Condition="!Exists('$(VCTargetsPath)$(LangID)\debugger_web_service.xml')" Include="$(VCTargetsPath)$(LangID)\debugger_web_service.xml" />
    <AppHostDebuggerPages Include="$(VCTargetsPath)$(LangID)\AppHostDebugger_Local.xml" />
    <AppHostDebuggerPages Include="$(VCTargetsPath)$(LangID)\AppHostDebugger_Remote.xml" />
    <AppHostDebuggerPages Include="$(MSBuildExtensionsPath)\Microsoft\Universal\$(LangID)\WindowsAppEmulatorDebugger.xaml" />
  </ItemGroup>
  <ItemGroup Condition="'$(UseDefaultPropertyPageSchemas)' != 'false'">
    <!-- Property pages that always apply -->
    <PropertyPageSchema Include="&#xD;&#xA;        $(VCTargetsPath)$(LangID)\ProjectItemsSchema.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\midl.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\build_events.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\custom_build_tool.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\custom_build_step.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\copy_file.xml;&#xD;&#xA;    " />
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general_file.xml">
      <Context>File</Context>
    </PropertyPageSchema>
    <!-- Debuggers -->
    <DebuggerPages Condition="'$(_ApplicableDebuggers)' == 'Desktop'" Include="@(DesktopDebuggerPages)" />
    <DebuggerPages Condition="'$(_ApplicableDebuggers)' == 'AppHost'" Include="@(AppHostDebuggerPages)" />
    <!-- We always need debuggers general page as soon as we have at least one debugger -->
    <PropertyPageSchema Condition="'@(DebuggerPages)' != ''" Include="$(VCTargetsPath)$(LangID)\debugger_general.xml" />
    <PropertyPageSchema Include="@(DebuggerPages)" />
    <!-- Property sheet specific property pages -->
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\usermacros.xml">
      <Context>PropertySheet</Context>
    </PropertyPageSchema>
    <!-- Switch view between project property based directories and environment variables -->
    <PropertyPageSchema Condition="'$(UseEnv)' != 'true'" Include="$(VCTargetsPath)$(LangID)\directories.xml" />
    <PropertyPageSchema Condition="'$(UseEnv)' == 'true'" Include="$(VCTargetsPath)$(LangID)\envvars.xml" />
    <!-- Non-Utility project property pages -->
    <PropertyPageSchema Condition="'$(ConfigurationType)' != 'Utility'" Include="$(VCTargetsPath)$(LangID)\mt.xml;">
      <Context>Project;PropertySheet</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Condition="'$(ConfigurationType)' != 'Utility'" Include="&#xD;&#xA;        $(VCTargetsPath)$(LangID)\cl.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\lib.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\link.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\alink.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\bscmake.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\fxc.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\rc.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\resgen.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\xdcmake.xml;&#xD;&#xA;        $(VCTargetsPath)$(LangID)\xsd.xml;&#xD;&#xA;    " />
  </ItemGroup>
  <ItemGroup Condition="'$(UseDefaultPropertyPageSchemas)' != 'false' and '$(UseDefaultGeneralPropertyPageSchema)' != 'false'">
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general.xml" Condition="'$(WindowsStoreApp)' != 'true'">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general_advanced.xml" Condition="'$(WindowsStoreApp)' != 'true'">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general_advanced_hostarm64.xml" Condition="'$(WindowsStoreApp)' != 'true' and '$(_VC_arm64_ToolsInstalled)' == 'true'">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general_advanced_netcore.xml" Condition="'$(WindowsStoreApp)' != 'true' and '$(CLRSupport)' == 'NetCore'">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general_appcontainerapplication.xml" Condition="'$(WindowsStoreApp)' == 'true'">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\general_ps.xml">
      <Context>PropertySheet</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\folder.xml">
      <Context>File;BrowseObject</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <ItemGroup Condition="'$(UseDefaultPropertyPageSchemas)' != 'false'">
    <!-- Platform and Platform toolset schemas. We want to include them last so that user's property pages can override the standard ones included above. -->
    <PropertyPageSchema Condition="'$(ConfigurationType)' != 'Utility'" Include="&#xD;&#xA;        $(VCTargetsPathEffective)Platforms\$(Platform)\$(LangID)\*.xml;&#xD;&#xA;        $(VCTargetsPathEffective)Platforms\$(Platform)\PlatformToolsets\$(PlatformToolset)\$(LangID)\*.xml;&#xD;&#xA;    " />
  </ItemGroup>
  <!-- Tools that show up in the IDE property pages for exe and dll projects -->
  <ItemGroup Condition="'$(UseDefaultProjectTools)' != 'false' and ('$(ConfigurationType)' == 'Application' or '$(ConfigurationType)' == 'DynamicLibrary')">
    <ProjectTools Include="Link" />
    <ProjectTools Include="Manifest" />
    <ProjectTools Include="Bscmake" />
    <ProjectTools Include="Xdcmake" />
    <ProjectTools Include="CustomBuildStep" />
  </ItemGroup>
  <!-- Tools that show up in the IDE property pages for lib project-->
  <ItemGroup Condition="'$(UseDefaultProjectTools)' != 'false' and '$(ConfigurationType)' == 'StaticLibrary'">
    <ProjectTools Include="Lib" />
    <ProjectTools Include="Bscmake" />
    <ProjectTools Include="Xdcmake" />
    <ProjectTools Include="CustomBuildStep" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MicrosoftNETSdkAfterCommonTargets)" Sdk="Microsoft.NET.Sdk" Condition="'$(CLRSupport)' == 'NetCore'  and '$(ImportNETCoreSdkFromVCTargets)' != 'false'" />-->
  <UsingTask TaskName="VCMessage" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="LIB" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="MIDL" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="RC" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="Mt" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="XSD" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="XDCMake" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="BscMake" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="CustomBuild" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="CL" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="Link" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="FXC" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="MultiToolTask" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="GetOutOfDateItems" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="ParallelCustomBuild" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="GetOutputFileName" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="SetModuleDependencies" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="CustomBuildStepMessage" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="GetLibraryModuleSources" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <!-- *******************************************************************************************
        AvailableItemName
       ******************************************************************************************* -->
  <!-- Creates a connection between item names and the targets to build them. -->
  <ItemGroup>
    <AvailableItemName Include="ClCompile">
      <Targets>ClCompile</Targets>
    </AvailableItemName>
    <AvailableItemName Include="Midl">
      <Targets>Midl</Targets>
    </AvailableItemName>
    <AvailableItemName Include="ResourceCompile">
      <Targets>ResourceCompile</Targets>
    </AvailableItemName>
    <AvailableItemName Include="EmbeddedResource">
      <Targets>ResGen</Targets>
    </AvailableItemName>
    <AvailableItemName Include="CustomBuild">
      <Targets>CustomBuild</Targets>
    </AvailableItemName>
    <AvailableItemName Include="Xsd">
      <Targets>Xsd</Targets>
    </AvailableItemName>
    <AvailableItemName Include="FxCompile">
      <Targets>FxCompile</Targets>
    </AvailableItemName>
    <AvailableItemName Include="CopyFileToFolders">
      <Targets>CopyFileToFolders</Targets>
    </AvailableItemName>
  </ItemGroup>
  <!-- *******************************************************************************************
        Build Events
       ******************************************************************************************* -->
  <PropertyGroup>
    <_BuildSuffix>
:VCEnd</_BuildSuffix>
  </PropertyGroup>
  <Target Name="PreBuildEvent" Condition="'$(PreBuildEventUseInBuild)'!='false'">
    <Message Text="%(PreBuildEvent.Message)" Condition="'%(PreBuildEvent.Message)' != '' and '%(PreBuildEvent.Command)' != ''" Importance="High" />
    <Exec Command="%(PreBuildEvent.Command)$(_BuildSuffix)" StdOutEncoding="%(PreBuildEvent.StdOutEncoding)" StdErrEncoding="%(PreBuildEvent.StdErrEncoding)" Condition="'%(PreBuildEvent.Command)' != ''" />
  </Target>
  <Target Name="PreLinkEvent" Condition="'$(PreLinkEventUseInBuild)'!='false'">
    <Message Text="%(PreLinkEvent.Message)" Condition="'%(PreLinkEvent.Message)' != '' and '%(PreLinkEvent.Command)' != ''" Importance="High" />
    <Exec Command="%(PreLinkEvent.Command)$(_BuildSuffix)" StdOutEncoding="%(PreLinkEvent.StdOutEncoding)" StdErrEncoding="%(PreLinkEvent.StdErrEncoding)" Condition="'%(PreLinkEvent.Command)' != ''" />
  </Target>
  <Target Name="PostBuildEvent" Condition="'$(PostBuildEventUseInBuild)'!='false'">
    <Message Text="%(PostBuildEvent.Message)" Condition="'%(PostBuildEvent.Message)' != '' and '%(PostBuildEvent.Command)' != ''" Importance="High" />
    <Exec Command="%(PostBuildEvent.Command)$(_BuildSuffix)" StdOutEncoding="%(PostBuildEvent.StdOutEncoding)" StdErrEncoding="%(PostBuildEvent.StdErrEncoding)" Condition="'%(PostBuildEvent.Command)' != ''" />
  </Target>
  <!-- *******************************************************************************************
        Custom Build
       ******************************************************************************************* -->
  <PropertyGroup Condition="'$(CustomBuildAfterTargets)'!='' or '$(CustomBuildBeforeTargets)'!=''">
    <CustomBuildToolBeforeTargets>$(CustomBuildBeforeTargets)</CustomBuildToolBeforeTargets>
    <CustomBuildToolAfterTargets>$(CustomBuildAfterTargets)</CustomBuildToolAfterTargets>
  </PropertyGroup>
  <!--If no before/after targets are set, then set the default-->
  <PropertyGroup Condition="'$(CustomBuildAfterTargets)'=='' and '$(CustomBuildBeforeTargets)'==''">
    <CustomBuildToolBeforeTargets>Midl</CustomBuildToolBeforeTargets>
    <CustomBuildToolAfterTargets>PreBuildEvent</CustomBuildToolAfterTargets>
    <CustomBuildBeforeTargets>PostBuildEvent</CustomBuildBeforeTargets>
    <CustomBuildAfterTargets>BscMake</CustomBuildAfterTargets>
  </PropertyGroup>
  <!--  If Selective File Build is enabled, then dont let custom interupt the build order-->
  <PropertyGroup Condition="'$(SelectedFiles)'!=''">
    <CustomBuildToolBeforeTargets />
    <CustomBuildToolAfterTargets />
    <CustomBuildBeforeTargets />
    <CustomBuildAfterTargets />
  </PropertyGroup>
  <Target Name="CustomBuild" DependsOnTargets="SelectCustomBuild;ComputeCustomBuildOutput" BeforeTargets="$(CustomBuildToolBeforeTargets)" AfterTargets="$(CustomBuildToolAfterTargets)">
    <PropertyGroup>
      <CustomBuildToolArchitecture Condition="'$(CustomBuildToolArchitecture)' == ''">Native32Bit</CustomBuildToolArchitecture>
    </PropertyGroup>
    <!-- delete old ParallelCustomBuild tlogs-->
    <GetOutOfDateItems Sources="@(_EmptyItemGroup)" OutputsMetadataName="Outputs" DependenciesMetadataName="AdditionalInputs" CommandMetadataName="Command" TLogDirectory="$(TLogLocation)" TLogNamePrefix="ParallelCustomBuild" TrackFileAccess="$(TrackFileAccess)" />
    <!-- Get out of date items (will create tlogs for all custom build items) -->
    <GetOutOfDateItems Condition="'$(SelectedFiles)' == ''" Sources="@(CustomBuild)" OutputsMetadataName="Outputs" DependenciesMetadataName="AdditionalInputs" CommandMetadataName="Command" TLogDirectory="$(TLogLocation)" TLogNamePrefix="CustomBuild" TrackFileAccess="$(TrackFileAccess)" CheckForInterdependencies="true">
      <Output TaskParameter="OutOfDateSources" ItemName="_CustomBuild" />
    </GetOutOfDateItems>
    <ItemGroup Condition="'$(SelectedFiles)' != ''">
      <_CustomBuild Include="@(CustomBuild)" />
    </ItemGroup>
    <!-- Buidl items which can be built in parallel (ignored for selected files build)-->
    <ItemGroup Condition="'$(SelectedFiles)' == ''">
      <_ParallelCustomBuild Include="@(_CustomBuild)" Condition="'%(_CustomBuild.BuildInParallel)' == 'true' and '%(_CustomBuild.DependsOnAnotherItemOutput)' != 'true'" />
    </ItemGroup>
    <ParallelCustomBuild Condition="'@(_ParallelCustomBuild)' != ''" Sources="@(_ParallelCustomBuild)" MaxProcesses="%(_ParallelCustomBuild.MaxProcesses)" MaxItemsInBatch="%(_ParallelCustomBuild.MaxItemsInBatch)" AcceptableNonZeroExitCodes="%(_ParallelCustomBuild.AcceptableNonZeroExitCodes)" StdOutEncoding="%(_ParallelCustomBuild.StdOutEncoding)" StdErrEncoding="%(_ParallelCustomBuild.StdErrEncoding)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)" />
    <!-- build the remaining items -->
    <ItemGroup Condition="'@(_ParallelCustomBuild)' != ''">
      <_CustomBuild Remove="@(_ParallelCustomBuild)" />
      <_ParallelCustomBuild Remove="@(_ParallelCustomBuild)" />
    </ItemGroup>
    <CustomBuild Condition="'@(_CustomBuild)' != ''" Sources="@(_CustomBuild)" BuildSuffix="$(_BuildSuffix)" MinimalRebuildFromTracking="false" AcceptableNonZeroExitCodes="%(_CustomBuild.AcceptableNonZeroExitCodes)" StdOutEncoding="%(_CustomBuild.StdOutEncoding)" StdErrEncoding="%(_CustomBuild.StdErrEncoding)" />
    <ItemGroup Condition="'@(_CustomBuild)' != ''">
      <_CustomBuild Remove="@(_CustomBuild)" />
    </ItemGroup>
  </Target>
  <Target Name="CustomBuildStep" Condition="'@(CustomBuildStep)' != '' and '$(SelectedFiles)'==''" Inputs="%(CustomBuildStep.Inputs);$(ProjectFileName)" Outputs="%(CustomBuildStep.Outputs)" DependsOnTargets="ComputeCustomBuildOutput" BeforeTargets="$(CustomBuildBeforeTargets)" AfterTargets="$(CustomBuildAfterTargets)">
    <CustomBuildStepMessage Text="%(CustomBuildStep.Message)" />
    <!-- write tlogs to track custom build step inputs and outputs -->
    <ItemGroup>
      <_CustomBuildStepInput Include="@(CustomBuildStep-&gt;MetaData('Inputs')-&gt;FullPath()-&gt;ToUpperInvariant()-&gt;Distinct())" />
    </ItemGroup>
    <ItemGroup>
      <_CustomBuildStepInputForOutput Include="@(_CustomBuildStepInput, '|')" />
    </ItemGroup>
    <MakeDir Directories="$(TLogLocation)" />
    <WriteLinesToFile File="$(TLogLocation)CustomBuildStep.read.1u.tlog" Lines="@(_CustomBuildStepInput->'^%(Identity)');" Encoding="Unicode" Overwrite="true" />
    <WriteLinesToFile File="$(TLogLocation)CustomBuildStep.write.1u.tlog" Lines="@(_CustomBuildStepInputForOutput->'^%(Identity)');@(CustomBuildStep-&gt;MetaData('Outputs')-&gt;FullPath()-&gt;ToUpperInvariant()-&gt;Distinct())" Encoding="Unicode" Overwrite="true" />
    <Exec Command="%(CustomBuildStep.Command)$(_BuildSuffix)" StdOutEncoding="%(CustomBuildStep.StdOutEncoding)" StdErrEncoding="%(CustomBuildStep.StdErrEncoding)" />
    <ItemGroup>
      <_CustomBuildStepInput Remove="@(_CustomBuildStepInput)" />
      <_CustomBuildStepInputForOutput Remove="@(_CustomBuildStepInputForOutput)" />
    </ItemGroup>
  </Target>
  <!-- *******************************************************************************************
        CLCompile
       ******************************************************************************************* -->
  <!-- FixupCLCompileOptions and SetModuleDependencies should be the last targets in ComputeCompileInputsTargets in order to apply the fixup to all compiler source inputs. -->
  <PropertyGroup>
    <ComputeCompileInputsTargets>
      $(ComputeCompileInputsTargets);
      $(BeforeFixupCLCompileOptions);
      ComputeStdModulesCompileInputs;
      FixupCLCompileOptions;
      SetModuleDependencies;
    </ComputeCompileInputsTargets>
  </PropertyGroup>
  <Target Name="ComputeStdModulesCompileInputs" Condition="'@(ClCompile)' != '' and '$(EnableCppModules)' != 'false' and '$(EnableStdModules)' != 'false'" DependsOnTargets="SetCppLanguageStandardCapabilities">
    <PropertyGroup Condition="'$(EnableStdModules)' != 'false'">
      <EnableStdModules Condition="'$(MSVC_STL_MODULES_JSON)' != '' and Exists($(MSVC_STL_MODULES_JSON)) and&#xD;&#xA;                        ('$(ManagedAssembly)' != 'true' or '$(_ClCpp20ModulesSupportedInCppCLI)' == 'true') and&#xD;&#xA;                        '@(ClCompile-&gt;AnyHaveMetadataValue('StdModulesSupported', 'true'))' == 'true'">true</EnableStdModules>
    </PropertyGroup>
    <ItemGroup Condition="'$(EnableStdModules)' == 'true'">
      <LibraryManifests Include="$(MSVC_STL_MODULES_JSON)">
        <AlwaysBuildLibraryModules Condition="'@(ClCompile-&gt;AnyHaveMetadataValue('BuildStlModules', 'true'))' == 'true'">true</AlwaysBuildLibraryModules>
      </LibraryManifests>
    </ItemGroup>
    <GetLibraryModuleSources Condition="'@(LibraryManifests)' != ''" LibraryManifests="@(LibraryManifests)">
      <Output TaskParameter="LibraryModuleSources" ItemName="_LibraryModuleSources" />
    </GetLibraryModuleSources>
    <ItemGroup>
      <ClCompile Include="@(_LibraryModuleSources)">
        <CompileAs>CompileAsCppModule</CompileAs>
        <CompileAsWinRT />
        <ForcedIncludeFiles />
        <IgnoreStandardIncludePath />
        <PrecompiledHeader>NotUsing</PrecompiledHeader>
        <ObjectFileName>$(IntDir)%(_LibraryModuleSources.OwningLibrary)\</ObjectFileName>
        <ModuleOutputFile>$(IntDir)%(_LibraryModuleSources.OwningLibrary)\</ModuleOutputFile>
        <ModuleDependenciesFile>$(IntDir)%(_LibraryModuleSources.OwningLibrary)\</ModuleDependenciesFile>
        <SourceDependenciesFile>$(IntDir)%(_LibraryModuleSources.OwningLibrary)\</SourceDependenciesFile>
        <XMLDocumentationFileName>$(IntDir)%(_LibraryModuleSources.OwningLibrary)\</XMLDocumentationFileName>
        <TranslateIncludes />
        <ModulesSupported>true</ModulesSupported>
      </ClCompile>
    </ItemGroup>
  </Target>
  <Target Name="SetCppLanguageStandardCapabilities" Condition="'@(ClCompile)' != ''">
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.LanguageStandard)' != ''">
        <CppLanguageStandardNumber Condition="'%(ClCompile.LanguageStandard)' == 'stdcpplatest'">99</CppLanguageStandardNumber>
        <CppLanguageStandardNumber Condition="'%(ClCompile.LanguageStandard)' == 'default'">14</CppLanguageStandardNumber>
      </ClCompile>
    </ItemGroup>
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.LanguageStandard)' != '' and '%(ClCompile.CppLanguageStandardNumber)' == ''">
        <CppLanguageStandardNumber>$([System.String]::new('%(ClCompile.LanguageStandard)').Substring(6))</CppLanguageStandardNumber>
      </ClCompile>
    </ItemGroup>
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.CppLanguageStandardNumber)' != '' and '%(ClCompile.CppLanguageStandardNumber)' &gt;= '20'">
        <StdModulesSupported Condition="'%(ClCompile.CppLanguageStandardNumber)' &gt;= '23'">true</StdModulesSupported>
        <ModulesSupported Condition="'%(ClCompile.ModulesSupported)' == ''">true</ModulesSupported>
      </ClCompile>
    </ItemGroup>
  </Target>
  <Target Name="FixupCLCompileOptions" Condition="'@(ClCompile)' != ''" DependsOnTargets="$(FixupCLCompileOptionsDependsOn);SetCppLanguageStandardCapabilities">
    <PropertyGroup>
      <MultiProcCL Condition="'$(MultiProcCL)' == '' and '$(UseMultiToolTask)' == 'true'">true</MultiProcCL>
    </PropertyGroup>
    <!-- remove excluded from build items -->
    <ItemGroup>
      <ClCompile Remove="@(ClCompile)" Condition="'%(ClCompile.ExcludedFromBuild)' == 'true'" />
    </ItemGroup>
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.ModulesSupported)' != 'true'">
        <CompileAs Condition="'%(ClCompile.CompileAs)' == 'CompileAsCppModule' or '%(ClCompile.CompileAs)' == 'CompileAsHeaderUnit' or '%(ClCompile.CompileAs)' == 'CompileAsCppModuleInternalPartition'">Default</CompileAs>
        <ScanSourceForModuleDependencies>false</ScanSourceForModuleDependencies>
      </ClCompile>
    </ItemGroup>
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.ModulesSupported)' == 'true' and '%(ClCompile.CompileAs)' == 'Default'">
        <CompileAs Condition="'%(ClCompile.Extension)' == '.ixx' or '%(ClCompile.Extension)' == '.cppm'">CompileAsCppModule</CompileAs>
        <CompileAs Condition="'%(ClCompile.Extension)' == '.h'">CompileAsHeaderUnit</CompileAs>
      </ClCompile>
    </ItemGroup>
    <ItemGroup>
      <ClCompile>
        <PrecompiledHeaderOutputFile Condition="'%(ClCompile.PrecompiledHeader)' == 'NotUsing' or '%(ClCompile.PrecompiledHeader)' == ''" />
        <PrecompiledHeaderFile Condition="'%(ClCompile.PrecompiledHeader)' == 'NotUsing' or '%(ClCompile.PrecompiledHeader)' == ''" />
        <UseUnicodeForAssemblerListing Condition="'%(ClCompile.AssemblerOutput)' == 'NoListing' or '%(ClCompile.AssemblerOutput)' == ''" />
        <AssemblerListingLocation Condition="'%(ClCompile.AssemblerOutput)' == 'NoListing' or '%(ClCompile.AssemblerOutput)' == ''" />
        <CompileAs Condition="'%(ClCompile.CompileAs)' == 'Default' and '%(ClCompile.Extension)' == '.c'">CompileAsC</CompileAs>
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <WinRTNoStdLib Condition="'%(ClCompile.CompileAsWinRT)' != 'true'">false</WinRTNoStdLib>
        <StdIfcDirectory Condition="'%(ClCompile.EnableModules)' == 'true'">$(VC_IFCPath)</StdIfcDirectory>
        <SupportJustMyCode Condition="'$(ManagedAssembly)' == 'true' or&#xD;&#xA;                                                  '%(ClCompile.DebugInformationFormat)' == 'None' or&#xD;&#xA;                                                  '%(ClCompile.DebugInformationFormat)' == ''">false</SupportJustMyCode>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
        <ExternalWarningLevel Condition="'%(ClCompile.ExternalWarningLevel)'  == 'InheritWarningLevel'">%(ClCompile.WarningLevel)</ExternalWarningLevel>
        <DeleteOutputBeforeExecute>$(CLDeleteOutputOnExecute)</DeleteOutputBeforeExecute>
        <DeleteOutputBeforeExecute Condition="'%(ClCompile.DeleteOutputBeforeExecute)' == ''">true</DeleteOutputBeforeExecute>
        <BuildingInIDE>$(BuildingInsideVisualStudio)</BuildingInIDE>
      </ClCompile>
      <!-- need to have a separate group to check for (potentially changed) metadata value in a condition -->
      <ClCompile>
        <CompileAs Condition="'%(ClCompile.CompileAs)' == 'Default'">CompileAsCpp</CompileAs>
        <ExternalWarningLevel Condition="'%(ClCompile.ExternalWarningLevel)'  == 'EnableAllWarnings'">Level4</ExternalWarningLevel>
      </ClCompile>
      <ClCompile Condition="'%(ClCompile.CompileAs)' == 'CompileAsCppModule' or '%(ClCompile.CompileAs)' == 'CompileAsCppModuleInternalPartition' or '%(ClCompile.CompileAs)' == 'CompileAsHeaderUnit'">
        <ModuleOrHeaderUnit>true</ModuleOrHeaderUnit>
        <ScanSourceForModuleDependencies>true</ScanSourceForModuleDependencies>
        <ObjectFileName Condition="HasTrailingSlash('%(ClCompile.ObjectFileName)')">%(ClCompile.ObjectFileName)%(FileName)%(Extension).obj</ObjectFileName>
      </ClCompile>
      <ClCompile Condition="'%(ClCompile.CompileAs)' == 'CompileAsC'">
        <ScanSourceForModuleDependencies>false</ScanSourceForModuleDependencies>
      </ClCompile>
      <!-- cleanup ModuleOutputFile for files we are not going to scan-->
      <ClCompile Condition="'%(ClCompile.ScanSourceForModuleDependencies)' != 'true'">
        <ModuleOutputFile />
      </ClCompile>
      <ClCompilePCH Include="@(ClCompile)" Condition="'%(ClCompile.PrecompiledHeader)' == 'Create' and '%(ClCompile.PrecompiledHeaderFile)' != ''" />
    </ItemGroup>
    <!-- MSVC currently requires /AI to be set for NetCore -->
    <ItemGroup Condition="'$(CLRSupport)' == 'NetCore'">
      <_NETCoreReferenceDirectory Include="%(ReferencePath.RootDir)%(ReferencePath.Directory)" Condition="'%(ReferencePath.Filename)' == 'System.Runtime'" />
    </ItemGroup>
    <ItemGroup Condition="'$(CLRSupport)' == 'NetCore'">
      <ClCompile>
        <AdditionalUsingDirectories>%(ClCompile.AdditionalUsingDirectories);@(_NETCoreReferenceDirectory)</AdditionalUsingDirectories>
      </ClCompile>
    </ItemGroup>
    <PropertyGroup>
      <EnableCppModules Condition="'@(ClCompile-&gt;AnyHaveMetadataValue('ModulesSupported', 'true'))' == 'true'">true</EnableCppModules>
      <EnableCppModules Condition="'$(EnableCppModules)' == 'true' and '@(ClCompile-&gt;AnyHaveMetadataValue('ScanSourceForModuleDependencies', 'true'))' != 'true' and '@(ReferencedProjectsPublicHeaderUnits)@(ReferencedProjectsPublicModules)' == ''">false</EnableCppModules>
      <!-- Check if any other compiles could run at the same time as the PCH, if so, enable /FS to sync write to the pdb. -->
      <_PCHForceSyncWrite Condition="'%(ClCompile.PrecompiledHeader)' == 'NotUsing' or '%(ClCompile.PrecompiledHeader)' == '' or '@(ClCompilePCH-&gt;Count())' &gt; '1'">true</_PCHForceSyncWrite>
    </PropertyGroup>
    <ItemGroup>
      <!-- EnableClServerMode requires /MP -->
      <ClCompile Condition="'$(EnableClServerMode)' == 'true'">
        <EnableClServerMode Condition="'%(ClCompile.EnableClServerMode)' == ''">true</EnableClServerMode>
      </ClCompile>
      <ClCompile Condition="'$(MultiProcCL)' == 'true'">
        <!-- Disable /MP for MTT only. -->
        <MultiProcessorCompilation Condition="'%(ClCompile.EnableClServerMode)' != 'true'" />
        <!-- If shared pdb via /ZI or /Zi, then enable synchronous operation to write to the pdb.  However, /FS has small perf loss, thus, in most cases, it is safe to create a PCH without /FS.  If needed, explicitly enable ForceSynchronousPDBWrites. -->
        <ForceSynchronousPDBWrites Condition="('%(ClCompile.DebugInformationFormat)' == 'EditAndContinue' or '%(ClCompile.DebugInformationFormat)' == 'ProgramDatabase') and ('%(ClCompile.PrecompiledHeader)' != 'Create' or '$(_PCHForceSyncWrite)' == 'true')">true</ForceSynchronousPDBWrites>
        <!-- The Cl Task can move source.i to the output, but in MTT let the compiler can do it directly.  -->
        <PreprocessOutputPath Condition="'%(ClCompile.PreprocessOutputPath)' == '' and '%(ClCompile.PreprocessToFile)' == 'true'">%(ClCompile.ObjectFileName)</PreprocessOutputPath>
      </ClCompile>
      <!-- The below requires its own group for batching to work. -->
      <!-- Set dependency so that pch would build first. -->
      <ClCompile Condition="('$(MultiProcCL)' == 'true' or '$(EnableCppModules)' == 'true') and '@(ClCompilePCH)' != ''">
        <!-- Using unqualified '%(PrecompiledHeaderFile)' and '%(PrecompiledHeaderOutputFile)' in the condition are required to filter @(ClCompilePCH) in the value
             to ClCompilePCH item(s) that have the same'%(PrecompiledHeaderFile)' and '%(PrecompiledHeaderOutputFile)' values as a given ClCompile item -->
        <MultiToolTaskDependency Condition="'%(PrecompiledHeaderFile)' != '' and '%(PrecompiledHeaderOutputFile)' != ''">@(ClCompilePCH);%(ClCompile.MultiToolTaskDependency)</MultiToolTaskDependency>
      </ClCompile>
      <ClCompilePCH Remove="@(ClCompilePCH)" />
    </ItemGroup>
    <!-- Code Analysis Fixup -->
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.EnablePREfast)' != 'true'">
        <DisableAnalyzeExternal />
        <AnalyzeExternalRuleset />
      </ClCompile>
      <ClCompile Condition="'%(ClCompile.DisableAnalyzeExternal)' == 'true'">
        <AnalyzeExternalRuleset />
      </ClCompile>
    </ItemGroup>
    <!-- Clear EnableVectorLength based on value of EnableEnhancedInstructionSet -->
    <ItemGroup>
      <ClCompile>
        <EnableVectorLength Condition="'%(ClCompile.EnableEnhancedInstructionSet)' != 'AdvancedVectorExtensions512' and '%(ClCompile.EnableEnhancedInstructionSet)' != 'AdvancedVectorExtensions101'" />
      </ClCompile>
    </ItemGroup>
  </Target>
  <Target Name="SetModuleDependencies" DependsOnTargets="$(SetModuleDependenciesDependsOn);MakeDirsForCl" Condition="'$(DesignTimeBuild)' != 'true' and '$(EnableCppModules)' == 'true'">
    <MakeDir Directories="$(TLogLocation_ModuleDependencies)" />
    <!-- scan modules and header units and set up MultiToolTaskDependency and AdditionalModuleDependencies metadata for future compilation for all sources.
         For module interfaces, the dependencies will include only modules they use
         Other sources will have all modules and header units in this project as dependencies unless ScanAllSourcesForModuleDependencies is 'true'
    -->
    <SetModuleDependencies Sources="@(ClCompile)" ReferencedHeaderUnitBMIs="@(ReferencedProjectsPublicHeaderUnits)" ReferencedModuleBMIs="@(ReferencedProjectsPublicModules)" TaskName="Microsoft.Build.CPPTasks.CL" TrackerLogDirectory="$(TLogLocation_ModuleDependencies)" MinimalRebuildFromTracking="true" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(CLNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" UseStructuredOutput="$(UseClStructuredOutput)" YieldDuringToolExecution="$(CLYieldDuringToolExecution)" MaxProcessCount="$(MultiProcMaxCount)" EnforceProcessCountAcrossBuilds="$(EnforceProcessCountAcrossBuilds)" SchedulerName="$(MultiProcSchedulerName)">
      <Output TaskParameter="SourcesWithDependencies" ItemName="_ClCompileWithModuleDependencies" />
      <Output TaskParameter="AdditionalIncludePath" PropertyName="_ReferencedHeaderUnitDirectories" />
    </SetModuleDependencies>
    <!-- SetModuleDependencies adds referenced header unit directories to INCLUDE env var, adjust the corresponding properties-->
    <PropertyGroup Condition="'$(_ReferencedHeaderUnitDirectories)' != ''">
      <INCLUDE>$(INCLUDE);$(_ReferencedHeaderUnitDirectories)</INCLUDE>
      <IncludePath>$(IncludePath);$(_ReferencedHeaderUnitDirectories)</IncludePath>
    </PropertyGroup>
    <ItemGroup>
      <ClCompile Remove="@(ClCompile)" />
      <ClCompile Include="@(_ClCompileWithModuleDependencies)" />
      <_ClCompileWithModuleDependencies Remove="@(_ClCompileWithModuleDependencies)" />
    </ItemGroup>
  </Target>
  <Target Name="ClCompile" Condition="'@(ClCompile)' != ''" DependsOnTargets="SelectClCompile">
    <PropertyGroup>
      <CLToolArchitecture Condition="'$(CLToolArchitecture)' == ''">$(VCToolArchitecture)</CLToolArchitecture>
    </PropertyGroup>
    <ItemGroup>
      <ClNoDependencies Condition="'@(ClNoDependencies)' == '' and '%(ClInclude.NoDependency)' == 'true'" Include="@(ClInclude)" />
      <ClNoDependencies Condition="'$(NoDependencies)' != ''" Include="$(NoDependencies)" />
    </ItemGroup>
    <!-- Delete the pch file if the pdb file has been deleted.  This will prevent a compiler warning about obsolete pch. -->
    <Delete Condition="'%(ClCompile.DebugInformationFormat)' != '' and '%(ClCompile.DebugInformationFormat)' != 'None' and '%(ClCompile.DebugInformationFormat)' != 'OldStyle' and '%(ClCompile.ProgramDataBaseFileName)' != '' and !Exists(%(ClCompile.ProgramDataBaseFileName))" Files="%(ClCompile.PrecompiledHeaderOutputFile)" />
    <MultiToolTask Condition="'%(ClCompile.CompilerIteration)' == 'Modules'" TaskName="Microsoft.Build.CPPTasks.CL" ShowCompilingMessage="true" Sources="@(ClCompile)" TrackerLogDirectory="$(TLogLocation)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(CLNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" UseStructuredOutput="$(UseClStructuredOutput)" YieldDuringToolExecution="$(CLYieldDuringToolExecution)" MaxProcessCount="$(MultiProcMaxCount)" EnforceProcessCountAcrossBuilds="$(EnforceProcessCountAcrossBuilds)" SchedulerName="$(MultiProcSchedulerName)" />
    <MultiToolTask Condition="'%(ClCompile.CompilerIteration)' == '' and '$(MultiProcCL)' == 'true'" TaskName="Microsoft.Build.CPPTasks.CL" Sources="@(ClCompile)" TrackerLogDirectory="$(TLogLocation)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(CLNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" UseStructuredOutput="$(UseClStructuredOutput)" YieldDuringToolExecution="$(CLYieldDuringToolExecution)" MaxProcessCount="$(MultiProcMaxCount)" EnforceProcessCountAcrossBuilds="$(EnforceProcessCountAcrossBuilds)" SchedulerName="$(MultiProcSchedulerName)" />
    <!-- Precompiled headers - need to build them first -->
    <CL Condition="'%(ClCompile.PrecompiledHeader)' == 'Create' and '%(ClCompile.CompilerIteration)' == '' and '$(MultiProcCL)' != 'true'" BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(ClCompile)" AdditionalBMIDirectories="%(ClCompile.AdditionalBMIDirectories)" AdditionalHeaderUnitDependencies="%(ClCompile.AdditionalHeaderUnitDependencies)" AdditionalIncludeDirectories="%(ClCompile.AdditionalIncludeDirectories)" AdditionalModuleDependencies="%(ClCompile.AdditionalModuleDependencies)" AdditionalOptions="%(ClCompile.AdditionalOptions)" AdditionalUsingDirectories="%(ClCompile.AdditionalUsingDirectories)" AssemblerListingLocation="%(ClCompile.AssemblerListingLocation)" AssemblerOutput="%(ClCompile.AssemblerOutput)" BasicRuntimeChecks="%(ClCompile.BasicRuntimeChecks)" BrowseInformation="%(ClCompile.BrowseInformation)" BrowseInformationFile="%(ClCompile.BrowseInformationFile)" BufferSecurityCheck="%(ClCompile.BufferSecurityCheck)" CallingConvention="%(ClCompile.CallingConvention)" ControlFlowGuard="%(ClCompile.ControlFlowGuard)" CompileAsManaged="%(ClCompile.CompileAsManaged)" CompileAsWinRT="%(ClCompile.CompileAsWinRT)" CompileAs="%(ClCompile.CompileAs)" UseDynamicDebugging="%(ClCompile.UseDynamicDebugging)" DynamicDebuggingSuffix="%(ClCompile.DynamicDebuggingSuffix)" ConformanceMode="%(ClCompile.ConformanceMode)" DebugInformationFormat="%(ClCompile.DebugInformationFormat)" DiagnosticsFormat="%(ClCompile.DiagnosticsFormat)" DisableLanguageExtensions="%(ClCompile.DisableLanguageExtensions)" DisableSpecificWarnings="%(ClCompile.DisableSpecificWarnings)" EnableASAN="%(ClCompile.EnableASAN)" EnableEnhancedInstructionSet="%(ClCompile.EnableEnhancedInstructionSet)" EnableVectorLength="%(ClCompile.EnableVectorLength)" EnableFiberSafeOptimizations="%(ClCompile.EnableFiberSafeOptimizations)" EnableFuzzer="%(ClCompile.EnableFuzzer)" EnableModules="%(ClCompile.EnableModules)" EnableParallelCodeGeneration="%(ClCompile.EnableParallelCodeGeneration)" EnablePREfast="%(ClCompile.EnablePREfast)" EnforceTypeConversionRules="%(ClCompile.EnforceTypeConversionRules)" ErrorReporting="%(ClCompile.ErrorReporting)" ExceptionHandling="%(ClCompile.ExceptionHandling)" ExpandAttributedSource="%(ClCompile.ExpandAttributedSource)" ExternalDirectoriesEnv="%(ClCompile.ExternalDirectoriesEnv)" ExternalTemplatesDiagnostics="%(ClCompile.ExternalTemplatesDiagnostics)" ExternalWarningLevel="%(ClCompile.ExternalWarningLevel)" DisableAnalyzeExternal="%(ClCompile.DisableAnalyzeExternal)" AnalyzeExternalRuleset="%(ClCompile.AnalyzeExternalRuleset)" FavorSizeOrSpeed="%(ClCompile.FavorSizeOrSpeed)" FloatingPointExceptions="%(ClCompile.FloatingPointExceptions)" FloatingPointModel="%(ClCompile.FloatingPointModel)" ForceConformanceInForLoopScope="%(ClCompile.ForceConformanceInForLoopScope)" ForcedIncludeFiles="%(ClCompile.ForcedIncludeFiles)" ForcedUsingFiles="%(ClCompile.ForcedUsingFiles)" ForceSynchronousPDBWrites="%(ClCompile.ForceSynchronousPDBWrites)" FunctionLevelLinking="%(ClCompile.FunctionLevelLinking)" GenerateModuleDependencies="%(ClCompile.GenerateModuleDependencies)" GenerateSourceDependencies="%(ClCompile.GenerateSourceDependencies)" GenerateXMLDocumentationFiles="%(ClCompile.GenerateXMLDocumentationFiles)" GuardEHContMetadata="%(ClCompile.GuardEHContMetadata)" GuardSignedReturns="%(ClCompile.GuardSignedReturns)" IgnoreStandardIncludePath="%(ClCompile.IgnoreStandardIncludePath)" InlineFunctionExpansion="%(ClCompile.InlineFunctionExpansion)" IntelJCCErratum="%(ClCompile.IntelJCCErratum)" IntrinsicFunctions="%(ClCompile.IntrinsicFunctions)" LanguageStandard="%(ClCompile.LanguageStandard)" LanguageStandard_C="%(ClCompile.LanguageStandard_C)" MinimalRebuild="%(ClCompile.MinimalRebuild)" ModuleDependenciesFile="%(ClCompile.ModuleDependenciesFile)" ModuleOutputFile="%(ClCompile.ModuleOutputFile)" MultiProcessorCompilation="%(ClCompile.MultiProcessorCompilation)" ObjectFileName="%(ClCompile.ObjectFileName)" OmitDefaultLibName="%(ClCompile.OmitDefaultLibName)" OmitFramePointers="%(ClCompile.OmitFramePointers)" OpenMPSupport="%(ClCompile.OpenMPSupport)" Optimization="%(ClCompile.Optimization)" PrecompiledHeader="%(ClCompile.PrecompiledHeader)" PrecompiledHeaderFile="%(ClCompile.PrecompiledHeaderFile)" PrecompiledHeaderOutputFile="%(ClCompile.PrecompiledHeaderOutputFile)" PREfastAdditionalOptions="%(ClCompile.PREfastAdditionalOptions)" PREfastAdditionalPlugins="%(ClCompile.PREfastAdditionalPlugins)" PREfastLog="%(ClCompile.PREfastLog)" PREfastRulesetFile="%(ClCompile.PREfastRulesetFile)" PREfastProjectDirectory="%(ClCompile.PREfastProjectDirectory)" PREfastRulesetDirectories="%(ClCompile.PREfastRulesetDirectories)" PreprocessKeepComments="%(ClCompile.PreprocessKeepComments)" PreprocessorDefinitions="%(ClCompile.PreprocessorDefinitions)" PreprocessSuppressLineNumbers="%(ClCompile.PreprocessSuppressLineNumbers)" PreprocessToFile="%(ClCompile.PreprocessToFile)" ProcessorNumber="%(ClCompile.ProcessorNumber)" ProgramDataBaseFileName="%(ClCompile.ProgramDataBaseFileName)" RemoveUnreferencedCodeData="%(ClCompile.RemoveUnreferencedCodeData)" RuntimeLibrary="%(ClCompile.RuntimeLibrary)" RuntimeTypeInfo="%(ClCompile.RuntimeTypeInfo)" SDLCheck="%(ClCompile.SDLCheck)" ShowIncludes="%(ClCompile.ShowIncludes)" SourceDependenciesFile="%(ClCompile.SourceDependenciesFile)" WarningVersion="%(ClCompile.WarningVersion)" SmallerTypeCheck="%(ClCompile.SmallerTypeCheck)" SpectreMitigation="%(ClCompile.SpectreMitigation)" StdIfcDirectory="%(ClCompile.StdIfcDirectory)" StringPooling="%(ClCompile.StringPooling)" StructMemberAlignment="%(ClCompile.StructMemberAlignment)" SupportJustMyCode="%(ClCompile.SupportJustMyCode)" SuppressStartupBanner="%(ClCompile.SuppressStartupBanner)" TranslateIncludes="%(ClCompile.TranslateIncludes)" TreatAngleIncludeAsExternal="%(ClCompile.TreatAngleIncludeAsExternal)" TreatSpecificWarningsAsErrors="%(ClCompile.TreatSpecificWarningsAsErrors)" TreatWarningAsError="%(ClCompile.TreatWarningAsError)" TreatWChar_tAsBuiltInType="%(ClCompile.TreatWChar_tAsBuiltInType)" UndefineAllPreprocessorDefinitions="%(ClCompile.UndefineAllPreprocessorDefinitions)" UndefinePreprocessorDefinitions="%(ClCompile.UndefinePreprocessorDefinitions)" UseFullPaths="%(ClCompile.UseFullPaths)" UseStandardPreprocessor="%(ClCompile.UseStandardPreprocessor)" UseUnicodeForAssemblerListing="%(ClCompile.UseUnicodeForAssemblerListing)" WarningLevel="%(ClCompile.WarningLevel)" WholeProgramOptimization="%(ClCompile.WholeProgramOptimization)" WinRTNoStdLib="%(ClCompile.WinRTNoStdLib)" XMLDocumentationFileName="%(ClCompile.XMLDocumentationFileName)" CreateHotpatchableImage="%(ClCompile.CreateHotpatchableImage)" TrackerLogDirectory="%(ClCompile.TrackerLogDirectory)" ExcludedInputPaths="%(ClCompile.ExcludedInputPaths)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(ClCompile.MinimalRebuildFromTracking)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TrackedInputFilesToIgnore="@(ClNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" DeleteOutputBeforeExecute="%(ClCompile.DeleteOutputBeforeExecute)" AcceptableNonZeroExitCodes="%(ClCompile.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(ClYieldDuringToolExecution)" EnableClServerMode="$(EnableClServerMode)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)" IgnoreErrorsFromLog="$(IgnoreErrorsFromLog)" ErrorListRegex="@(CLErrorListRegex)" UseStructuredOutput="$(UseClStructuredOutput)" />
    <!-- Rest of the sources -->
    <CL Condition="'%(ClCompile.PrecompiledHeader)' != 'Create' and '%(ClCompile.CompileAs)'!='CppModule' and '%(ClCompile.CompilerIteration)' == '' and @(ClCompile) != '' and '$(MultiProcCL)' != 'true'" BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(ClCompile)" AdditionalBMIDirectories="%(ClCompile.AdditionalBMIDirectories)" AdditionalHeaderUnitDependencies="%(ClCompile.AdditionalHeaderUnitDependencies)" AdditionalIncludeDirectories="%(ClCompile.AdditionalIncludeDirectories)" AdditionalModuleDependencies="%(ClCompile.AdditionalModuleDependencies)" AdditionalOptions="%(ClCompile.AdditionalOptions)" AdditionalUsingDirectories="%(ClCompile.AdditionalUsingDirectories)" AssemblerListingLocation="%(ClCompile.AssemblerListingLocation)" AssemblerOutput="%(ClCompile.AssemblerOutput)" BasicRuntimeChecks="%(ClCompile.BasicRuntimeChecks)" BrowseInformation="%(ClCompile.BrowseInformation)" BrowseInformationFile="%(ClCompile.BrowseInformationFile)" BufferSecurityCheck="%(ClCompile.BufferSecurityCheck)" CallingConvention="%(ClCompile.CallingConvention)" ControlFlowGuard="%(ClCompile.ControlFlowGuard)" CompileAsManaged="%(ClCompile.CompileAsManaged)" CompileAsWinRT="%(ClCompile.CompileAsWinRT)" CompileAs="%(ClCompile.CompileAs)" UseDynamicDebugging="%(ClCompile.UseDynamicDebugging)" DynamicDebuggingSuffix="%(ClCompile.DynamicDebuggingSuffix)" ConformanceMode="%(ClCompile.ConformanceMode)" DebugInformationFormat="%(ClCompile.DebugInformationFormat)" DiagnosticsFormat="%(ClCompile.DiagnosticsFormat)" DisableLanguageExtensions="%(ClCompile.DisableLanguageExtensions)" DisableSpecificWarnings="%(ClCompile.DisableSpecificWarnings)" EnableASAN="%(ClCompile.EnableASAN)" EnableEnhancedInstructionSet="%(ClCompile.EnableEnhancedInstructionSet)" EnableVectorLength="%(ClCompile.EnableVectorLength)" EnableFiberSafeOptimizations="%(ClCompile.EnableFiberSafeOptimizations)" EnableFuzzer="%(ClCompile.EnableFuzzer)" EnableModules="%(ClCompile.EnableModules)" EnableParallelCodeGeneration="%(ClCompile.EnableParallelCodeGeneration)" EnablePREfast="%(ClCompile.EnablePREfast)" EnforceTypeConversionRules="%(ClCompile.EnforceTypeConversionRules)" ErrorReporting="%(ClCompile.ErrorReporting)" ExceptionHandling="%(ClCompile.ExceptionHandling)" ExpandAttributedSource="%(ClCompile.ExpandAttributedSource)" ExternalDirectoriesEnv="%(ClCompile.ExternalDirectoriesEnv)" ExternalTemplatesDiagnostics="%(ClCompile.ExternalTemplatesDiagnostics)" ExternalWarningLevel="%(ClCompile.ExternalWarningLevel)" DisableAnalyzeExternal="%(ClCompile.DisableAnalyzeExternal)" AnalyzeExternalRuleset="%(ClCompile.AnalyzeExternalRuleset)" FavorSizeOrSpeed="%(ClCompile.FavorSizeOrSpeed)" FloatingPointExceptions="%(ClCompile.FloatingPointExceptions)" FloatingPointModel="%(ClCompile.FloatingPointModel)" ForceConformanceInForLoopScope="%(ClCompile.ForceConformanceInForLoopScope)" ForcedIncludeFiles="%(ClCompile.ForcedIncludeFiles)" ForcedUsingFiles="%(ClCompile.ForcedUsingFiles)" ForceSynchronousPDBWrites="%(ClCompile.ForceSynchronousPDBWrites)" FunctionLevelLinking="%(ClCompile.FunctionLevelLinking)" GenerateModuleDependencies="%(ClCompile.GenerateModuleDependencies)" GenerateSourceDependencies="%(ClCompile.GenerateSourceDependencies)" GenerateXMLDocumentationFiles="%(ClCompile.GenerateXMLDocumentationFiles)" GuardEHContMetadata="%(ClCompile.GuardEHContMetadata)" GuardSignedReturns="%(ClCompile.GuardSignedReturns)" IgnoreStandardIncludePath="%(ClCompile.IgnoreStandardIncludePath)" InlineFunctionExpansion="%(ClCompile.InlineFunctionExpansion)" IntelJCCErratum="%(ClCompile.IntelJCCErratum)" IntrinsicFunctions="%(ClCompile.IntrinsicFunctions)" LanguageStandard="%(ClCompile.LanguageStandard)" LanguageStandard_C="%(ClCompile.LanguageStandard_C)" MinimalRebuild="%(ClCompile.MinimalRebuild)" ModuleDependenciesFile="%(ClCompile.ModuleDependenciesFile)" ModuleOutputFile="%(ClCompile.ModuleOutputFile)" MultiProcessorCompilation="%(ClCompile.MultiProcessorCompilation)" ObjectFileName="%(ClCompile.ObjectFileName)" OmitDefaultLibName="%(ClCompile.OmitDefaultLibName)" OmitFramePointers="%(ClCompile.OmitFramePointers)" OpenMPSupport="%(ClCompile.OpenMPSupport)" Optimization="%(ClCompile.Optimization)" PrecompiledHeader="%(ClCompile.PrecompiledHeader)" PrecompiledHeaderFile="%(ClCompile.PrecompiledHeaderFile)" PrecompiledHeaderOutputFile="%(ClCompile.PrecompiledHeaderOutputFile)" PREfastAdditionalOptions="%(ClCompile.PREfastAdditionalOptions)" PREfastAdditionalPlugins="%(ClCompile.PREfastAdditionalPlugins)" PREfastLog="%(ClCompile.PREfastLog)" PREfastRulesetFile="%(ClCompile.PREfastRulesetFile)" PREfastProjectDirectory="%(ClCompile.PREfastProjectDirectory)" PREfastRulesetDirectories="%(ClCompile.PREfastRulesetDirectories)" PreprocessKeepComments="%(ClCompile.PreprocessKeepComments)" PreprocessorDefinitions="%(ClCompile.PreprocessorDefinitions)" PreprocessSuppressLineNumbers="%(ClCompile.PreprocessSuppressLineNumbers)" PreprocessToFile="%(ClCompile.PreprocessToFile)" ProcessorNumber="%(ClCompile.ProcessorNumber)" ProgramDataBaseFileName="%(ClCompile.ProgramDataBaseFileName)" RemoveUnreferencedCodeData="%(ClCompile.RemoveUnreferencedCodeData)" RuntimeLibrary="%(ClCompile.RuntimeLibrary)" RuntimeTypeInfo="%(ClCompile.RuntimeTypeInfo)" SDLCheck="%(ClCompile.SDLCheck)" ShowIncludes="%(ClCompile.ShowIncludes)" SourceDependenciesFile="%(ClCompile.SourceDependenciesFile)" WarningVersion="%(ClCompile.WarningVersion)" SmallerTypeCheck="%(ClCompile.SmallerTypeCheck)" SpectreMitigation="%(ClCompile.SpectreMitigation)" StdIfcDirectory="%(ClCompile.StdIfcDirectory)" StringPooling="%(ClCompile.StringPooling)" StructMemberAlignment="%(ClCompile.StructMemberAlignment)" SupportJustMyCode="%(ClCompile.SupportJustMyCode)" SuppressStartupBanner="%(ClCompile.SuppressStartupBanner)" TranslateIncludes="%(ClCompile.TranslateIncludes)" TreatAngleIncludeAsExternal="%(ClCompile.TreatAngleIncludeAsExternal)" TreatSpecificWarningsAsErrors="%(ClCompile.TreatSpecificWarningsAsErrors)" TreatWarningAsError="%(ClCompile.TreatWarningAsError)" TreatWChar_tAsBuiltInType="%(ClCompile.TreatWChar_tAsBuiltInType)" UndefineAllPreprocessorDefinitions="%(ClCompile.UndefineAllPreprocessorDefinitions)" UndefinePreprocessorDefinitions="%(ClCompile.UndefinePreprocessorDefinitions)" UseFullPaths="%(ClCompile.UseFullPaths)" UseStandardPreprocessor="%(ClCompile.UseStandardPreprocessor)" UseUnicodeForAssemblerListing="%(ClCompile.UseUnicodeForAssemblerListing)" WarningLevel="%(ClCompile.WarningLevel)" WholeProgramOptimization="%(ClCompile.WholeProgramOptimization)" WinRTNoStdLib="%(ClCompile.WinRTNoStdLib)" XMLDocumentationFileName="%(ClCompile.XMLDocumentationFileName)" CreateHotpatchableImage="%(CLCompile.CreateHotpatchableImage)" TrackerLogDirectory="%(ClCompile.TrackerLogDirectory)" ExcludedInputPaths="%(ClCompile.ExcludedInputPaths)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(ClCompile.MinimalRebuildFromTracking)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TrackedInputFilesToIgnore="@(ClNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" DeleteOutputBeforeExecute="%(ClCompile.DeleteOutputBeforeExecute)" AcceptableNonZeroExitCodes="%(ClCompile.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(ClYieldDuringToolExecution)" EnableClServerMode="$(EnableClServerMode)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)" IgnoreErrorsFromLog="$(IgnoreErrorsFromLog)" ErrorListRegex="@(CLErrorListRegex)" UseStructuredOutput="$(UseClStructuredOutput)" />
    <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
    <OnError Condition="'$(OnClCompileErrorTargets)' != ''" ExecuteTargets="$(OnClCompileErrorTargets)" />
  </Target>
  <Target Name="CompileXamlGeneratedFiles">
    <ItemGroup>
      <ClCompile Condition="'%(ClCompile.CompilerIteration)' == 'XamlGenerated'">
        <PrecompiledHeaderOutputFile Condition="'%(ClCompile.PrecompiledHeader)' == 'NotUsing' or '%(ClCompile.PrecompiledHeader)' == ''" />
        <PrecompiledHeaderFile Condition="'%(ClCompile.PrecompiledHeader)' == 'NotUsing' or '%(ClCompile.PrecompiledHeader)' == ''" />
        <UseUnicodeForAssemblerListing Condition="'%(ClCompile.AssemblerOutput)' == 'NoListing' or '%(ClCompile.AssemblerOutput)' == ''" />
        <AssemblerListingLocation Condition="'%(ClCompile.AssemblerOutput)' == 'NoListing' or '%(ClCompile.AssemblerOutput)' == ''" />
        <CompileAs Condition="'%(ClCompile.CompileAs)' == 'Default' and '%(ClCompile.Extension)' == '.c'">CompileAsC</CompileAs>
        <CompileAs Condition="'%(ClCompile.CompileAs)' == 'Default' and '%(ClCompile.Extension)' != '.c'">CompileAsCpp</CompileAs>
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <WinRTNoStdLib Condition="'%(ClCompile.CompileAsWinRT)' != 'true'">false</WinRTNoStdLib>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </ClCompile>
    </ItemGroup>
    <MultiToolTask Condition="'%(ClCompile.ExcludedFromBuild)'!='true' and '%(ClCompile.CompilerIteration)' == 'XamlGenerated' and '$(MultiProcCL)' == 'true'" TaskName="Microsoft.Build.CPPTasks.CL" Sources="@(ClCompile)" TrackerLogDirectory="$(TLogLocation)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(CLNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" UseStructuredOutput="$(UseClStructuredOutput)" YieldDuringToolExecution="$(CLYieldDuringToolExecution)" MaxProcessCount="$(MultiProcMaxCount)" EnforceProcessCountAcrossBuilds="$(EnforceProcessCountAcrossBuilds)" SchedulerName="$(MultiProcSchedulerName)" />
    <CL Condition="'%(ClCompile.PrecompiledHeader)' != 'Create' and '%(ClCompile.ExcludedFromBuild)'!='true' and '%(ClCompile.CompilerIteration)' == 'XamlGenerated' and '$(MultiProcCL)' != 'true'" BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(ClCompile)" AdditionalBMIDirectories="%(ClCompile.AdditionalBMIDirectories)" AdditionalHeaderUnitDependencies="%(ClCompile.AdditionalHeaderUnitDependencies)" AdditionalIncludeDirectories="%(ClCompile.AdditionalIncludeDirectories)" AdditionalModuleDependencies="%(ClCompile.AdditionalModuleDependencies)" AdditionalOptions="%(ClCompile.AdditionalOptions)" AdditionalUsingDirectories="%(ClCompile.AdditionalUsingDirectories)" AssemblerListingLocation="%(ClCompile.AssemblerListingLocation)" AssemblerOutput="%(ClCompile.AssemblerOutput)" BasicRuntimeChecks="%(ClCompile.BasicRuntimeChecks)" BrowseInformation="%(ClCompile.BrowseInformation)" BrowseInformationFile="%(ClCompile.BrowseInformationFile)" BufferSecurityCheck="%(ClCompile.BufferSecurityCheck)" CallingConvention="%(ClCompile.CallingConvention)" ControlFlowGuard="%(ClCompile.ControlFlowGuard)" CompileAsManaged="%(ClCompile.CompileAsManaged)" CompileAsWinRT="%(ClCompile.CompileAsWinRT)" CompileAs="%(ClCompile.CompileAs)" UseDynamicDebugging="%(ClCompile.UseDynamicDebugging)" DynamicDebuggingSuffix="%(ClCompile.DynamicDebuggingSuffix)" ConformanceMode="%(ClCompile.ConformanceMode)" DebugInformationFormat="%(ClCompile.DebugInformationFormat)" DiagnosticsFormat="%(ClCompile.DiagnosticsFormat)" DisableLanguageExtensions="%(ClCompile.DisableLanguageExtensions)" DisableSpecificWarnings="%(ClCompile.DisableSpecificWarnings)" EnableASAN="%(ClCompile.EnableASAN)" EnableEnhancedInstructionSet="%(ClCompile.EnableEnhancedInstructionSet)" EnableVectorLength="%(ClCompile.EnableVectorLength)" EnableFiberSafeOptimizations="%(ClCompile.EnableFiberSafeOptimizations)" EnableFuzzer="%(ClCompile.EnableFuzzer)" EnableModules="%(ClCompile.EnableModules)" EnableParallelCodeGeneration="%(ClCompile.EnableParallelCodeGeneration)" EnablePREfast="%(ClCompile.EnablePREfast)" EnforceTypeConversionRules="%(ClCompile.EnforceTypeConversionRules)" ErrorReporting="%(ClCompile.ErrorReporting)" ExceptionHandling="%(ClCompile.ExceptionHandling)" ExpandAttributedSource="%(ClCompile.ExpandAttributedSource)" ExternalDirectoriesEnv="%(ClCompile.ExternalDirectoriesEnv)" ExternalTemplatesDiagnostics="%(ClCompile.ExternalTemplatesDiagnostics)" ExternalWarningLevel="%(ClCompile.ExternalWarningLevel)" DisableAnalyzeExternal="%(ClCompile.DisableAnalyzeExternal)" AnalyzeExternalRuleset="%(ClCompile.AnalyzeExternalRuleset)" FavorSizeOrSpeed="%(ClCompile.FavorSizeOrSpeed)" FloatingPointExceptions="%(ClCompile.FloatingPointExceptions)" FloatingPointModel="%(ClCompile.FloatingPointModel)" ForceConformanceInForLoopScope="%(ClCompile.ForceConformanceInForLoopScope)" ForcedIncludeFiles="%(ClCompile.ForcedIncludeFiles)" ForcedUsingFiles="%(ClCompile.ForcedUsingFiles)" ForceSynchronousPDBWrites="%(ClCompile.ForceSynchronousPDBWrites)" FunctionLevelLinking="%(ClCompile.FunctionLevelLinking)" GenerateModuleDependencies="%(ClCompile.GenerateModuleDependencies)" GenerateSourceDependencies="%(ClCompile.GenerateSourceDependencies)" GenerateXMLDocumentationFiles="%(ClCompile.GenerateXMLDocumentationFiles)" GuardEHContMetadata="%(ClCompile.GuardEHContMetadata)" GuardSignedReturns="%(ClCompile.GuardSignedReturns)" IgnoreStandardIncludePath="%(ClCompile.IgnoreStandardIncludePath)" InlineFunctionExpansion="%(ClCompile.InlineFunctionExpansion)" IntelJCCErratum="%(ClCompile.IntelJCCErratum)" IntrinsicFunctions="%(ClCompile.IntrinsicFunctions)" LanguageStandard="%(ClCompile.LanguageStandard)" LanguageStandard_C="%(ClCompile.LanguageStandard_C)" MinimalRebuild="%(ClCompile.MinimalRebuild)" ModuleDependenciesFile="%(ClCompile.ModuleDependenciesFile)" ModuleOutputFile="%(ClCompile.ModuleOutputFile)" MultiProcessorCompilation="%(ClCompile.MultiProcessorCompilation)" ObjectFileName="%(ClCompile.ObjectFileName)" OmitDefaultLibName="%(ClCompile.OmitDefaultLibName)" OmitFramePointers="%(ClCompile.OmitFramePointers)" OpenMPSupport="%(ClCompile.OpenMPSupport)" Optimization="%(ClCompile.Optimization)" PrecompiledHeader="%(ClCompile.PrecompiledHeader)" PrecompiledHeaderFile="%(ClCompile.PrecompiledHeaderFile)" PrecompiledHeaderOutputFile="%(ClCompile.PrecompiledHeaderOutputFile)" PREfastAdditionalOptions="%(ClCompile.PREfastAdditionalOptions)" PREfastAdditionalPlugins="%(ClCompile.PREfastAdditionalPlugins)" PREfastLog="%(ClCompile.PREfastLog)" PREfastRulesetFile="%(ClCompile.PREfastRulesetFile)" PREfastProjectDirectory="%(ClCompile.PREfastProjectDirectory)" PREfastRulesetDirectories="%(ClCompile.PREfastRulesetDirectories)" PreprocessKeepComments="%(ClCompile.PreprocessKeepComments)" PreprocessorDefinitions="%(ClCompile.PreprocessorDefinitions)" PreprocessSuppressLineNumbers="%(ClCompile.PreprocessSuppressLineNumbers)" PreprocessToFile="%(ClCompile.PreprocessToFile)" ProcessorNumber="%(ClCompile.ProcessorNumber)" ProgramDataBaseFileName="%(ClCompile.ProgramDataBaseFileName)" RemoveUnreferencedCodeData="%(ClCompile.RemoveUnreferencedCodeData)" RuntimeLibrary="%(ClCompile.RuntimeLibrary)" RuntimeTypeInfo="%(ClCompile.RuntimeTypeInfo)" SDLCheck="%(ClCompile.SDLCheck)" ShowIncludes="%(ClCompile.ShowIncludes)" SourceDependenciesFile="%(ClCompile.SourceDependenciesFile)" WarningVersion="%(ClCompile.WarningVersion)" SmallerTypeCheck="%(ClCompile.SmallerTypeCheck)" SpectreMitigation="%(ClCompile.SpectreMitigation)" StdIfcDirectory="%(ClCompile.StdIfcDirectory)" StringPooling="%(ClCompile.StringPooling)" StructMemberAlignment="%(ClCompile.StructMemberAlignment)" SupportJustMyCode="%(ClCompile.SupportJustMyCode)" SuppressStartupBanner="%(ClCompile.SuppressStartupBanner)" TranslateIncludes="%(ClCompile.TranslateIncludes)" TreatAngleIncludeAsExternal="%(ClCompile.TreatAngleIncludeAsExternal)" TreatSpecificWarningsAsErrors="%(ClCompile.TreatSpecificWarningsAsErrors)" TreatWarningAsError="%(ClCompile.TreatWarningAsError)" TreatWChar_tAsBuiltInType="%(ClCompile.TreatWChar_tAsBuiltInType)" UndefineAllPreprocessorDefinitions="%(ClCompile.UndefineAllPreprocessorDefinitions)" UndefinePreprocessorDefinitions="%(ClCompile.UndefinePreprocessorDefinitions)" UseFullPaths="%(ClCompile.UseFullPaths)" UseStandardPreprocessor="%(ClCompile.UseStandardPreprocessor)" UseUnicodeForAssemblerListing="%(ClCompile.UseUnicodeForAssemblerListing)" WarningLevel="%(ClCompile.WarningLevel)" WholeProgramOptimization="%(ClCompile.WholeProgramOptimization)" WinRTNoStdLib="%(ClCompile.WinRTNoStdLib)" XMLDocumentationFileName="%(ClCompile.XMLDocumentationFileName)" CreateHotpatchableImage="%(CLCompile.CreateHotpatchableImage)" TrackerLogDirectory="%(ClCompile.TrackerLogDirectory)" ExcludedInputPaths="%(ClCompile.ExcludedInputPaths)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(ClCompile.MinimalRebuildFromTracking)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TrackedInputFilesToIgnore="@(ClNoDependencies)" TrackedOutputFilesToIgnore="@(ClTrackedOutputFilesToIgnore)" DeleteOutputBeforeExecute="%(ClCompile.DeleteOutputBeforeExecute)" AcceptableNonZeroExitCodes="%(ClCompile.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(ClYieldDuringToolExecution)" EnableClServerMode="$(EnableClServerMode)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)" IgnoreErrorsFromLog="$(IgnoreErrorsFromLog)" ErrorListRegex="@(CLErrorListRegex)" UseStructuredOutput="$(UseClStructuredOutput)" />
  </Target>
  <!-- *******************************************************************************************
        Link
       ******************************************************************************************* -->
  <Target Name="ComputeLinkSwitches" Condition="'@(Link)' != ''">
    <ItemGroup>
      <_EmbedManagedResourceFile Include="@(Link-&gt;Metadata('EmbedManagedResourceFile')-&gt;Distinct())" />
      <_EmbedManagedResourceFile Include="@(Link-&gt;Metadata('AddModuleNamesToAssembly')-&gt;Distinct())" />
      <_EmbedManagedResourceFile Condition="'%(EmbeddedResource.LogicalName)' == '' and '%(EmbeddedResource.WithCulture)' != 'true' and '%(EmbeddedResource.ExcludedFromBuild)' != 'true'" Include="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" />
      <_EmbedManagedResourceFile Condition="'%(EmbeddedResource.LogicalName)' != '' and '%(EmbeddedResource.WithCulture)' != 'true' and '%(EmbeddedResource.ExcludedFromBuild)' != 'true'" Include="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources,%(LogicalName)')" />
      <Link Include="@(ResObjMt-&gt;WithMetadataValue('LinkCompiled', 'true')-&gt;ClearMetadata())" />
    </ItemGroup>
    <PropertyGroup>
      <Link_MinimalRebuildFromTracking Condition="'@(Link-&gt;AnyHaveMetadataValue('MinimalRebuildFromTracking', 'false'))' == 'true'">false</Link_MinimalRebuildFromTracking>
      <Link_MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</Link_MinimalRebuildFromTracking>
      <Link_MinimalRebuildFromTracking Condition="'$(Link_MinimalRebuildFromTracking)' == ''">true</Link_MinimalRebuildFromTracking>
      <LinkToolArchitecture Condition="'$(LinkToolArchitecture)' == ''">$(VCToolArchitecture)</LinkToolArchitecture>
      <LinkYieldDuringToolExecution Condition="'$(LinkYieldDuringToolExecution)' == '' and '%(Link.LinkTimeCodeGeneration)' == 'UseLinkTimeCodeGeneration'">true</LinkYieldDuringToolExecution>
      <_GenerateWindowsMetadata Condition="'$(_GenerateWindowsMetadata)' == '' and '$(OnlyCreateWinMD)' == 'true' and '$(GenerateBuildCompilePassWinMD)' == 'true'">false</_GenerateWindowsMetadata>
      <_GenerateWindowsMetadata Condition="'$(_GenerateWindowsMetadata)' == ''">%(Link.GenerateWindowsMetadata)</_GenerateWindowsMetadata>
      <!-- convert old values in case somebody set them explicitly -->
      <LinkControlFlowGuard Condition="'$(LinkControlFlowGuard)' == 'Guard'">true</LinkControlFlowGuard>
      <LinkGuardEHContMetadata Condition="'$(LinkGuardEHContMetadata)' == 'Enabled'">true</LinkGuardEHContMetadata>
      <!-- Compile's ControlFlowGuard needs to enable guard:cf on linker -->
      <LinkControlFlowGuard Condition="'$(LinkControlFlowGuard)' == '' and '@(ClCompile)' != '' and '@(ClCompile-&gt;AnyHaveMetadataValue('ControlFlowGuard', 'Guard'))' == 'true'">true</LinkControlFlowGuard>
      <!-- Compile's GuardEHContMetadata needs to enable guard:cf and guard:ehcont on linker -->
      <_EnableGuardEHContMetadata Condition="'@(ClCompile)' != '' and '@(ClCompile-&gt;AnyHaveMetadataValue('GuardEHContMetadata', 'true'))' == 'true'">true</_EnableGuardEHContMetadata>
      <LinkControlFlowGuard Condition="'$(LinkControlFlowGuard)' == '' and '$(_EnableGuardEHContMetadata)'== 'true'">true</LinkControlFlowGuard>
      <LinkGuardEHContMetadata Condition="'$(LinkGuardEHContMetadata)' == '' and '$(_EnableGuardEHContMetadata)'== 'true'">true</LinkGuardEHContMetadata>
      <!-- Compile's GuardSignedReturns needs to enable guard:delayloadsignret on linker -->
      <LinkGuardSignedReturns Condition="'$(LinkGuardSignedReturns)' == '' and '@(ClCompile)' != '' and '@(ClCompile-&gt;AnyHaveMetadataValue('GuardSignedReturns', 'true'))' == 'true'">true</LinkGuardSignedReturns>
    </PropertyGroup>
  </Target>
  <Target Name="Link" Condition="'@(Link)' != ''" DependsOnTargets="ComputeLinkSwitches">
    <ItemGroup>
      <Link>
        <ProfileGuidedDatabase Condition="'%(Link.LinkTimeCodeGeneration)' != 'PGOptimization' and&#xD;&#xA;                                          '%(Link.LinkTimeCodeGeneration)' != 'PGUpdate' and&#xD;&#xA;                                          '%(Link.LinkTimeCodeGeneration)' != 'PGInstrument'" />
        <ManifestEmbed Condition="'%(Link.ManifestEmbed)' == '' and '$(LegacyManifestEmbedding)' != 'true'">$(EmbedManifest)</ManifestEmbed>
        <ManifestInput Condition="'$(LegacyManifestEmbedding)' != 'true' and '$(EmbedManifest)' == 'true'">@(Link->'%(ManifestInput)');@(Manifest);$(ManifestAdditionalManifestFiles)</ManifestInput>
        <ManifestFile Condition="'$(LegacyManifestEmbedding)' != 'true'" />
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </Link>
      <!-- Remove some Winmd switches if generation is false -->
      <Link>
        <WindowsMetadataFile Condition="'%(Link.GenerateWindowsMetadata)' == ''" />
        <WindowsMetadataLinkKeyFile Condition="'%(Link.GenerateWindowsMetadata)' == ''" />
        <WindowsMetadataKeyContainer Condition="'%(Link.GenerateWindowsMetadata)' == ''" />
        <WindowsMetadataLinkDelaySign Condition="'%(Link.GenerateWindowsMetadata)' == ''" />
        <WindowsMetadataSignHash Condition="'%(Link.GenerateWindowsMetadata)' == ''" />
      </Link>
      <Link>
        <!-- Generate full PDB. For now call link without /debug:fastlink. Later will'll call a special tool to create merge pdbs  -->
        <GenerateDebugInformation Condition="'%(Link.GenerateDebugInformation)' == 'DebugFastLink' and ('%(Link.FullProgramDatabaseFile)' == 'true'  or '$(UseDebugFastLink)' == 'false')">DebugFull</GenerateDebugInformation>
        <!-- add ijwhost.lib location for NetCore projects -->
        <AdditionalLibraryDirectories Condition="'$(UseIJWHost)' == 'true' and Exists('$(IjwHostSourcePath)')">%(Link.AdditionalLibraryDirectories);$([System.IO.Directory]::GetParent($(IjwHostSourcePath)))</AdditionalLibraryDirectories>
      </Link>
      <Link>
        <EnableCOMDATFolding Condition="'$(UseDynamicDebugging)' == 'true'">false</EnableCOMDATFolding>
      </Link>
    </ItemGroup>
    <Link BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(Link)" AdditionalDependencies="%(Link.AdditionalDependencies)" AdditionalLibraryDirectories="%(Link.AdditionalLibraryDirectories)" AdditionalManifestDependencies="%(Link.AdditionalManifestDependencies)" AdditionalOptions="%(Link.AdditionalOptions)" AddModuleNamesToAssembly="%(Link.AddModuleNamesToAssembly)" AllowIsolation="%(Link.AllowIsolation)" AppContainer="%(Link.AppContainer)" AssemblyDebug="%(Link.AssemblyDebug)" AssemblyLinkResource="%(Link.AssemblyLinkResource)" BaseAddress="%(Link.BaseAddress)" CETCompat="%(Link.CETCompat)" ControlFlowGuard="$(LinkControlFlowGuard)" CLRImageType="%(Link.CLRImageType)" CLRSupportLastError="%(Link.CLRSupportLastError)" CLRThreadAttribute="%(Link.CLRThreadAttribute)" CLRUnmanagedCodeCheck="%(Link.CLRUnmanagedCodeCheck)" CreateHotPatchableImage="%(Link.CreateHotPatchableImage)" DataExecutionPrevention="%(Link.DataExecutionPrevention)" DelayLoadDLLs="%(Link.DelayLoadDLLs)" DelaySign="$(LinkDelaySign)" Driver="%(Link.Driver)" EmbedManagedResourceFile="@(_EmbedManagedResourceFile)" EnableCOMDATFolding="%(Link.EnableCOMDATFolding)" EnableUAC="%(Link.EnableUAC)" EntryPointSymbol="%(Link.EntryPointSymbol)" LinkErrorReporting="%(Link.LinkErrorReporting)" FixedBaseAddress="%(Link.FixedBaseAddress)" ForceFileOutput="%(Link.ForceFileOutput)" ForceSymbolReferences="%(Link.ForceSymbolReferences)" FunctionOrder="%(Link.FunctionOrder)" GenerateDebugInformation="%(Link.GenerateDebugInformation)" GenerateImportLib="$(GenerateImportLib)" GenerateManifest="$(GenerateManifest)" GenerateMapFile="%(Link.GenerateMapFile)" GenerateWindowsMetadata="$(_GenerateWindowsMetadata)" GuardEHContMetadata="$(LinkGuardEHContMetadata)" GuardSignedReturns="$(LinkGuardSignedReturns)" WindowsMetadataFile="%(Link.WindowsMetadataFile)" HeapCommitSize="%(Link.HeapCommitSize)" HeapReserveSize="%(Link.HeapReserveSize)" IgnoreAllDefaultLibraries="%(Link.IgnoreAllDefaultLibraries)" IgnoreEmbeddedIDL="%(Link.IgnoreEmbeddedIDL)" IgnoreSpecificDefaultLibraries="%(Link.IgnoreSpecificDefaultLibraries)" ImageHasSafeExceptionHandlers="%(Link.ImageHasSafeExceptionHandlers)" ImportLibrary="%(Link.ImportLibrary)" IncrementalLinkDatabaseFile="%(Link.IncrementalLinkDatabaseFile)" KeyContainer="%(Link.KeyContainer)" KeyFile="$(LinkKeyFile)" LargeAddressAware="%(Link.LargeAddressAware)" LinkDLL="%(Link.LinkDLL)" LinkIncremental="$(LinkIncremental)" LinkStatus="%(Link.LinkStatus)" LinkTimeCodeGeneration="%(Link.LinkTimeCodeGeneration)" LinkTimeCodeGenerationObjectFile="%(Link.LinkTimeCodeGenerationObjectFile)" UseDynamicDebugging="%(Link.UseDynamicDebugging)" DynamicDebuggingSuffix="%(Link.DynamicDebuggingSuffix)" ManifestFile="%(Link.ManifestFile)" ManifestEmbed="%(Link.ManifestEmbed)" ManifestInput="%(Link.ManifestInput)" MapExports="%(Link.MapExports)" MapFileName="%(Link.MapFileName)" MergedIDLBaseFileName="%(Link.MergedIDLBaseFileName)" MergeSections="%(Link.MergeSections)" MidlCommandFile="%(Link.MidlCommandFile)" MinimumRequiredVersion="%(Link.MinimumRequiredVersion)" ModuleDefinitionFile="%(Link.ModuleDefinitionFile)" MSDOSStubFileName="%(Link.MSDOSStubFileName)" Natvis="@(Natvis)" OptimizeReferences="%(Link.OptimizeReferences)" OutputFile="%(Link.OutputFile)" PreventDllBinding="%(Link.PreventDllBinding)" Profile="%(Link.Profile)" ProfileGuidedDatabase="%(Link.ProfileGuidedDatabase)" ProgramDatabaseFile="%(Link.ProgramDatabaseFile)" RandomizedBaseAddress="%(Link.RandomizedBaseAddress)" NoEntryPoint="%(Link.NoEntryPoint)" SectionAlignment="%(Link.SectionAlignment)" SetChecksum="%(Link.SetChecksum)" ShowProgress="%(Link.ShowProgress)" SignHash="%(Link.SignHash)" SpecifySectionAttributes="%(Link.SpecifySectionAttributes)" StackCommitSize="%(Link.StackCommitSize)" StackReserveSize="%(Link.StackReserveSize)" StripPrivateSymbols="%(Link.StripPrivateSymbols)" SubSystem="%(Link.SubSystem)" SupportUnloadOfDelayLoadedDLL="%(Link.SupportUnloadOfDelayLoadedDLL)" SupportNobindOfDelayLoadedDLL="%(Link.SupportNobindOfDelayLoadedDLL)" SuppressStartupBanner="%(Link.SuppressStartupBanner)" SwapRunFromCD="%(Link.SwapRunFromCD)" SwapRunFromNET="%(Link.SwapRunFromNET)" TargetMachine="%(Link.TargetMachine)" TerminalServerAware="%(Link.TerminalServerAware)" TreatLinkerWarningAsErrors="%(Link.TreatLinkerWarningAsErrors)" TurnOffAssemblyGeneration="%(Link.TurnOffAssemblyGeneration)" TypeLibraryFile="%(Link.TypeLibraryFile)" TypeLibraryResourceID="%(Link.TypeLibraryResourceID)" UACExecutionLevel="%(Link.UACExecutionLevel)" UACUIAccess="%(Link.UACUIAccess)" Version="%(Link.Version)" WindowsMetadataLinkKeyFile="%(Link.WindowsMetadataLinkKeyFile)" WindowsMetadataKeyContainer="%(Link.WindowsMetadataKeyContainer)" WindowsMetadataLinkDelaySign="%(Link.WindowsMetadataLinkDelaySign)" WindowsMetadataSignHash="%(Link.WindowsMetadataSignHash)" TrackerLogDirectory="%(Link.TrackerLogDirectory)" ExcludedInputPaths="%(Link.ExcludedInputPaths)" TLogReadFiles="@(LinkTLogReadFiles)" TLogWriteFiles="@(LinkTLogWriteFiles)" ToolExe="$(LinkToolExe)" ToolPath="$(LinkToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="$(Link_MinimalRebuildFromTracking)" ToolArchitecture="$(LinkToolArchitecture)" TrackerFrameworkPath="$(LinkTrackerFrameworkPath)" TrackerSdkPath="$(LinkTrackerSdkPath)" TrackedInputFilesToIgnore="@(LinkNoDependencies)" TrackedOutputFilesToIgnore="@(LinkTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(Link.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(LinkYieldDuringToolExecution)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)">
      <Output TaskParameter="SkippedExecution" PropertyName="LinkSkippedExecution" />
    </Link>
    <Message Text="$(MSBuildProjectFile) -&gt; $(TargetPath)" Importance="High" Condition="'$(EmbedManifestBy)' != 'LINK' or '$(LegacyManifestEmbedding)' != 'true' or '$(LinkSkippedExecution)' == 'true'" />
    <VCMessage Code="MSB8033" Type="Message" Arguments="$(MSBuildProjectFile);%(Link.ProgramDatabaseFile)" Importance="High" Condition="('$(EmbedManifestBy)' != 'LINK' or '$(LegacyManifestEmbedding)' != 'true' or '$(LinkSkippedExecution)' == 'true') and&#xD;&#xA;             %(Link.GenerateDebugInformation) == 'DebugFastLink' and %(Link.ProgramDataBaseFileName) != ''" />
    <VCMessage Code="MSB8034" Type="Message" Arguments="$(MSBuildProjectFile);%(Link.ProgramDatabaseFile)" Importance="High" Condition="('$(EmbedManifestBy)' != 'LINK' or '$(LegacyManifestEmbedding)' != 'true' or '$(LinkSkippedExecution)' == 'true') and&#xD;&#xA;             %(Link.GenerateDebugInformation) == 'true' and %(Link.ProgramDataBaseFileName) != ''" />
  </Target>
  <Target Name="LinkEmbedManifest" Condition="'@(Link)' != '' AND '$(EmbedManifestBy)'=='LINK' AND '$(LinkSkippedExecution)' != 'true'" DependsOnTargets="ComputeLinkSwitches">
    <Link BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(Link)" AdditionalDependencies="%(Link.AdditionalDependencies)" AdditionalLibraryDirectories="%(Link.AdditionalLibraryDirectories)" AdditionalManifestDependencies="%(Link.AdditionalManifestDependencies)" AdditionalOptions="%(Link.AdditionalOptions)" AddModuleNamesToAssembly="%(Link.AddModuleNamesToAssembly)" AllowIsolation="%(Link.AllowIsolation)" AppContainer="%(Link.AppContainer)" AssemblyDebug="%(Link.AssemblyDebug)" AssemblyLinkResource="%(Link.AssemblyLinkResource)" BaseAddress="%(Link.BaseAddress)" CETCompat="%(Link.CETCompat)" ControlFlowGuard="$(LinkControlFlowGuard)" CLRImageType="%(Link.CLRImageType)" CLRSupportLastError="%(Link.CLRSupportLastError)" CLRThreadAttribute="%(Link.CLRThreadAttribute)" CLRUnmanagedCodeCheck="%(Link.CLRUnmanagedCodeCheck)" CreateHotPatchableImage="%(Link.CreateHotPatchableImage)" DataExecutionPrevention="%(Link.DataExecutionPrevention)" DelayLoadDLLs="%(Link.DelayLoadDLLs)" DelaySign="$(LinkDelaySign)" Driver="%(Link.Driver)" EmbedManagedResourceFile="@(_EmbedManagedResourceFile)" EnableCOMDATFolding="%(Link.EnableCOMDATFolding)" EnableUAC="%(Link.EnableUAC)" EntryPointSymbol="%(Link.EntryPointSymbol)" LinkErrorReporting="%(Link.LinkErrorReporting)" FixedBaseAddress="%(Link.FixedBaseAddress)" ForceFileOutput="%(Link.ForceFileOutput)" ForceSymbolReferences="%(Link.ForceSymbolReferences)" FunctionOrder="%(Link.FunctionOrder)" GenerateDebugInformation="%(Link.GenerateDebugInformation)" GenerateImportLib="$(GenerateImportLib)" GenerateManifest="$(GenerateManifest)" GenerateMapFile="%(Link.GenerateMapFile)" GenerateWindowsMetadata="$(_GenerateWindowsMetadata)" GuardEHContMetadata="$(LinkGuardEHContMetadata)" GuardSignedReturns="$(LinkGuardSignedReturns)" WindowsMetadataFile="%(Link.WindowsMetadataFile)" HeapCommitSize="%(Link.HeapCommitSize)" HeapReserveSize="%(Link.HeapReserveSize)" IgnoreAllDefaultLibraries="%(Link.IgnoreAllDefaultLibraries)" IgnoreEmbeddedIDL="%(Link.IgnoreEmbeddedIDL)" IgnoreSpecificDefaultLibraries="%(Link.IgnoreSpecificDefaultLibraries)" ImageHasSafeExceptionHandlers="%(Link.ImageHasSafeExceptionHandlers)" ImportLibrary="%(Link.ImportLibrary)" IncrementalLinkDatabaseFile="%(Link.IncrementalLinkDatabaseFile)" KeyContainer="%(Link.KeyContainer)" KeyFile="$(LinkKeyFile)" LargeAddressAware="%(Link.LargeAddressAware)" LinkDLL="%(Link.LinkDLL)" LinkIncremental="$(LinkIncremental)" LinkStatus="%(Link.LinkStatus)" LinkTimeCodeGeneration="%(Link.LinkTimeCodeGeneration)" LinkTimeCodeGenerationObjectFile="%(Link.LinkTimeCodeGenerationObjectFile)" UseDynamicDebugging="%(Link.UseDynamicDebugging)" DynamicDebuggingSuffix="%(Link.DynamicDebuggingSuffix)" ManifestFile="%(Link.ManifestFile)" ManifestEmbed="%(Link.ManifestEmbed)" ManifestInput="%(Link.ManifestInput)" MapExports="%(Link.MapExports)" MapFileName="%(Link.MapFileName)" MergedIDLBaseFileName="%(Link.MergedIDLBaseFileName)" MergeSections="%(Link.MergeSections)" MidlCommandFile="%(Link.MidlCommandFile)" MinimumRequiredVersion="%(Link.MinimumRequiredVersion)" ModuleDefinitionFile="%(Link.ModuleDefinitionFile)" MSDOSStubFileName="%(Link.MSDOSStubFileName)" Natvis="@(Natvis)" OptimizeReferences="%(Link.OptimizeReferences)" OutputFile="%(Link.OutputFile)" PreventDllBinding="%(Link.PreventDllBinding)" Profile="%(Link.Profile)" ProfileGuidedDatabase="%(Link.ProfileGuidedDatabase)" ProgramDatabaseFile="%(Link.ProgramDatabaseFile)" RandomizedBaseAddress="%(Link.RandomizedBaseAddress)" NoEntryPoint="%(Link.NoEntryPoint)" SectionAlignment="%(Link.SectionAlignment)" SetChecksum="%(Link.SetChecksum)" ShowProgress="%(Link.ShowProgress)" SignHash="%(Link.SignHash)" SpecifySectionAttributes="%(Link.SpecifySectionAttributes)" StackCommitSize="%(Link.StackCommitSize)" StackReserveSize="%(Link.StackReserveSize)" StripPrivateSymbols="%(Link.StripPrivateSymbols)" SubSystem="%(Link.SubSystem)" SupportUnloadOfDelayLoadedDLL="%(Link.SupportUnloadOfDelayLoadedDLL)" SupportNobindOfDelayLoadedDLL="%(Link.SupportNobindOfDelayLoadedDLL)" SuppressStartupBanner="%(Link.SuppressStartupBanner)" SwapRunFromCD="%(Link.SwapRunFromCD)" SwapRunFromNET="%(Link.SwapRunFromNET)" TargetMachine="%(Link.TargetMachine)" TerminalServerAware="%(Link.TerminalServerAware)" TreatLinkerWarningAsErrors="%(Link.TreatLinkerWarningAsErrors)" TurnOffAssemblyGeneration="%(Link.TurnOffAssemblyGeneration)" TypeLibraryFile="%(Link.TypeLibraryFile)" TypeLibraryResourceID="%(Link.TypeLibraryResourceID)" UACExecutionLevel="%(Link.UACExecutionLevel)" UACUIAccess="%(Link.UACUIAccess)" Version="%(Link.Version)" WindowsMetadataLinkKeyFile="%(Link.WindowsMetadataLinkKeyFile)" WindowsMetadataKeyContainer="%(Link.WindowsMetadataKeyContainer)" WindowsMetadataLinkDelaySign="%(Link.WindowsMetadataLinkDelaySign)" WindowsMetadataSignHash="%(Link.WindowsMetadataSignHash)" TrackerLogDirectory="%(Link.TrackerLogDirectory)" ExcludedInputPaths="%(Link.ExcludedInputPaths)" TLogReadFiles="@(LinkTLogReadFiles)" TLogWriteFiles="@(LinkTLogWriteFiles)" ToolExe="$(LinkToolExe)" ToolPath="$(LinkToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="$(Link_MinimalRebuildFromTracking)" ToolArchitecture="$(LinkToolArchitecture)" TrackerFrameworkPath="$(LinkTrackerFrameworkPath)" TrackerSdkPath="$(LinkTrackerSdkPath)" TrackedInputFilesToIgnore="@(LinkNoDependencies)" TrackedOutputFilesToIgnore="@(LinkTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(Link.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(LinkYieldDuringToolExecution)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)" />
    <Message Text="$(MSBuildProjectFile) -&gt; $(TargetPath)" Importance="High" />
    <VCMessage Code="MSB8033" Type="Message" Arguments="$(MSBuildProjectFile);%(Link.ProgramDatabaseFile)" Importance="High" Condition="%(Link.GenerateDebugInformation) == 'DebugFastLink'" />
    <VCMessage Code="MSB8034" Type="Message" Arguments="$(MSBuildProjectFile);%(Link.ProgramDatabaseFile)" Importance="High" Condition="%(Link.GenerateDebugInformation) == 'true'" />
  </Target>
  <Target Name="CreateWinMD" Condition="'@(Link)' != '' and '$(GenerateBuildCompilePassWinMD)' == 'true' and '$(OnlyCreateWinMD)' == 'true'" DependsOnTargets="ComputeLinkSwitches">
    <PropertyGroup>
      <LinkToolArchitecture Condition="'$(LinkToolArchitecture)' == ''">$(VCToolArchitecture)</LinkToolArchitecture>
    </PropertyGroup>
    <ItemGroup>
      <Link>
        <ProfileGuidedDatabase Condition="'%(Link.LinkTimeCodeGeneration)' != 'PGOptimization' and&#xD;&#xA;                                          '%(Link.LinkTimeCodeGeneration)' != 'PGUpdate' and&#xD;&#xA;                                          '%(Link.LinkTimeCodeGeneration)' != 'PGInstrument'" />
        <!-- Generate full PDB. For now call link without /debug:fastlink. Later will'll call a special tool to create merge pdbs  -->
        <GenerateDebugInformation Condition="'%(Link.GenerateDebugInformation)' == 'DebugFastLink' and '%(Link.FullProgramDatabaseFile)' == 'true'">DebugFull</GenerateDebugInformation>
      </Link>
    </ItemGroup>
    <Link BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(Link)" AdditionalDependencies="%(Link.AdditionalDependencies)" AdditionalLibraryDirectories="%(Link.AdditionalLibraryDirectories)" AdditionalManifestDependencies="%(Link.AdditionalManifestDependencies)" AdditionalOptions="%(Link.AdditionalOptions)" AddModuleNamesToAssembly="%(Link.AddModuleNamesToAssembly)" AllowIsolation="%(Link.AllowIsolation)" AppContainer="%(Link.AppContainer)" AssemblyDebug="%(Link.AssemblyDebug)" AssemblyLinkResource="%(Link.AssemblyLinkResource)" BaseAddress="%(Link.BaseAddress)" CETCompat="%(Link.CETCompat)" ControlFlowGuard="$(LinkControlFlowGuard)" CLRImageType="%(Link.CLRImageType)" CLRSupportLastError="%(Link.CLRSupportLastError)" CLRThreadAttribute="%(Link.CLRThreadAttribute)" CLRUnmanagedCodeCheck="%(Link.CLRUnmanagedCodeCheck)" CreateHotPatchableImage="%(Link.CreateHotPatchableImage)" DataExecutionPrevention="%(Link.DataExecutionPrevention)" DelayLoadDLLs="%(Link.DelayLoadDLLs)" DelaySign="$(LinkDelaySign)" Driver="%(Link.Driver)" EmbedManagedResourceFile="@(_EmbedManagedResourceFile)" EnableCOMDATFolding="%(Link.EnableCOMDATFolding)" EnableUAC="%(Link.EnableUAC)" EntryPointSymbol="%(Link.EntryPointSymbol)" LinkErrorReporting="%(Link.LinkErrorReporting)" FixedBaseAddress="%(Link.FixedBaseAddress)" ForceFileOutput="%(Link.ForceFileOutput)" ForceSymbolReferences="%(Link.ForceSymbolReferences)" FunctionOrder="%(Link.FunctionOrder)" GenerateDebugInformation="%(Link.GenerateDebugInformation)" GenerateImportLib="$(GenerateImportLib)" GenerateManifest="$(GenerateManifest)" GenerateMapFile="%(Link.GenerateMapFile)" GenerateWindowsMetadata="Only" GuardEHContMetadata="$(LinkGuardEHContMetadata)" GuardSignedReturns="$(LinkGuardSignedReturns)" WindowsMetadataFile="%(Link.WindowsMetadataFile)" HeapCommitSize="%(Link.HeapCommitSize)" HeapReserveSize="%(Link.HeapReserveSize)" IgnoreAllDefaultLibraries="%(Link.IgnoreAllDefaultLibraries)" IgnoreEmbeddedIDL="%(Link.IgnoreEmbeddedIDL)" IgnoreSpecificDefaultLibraries="%(Link.IgnoreSpecificDefaultLibraries)" ImageHasSafeExceptionHandlers="%(Link.ImageHasSafeExceptionHandlers)" ImportLibrary="%(Link.ImportLibrary)" IncrementalLinkDatabaseFile="%(Link.IncrementalLinkDatabaseFile)" KeyContainer="%(Link.KeyContainer)" KeyFile="$(LinkKeyFile)" LargeAddressAware="%(Link.LargeAddressAware)" LinkDLL="%(Link.LinkDLL)" LinkIncremental="$(LinkIncremental)" LinkStatus="%(Link.LinkStatus)" LinkTimeCodeGeneration="%(Link.LinkTimeCodeGeneration)" LinkTimeCodeGenerationObjectFile="%(Link.LinkTimeCodeGenerationObjectFile)" UseDynamicDebugging="%(Link.UseDynamicDebugging)" DynamicDebuggingSuffix="%(Link.DynamicDebuggingSuffix)" ManifestFile="%(Link.ManifestFile)" ManifestEmbed="%(Link.ManifestEmbed)" ManifestInput="%(Link.ManifestInput)" MapExports="%(Link.MapExports)" MapFileName="%(Link.MapFileName)" MergedIDLBaseFileName="%(Link.MergedIDLBaseFileName)" MergeSections="%(Link.MergeSections)" MidlCommandFile="%(Link.MidlCommandFile)" MinimumRequiredVersion="%(Link.MinimumRequiredVersion)" ModuleDefinitionFile="%(Link.ModuleDefinitionFile)" MSDOSStubFileName="%(Link.MSDOSStubFileName)" Natvis="@(Natvis)" OptimizeReferences="%(Link.OptimizeReferences)" OutputFile="%(Link.OutputFile)" PreventDllBinding="%(Link.PreventDllBinding)" Profile="%(Link.Profile)" ProfileGuidedDatabase="%(Link.ProfileGuidedDatabase)" ProgramDatabaseFile="%(Link.ProgramDatabaseFile)" RandomizedBaseAddress="%(Link.RandomizedBaseAddress)" NoEntryPoint="%(Link.NoEntryPoint)" SectionAlignment="%(Link.SectionAlignment)" SetChecksum="%(Link.SetChecksum)" ShowProgress="%(Link.ShowProgress)" SignHash="%(Link.SignHash)" SpecifySectionAttributes="%(Link.SpecifySectionAttributes)" StackCommitSize="%(Link.StackCommitSize)" StackReserveSize="%(Link.StackReserveSize)" StripPrivateSymbols="%(Link.StripPrivateSymbols)" SubSystem="%(Link.SubSystem)" SupportUnloadOfDelayLoadedDLL="%(Link.SupportUnloadOfDelayLoadedDLL)" SupportNobindOfDelayLoadedDLL="%(Link.SupportNobindOfDelayLoadedDLL)" SuppressStartupBanner="%(Link.SuppressStartupBanner)" SwapRunFromCD="%(Link.SwapRunFromCD)" SwapRunFromNET="%(Link.SwapRunFromNET)" TargetMachine="%(Link.TargetMachine)" TerminalServerAware="%(Link.TerminalServerAware)" TreatLinkerWarningAsErrors="%(Link.TreatLinkerWarningAsErrors)" TurnOffAssemblyGeneration="%(Link.TurnOffAssemblyGeneration)" TypeLibraryFile="%(Link.TypeLibraryFile)" TypeLibraryResourceID="%(Link.TypeLibraryResourceID)" UACExecutionLevel="%(Link.UACExecutionLevel)" UACUIAccess="%(Link.UACUIAccess)" Version="%(Link.Version)" WindowsMetadataLinkKeyFile="%(Link.WindowsMetadataLinkKeyFile)" WindowsMetadataKeyContainer="%(Link.WindowsMetadataKeyContainer)" WindowsMetadataLinkDelaySign="%(Link.WindowsMetadataLinkDelaySign)" WindowsMetadataSignHash="%(Link.WindowsMetadataSignHash)" TrackerLogDirectory="%(Link.TrackerLogDirectory)" ExcludedInputPaths="%(Link.ExcludedInputPaths)" TLogReadFiles="@(LinkTLogReadFiles)" TLogWriteFiles="@(LinkTLogWriteFiles)" ToolExe="$(LinkToolExe)" ToolPath="$(LinkToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="$(Link_MinimalRebuildFromTracking)" ToolArchitecture="$(LinkToolArchitecture)" TrackerFrameworkPath="$(LinkTrackerFrameworkPath)" TrackerSdkPath="$(LinkTrackerSdkPath)" TrackedInputFilesToIgnore="@(LinkNoDependencies)" TrackedOutputFilesToIgnore="@(LinkTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(Link.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(LinkYieldDuringToolExecution)" UseMsbuildResourceManager="$(UseMsbuildResourceManager)" />
    <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
  </Target>
  <Target Name="CreateFullDebugSymbols" DependsOnTargets="DebugSymbolsProjectOutputGroup">
    <VCMessage Code="MSB8035" Type="Message" Arguments="$(MSBuildProjectFile);%(DebugSymbolsProjectOutputGroupOutput.FullPath)" Importance="High" Condition="$(ConfigurationType) != 'StaticLibrary'" />
    <VCMessage Code="MSB8039" Type="Message" Importance="High" Condition="$(ConfigurationType) == 'StaticLibrary'" />
    <!-- Calling target DebugSymbolsProjectOutputGroup to get the pdb path -->
    <!-- mspdbcmd returns error if it is already a full pdb. -->
    <Exec Command="mspdbcmf.exe /nologo &quot;%(DebugSymbolsProjectOutputGroupOutput.FullPath)&quot;" IgnoreExitCode="true" Condition="$(ConfigurationType) != 'StaticLibrary'" />
  </Target>
  <!-- *******************************************************************************************
        Lib
       ******************************************************************************************* -->
  <Target Name="Lib" Condition="'@(Lib)' != ''">
    <ItemGroup>
      <!--These objects are removed because lib.exe can only remove objects from an existing lib. -->
      <Lib Remove="%(Lib.RemoveObjects)" Condition="'%(Lib.RemoveObjects)' != ''" />
      <Lib>
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </Lib>
    </ItemGroup>
    <PropertyGroup>
      <LibToolArchitecture Condition="'$(LibToolArchitecture)' == ''">$(VCToolArchitecture)</LibToolArchitecture>
    </PropertyGroup>
    <LIB Sources="@(Lib)" BuildingInIDE="$(BuildingInsideVisualStudio)" AdditionalDependencies="%(Lib.AdditionalDependencies)" AdditionalLibraryDirectories="%(Lib.AdditionalLibraryDirectories)" AdditionalOptions="$(LibAdditionalOptions)" DisplayLibrary="%(Lib.DisplayLibrary)" DynamicDebuggingSuffix="%(Lib.DynamicDebuggingSuffix)" ErrorReporting="%(Lib.LinkErrorReporting)" ExportNamedFunctions="%(Lib.ExportNamedFunctions)" ForceSymbolReferences="%(Lib.ForceSymbolReferences)" IgnoreAllDefaultLibraries="%(Lib.IgnoreAllDefaultLibraries)" IgnoreSpecificDefaultLibraries="%(Lib.IgnoreSpecificDefaultLibraries)" LinkTimeCodeGeneration="%(Lib.LinkTimeCodeGeneration)" ModuleDefinitionFile="%(Lib.ModuleDefinitionFile)" Name="%(Lib.Name)" OutputFile="%(Lib.OutputFile)" SubSystem="%(Lib.SubSystem)" SuppressStartupBanner="%(Lib.SuppressStartupBanner)" TargetMachine="%(Lib.TargetMachine)" TreatLibWarningAsErrors="%(Lib.TreatLibWarningAsErrors)" Verbose="%(Lib.Verbose)" TrackerLogDirectory="%(Lib.TrackerLogDirectory)" ExcludedInputPaths="%(Lib.ExcludedInputPaths)" TLogReadFiles="@(LIBTLogReadFiles)" TLogWriteFiles="@(LIBTLogWriteFiles)" ToolExe="$(LIBToolExe)" ToolPath="$(LIBToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(Lib.MinimalRebuildFromTracking)" ToolArchitecture="$(LibToolArchitecture)" TrackerFrameworkPath="$(LibTrackerFrameworkPath)" TrackerSdkPath="$(LibTrackerSdkPath)" TrackedInputFilesToIgnore="@(LibNoDependencies)" TrackedOutputFilesToIgnore="@(LibTrackedOutputFilesToIgnore)" UseDynamicDebugging="%(Lib.UseDynamicDebugging)" AcceptableNonZeroExitCodes="%(Lib.AcceptableNonZeroExitCodes)" />
    <!-- make sure lib's pdb is near the lib -->
    <PropertyGroup>
      <_BuiltPdb Condition="'%(ClCompile.ProgramDatabaseFileName)' != ''">$([MSBuild]::NormalizePath('$(ProjectDir)','%(ClCompile.ProgramDatabaseFileName)'))</_BuiltPdb>
      <_LibPdb>$([MSBuild]::NormalizePath('$(ProjectDir)','$(OutDir)$(TargetName).pdb'))</_LibPdb>
    </PropertyGroup>
    <Copy Condition="'$(_BuiltPdb)' != '' and&#xD;&#xA;                     '$(_BuiltPdb)' != '$(_LibPdb)' and&#xD;&#xA;                     ('%(ClCompile.DebugInformationFormat)' == 'ProgramDatabase' or '%(ClCompile.DebugInformationFormat)' == 'EditAndContinue') and&#xD;&#xA;                     Exists($(_BuiltPdb))" SourceFiles="$(_BuiltPdb)" DestinationFiles="$(_LibPdb)" />
    <Message Text="$(MSBuildProjectFile) -&gt; $(TargetPath)" Importance="High" />
  </Target>
  <Target Name="ImpLib" Condition="'@(ImpLib)' != '' and '$(IgnoreImportLibrary)' != 'true' and '$(GenerateImportLib)' == 'true'">
    <ItemGroup>
      <ImpLib>
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </ImpLib>
      <!-- Create a temp link variable to extract metadata from Link. -->
      <Link Include="__Temp__" />
    </ItemGroup>
    <PropertyGroup>
      <LibUseEmptyDef Condition="'%(ImpLib.ModuleDefinitionFile)' == ''">/DEF:</LibUseEmptyDef>
      <LibToolArchitecture Condition="'$(LibToolArchitecture)' == ''">$(VCToolArchitecture)</LibToolArchitecture>
      <!-- Use the output library name from Link -->
      <LinkImportLibrary>%(Link.ImportLibrary)</LinkImportLibrary>
    </PropertyGroup>
    <ItemGroup>
      <ImpLib>
        <OutputFile Condition="'%(ImpLib.OutputFile)' == ''">$(LinkImportLibrary)</OutputFile>
      </ImpLib>
    </ItemGroup>
    <ItemGroup>
      <Link Remove="__Temp__" />
    </ItemGroup>
    <LIB Sources="@(ImpLib)" BuildingInIDE="$(BuildingInsideVisualStudio)" AdditionalDependencies="%(ImpLib.AdditionalDependencies)" AdditionalLibraryDirectories="%(ImpLib.AdditionalLibraryDirectories)" AdditionalOptions="$(ImpLibAdditionalOptions) $(LibUseEmptyDef)" DisplayLibrary="%(ImpLib.DisplayLibrary)" DynamicDebuggingSuffix="%(ImpLib.DynamicDebuggingSuffix)" ErrorReporting="%(ImpLib.LinkErrorReporting)" ExportNamedFunctions="%(ImpLib.ExportNamedFunctions)" ForceSymbolReferences="%(ImpLib.ForceSymbolReferences)" IgnoreAllDefaultLibraries="%(ImpLib.IgnoreAllDefaultLibraries)" IgnoreSpecificDefaultLibraries="%(ImpLib.IgnoreSpecificDefaultLibraries)" LinkTimeCodeGeneration="%(ImpLib.LinkTimeCodeGeneration)" ModuleDefinitionFile="%(ImpLib.ModuleDefinitionFile)" Name="%(ImpLib.Name)" OutputFile="%(ImpLib.OutputFile)" SubSystem="%(ImpLib.SubSystem)" SuppressStartupBanner="%(ImpLib.SuppressStartupBanner)" TargetMachine="%(ImpLib.TargetMachine)" TreatLibWarningAsErrors="%(ImpLib.TreatLibWarningAsErrors)" Verbose="%(ImpLib.Verbose)" TrackerLogDirectory="%(ImpLib.TrackerLogDirectory)" ExcludedInputPaths="%(ImpLib.ExcludedInputPaths)" TLogReadFiles="@(LIBTLogReadFiles)" TLogWriteFiles="@(LIBTLogWriteFiles)" ToolExe="$(LIBToolExe)" ToolPath="$(LIBToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(ImpLib.MinimalRebuildFromTracking)" ToolArchitecture="$(LibToolArchitecture)" TrackerFrameworkPath="$(LibTrackerFrameworkPath)" TrackerSdkPath="$(LibTrackerSdkPath)" TrackedInputFilesToIgnore="@(LibNoDependencies)" TrackedOutputFilesToIgnore="@(LibTrackedOutputFilesToIgnore)" UseDynamicDebugging="%(ImpLib.UseDynamicDebugging)" AcceptableNonZeroExitCodes="%(ImpLib.AcceptableNonZeroExitCodes)" />
  </Target>
  <!-- *******************************************************************************************
        FXC
       ******************************************************************************************* -->
  <PropertyGroup Condition="'$(FxCompileBeforeTargets)' == '' and '$(FxCompileAfterTargets)' == '' and '$(ConfigurationType)' != 'Makefile'">
    <FxCompileBeforeTargets>Midl</FxCompileBeforeTargets>
    <FxCompileAfterTargets>CustomBuild</FxCompileAfterTargets>
  </PropertyGroup>
  <Target Name="FxExport" BeforeTargets="$(FxCompileBeforeTargets)" AfterTargets="$(FxCompileAfterTargets)" Condition="'@(FxCompile)' != ''" DependsOnTargets="_SelectedFiles;MakeDirsForFxc">
    <ItemGroup Condition="'@(SelectedFiles)' != ''">
      <FxCompile Remove="@(FxCompile)" Condition="'%(Identity)' != '@(SelectedFiles)'" />
    </ItemGroup>
    <ItemGroup>
      <FxCompile Condition="'@(FxCompile)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
      </FxCompile>
    </ItemGroup>
    <ItemGroup>
      <FxCompile Condition="'%(FxCompile.CompileD2DCustomEffect)'=='true'">
        <OriginalPreprocessorDefinitions>%(FxCompile.PreprocessorDefinitions)</OriginalPreprocessorDefinitions>
        <PreprocessorDefinitions>D2D_FUNCTION;D2D_ENTRY=%(FxCompile.EntryPointName);%(FxCompile.OriginalPreprocessorDefinitions)</PreprocessorDefinitions>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
        <D2DCustomEffectExportFile Condition="'%(FxCompile.CompileD2DCustomEffect)'=='true'">$(OutDir)%(FxCompile.Filename).fxlib</D2DCustomEffectExportFile>
      </FxCompile>
    </ItemGroup>
    <PropertyGroup>
      <FxCompileToolArchitecture Condition="'$(FxCompileToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</FxCompileToolArchitecture>
    </PropertyGroup>
    <FXC Condition="'@(FxCompile)' != '' and '%(FxCompile.ExcludedFromBuild)'!='true' and '%(FxCompile.CompileD2DCustomEffect)'=='true'" Source="%(FxCompile.Identity)" ToolPath="$(FXCToolPath)" AdditionalIncludeDirectories="%(FxCompile.AdditionalIncludeDirectories)" SuppressStartupBanner="%(FxCompile.SuppressStartupBanner)" TreatWarningAsError="%(FxCompile.TreatWarningAsError)" PreprocessorDefinitions="%(FxCompile.PreprocessorDefinitions)" AdditionalOptions="%(FxCompile.AdditionalOptions)" DisableOptimizations="%(FxCompile.DisableOptimizations)" EnableDebuggingInformation="%(FxCompile.EnableDebuggingInformation)" GenerateExportFile="%(FxCompile.D2DCustomEffectExportFile)" GenerateExportShaderProfile="%(FxCompile.ShaderType);%(FxCompile.ShaderModel)" ExcludedInputPaths="%(FxCompile.ExcludedInputPaths)" ToolArchitecture="$(FxCompileToolArchitecture)" TrackerLogDirectory="%(FxCompile.TrackerLogDirectory)" TrackedInputFilesToIgnore="@(FxCompileNoDependencies)" TrackedOutputFilesToIgnore="@(FxTrackedOutputFilesToIgnore)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(FxCompile.MinimalRebuildFromTracking)" />
  </Target>
  <Target Name="FxCompile" BeforeTargets="$(FxCompileBeforeTargets)" AfterTargets="$(FxCompileAfterTargets)" Condition="'@(FxCompile)' != ''" DependsOnTargets="_SelectedFiles;MakeDirsForFxc;FxExport">
    <ItemGroup Condition="'@(SelectedFiles)' != ''">
      <FxCompile Remove="@(FxCompile)" Condition="'%(Identity)' != '@(SelectedFiles)'" />
    </ItemGroup>
    <ItemGroup>
      <FxCompile Condition="'@(FxCompile)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
      </FxCompile>
    </ItemGroup>
    <PropertyGroup>
      <FxCompileToolArchitecture Condition="'$(FxCompileToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</FxCompileToolArchitecture>
      <D2DCustomEffectExportFile Condition="'%(FxCompile.CompileD2DCustomEffect)'=='true'">$(OutDir)%(FxCompile.Filename).fxlib</D2DCustomEffectExportFile>
      <MultiProcFXC Condition="'$(UseMultiToolTask)' == 'true'">true</MultiProcFXC>
      <ToolTaskCount Condition="'$(UseMultiToolTask)' == 'true'">$(CL_MPCount)</ToolTaskCount>
    </PropertyGroup>
    <ItemGroup>
      <FxCompile Condition="'%(FxCompile.CompileD2DCustomEffect)'=='true'">
        <PreprocessorDefinitions>D2D_FULL_SHADER;D2D_ENTRY=%(FxCompile.EntryPointName);%(FxCompile.OriginalPreprocessorDefinitions)</PreprocessorDefinitions>
      </FxCompile>
      <FxCompile>
        <ConsumeExportFile>$(D2DCustomEffectExportFile)</ConsumeExportFile>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </FxCompile>
    </ItemGroup>
    <ItemGroup Condition="'@(FxTrackedOutputFilesToIgnore)' == ''">
      <FxTrackedOutputFilesToIgnore Include="@(FxCompileNoDependencies)" />
    </ItemGroup>
    <MultiToolTask Condition="'%(FxCompile.ExcludedFromBuild)'!='true' and '$(MultiProcFXC)' == 'true'" TaskName="Microsoft.Build.FXCTask.FXC" Sources="@(FxCompile)" TrackerLogDirectory="$(TLogLocation)" ToolArchitecture="$(FxCompileToolArchitecture)" TrackerFrameworkPath="$(FxCompileTrackerFrameworkPath)" TrackerSdkPath="$(FxCompileTrackerSdkPath)" TLogReadFiles="@(FxCompileTLogReadFiles)" TLogWriteFiles="@(FxCompileTLogWriteFiles)" ToolExe="$(FxCompileToolExe)" ToolPath="$(FXCToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(FxCompileNoDependencies)" TrackedOutputFilesToIgnore="@(FxTrackedOutputFilesToIgnore)" YieldDuringToolExecution="$(FxCompileYieldDuringToolExecution)" MaxProcessCount="$(MultiProcMaxCount)" EnforceProcessCountAcrossBuilds="$(EnforceProcessCountAcrossBuilds)" SchedulerName="$(MultiProcSchedulerName)" />
    <FXC Condition="'@(FxCompile)' != '' and '%(FxCompile.ExcludedFromBuild)'!='true' and '$(MultiProcFXC)' != 'true'" Source="%(FxCompile.Identity)" ToolPath="$(FXCToolPath)" AdditionalIncludeDirectories="%(FxCompile.AdditionalIncludeDirectories)" SuppressStartupBanner="%(FxCompile.SuppressStartupBanner)" EntryPointName="%(FxCompile.EntryPointName)" TreatWarningAsError="%(FxCompile.TreatWarningAsError)" ShaderType="%(FxCompile.ShaderType)" ShaderModel="%(FxCompile.ShaderModel)" AllResourcesBound="%(FxCompile.AllResourcesBound)" EnableUnboundedDescriptorTables="%(FxCompile.EnableUnboundedDescriptorTables)" SetRootSignature="%(FxCompile.SetRootSignature)" PreprocessorDefinitions="%(FxCompile.PreprocessorDefinitions)" HeaderFileOutput="%(FxCompile.HeaderFileOutput)" ObjectFileOutput="%(FxCompile.ObjectFileOutput)" AssemblerOutput="%(FxCompile.AssemblerOutput)" AssemblerOutputFile="%(FxCompile.AssemblerOutputFile)" VariableName="%(FxCompile.VariableName)" AdditionalOptions="%(FxCompile.AdditionalOptions)" DisableOptimizations="%(FxCompile.DisableOptimizations)" EnableDebuggingInformation="%(FxCompile.EnableDebuggingInformation)" ConsumeExportFile="%(FxCompile.ConsumeExportFile)" ExcludedInputPaths="%(FxCompile.ExcludedInputPaths)" ToolArchitecture="$(FxCompileToolArchitecture)" TrackerLogDirectory="%(FxCompile.TrackerLogDirectory)" TrackedInputFilesToIgnore="@(FxCompileNoDependencies)" TrackedOutputFilesToIgnore="@(FxTrackedOutputFilesToIgnore)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(FxCompile.MinimalRebuildFromTracking)" />
  </Target>
  <!-- *******************************************************************************************
        MIDL
       ******************************************************************************************* -->
  <Target Name="Midl" Condition="'@(Midl)' != ''" DependsOnTargets="SelectMidl">
    <ItemGroup>
      <Midl Condition="'@(Midl)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </Midl>
    </ItemGroup>
    <PropertyGroup>
      <MidlToolArchitecture Condition="'$(MidlToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</MidlToolArchitecture>
      <MultiProcMIDL Condition="'$(UseMultiToolTask)' == 'true'">true</MultiProcMIDL>
      <ToolTaskCount Condition="'$(UseMultiToolTask)' == 'true'">$(CL_MPCount)</ToolTaskCount>
    </PropertyGroup>
    <ItemGroup>
      <MidlNoDependencies Condition="'@(MidlNoDependencies)' == '' and '%(ClInclude.NoDependency)' == 'true'" Include="@(ClInclude)" />
      <MidlNoDependencies Condition="'$(NoDependencies)' != ''" Include="$(NoDependencies)" />
      <MidlNoDependencies Condition="'%(Midl.DllDataFileName)' != '' and '%(Midl.OutputDirectory)' != ''" Include="$([System.IO.Path]::Combine($(MSBuildProjectDirectory), %(Midl.OutputDirectory), %(Midl.DllDataFileName)))" />
      <MidlNoDependencies Condition="'%(Midl.DllDataFileName)' == '' and '%(Midl.OutputDirectory)' != ''" Include="$([System.IO.Path]::Combine($(MSBuildProjectDirectory), %(Midl.OutputDirectory), dlldata.c))" />
      <MidlNoDependencies Condition="'%(Midl.DllDataFileName)' == '' and '%(Midl.OutputDirectory)' == ''" Include="$([System.IO.Path]::Combine($(MSBuildProjectDirectory), dlldata.c))" />
    </ItemGroup>
    <ItemGroup Condition="'@(MidlTrackedOutputFilesToIgnore)' == ''">
      <MidlTrackedOutputFilesToIgnore Include="@(MidlNoDependencies)" />
    </ItemGroup>
    <MultiToolTask Condition="'%(Midl.ExcludedFromBuild)'!='true' and '$(MultiProcMIDL)' == 'true'" TaskName="Microsoft.Build.CPPTasks.MIDL" Sources="@(Midl)" TrackerLogDirectory="$(TLogLocation)" ToolArchitecture="$(MidlToolArchitecture)" TrackerFrameworkPath="$(MidlTrackerFrameworkPath)" TrackerSdkPath="$(MidlTrackerSdkPath)" TLogReadFiles="@(MIDLTLogReadFiles)" TLogWriteFiles="@(MIDLTLogWriteFiles)" ToolExe="$(MIDLToolExe)" ToolPath="$(MIDLToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(MidlNoDependencies)" TrackedOutputFilesToIgnore="@(MidlTrackedOutputFilesToIgnore)" YieldDuringToolExecution="$(MidlYieldDuringToolExecution)" MaxProcessCount="$(MultiProcMaxCount)" EnforceProcessCountAcrossBuilds="$(EnforceProcessCountAcrossBuilds)" SchedulerName="$(MultiProcSchedulerName)" />
    <MIDL Condition="'%(Midl.ExcludedFromBuild)'!='true' and '$(MultiProcMIDL)' != 'true'" Source="%(Midl.Identity)" AdditionalIncludeDirectories="%(Midl.AdditionalIncludeDirectories)" AdditionalMetadataDirectories="%(Midl.AdditionalMetadataDirectories)" AdditionalOptions="%(Midl.AdditionalOptions)" ApplicationConfigurationMode="%(Midl.ApplicationConfigurationMode)" ClientStubFile="%(Midl.ClientStubFile)" CPreprocessOptions="%(Midl.CPreprocessOptions)" DefaultCharType="%(Midl.DefaultCharType)" DllDataFileName="%(Midl.DllDataFileName)" EnableErrorChecks="%(Midl.EnableErrorChecks)" EnableWindowsRuntime="%(Midl.EnableWindowsRuntime)" Enumclass="%(Midl.Enumclass)" ErrorCheckAllocations="%(Midl.ErrorCheckAllocations)" ErrorCheckBounds="%(Midl.ErrorCheckBounds)" ErrorCheckEnumRange="%(Midl.ErrorCheckEnumRange)" ErrorCheckRefPointers="%(Midl.ErrorCheckRefPointers)" ErrorCheckStubData="%(Midl.ErrorCheckStubData)" GenerateClientFiles="%(Midl.GenerateClientFiles)" GenerateServerFiles="%(Midl.GenerateServerFiles)" GenerateStublessProxies="%(Midl.GenerateStublessProxies)" GenerateTypeLibrary="%(Midl.GenerateTypeLibrary)" HeaderFileName="%(Midl.HeaderFileName)" IgnoreStandardIncludePath="%(Midl.IgnoreStandardIncludePath)" InterfaceIdentifierFileName="%(Midl.InterfaceIdentifierFileName)" LocaleID="%(Midl.LocaleID)" MkTypLibCompatible="%(Midl.MkTypLibCompatible)" MetadataFileName="%(Midl.MetadataFileName)" MinimumTargetSystem="%(Midl.MinimumTargetSystem)" OutputDirectory="%(Midl.OutputDirectory)" PrependWithABINamepsace="%(Midl.PrependWithABINamepsace)" PreprocessorDefinitions="%(Midl.PreprocessorDefinitions)" ProxyFileName="%(Midl.ProxyFileName)" RedirectOutputAndErrors="%(Midl.RedirectOutputAndErrors)" ServerStubFile="%(Midl.ServerStubFile)" StructMemberAlignment="%(Midl.StructMemberAlignment)" SuppressCompilerWarnings="%(Midl.SuppressCompilerWarnings)" SuppressStartupBanner="%(Midl.SuppressStartupBanner)" TargetEnvironment="%(Midl.TargetEnvironment)" TypeLibFormat="%(Midl.TypeLibFormat)" TypeLibraryName="%(Midl.TypeLibraryName)" UndefinePreprocessorDefinitions="%(Midl.UndefinePreprocessorDefinitions)" UseResponseFile="%(Midl.UseResponseFile)" ValidateAllParameters="%(Midl.ValidateAllParameters)" WarnAsError="%(Midl.WarnAsError)" WarningLevel="%(Midl.WarningLevel)" TrackerLogDirectory="%(Midl.TrackerLogDirectory)" MinimalRebuildFromTracking="%(Midl.MinimalRebuildFromTracking)" ToolArchitecture="$(MidlToolArchitecture)" TrackerFrameworkPath="$(MidlTrackerFrameworkPath)" TrackerSdkPath="$(MidlTrackerSdkPath)" TrackedInputFilesToIgnore="@(MidlNoDependencies)" TrackedOutputFilesToIgnore="@(MidlTrackedOutputFilesToIgnore)" ExcludedInputPaths="%(Midl.ExcludedInputPaths)" TLogReadFiles="@(MIDLTLogReadFiles)" TLogWriteFiles="@(MIDLTLogWriteFiles)" ToolExe="$(MIDLToolExe)" ToolPath="$(MIDLToolPath)" TrackFileAccess="$(TrackFileAccess)" AcceptableNonZeroExitCodes="%(Midl.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(MidlYieldDuringToolExecution)" />
  </Target>
  <!-- *******************************************************************************************
        ResourceCompile
       ******************************************************************************************* -->
  <Target Name="ResourceCompile" Condition="'@(ResourceCompile)' != ''" DependsOnTargets="SelectResourceCompile">
    <ItemGroup>
      <ResourceCompile Condition="'@(ResourceCompile)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </ResourceCompile>
    </ItemGroup>
    <PropertyGroup>
      <RCToolArchitecture Condition="'$(RCToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</RCToolArchitecture>
    </PropertyGroup>
    <ItemGroup>
      <RCNoDependencies Condition="'@(RCNoDependencies)' == '' and '%(ClInclude.NoDependency)' == 'true'" Include="@(ClInclude)" />
      <RCNoDependencies Condition="'@(NoDependencies)' != ''" Include="@(NoDependencies)" />
    </ItemGroup>
    <RC Condition="'%(ResourceCompile.ExcludedFromBuild)'!='true'" Source="%(ResourceCompile.Identity)" AdditionalIncludeDirectories="%(ResourceCompile.AdditionalIncludeDirectories)" AdditionalOptions="%(ResourceCompile.AdditionalOptions)" Culture="%(ResourceCompile.Culture)" IgnoreStandardIncludePath="%(ResourceCompile.IgnoreStandardIncludePath)" NullTerminateStrings="%(ResourceCompile.NullTerminateStrings)" PreprocessorDefinitions="%(ResourceCompile.PreprocessorDefinitions)" ResourceOutputFileName="%(ResourceCompile.ResourceOutputFileName)" SuppressStartupBanner="%(ResourceCompile.SuppressStartupBanner)" ShowProgress="%(ResourceCompile.ShowProgress)" UndefinePreprocessorDefinitions="%(ResourceCompile.UndefinePreprocessorDefinitions)" UseResponseFile="%(ResourceCompile.UseResponseFile)" TrackerLogDirectory="%(ResourceCompile.TrackerLogDirectory)" MinimalRebuildFromTracking="%(ResourceCompile.MinimalRebuildFromTracking)" ToolArchitecture="$(RCToolArchitecture)" TrackerFrameworkPath="$(RCTrackerFrameworkPath)" TrackerSdkPath="$(RCTrackerSdkPath)" TrackedInputFilesToIgnore="@(RCNoDependencies)" TrackedOutputFilesToIgnore="@(RCTrackedOutputFilesToIgnore)" ExcludedInputPaths="%(ResourceCompile.ExcludedInputPaths)" TLogReadFiles="@(RCTLogReadFiles)" TLogWriteFiles="@(RCTLogWriteFiles)" ToolExe="$(RCToolExe)" ToolPath="$(RCToolPath)" TrackFileAccess="$(TrackFileAccess)" AcceptableNonZeroExitCodes="%(ResourceCompile.AcceptableNonZeroExitCodes)" />
  </Target>
  <!-- *******************************************************************************************
        Managed Resource Compile
       ******************************************************************************************* -->
  <Target Name="BeforeResGen" DependsOnTargets="CreateManifestResourceNames" />
  <Target Name="ResGen" DependsOnTargets="$(ResGenDependsOn)" />
  <Target Name="_ResGen" DependsOnTargets="ResGen" Condition="'@(EmbeddedResource)'!=''" />
  <PropertyGroup>
    <CreateManifestResourceNamesDependsOn />
    <!-- CopyFilesToOutputDirectory target will copy the managed files to the output directory.
         This flag will skip the primary output. -->
    <SkipCopyBuildProduct>true</SkipCopyBuildProduct>
    <BuildingProject>true</BuildingProject>
  </PropertyGroup>
  <Target Name="CreateManifestResourceNames" Condition="'@(EmbeddedResource)' != ''" DependsOnTargets="$(CreateManifestResourceNamesDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" Condition="'%(EmbeddedResource.ExcludedFromBuild)' != 'true' and '%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <!-- Create manifest names for all culture non-resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" PrependCultureAsDirectory="false" Condition="'%(EmbeddedResource.ExcludedFromBuild)' != 'true' and '%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <ItemGroup>
      <EmbeddedResource Remove="@(EmbeddedResource)" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' " />
      <EmbeddedResource Include="@(_Temporary)" />
    </ItemGroup>
    <!-- create tlogs, but don't use the out if date items as all embedded resources should be passed to common msbuild targets-->
    <ItemGroup>
      <_Temporary Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.ManifestResourceName)' != '' " />
      <_Temporary>
        <OutputFile>$(TargetPath)</OutputFile>
        <AdditionalInputs>$(ProjectPath)</AdditionalInputs>
      </_Temporary>
    </ItemGroup>
    <GetOutOfDateItems Condition="'$(SelectedFiles)' == ''" Sources="@(_Temporary)" OutputsMetadataName="OutputFile" DependenciesMetadataName="AdditionalInputs" CommandMetadataName="AdditionalInputs" TLogDirectory="$(TLogLocation)" TLogNamePrefix="ResGen" TrackFileAccess="$(TrackFileAccess)">
      <Output TaskParameter="OutOfDateSources" ItemName="_OutOfDateEmbeddedResource" />
    </GetOutOfDateItems>
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
      <_OutOfDateEmbeddedResource Remove="@(_OutOfDateEmbeddedResource)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSatelliteAssemblies

    al.exe to create the satellite assemblies into the OutDir.
    ============================================================
    -->
  <Target Name="GenerateSatelliteAssemblies" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(OutDir)$(TargetName)$(TargetExt)" Outputs="$(OutDir)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != ''">
    <MakeDir Directories="@(EmbeddedResource->'$(OutDir)%(Culture)')" />
    <AL AlgorithmId="$(Satellite_AlgorithmId)" BaseAddress="$(Satellite_BaseAddress)" CompanyName="$(Satellite_CompanyName)" Configuration="$(Satellite_Configuration)" Copyright="$(Satellite_Copyright)" Culture="%(Culture)" DelaySign="$(DelaySign)" Description="$(Satellite_Description)" EmbedResources="@(_SatelliteAssemblyResourceInputs)" EnvironmentVariables="$(AlEnvironment)" EvidenceFile="$(Satellite_EvidenceFile)" FileVersion="$(Satellite_FileVersion)" Flags="$(Satellite_Flags)" GenerateFullPaths="$(Satellite_GenerateFullPaths)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LinkResources="@(Satellite_LinkResource)" MainEntryPoint="$(Satellite_MainEntryPoint)" OutputAssembly="$(OutDir)%(Culture)\$(TargetName).resources.dll" Platform="$(PlatformTarget)" ProductName="$(Satellite_ProductName)" ProductVersion="$(Satellite_ProductVersion)" ResponseFiles="@(AlResponseFile)" SourceModules="@(Satellite_SourceModule)" TargetType="$(Satellite_TargetType)" TemplateFile="$(OutDir)$(TargetName)$(TargetExt)" Title="$(Satellite_Title)" ToolPath="$(AlToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" Trademark="$(Satellite_Trademark)" Version="$(Satellite_Version)" Win32Icon="$(Satellite_Win32Icon)" Win32Resource="$(Satellite_Win32Resource)">
      <Output TaskParameter="OutputAssembly" ItemName="GenerateSatelliteAssembliesOutputs" />
    </AL>
    <WriteLinesToFile File="$(TLogLocation)$(ProjectName).write.1u.tlog" Lines="^$(ProjectPath);@(GenerateSatelliteAssembliesOutputs-&gt;FullPath()-&gt;Distinct())" Encoding="Unicode" />
  </Target>
  <!-- *******************************************************************************************
        MT
       ******************************************************************************************* -->
  <Target Name="Manifest" Condition="'@(Manifest)' != ''" DependsOnTargets="MakeDirsForManifest;$(ComputeManifestInputsTargets)">
    <ItemGroup>
      <Manifest>
        <OutputResourceManifests Condition="'$(LegacyManifestEmbedding)' == 'true' and '$(EmbedManifest)' == 'true' AND '$(EmbedManifestBy)'=='MT' AND '$(ConfigurationType)'=='Application'">%(Link.OutputFile);#1</OutputResourceManifests>
        <OutputResourceManifests Condition="'$(LegacyManifestEmbedding)' == 'true' and '$(EmbedManifest)' == 'true' AND '$(EmbedManifestBy)'=='MT' AND '$(ConfigurationType)'=='DynamicLibrary'">%(Link.OutputFile);#2</OutputResourceManifests>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </Manifest>
    </ItemGroup>
    <PropertyGroup>
      <ManifestToolArchitecture Condition="'$(ManifestToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</ManifestToolArchitecture>
      <RCToolArchitecture Condition="'$(RCToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</RCToolArchitecture>
    </PropertyGroup>
    <!-- Deleting the outputs incase it came from an older build. This will force a clean MT instead of an incremental run.-->
    <Delete Condition="('$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true') and '$(EmbedManifestby)'=='LINK'" Files="@(Manifest-&gt;Metadata('OutputManifestFile')-&gt;Distinct());@(Manifest-&gt;Metadata('OutputResourceManifests')-&gt;Distinct())" />
    <Mt Sources="@(Manifest);$(ManifestAdditionalManifestFiles)" AdditionalOptions="%(Manifest.AdditionalOptions)" AssemblyIdentity="%(Manifest.AssemblyIdentity)" ComponentFileName="%(Manifest.ComponentFileName)" GenerateCatalogFiles="%(Manifest.GenerateCatalogFiles)" GenerateCategoryTags="%(Manifest.GenerateCategoryTags)" InputResourceManifests="%(Manifest.InputResourceManifests)" OutputResourceManifests="%(Manifest.OutputResourceManifests)" ManifestFromManagedAssembly="%(Manifest.ManifestFromManagedAssembly)" OutputManifestFile="%(Manifest.OutputManifestFile)" RegistrarScriptFile="%(Manifest.RegistrarScriptFile)" ReplacementsFile="%(Manifest.ReplacementsFile)" SuppressDependencyElement="%(Manifest.SuppressDependencyElement)" SuppressStartupBanner="%(Manifest.SuppressStartupBanner)" TypeLibraryFile="%(Manifest.TypeLibraryFile)" UpdateFileHashes="%(Manifest.UpdateFileHashes)" UpdateFileHashesSearchPath="%(Manifest.UpdateFileHashesSearchPath)" VerboseOutput="%(Manifest.VerboseOutput)" MinimalRebuildFromTracking="$(LinkSkippedExecution)" TrackerLogDirectory="%(Manifest.TrackerLogDirectory)" ToolArchitecture="$(ManifestToolArchitecture)" TrackerFrameworkPath="$(ManifestTrackerFrameworkPath)" TrackerSdkPath="$(ManifestTrackerSdkPath)" ExcludedInputPaths="%(Manifest.ExcludedInputPaths)" ManifestToIgnore="$(_ManifestToIgnore)" TLogReadFiles="@(MtTLogReadFiles)" TLogWriteFiles="@(MtTLogWriteFiles)" ToolExe="$(MtToolExe)" ToolPath="$(MtToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(MTNoDependencies)" TrackedOutputFilesToIgnore="@(MTTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(Manifest.AcceptableNonZeroExitCodes)" />
    <ItemGroup>
      <ManifestResourceCompile Condition="'@(ManifestResourceCompile)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
      </ManifestResourceCompile>
    </ItemGroup>
    <!-- If we are embedding with Link, we need to regenerate the .res file with the updated manifest.
         The .rc should have been auto-generated by the previous ManifestResourceCompile target. -->
    <RC Condition="'$(EmbedManifestby)'=='LINK'" Source="@(ManifestResourceCompile)" ResourceOutputFileName="%(ManifestResourceCompile.ResourceOutputFileName)" SuppressStartupBanner="%(ManifestResourceCompile.SuppressStartupBanner)" ExcludedInputPaths="%(ManifestResourceCompile.ExcludedInputPaths)" MinimalRebuildFromTracking="%(ManifestResourceCompile.MinimalRebuildFromTracking)" TrackerLogDirectory="%(ManifestResourceCompile.TrackerLogDirectory)" ToolArchitecture="$(RCToolArchitecture)" TrackerFrameworkPath="$(RCTrackerFrameworkPath)" TrackerSdkPath="$(RCTrackerSdkPath)" TLogReadFiles="@(RCTLogReadFiles)" TLogWriteFiles="@(RCTLogWriteFiles)" ToolExe="$(RCToolExe)" ToolPath="$(RCToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(RCNoDependencies)" TrackedOutputFilesToIgnore="@(RCTrackedOutputFilesToIgnore)">
      <Output TaskParameter="SourcesCompiled" ItemName="RCSourcesCompiled" />
    </RC>
    <!-- If RC did produce an output, then force link to embed that manifest.
         This enforcement is required for projects residing on FAT32 drives. -->
    <ItemGroup Condition="'$(EmbedManifestby)'=='LINK'">
      <Link>
        <MinimalRebuildFromTracking Condition="@(RCSourcesCompiled)!=''">false</MinimalRebuildFromTracking>
      </Link>
    </ItemGroup>
  </Target>
  <!-- Makes the the directories that Manifest uses -->
  <Target Name="MakeDirsForManifest">
    <!-- List of directories and files whose directories should be made prior to running Manifest -->
    <ItemGroup Condition="'@(Manifest)'!=''">
      <ManifestDirsToMake Include="@(Manifest->'%(OutputManifestFile)')" />
      <ManifestDirsToMake Include="@(Manifest->'%(OutputResourceManifests)')" />
    </ItemGroup>
    <ItemGroup Condition="'@(ManifestResourceCompile)'!=''">
      <ManifestDirsToMake Include="@(ManifestResourceCompile->'%(ResourceOutputFileName)')" />
    </ItemGroup>
    <MakeDir Directories="@(ManifestDirsToMake->'%(RootDir)%(Directory)')" />
  </Target>
  <!-- *******************************************************************************************
        ManifestResourceCompile
       ******************************************************************************************* -->
  <ItemGroup Condition="'$(EmbedManifestBy)'=='LINK'">
    <ManifestResourceCompile Include="$(IntDir)$(TargetName)_manifest.rc">
      <MinimalRebuildFromTracking>true</MinimalRebuildFromTracking>
      <TrackerLogDirectory>$(TLogLocation)</TrackerLogDirectory>
    </ManifestResourceCompile>
  </ItemGroup>
  <Target Name="ManifestResourceCompile" Condition="'$(EmbedManifestBy)' == 'LINK' and '@(Manifest)' != ''">
    <!-- This goes into the rc file as a string so '\' needs to be escaped: IntDir already has one '\',
         so we add one more here. -->
    <PropertyGroup>
      <InputManifest>%(Manifest.OutputManifestFile)</InputManifest>
      <InputManifest>$(InputManifest.Replace(`\`,`\\`))</InputManifest>
    </PropertyGroup>
    <!-- Create an place holder manifest file for RC -->
    <WriteLinesToFile Condition="!EXISTS('%(Manifest.OutputManifestFile)')" File="%(Manifest.OutputManifestFile)" Lines="" Overwrite="false" Encoding="Unicode" />
    <WriteLinesToFile Condition="'$(ConfigurationType)'=='Application' AND !EXISTS('@(ManifestResourceCompile)')" File="@(ManifestResourceCompile)" Lines="1 /* CREATEPROCESS_MANIFEST_RESOURCE_ID */ 24 /* RT_MANIFEST */ &quot;$(InputManifest)&quot;" Overwrite="false" Encoding="Unicode" />
    <WriteLinesToFile Condition="'$(ConfigurationType)'=='DynamicLibrary' AND !EXISTS('@(ManifestResourceCompile)')" File="@(ManifestResourceCompile)" Lines="2 /* ISOLATIONAWARE_MANIFEST_RESOURCE_ID */ 24 /* RT_MANIFEST */ &quot;$(InputManifest)&quot;" Overwrite="false" Encoding="Unicode" />
    <ItemGroup>
      <ManifestResourceCompile Condition="'@(ManifestResourceCompile)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
      </ManifestResourceCompile>
    </ItemGroup>
    <PropertyGroup>
      <RCToolArchitecture Condition="'$(RCToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</RCToolArchitecture>
    </PropertyGroup>
    <RC Source="@(ManifestResourceCompile)" ResourceOutputFileName="%(ManifestResourceCompile.ResourceOutputFileName)" SuppressStartupBanner="%(ManifestResourceCompile.SuppressStartupBanner)" ExcludedInputPaths="%(ManifestResourceCompile.ExcludedInputPaths)" TrackerLogDirectory="%(ManifestResourceCompile.TrackerLogDirectory)" MinimalRebuildFromTracking="%(ManifestResourceCompile.MinimalRebuildFromTracking)" ToolArchitecture="$(RCToolArchitecture)" TrackerFrameworkPath="$(RCTrackerFrameworkPath)" TrackerSdkPath="$(RCTrackerSdkPath)" TLogReadFiles="@(RCTLogReadFiles)" TLogWriteFiles="@(RCTLogWriteFiles)" ToolExe="$(RCToolExe)" ToolPath="$(RCToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(RCNoDependencies)" TrackedOutputFilesToIgnore="@(RCTrackedOutputFilesToIgnore)" />
  </Target>
  <!-- *******************************************************************************************
        RegisterDll
       ******************************************************************************************* -->
  <!-- Allow regsvr32 for Win32 Platform.  If Platform is x64, then check if the host OS is 64bit. -->
  <Target Name="RegisterOutput" Condition="'$(LinkSkippedExecution)' != 'true' and (('$(Platform)' == 'x64' and ('$(PROCESSOR_ARCHITECTURE)' == 'AMD64' or '$(PROCESSOR_ARCHITEW6432)' == 'AMD64')) or '$(Platform)' == 'Win32')">
    <Exec Command="regsvr32 /s &quot;%(Link.OutputFile)&quot;" Condition="'$(ConfigurationType)'=='DynamicLibrary' and '%(Link.RegisterOutput)'=='true' and '%(Link.PerUserRedirection)'!='true'" ContinueOnError="true">
      <Output TaskParameter="ExitCode" PropertyName="_RegisterOutputExitCode" />
    </Exec>
    <Exec Command="regsvr32 /s /n /i:user &quot;%(Link.OutputFile)&quot;" Condition="'$(ConfigurationType)'=='DynamicLibrary' and '%(Link.RegisterOutput)'=='true' and '%(Link.PerUserRedirection)'=='true'" ContinueOnError="true">
      <Output TaskParameter="ExitCode" PropertyName="_RegisterOutputExitCode" />
    </Exec>
    <Exec Command="&quot;%(Link.OutputFile)&quot; /RegServer" Condition="'$(ConfigurationType)'=='Application' and '%(Link.RegisterOutput)'=='true' and '%(Link.PerUserRedirection)'!='true'" ContinueOnError="true">
      <Output TaskParameter="ExitCode" PropertyName="_RegisterOutputExitCode" />
    </Exec>
    <Exec Command="&quot;%(Link.OutputFile)&quot; /RegServerPerUser" Condition="'$(ConfigurationType)'=='Application' and '%(Link.RegisterOutput)'=='true' and '%(Link.PerUserRedirection)'=='true'" ContinueOnError="true">
      <Output TaskParameter="ExitCode" PropertyName="_RegisterOutputExitCode" />
    </Exec>
    <VCMessage Code="MSB8011" Type="Error" Condition="'$(_RegisterOutputExitCode)' != '' and '$(_RegisterOutputExitCode)' != '0'" />
  </Target>
  <!-- *******************************************************************************************
        XDCMake
       ******************************************************************************************* -->
  <Target Name="XdcMake" Condition="'@(XdcMake)' != ''">
    <ItemGroup>
      <XdcMake Condition="'@(XdcMake)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </XdcMake>
    </ItemGroup>
    <PropertyGroup>
      <XDCMakeToolArchitecture Condition="'$(XDCMakeToolArchitecture)' == ''">ManagedIL</XDCMakeToolArchitecture>
    </PropertyGroup>
    <XDCMake Sources="@(XdcMake)" AdditionalOptions="%(XdcMake.AdditionalOptions)" SuppressStartupBanner="%(XdcMake.SuppressStartupBanner)" OutputFile="%(XdcMake.OutputFile)" SlashOld="true" ProjectName="$(ProjectName)" ExcludedInputPaths="%(XdcMake.ExcludedInputPaths)" TrackerLogDirectory="%(XdcMake.TrackerLogDirectory)" MinimalRebuildFromTracking="%(XdcMake.MinimalRebuildFromTracking)" ToolArchitecture="$(XDCMakeToolArchitecture)" TrackerFrameworkPath="$(XDCMakeTrackerFrameworkPath)" TrackerSdkPath="$(XDCMakeTrackerSdkPath)" TLogReadFiles="@(XDCMakeTLogReadFiles)" TLogWriteFiles="@(XDCMakeTLogWriteFiles)" ToolExe="$(XDCMakeToolExe)" ToolPath="$(XDCMakeToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(XDCMakeNoDependencies)" TrackedOutputFilesToIgnore="@(XDCTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(XdcMake.AcceptableNonZeroExitCodes)" />
  </Target>
  <!-- *******************************************************************************************
          BscMake
       ******************************************************************************************* -->
  <Target Name="BscMake" Condition="'@(BscMake)' != ''">
    <ItemGroup>
      <BscMake Condition="'@(BscMake)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </BscMake>
    </ItemGroup>
    <PropertyGroup>
      <BSCMakeToolArchitecture Condition="'$(BSCMakeToolArchitecture)' == ''">$(VCToolArchitecture)</BSCMakeToolArchitecture>
    </PropertyGroup>
    <BSCMake Sources="@(BscMake)" AdditionalOptions="%(BscMake.AdditionalOptions)" SuppressStartupBanner="%(BscMake.SuppressStartupBanner)" OutputFile="%(BscMake.OutputFile)" PreserveSBR="%(BscMake.PreserveSBR)" ExcludedInputPaths="%(BscMake.ExcludedInputPaths)" TrackerLogDirectory="%(BscMake.TrackerLogDirectory)" MinimalRebuildFromTracking="%(BscMake.MinimalRebuildFromTracking)" ToolArchitecture="$(BSCMakeToolArchitecture)" TrackerFrameworkPath="$(BSCMakeTrackerFrameworkPath)" TrackerSdkPath="$(BSCMakeTrackerSdkPath)" TLogReadFiles="@(BSCMakeTLogReadFiles)" TLogWriteFiles="@(BSCMakeTLogWriteFiles)" ToolExe="$(BSCMakeToolExe)" ToolPath="$(BSCMakeToolPath)" TrackFileAccess="$(TrackFileAccess)" TrackedInputFilesToIgnore="@(BSCMakeNoDependencies)" TrackedOutputFilesToIgnore="@(BSCTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(BscMake.AcceptableNonZeroExitCodes)" />
  </Target>
  <!-- *******************************************************************************************
          XSD
       ******************************************************************************************* -->
  <Target Name="Xsd" Condition="'@(Xsd)' != ''" DependsOnTargets="SelectXsd">
    <ItemGroup>
      <Xsd Condition="'@(Xsd)' != ''">
        <MinimalRebuildFromTracking Condition="'$(_BuildActionType)' != 'Build' or '$(ForceRebuild)' == 'true'">false</MinimalRebuildFromTracking>
        <ExcludedInputPaths>$(ExcludePath)</ExcludedInputPaths>
      </Xsd>
    </ItemGroup>
    <PropertyGroup>
      <XSDToolArchitecture Condition="'$(XSDToolArchitecture)' == ''">$(WindowsSDKToolArchitecture)</XSDToolArchitecture>
    </PropertyGroup>
    <XSD Condition="'%(Xsd.ExcludedFromBuild)'!='true'" AdditionalOptions="%(Xsd.AdditionalOptions)" Sources="%(Xsd.Identity)" SuppressStartupBanner="%(Xsd.SuppressStartupBanner)" GenerateFromSchema="%(Xsd.GenerateFromSchema)" Language="%(Xsd.Language)" Namespace="%(Xsd.Namespace)" TrackerLogDirectory="%(Xsd.TrackerLogDirectory)" ToolArchitecture="$(XSDToolArchitecture)" TrackerFrameworkPath="$(XSDTrackerFrameworkPath)" TrackerSdkPath="$(XSDTrackerSdkPath)" ExcludedInputPaths="%(Xsd.ExcludedInputPaths)" TLogReadFiles="@(XSDTLogReadFiles)" TLogWriteFiles="@(XSDTLogWriteFiles)" ToolExe="$(XSDToolExe)" ToolPath="$(XSDToolPath)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(Xsd.MinimalRebuildFromTracking)" TrackedInputFilesToIgnore="@(XSDNoDependencies)" TrackedOutputFilesToIgnore="@(XSDTrackedOutputFilesToIgnore)" AcceptableNonZeroExitCodes="%(Xsd.AcceptableNonZeroExitCodes)" />
  </Target>
  <!-- *******************************************************************************************
          MetaGen
       ******************************************************************************************* -->
  <PropertyGroup>
    <MetaGenTargets Condition="'$(MetaGenTargets)'==''">$(VCTargetsPath)\Microsoft.MetaGen.targets</MetaGenTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MetaGenTargets)" Condition="Exists('$(MetaGenTargets)')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.MetaGen.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.MetaGen.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file is required to build Visual C++ projects
using Managed Incremental Build.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="METAGEN" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="MIBPreProcessDependencyGraph" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="MIBPostProcessDependencyGraph" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <!--
    ============================================================
    MetaGen

    Generates the assembly metagen file
    ============================================================
    -->
  <Target Name="ComputeMetaGenInputs" />
  <Target Name="MetaGenInputsOutputs" Condition="'$(EnableManagedIncrementalBuild)' == 'True'" AfterTargets="$(MetagenInputTarget)">
    <ItemGroup>
      <MetaGen Condition="'$(OutputAssemblyFile)' != ''" Include="$(OutputAssemblyFile)" />
    </ItemGroup>
  </Target>
  <Target Name="MetaGen" Condition="'@(MetaGen)' != ''" AfterTargets="MetaGenInputsOutputs" Inputs="$(OutputAssemblyFile)" Outputs="$(TLogLocation)\metagen.write.1.tlog">
    <PropertyGroup>
      <MIBProcessDependencyGraphExcludedFolders Condition="'$(MIBProcessDependencyGraphExcludedFolders)' == ''">$(ExcludePath);$(FrameworkDir);$(VSInstallDir);$(_FullFrameworkReferenceAssemblyPaths)</MIBProcessDependencyGraphExcludedFolders>
      <MIBSearchPaths>$(ReferencePath);@(ClCompile-&gt;'%(AdditionalUsingDirectories)'-&gt;Distinct())</MIBSearchPaths>
    </PropertyGroup>
    <METAGEN AssemblyFile="@(MetaGen)" SearchPath="$(MIBSearchPaths)" Sources="@(ClCompile)" ExcludedInputPaths="$(MIBProcessDependencyGraphExcludedFolders)" IntDir="$([System.IO.Path]::GetFullPath($(TLogLocation)))" ContinueOnError="true" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" />
  </Target>
  <!--
    ============================================================
    ManagedIncrementalBuildProcessDependencyGraph Targets
    ============================================================
    -->
  <PropertyGroup>
    <ManagedIncrementalBuildProcessDependencyGraphBeforeTarget Condition="'$(ManagedIncrementalBuildProcessDependencyGraphBeforeTarget)' == '' and '$(Language)' == 'c++'">
      ClCompile
    </ManagedIncrementalBuildProcessDependencyGraphBeforeTarget>
    <ManagedIncrementalBuildProcessDependencyGraphAfterTarget Condition="'$(ManagedIncrementalBuildProcessDependencyGraphAfterTarget)' == '' and '$(Language)' == 'c++'">
      ClCompile
    </ManagedIncrementalBuildProcessDependencyGraphAfterTarget>
  </PropertyGroup>
  <Target Name="ManagedIncrementalBuildPreProcessDependencyGraph" Condition="'@(ClCompile)' != '' and '$(EnableManagedIncrementalBuild)' == 'True'" DependsOnTargets="GetReferenceAssemblyPaths" BeforeTargets="$(ManagedIncrementalBuildProcessDependencyGraphBeforeTarget)">
    <PropertyGroup>
      <MIBProcessDependencyGraphExcludedFolders Condition="'$(MIBProcessDependencyGraphExcludedFolders)' == ''">$(ExcludePath);$(FrameworkDir);$(VSInstallDir);$(_FullFrameworkReferenceAssemblyPaths)</MIBProcessDependencyGraphExcludedFolders>
      <MIBSearchPaths>$(ReferencePath);@(ClCompile-&gt;'%(AdditionalUsingDirectories)'-&gt;Distinct())</MIBSearchPaths>
    </PropertyGroup>
    <MIBPreProcessDependencyGraph Sources="@(ClCompile)" SearchPath="$(MIBSearchPaths)" ExcludedInputPaths="$(MIBProcessDependencyGraphExcludedFolders)" IntDir="$([System.IO.Path]::GetFullPath($(TLogLocation)))" ContinueOnError="true" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" />
  </Target>
  <Target Name="ManagedIncrementalBuildPostProcessDependencyGraph" Condition="'@(ClCompile)' != '' and '$(EnableManagedIncrementalBuild)' == 'True'" DependsOnTargets="GetReferenceAssemblyPaths" AfterTargets="$(ManagedIncrementalBuildProcessDependencyGraphAfterTarget)">
    <PropertyGroup>
      <MIBProcessDependencyGraphExcludedFolders Condition="'$(MIBProcessDependencyGraphExcludedFolders)' == ''">$(ExcludePath);$(FrameworkDir);$(VSInstallDir);$(_FullFrameworkReferenceAssemblyPaths)</MIBProcessDependencyGraphExcludedFolders>
      <MIBSearchPaths>$(ReferencePath);@(ClCompile-&gt;'%(AdditionalUsingDirectories)'-&gt;Distinct())</MIBSearchPaths>
    </PropertyGroup>
    <MIBPostProcessDependencyGraph Sources="@(ClCompile)" SearchPath="$(MIBSearchPaths)" ExcludedInputPaths="$(MIBProcessDependencyGraphExcludedFolders)" IntDir="$([System.IO.Path]::GetFullPath($(TLogLocation)))" ContinueOnError="true" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <MetagenInputTarget Condition="'$(MetagenInputTarget)' == ''">Link</MetagenInputTarget>
  </PropertyGroup>
  <Target Name="ComputeMetaGenInputs" BeforeTargets="MetaGenInputsOutputs" Condition="'$(CLRSupport)'!='' and '$(CLRSupport)'!='false' and '$(CLRSupport)'!='NetCore'">
    <PropertyGroup>
      <ConsumeAnyMetaAssembly Condition="'$(ConsumeAnyMetaAssembly)' == '' and '$(EnableManagedIncrementalBuild)' != ''">$(EnableManagedIncrementalBuild)</ConsumeAnyMetaAssembly>
      <ConsumeAnyMetaAssembly Condition="'$(ConsumeAnyMetaAssembly)' == ''">False</ConsumeAnyMetaAssembly>
      <OutputAssemblyFile>%(Link.OutputFile)</OutputAssemblyFile>
      <OutputAssemblyMetagenFile>%(Link.OutputFile).metagen</OutputAssemblyMetagenFile>
    </PropertyGroup>
    <Delete Condition="'$(OutputAssemblyMetagenFile)' != '' and '$(ConsumeAnyMetaAssembly)' == 'false' and Exists('$(OutputAssemblyMetagenFile)')" Files="$(OutputAssemblyMetagenFile)" ContinueOnError="true" />
  </Target>
  <!-- *******************************************************************************************
          GetNativeManifest : Override GetNativeManifest in Microsoft.Common.targets
       ******************************************************************************************* -->
  <Target Name="GetNativeManifest" Returns="@(ComputedApplicationManifest)">
    <ItemGroup>
      <Link Include="tmp" Condition="'@(Link)' == ''">
        <DeleteSoon>true</DeleteSoon>
      </Link>
      <Manifest Include="tmp" Condition="'@(Manifest)' == ''">
        <DeleteSoon>true</DeleteSoon>
      </Manifest>
    </ItemGroup>
    <PropertyGroup>
      <_HasNativeManifest>true</_HasNativeManifest>
      <_HasNativeManifest Condition="'$(GenerateManifest)' != 'true'">false</_HasNativeManifest>
      <_HasNativeManifest Condition="'$(EmbedManifest)' != 'false'">false</_HasNativeManifest>
      <_HasNativeManifest Condition="'%(Manifest.AssemblyIdentity)' == ''">false</_HasNativeManifest>
      <_HasNativeManifest Condition="!Exists('@(Manifest-&gt;Metadata('OutputManifestFile')-&gt;FullPath()-&gt;Distinct())')">false</_HasNativeManifest>
    </PropertyGroup>
    <ItemGroup>
      <ComputedApplicationManifest Include="@(Manifest-&gt;Metadata('OutputManifestFile')-&gt;Filename()-&gt;Distinct())" Condition="'$(_HasNativeManifest)' == 'true'">
        <HintPath>@(Manifest-&gt;Metadata('OutputManifestFile')-&gt;FullPath()-&gt;Distinct())</HintPath>
      </ComputedApplicationManifest>
    </ItemGroup>
    <ItemGroup>
      <Link Remove="@(Link)" Condition="'%(Link.DeleteSoon)' == 'true'" />
      <Manifest Remove="@(Manifest)" Condition="'%(Manifest.DeleteSoon)' == 'true'" />
    </ItemGroup>
  </Target>
  <Target Name="AddAsanBinariesToCopy" Condition="'$(EnableASAN)' == 'true' and '$(CopyAsanBinariesToOutDir)' == 'true'">
    <ItemGroup>
      <CopyFileToFolders Condition="'$(PlatformTarget)' == 'x86'" Include="$(VC_ExecutablePath_x86_x86)\clang_rt.asan_dynamic-$(LlvmPlatformName).dll" />
      <CopyFileToFolders Condition="'$(PlatformTarget)' == 'x64'" Include="$(VC_ExecutablePath_x86_x64)\clang_rt.asan_dynamic-$(LlvmPlatformName).dll" />
    </ItemGroup>
  </Target>
  <PropertyGroup Condition="'$(EnableASAN)' == 'true' and '$(CopyAsanBinariesToOutDir)' == 'true'">
    <PrepareForBuildDependsOn>AddAsanBinariesToCopy;$(PrepareForBuildDependsOn)</PrepareForBuildDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <ContentFilesProjectOutputGroupDependsOn>$(ContentFilesProjectOutputGroupDependsOn);_CreateCopyFileItems;</ContentFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="_CreateCopyFileItems" Condition="'@(CopyFileToFolders)' != ''" DependsOnTargets="$(_CreateCopyFileItemsDependsOn)">
    <ItemGroup>
      <!-- one file can be copies to multiple directories and we need a separate item for each copy to use Copy task -->
      <_CopyFileDestination Include="%(CopyFileToFolders.DestinationFolders)" Condition="'%(CopyFileToFolders.ExcludedFromBuild)' != 'true' and '%(CopyFileToFolders.DestinationFolders)' != ''">
        <DestinationFileName>%(CopyFileToFolders.DestinationFileName)</DestinationFileName>
        <SrcFile>%(CopyFileToFolders.Identity)</SrcFile>
        <DestingationFolders />
        <TreatOutputAsContent>%(CopyFileToFolders.TreatOutputAsContent)</TreatOutputAsContent>
        <RootFolder>%(CopyFileToFolders.RootFolder)</RootFolder>
      </_CopyFileDestination>
      <_CopyFile Include="@(CopyFileToFolders)" Condition="'%(CopyFileToFolders.ExcludedFromBuild)' != 'true' and '%(CopyFileToFolders.DestinationFolders)' == '' and %(CopyFileToFolders.DestinationFileName) != ''">
        <DestinationFolder>%(RootDir)%(Directory)</DestinationFolder>
      </_CopyFile>
    </ItemGroup>
    <ItemGroup Condition="'@(_CopyFileDestination)' != ''">
      <_CopyFile Include="%(_CopyFileDestination.SrcFile)">
        <DestinationFolder>%(_CopyFileDestination.Identity)</DestinationFolder>
        <DestinationFileName>%(_CopyFileDestination.DestinationFileName)</DestinationFileName>
        <TreatOutputAsContent>%(_CopyFileDestination.TreatOutputAsContent)</TreatOutputAsContent>
        <RootFolder>%(_CopyFileDestination.RootFolder)</RootFolder>
      </_CopyFile>
      <_CopyFile>
        <DestinationFileName Condition="'%(DestinationFileName)' == ''">%(FileName).%(Extension)</DestinationFileName>
        <FullDestinationPath>$([MSBuild]::NormalizePath('%(DestinationFolder)', '%(DestinationFileName)'))</FullDestinationPath>
      </_CopyFile>
    </ItemGroup>
    <ItemGroup>
      <_CopyFileDestination Remove="@(_CopyFileDestination)" />
    </ItemGroup>
  </Target>
  <Target Name="CopyFileToFolders" BeforeTargets="$(CopyFileBeforeTargets)" AfterTargets="$(CopyFileAfterTargets)" DependsOnTargets="_CreateCopyFileItems;_SelectedFiles">
    <ItemGroup Condition="'@(SelectedFiles)' != ''">
      <_CopyFile Remove="@(_CopyFile)" Condition="'%(Identity)' != '@(SelectedFiles)'" />
      <_OutOfDateCopyFile Include="@(_CopyFile)" />
    </ItemGroup>
    <GetOutOfDateItems Condition="'$(SelectedFiles)' == ''" Sources="@(_CopyFile)" OutputsMetadataName="FullDestinationPath" CommandMetadataName="FullDestinationPath" TLogDirectory="$(TLogLocation)" TLogNamePrefix="CopyFile" TrackFileAccess="$(TrackFileAccess)">
      <Output TaskParameter="OutOfDateSources" ItemName="_OutOfDateCopyFile" />
    </GetOutOfDateItems>
    <Copy SourceFiles="%(_OutOfDateCopyFile.FullPath)" DestinationFiles="%(_OutOfDateCopyFile.FullDestinationPath)" SkipUnchangedFiles="false" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" Condition="'@(_OutOfDateCopyFile)' != ''" />
  </Target>
  <!-- Set the properties needed to ensure ARM64X project reference builds actually build when building from inside visual studio -->
  <Target Name="SetBuildAsXTransitiveProperties">
    <PropertyGroup>
      <BuildingInsideVisualStudio>false</BuildingInsideVisualStudio>
      <BuildingXReferences>true</BuildingXReferences>
    </PropertyGroup>
  </Target>
  <!-- Modify the project references to be built during an arm64x build of the other configuration. Remove non c++ projects as they should have been built by original configuration.
  Also update the targets to make sure the project references also call SetBuildAsXTransitiveProperties so that their own references also build. -->
  <Target Name="UpdateProjectReferenceBuildTargets" DependsOnTargets="PrepareProjectReferences" BeforeTargets="ResolveProjectReferences" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(BuildingXReferences)' == 'true'">
    <!-- remove non vcxproj -->
    <ItemGroup>
      <_TempMSBuildProjectReferenceExistent Include="@(_MSBuildProjectReferenceExistent)" />
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" />
    </ItemGroup>
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Include="@(_TempMSBuildProjectReferenceExistent)" Condition="'%(_TempMSBuildProjectReferenceExistent.Extension)' == '.vcxproj'">
        <Targets>SetBuildAsXTransitiveProperties;%(_TempMSBuildProjectReferenceExistent.Targets);Build</Targets>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
  </Target>
  <!-- The name of UAP debugger changed during Dev14 update-1 - So mapping 'AppHostRemoteDebugger' to 'UWPRemoteDebugger' to ensure compatibility-->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)'=='UAP' and '$(DebuggerFlavor)'=='AppHostRemoteDebugger'">
    <DebuggerFlavor>UWPRemoteDebugger</DebuggerFlavor>
  </PropertyGroup>
  <!--<Import Project="$(VCLibPackagePath).targets" Condition="'$(VCLibPackagePath)' != '' and Exists('$(VCLibPackagePath).targets')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.CodeAnalysis.Extensions.targets" Condition="exists('$(VCTargetsPath)\Microsoft.CodeAnalysis.Extensions.targets')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CodeAnalysis.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CodeAnalysis.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- NOTE: this file is published to the VCTargets folder and so is implicitly versioned
     with the rest of the Cpp targets files. Keep that in mind when modifying -->
  <!-- If any extension is enabled, determine the EspXEngine path -->
  <PropertyGroup Condition="'$(RunMsvcAnalysis)' == 'true' and '$(EspXtensions)' != ''">
    <AfterBuildCompileTargets>
      $(AfterBuildCompileTargets)
    </AfterBuildCompileTargets>
    <EspXEnginePath>$(VC_ExecutablePath_x86_x86)\EspXEngine.dll</EspXEnginePath>
    <EspXEnginePath Condition="'$(VCToolArchitecture)' == 'Native64Bit'">$(VC_ExecutablePath_x64_x64)\EspXEngine.dll</EspXEnginePath>
    <EspXEnginePath Condition="'$(VCToolArchitecture)' == 'NativeARM64'">$(VC_ExecutablePath_ARM64_ARM64)\EspXEngine.dll</EspXEnginePath>
    <EspXEnginePath Condition="'$(_CodeAnalysisExtensions)' == 'true'">$(MsvcAnalysisPluginPath)\EspXEngine.dll</EspXEnginePath>
  </PropertyGroup>
  <!-- If any EspX extensions are enabled, include EspXEngine plugin -->
  <ItemDefinitionGroup Condition="'$(RunMsvcAnalysis)' == 'true' and '$(EspXtensions)' != ''">
    <ClCompile>
      <!-- Only enable the EspX plugin if prefast is enabled and the project is not a managed code project -->
      <PREfastAdditionalPlugins Condition="'%(ClCompile.EnablePREfast)' == 'true' and ('%(ClCompile.CompileAsManaged)' == 'false' or '%(ClCompile.CompileAsManaged)' == '') and '%(ClCompile.CompileAsWinRT)' != 'true'">
        $(EspXEnginePath);%(ClCompile.PREfastAdditionalPlugins)
      </PREfastAdditionalPlugins>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Set the Esp_Extensions environment variable with the list of extensions -->
  <ItemGroup Condition="'$(RunMsvcAnalysis)' == 'true' and '$(EspXtensions)' != ''">
    <BuildMacro Include="Esp_Extensions">
      <EnvironmentVariable>true</EnvironmentVariable>
      <Value>$(EspXtensions)</Value>
    </BuildMacro>
  </ItemGroup>
  <!-- Set Esp_AnnotationBuildLevel environment variable to ignore if ConcurrencyCheck is disabled -->
  <ItemGroup Condition="'$(RunMsvcAnalysis)' == 'true' and '$(EspXtensions)' != '' and (!Exists('$(ConcurrencyCheckPath)') or '$(EnableConcurrencyCheck)'=='false')">
    <BuildMacro Include="Esp_AnnotationBuildLevel">
      <EnvironmentVariable>true</EnvironmentVariable>
      <Value>Ignore</Value>
    </BuildMacro>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(_CppCommonExtensionTargets)" Condition="'$(_CppCommonExtensionTargets)' != ''">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\Microsoft.Windows.UI.Xaml.Cpp.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <IsCppProject>True</IsCppProject>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Windows.UI.Xaml.Common.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\Microsoft.Windows.UI.Xaml.Common.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(TargetPlatformVersion)'==''">
    <TargetPlatformVersion>8.0</TargetPlatformVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP' And '$(TargetPlatformMinVersion)' != '' And '$(TargetPlatformMinVersion)' &gt; '10.0.10587.0'">
    <RedirectionTarget>8.21</RedirectionTarget>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP' And '$(RedirectionTarget)' == ''">
    <RedirectionTarget>8.2</RedirectionTarget>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RedirectionTarget)' == ''">
    <RedirectionTarget>$(TargetPlatformVersion)</RedirectionTarget>
  </PropertyGroup>
  <!-- Direct 8.0 projects to 8.1 targets to enable retargeting  -->
  <PropertyGroup Condition="'$(RedirectionTarget)' == '8.0'">
    <RedirectionTarget>8.1</RedirectionTarget>
  </PropertyGroup>
  <!-- UnitTest SDKs always match VS Versions -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP' And '$(UnitTestPlatformVersion)' != ''">
    <UnitTestPlatformVersion>$(VisualStudioVersion)</UnitTestPlatformVersion>
  </PropertyGroup>
  <!-- User Sets this property in csproj -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP' And '$(UnitTestPlatformVersion)' == '17.0'">
    <!-- Needed to drop PDB's inside Appx -->
    <AppxPackageIncludePrivateSymbols Condition="'$(AppxPackageIncludePrivateSymbols)' == ''">true</AppxPackageIncludePrivateSymbols>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UwpUnitTestSdkPkgVersion)' == ''">
    <UwpUnitTestSdkPkgVersion>16.11.0</UwpUnitTestSdkPkgVersion>
  </PropertyGroup>
  <!-- Tpv2 needs following packages at runtime -->
  <Choose>
    <When Condition="'$(TargetPlatformIdentifier)' == 'UAP' And '$(UnitTestPlatformVersion)' == '17.0' And '$(RestoreProjectStyle)' == 'PackageReference' And '$(IsCppProject)' != 'True' ">
      <ItemGroup>
        <PackageReference Include="Microsoft.NET.Test.Sdk" IsImplicitlyDefined="true">
          <Version>$(UwpUnitTestSdkPkgVersion)</Version>
        </PackageReference>
      </ItemGroup>
    </When>
  </Choose>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\Microsoft.Windows.UI.Xaml.Cpp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(RedirectionTarget)\Microsoft.Windows.UI.Xaml.Cpp.targets" Condition="Exists('$(RedirectionTarget)\Microsoft.Windows.UI.Xaml.Cpp.targets')">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\8.21\Microsoft.Windows.UI.Xaml.Cpp.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.Cpp.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <BeforeClCompileTargets>
            MarkupCompilePass1;
            $(BeforeClCompileTargets)
        </BeforeClCompileTargets>
    <ComputeCompileInputsTargets>
            ComputeXamlGeneratedCompileInputs;
            $(ComputeCompileInputsTargets)
        </ComputeCompileInputsTargets>
  </PropertyGroup>
  <Choose>
    <When Condition="'$(ConfigurationType)'=='StaticLibrary'">
      <PropertyGroup>
        <AfterClCompileTargets>
                  $(ComputeLinkInputsTargets);
                  CreateWinMD;
                  ComputeGeneratedWinMD;
                  MarkupCompilePass2;
                  ComputeInvalidXamlGenerated;
                  CompileXamlGeneratedFiles;
                  $(AfterClCompileTargets)
                </AfterClCompileTargets>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <AfterBuildCompileTargets>
                  $(ComputeLinkInputsTargets);
                  CreateWinMD;
                  ComputeGeneratedWinMD;
                  MarkupCompilePass2;
                  ComputeInvalidXamlGenerated;
                  CompileXamlGeneratedFiles;
                  $(AfterBuildCompileTargets)
                </AfterBuildCompileTargets>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup>
    <XamlPreLinkDependsOn>
            $(XamlPreLinkDependsOn);
            ComputeXamlGeneratedCLOutputs
        </XamlPreLinkDependsOn>
    <XamlPreLibDependsOn>
          $(XamlPreLibDependsOn);
          ComputeXamlGeneratedCLOutputs
        </XamlPreLibDependsOn>
    <GenerateProjectionAssembly>True</GenerateProjectionAssembly>
    <OnlyCreateWinMD>true</OnlyCreateWinMD>
    <ImplicitlyExpandTargetPlatform>false</ImplicitlyExpandTargetPlatform>
  </PropertyGroup>
  <PropertyGroup>
    <ValidatePresenceOfAppxManifestItemsDependsOn>
            $(ValidatePresenceOfAppxManifestItemsDependsOn);
            _CreateContentItemOutOfCustomAppxManifest
        </ValidatePresenceOfAppxManifestItemsDependsOn>
  </PropertyGroup>
  <ItemGroup>
    <PropertyPageSchema Include="$(VCTargetsPath)$(LangID)\Xaml.xml" />
  </ItemGroup>
  <!-- This is a proxy target that holds stuff that runs before the final Link -->
  <Target Name="XamlPreLink" BeforeTargets="Link" DependsOnTargets="$(XamlPreLinkDependsOn)" />
  <!-- This is a proxy target that holds stuff that runs before the final Link -->
  <Target Name="XamlPreLib" BeforeTargets="Lib" DependsOnTargets="$(XamlPreLibDependsOn)" />
  <Target Name="ComputeGeneratedWinMD">
    <PropertyGroup>
      <LocalAssembly Condition="'$(LocalAssembly)' == '' and '%(Link.WindowsMetadataFile)' != ''">%(Link.WindowsMetadataFile)</LocalAssembly>
    </PropertyGroup>
  </Target>
  <!-- Change AppxManifest.xml override item to be of Content type. -->
  <Target Name="_CreateContentItemOutOfCustomAppxManifest">
    <ItemGroup>
      <Content Include="@(Xml)" Condition="'%(Identity)' == 'AppxManifest.xml'" />
      <Xml Remove="@(Xml)" Condition="'%(Identity)' == 'AppxManifest.xml'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <GeneratedFilesDir Condition=" '$(GeneratedFilesDir)' == ''">Generated Files\</GeneratedFilesDir>
    <XamlGeneratedOutputPath>$(GeneratedFilesDir)</XamlGeneratedOutputPath>
    <ExtensionsToDeleteOnClean>$(ExtensionsToDeleteOnClean);*.g.h;*.g.cpp;*.xaml</ExtensionsToDeleteOnClean>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Windows.UI.Xaml.Common.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\8.21\Microsoft.Windows.UI.Xaml.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="ImportBefore\*" />-->
  <PropertyGroup>
    <AvailablePlatforms>$(AvailablePlatforms),ARM64</AvailablePlatforms>
  </PropertyGroup>
  <!-- Need the path to vcmeta.dll -->
  <PropertyGroup>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\15.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\15.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VSWinExpress\15.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VSWinExpress\15.0\Setup\VC@ProductDir)</VCInstallDir>
    <VCInstallDir Condition="'$(VCInstallDir)' == ''">$(VsInstallRoot)\Common7\IDE\VC\</VCInstallDir>
    <WindowsKitsPath Condition="'$(WindowsKitsPath)' == '' and '$(TargetPlatformSdkRootOverride)' != ''">$(TargetPlatformSdkRootOverride)\</WindowsKitsPath>
    <WindowsKitsPath Condition="'$(WindowsKitsPath)'==''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10', null, RegistryView.Registry32, RegistryView.Default))</WindowsKitsPath>
    <!--
	if (TPV > RS2(10.0.15063.0) && TPMinV > TH2(10.0.10587.0)), use TPV XAML Compiler
	else, use TPMinV XAML Compiler
    -->
    <WindowsKitsXamlCompilerTargetsPath Condition="'$(TargetPlatformVersion)' &gt; '10.0.15064.0' AND '$(TargetPlatformMinVersion)' &gt; '10.0.14392.0'">$(WindowsKitsPath)bin\$(TargetPlatformVersion)\XamlCompiler\Microsoft.Windows.UI.Xaml.Common.targets</WindowsKitsXamlCompilerTargetsPath>
    <WindowsKitsXamlCompilerTargetsPath Condition="'$(WindowsKitsXamlCompilerTargetsPath)' == ''">$(WindowsKitsPath)bin\$(TargetPlatformMinVersion)\XamlCompiler\Microsoft.Windows.UI.Xaml.Common.targets</WindowsKitsXamlCompilerTargetsPath>
  </PropertyGroup>
  <!-- Import the targets SDK -->
  <!--
============================================================================================================================================
  <Import Project="$(WindowsKitsXamlCompilerTargetsPath)" Condition="Exists($(WindowsKitsXamlCompilerTargetsPath)) AND ('$(IsWinUIAlpha)' != 'true') AND ('$(DefaultXamlRuntime)' != 'WinUI')">

C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\XamlCompiler\Microsoft.Windows.UI.Xaml.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Windows.UI.Xaml.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="ImportBefore\*" />-->
  <!-- Need the path to vcmeta.dll -->
  <PropertyGroup>
    <XamlProjectName Condition=" '$(XamlProjectName)' == '' ">$(MSBuildProjectName)</XamlProjectName>
    <WindowsSdkPath Condition="'$(WindowsSdkPath)'==''">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\$(SDKIdentifier)\v$(SDKVersion)', 'InstallationFolder', null, RegistryView.Registry32, RegistryView.Default))</WindowsSdkPath>
    <XAMLFingerprint Condition="'$(XAMLFingerprint)' == ''">true</XAMLFingerprint>
    <DisableXbfGeneration Condition="'$(DisableXbfGeneration)' == '' AND '$(TargetPlatformVersion)' == '8.0'">true</DisableXbfGeneration>
    <DisableXbfGeneration Condition="'$(DisableXbfGeneration)' == ''">false</DisableXbfGeneration>
    <XamlSavedStateFileName Condition="'$(XamlSavedStateFileName)' == ''">XamlSaveStateFile.xml</XamlSavedStateFileName>
    <XamlSavedStateFilePath>$(IntermediateOutputPath)\$(XamlSavedStateFileName)</XamlSavedStateFilePath>
    <XAMLFingerprintIgnorePaths Condition="'$(XAMLFingerprintIgnorePaths)'==''">
      @(ReferenceAssemblyPaths);
      $(WindowsSdkPath)
    </XAMLFingerprintIgnorePaths>
    <PlatformXmlDir Condition="'$(PlatformXmlDir)' == ''">$(WindowsSdkPath)\Platforms\UAP\$(TargetPlatformVersion)\</PlatformXmlDir>
    <TPVFacadeWinmdPath>$(WindowsSdkPath)UnionMetadata\$(TargetPlatformVersion)\Facade\Windows.winmd</TPVFacadeWinmdPath>
    <!-- Favor a per-SDK Facade winmd. -->
    <FacadeWinmdPath Condition="'$(FacadeWinmdPath)' == '' AND Exists('$(TPVFacadeWinmdPath)')">$(TPVFacadeWinmdPath)</FacadeWinmdPath>
    <!-- If we can't find a per-SDK Facade winmd, use the one we used before. -->
    <FacadeWinmdPath Condition="'$(FacadeWinmdPath)' == ''">$(WindowsSdkPath)UnionMetadata\facade\Windows.winmd</FacadeWinmdPath>
    <XamlLanguage Condition="'$(XamlLanguage)' == ''">$(Language)</XamlLanguage>
    <!-- If building a C++\WinRT project, we need the cppwinrt.exe compiler to generate an IDL for our metadata provider -->
    <CppWinRTAddXamlMetaDataProviderIdl Condition="$(CppWinRTAddXamlMetaDataProviderIdl) != 'false'">true</CppWinRTAddXamlMetaDataProviderIdl>
    <!-- Turning CppWinRTHeapEnforcement back on by default for Xaml Projects.
         It had been previously turned off because of a bug in compiler code-gen. -->
    <CppWinRTHeapEnforcement Condition="'$(CppWinRTHeapEnforcement)' == ''">true</CppWinRTHeapEnforcement>
    <!-- Assume we're managed by default -->
    <IsNativeLanguage Condition="'$(IsNativeLanguage)' == ''">false</IsNativeLanguage>
    <IsNativeLanguage Condition="'$(IsNativeLanguage)' == 'false' AND '$(Language)' == 'C++'">true</IsNativeLanguage>
    <!-- If DisableGenXbfLineInfo is explicitly set, we should respect that value -->
    <!-- Otherwise, only enable XBF line info for debug builds -->
    <DisableXbfLineInfo Condition="'$(DisableXbfLineInfo)' == '' AND '$(Configuration)' != 'Debug'">true</DisableXbfLineInfo>
    <DisableXbfLineInfo Condition="'$(DisableXbfLineInfo)' == ''">false</DisableXbfLineInfo>
    <!-- EnableCsWinRTXamlCompilerGeneration is always false by default (this matches the behavior of legacy UWP, so the codegen is not affected there).
         On modern UWP (ie. .NET 8 and above), it is set by 'Microsoft.Windows.UI.Xaml.ModernNET.CSharp.targets', which ships in Visual Studio. -->
    <EnableCsWinRTXamlCompilerGeneration Condition="'$(EnableCsWinRTXamlCompilerGeneration)' == ''">false</EnableCsWinRTXamlCompilerGeneration>
    <!-- ReduceGeneratedXamlTypeStaticInitializers is always false by default. It's an opt-in set by the .targets in VS, when appropriate.
         The existing behavior of UWP apps (both legacy UWP and using CsWinRT) never changes unless that property is explicitly set. -->
    <ReduceGeneratedXamlTypeStaticInitializers Condition="'$(ReduceGeneratedXamlTypeStaticInitializers)' == ''">false</ReduceGeneratedXamlTypeStaticInitializers>
    <!-- EnableRequiredAndInitOnlyFeatureSupport is also false by default, matching the original behavior for pre-C# 9 syntax.
         This opt-in support should only be enabled by projects referencing modern .NET, as supporting types needs to be present
         in corelib for the logic to work. If they're not present, things will still work, but this flag will just not do anything. -->
    <EnableRequiredAndInitOnlyFeatureSupport Condition="'$(EnableRequiredAndInitOnlyFeatureSupport)' == ''">false</EnableRequiredAndInitOnlyFeatureSupport>
    <!-- DisableXamlRootsLogGeneration allows projects to opt-out of the default generation of the XAML roots log file. This is usually
         always generated for managed projects. However, the .xml file is specifically only used by .NET Native, and relies on the XAML
         type info reflection infrastructure. Projects using modern .NET might want to opt-out, since the file will not be used.
         This can simplify automatic NuGet packing for library authors. -->
    <DisableXamlRootsLogGeneration Condition="'$(DisableXamlRootsLogGeneration)' == ''">false</DisableXamlRootsLogGeneration>
    <!-- Type info reflection for CppWinRT isn't supported yet, always disable it.  Additionally, disable it for CX until the implementation stabilizes -->
    <!-- This leaves type info reflection enabled for C# and VB -->
    <EnableTypeInfoReflection Condition="'$(XamlLanguage)' == 'CppWinRT' OR '$(XamlLanguage)' == 'C++'">false</EnableTypeInfoReflection>
    <!-- Type info reflection is also not supported when using CsWinRT, so also disable it in this case (this matches the .NET Native behavior) -->
    <EnableTypeInfoReflection Condition="'$(EnableCsWinRTXamlCompilerGeneration)' == 'true'">false</EnableTypeInfoReflection>
    <!-- By default, we only enable type info reflection for debug CoreCLR builds.  We should respect if a project wants to enable/disable it in other cases -->
    <EnableTypeInfoReflection Condition="'$(EnableTypeInfoReflection)' == '' AND '$(Configuration)' == 'Debug' AND '$(UseDotNetNativeToolChain)' != 'true'">true</EnableTypeInfoReflection>
    <EnableTypeInfoReflection Condition="'$(EnableTypeInfoReflection)' == ''">false</EnableTypeInfoReflection>
    <!-- By default, XBindDiagnostics should not be generated on builds where E&C and Designer are likely not going to run -->
    <EnableXBindDiagnostics Condition="'$(EnableXBindDiagnostics)' == '' and '$(DisableXbfLineInfo)' == 'false'">true</EnableXBindDiagnostics>
    <!-- If EnableDefaultValidationContextGeneration is set, respect that value. Otherwise, we always generate it-->
    <EnableDefaultValidationContextGeneration Condition="'$(EnableDefaultValidationContextGeneration)' == ''">true</EnableDefaultValidationContextGeneration>
  </PropertyGroup>
  <!-- When using reflection for our metadata provider, we need to include the reflection helper DLL which is in the same folder as this targets file -->
  <Choose>
    <When Condition="'$(EnableTypeInfoReflection)' == 'true'">
      <ItemGroup>
        <Reference Include="Microsoft.UI.Xaml.Markup">
          <HintPath>$(MSBuildThisFileDirectory)Microsoft.UI.Xaml.Markup.winmd</HintPath>
        </Reference>
      </ItemGroup>
    </When>
  </Choose>
  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="PRIResource" />
    <AvailableItemName Include="AppxManifest" />
    <AvailableItemName Include="ApplicationDefinition" />
    <AvailableItemName Include="Page" />
    <AvailableItemName Include="DesignData" />
    <AvailableItemName Include="DesignDataWithDesignTimeCreatableTypes" />
  </ItemGroup>
  <ItemGroup>
    <ProjectCapability Include="WindowsXaml" />
    <ProjectCapability Include="WindowsXamlPage" />
    <ProjectCapability Include="WindowsXamlCodeBehind" />
    <ProjectCapability Include="WindowsXamlResourceDictionary" />
    <ProjectCapability Include="WindowsXamlUserControl" />
    <ProjectCapability Include="WindowsUniversalMultiViews" />
  </ItemGroup>
  <!-- For Managed Assemblies Create a XAML Roots Log -->
  <PropertyGroup Condition="'$(ManagedAssembly)' != 'false' and '$(DisableXamlRootsLogGeneration)' != 'true'">
    <XamlRootsLog>$(AssemblyName).xr.xml</XamlRootsLog>
  </PropertyGroup>
  <!-- Setting PRI index name.  The XAML compiler use this in the LoadComponent() string.
         It must match the name of the directoy the AppX Packaging system uses -->
  <PropertyGroup>
    <!-- Exe's don't have an PriIndexName -->
    <PriIndexName Condition="'$(AppxPackage)' == 'true'" />
    <!-- Managed Dll's use the "safe" name of the project as the App Package Name -->
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and '$(ManagedAssembly)' != 'false' and '$(OutputType)' != 'winmdobj'">$(TargetName)</PriIndexName>
    <!-- Winmd library targets (managed or native) use the default root namespace of the project for the App package name -->
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and '$(ManagedAssembly)' != 'false' and '$(OutputType)' == 'winmdobj'">$(RootNamespace)</PriIndexName>
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and '$(ManagedAssembly)' == 'false' and '$(RootNamespace)' != ''">$(RootNamespace)</PriIndexName>
    <!-- If RootNamespace is empty fall back to TargetName -->
    <PriIndexName Condition="'$(AppxPackage)' != 'true' and $(PriIndexName) == ''">$(TargetName)</PriIndexName>
    <!-- Optionally override the PRI index name. For instance, this is used by modern UWP to make sure PriIndexName is empty if
         the output is an .exe file. This would not be caught by the previous test cases, because 'AppxPackage' would also be false.
         We allow overriding this externally to make this more flexible, rather than hardcoding a specific case in this .targets file.
    -->
    <PriIndexName Condition="'$(PriIndexNameOverridden)' == 'true'">$(PriIndexNameOverride)</PriIndexName>
  </PropertyGroup>
  <PropertyGroup>
    <AvailablePlatforms>$(AvailablePlatforms),ARM</AvailablePlatforms>
    <!-- this Property is used only for the Managed build.
            See Microsoft.Windows.UI.Xaml.Cpp.Targets for Native build rules -->
    <PrepareResourcesDependsOn>
      ResolveKeySource;
      MarkupCompilePass1;
      XamlPreCompile;
      MarkupCompilePass2;
      $(PrepareResourcesDependsOn)
    </PrepareResourcesDependsOn>
    <Prefer32Bit Condition="'$(Prefer32Bit)' == '' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe')">true</Prefer32Bit>
    <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">true</HighEntropyVA>
    <SubsystemVersion Condition="'$(SubsystemVersion)' == '' and ('$(PlatformTarget)' == 'ARM' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == 'winmdobj')">6.02</SubsystemVersion>
    <SubsystemVersion Condition="'$(SubsystemVersion)' == ''">6.00</SubsystemVersion>
    <OnXamlPreCompileErrorTarget Condition="'$(OnXamlPreCompileErrorTarget)' == ''">_OnXamlPreCompileError</OnXamlPreCompileErrorTarget>
    <!-- Use Intermediate dir if XamlGeneratedOutputPath is not defined -->
    <XamlGeneratedOutputPath Condition="'$(XamlGeneratedOutputPath)' == ''">$(IntermediateOutputPath)</XamlGeneratedOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="$(XamlCompilerTaskPath) == ''">
    <XamlCompilerTaskPath>$(MSBuildThisFileDirectory)Microsoft.Windows.UI.Xaml.Build.Tasks.dll</XamlCompilerTaskPath>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.CompileXaml" AssemblyFile="$(XamlCompilerTaskPath)" />
  <UsingTask TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.AddDefaultXamlLinkMetadata" AssemblyFile="$(XamlCompilerTaskPath)" />
  <UsingTask TaskName="Microsoft.Windows.UI.Xaml.Build.Tasks.GetXamlCppIncludeDirectories" AssemblyFile="$(XamlCompilerTaskPath)" />
  <PropertyGroup>
    <!--If the path to the sign tool is not set, assume the SDK path -->
    <SignToolPath Condition="'$(SignToolPath)' == ''">$(FrameworkSDKRoot)bin</SignToolPath>
    <!--Integration with packaging for GeneratedXamlFilesOutputGroupOutput -->
    <IncludeCustomOutputGroupForPackaging>true</IncludeCustomOutputGroupForPackaging>
  </PropertyGroup>
  <ItemGroup>
    <XamlIntermediateAssembly Condition="'$(ManagedAssembly)'!='false'" Include="$(XamlGeneratedOutputPath)intermediatexaml\$(TargetName)$(TargetExt)" />
    <XamlIntermediateAssembly Condition="'$(ManagedAssembly)'=='false'" Include="$(OutputPath)\$(TargetName).winmd" />
  </ItemGroup>
  <!--
    ============================================================
    Adds all XAML Pages to the $(Resource) collection
    ============================================================
    -->
  <ItemGroup Condition=" '$(ManagedAssembly)'=='' ">
    <!-- Add XAML Page items to $(Resource) -->
    <Resource Include="@(Page)" />
    <Resource Include="@(ApplicationDefinition)" />
  </ItemGroup>
  <!-- Manifest metadata items.                       -->
  <!-- See Microsoft.AppxPackage.targets for details. -->
  <!-- Project binary needs to be updated after updating xaml page -->
  <ItemGroup>
    <CustomAdditionalCompileInputs Include="@(Page)" />
  </ItemGroup>
  <ItemGroup Label="AppxManifestMetadata">
    <AppxManifestMetadata Include="$(XamlCompilerTaskPath)" />
  </ItemGroup>
  <PropertyGroup>
    <MarkupCompilePass1DependsOn>
      XamlAddCppWinRTMergedWinmd;
      GetXamlCppIncludeDirectories;
      $(GetXamlCppIncludeDirectories)
    </MarkupCompilePass1DependsOn>
    <MarkupCompilePass2DependsOn>
      XamlAddCppWinRTMergedWinmd;
      GetXamlCppIncludeDirectories;
      $(GetXamlCppIncludeDirectories)
    </MarkupCompilePass2DependsOn>
    <Prep_ComputeProcessXamlFilesDependsOn>
      XamlAddCppWinRTMergedWinmd;
      GetXamlCppIncludeDirectories;
      $(Prep_ComputeProcessXamlFilesDependsOn)
    </Prep_ComputeProcessXamlFilesDependsOn>
  </PropertyGroup>
  <!-- In order for the XAML compiler to generated the correct relative paths for #includes in
         the generated C++ code it needs to know the AdditionalIncludeDirectories of all the .cpp
         files are DependentUpon XAML files.-->
  <Target Name="GetXamlCppIncludeDirectories" Condition="'$(ManagedAssembly)'=='false' and '$(XamlCppIncludeDirectories)' == ''">
    <GetXamlCppIncludeDirectories ClCompile="@(ClCompile)">
      <Output PropertyName="XamlCppIncludeDirectories" TaskParameter="ComputedIncludeDirectories" />
    </GetXamlCppIncludeDirectories>
  </Target>
  <Target Name="XamlAddCppWinRTMergedWinmd" AfterTargets="CppWinRTMergeProjectWinMDInputs">
    <ItemGroup>
      <XamlCppWinRTLocalAssembly Include="%(_MdMergedOutput.FullPath)" />
    </ItemGroup>
  </Target>
  <!-- 
    ================================================================
                        DesignTimeMarkupCompilation
                        
    Support for the Intellisense build
    ================================================================
     -->
  <PropertyGroup>
    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true' ">
      DesignTimeMarkupCompilation;
      $(CoreCompileDependsOn)
    </CoreCompileDependsOn>
  </PropertyGroup>
  <Target Name="DesignTimeMarkupCompilation">
    <!-- BuildingProject is used in Managed builds (always true in Native) -->
    <!-- DesignTimeBuild is used in Native builds (always false in Managed) -->
    <CallTarget Condition="'$(BuildingProject)' != 'true' Or $(DesignTimeBuild) == 'true'" Targets="DesignTimeMarkupCompilationCT" />
  </Target>
  <!-- A copy of the first pass, without the WarningLevel manipulation -->
  <Target Name="DesignTimeMarkupCompilationCT" DependsOnTargets="$(MarkupCompilePass1DependsOn)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != '' ">
    <MakeDir Condition="'$(ManagedAssembly)'!='false'" Directories="$(XamlGeneratedOutputPath)intermediatexaml\" />
    <ItemGroup>
      <ReferencePath Condition="'$(IsNativeLanguage)'=='true' and Exists($(FacadeWinmdPath))" Include="$(FacadeWinmdPath)" />
    </ItemGroup>
    <CompileXaml LanguageSourceExtension="$(DefaultLanguageSourceExtension)" Language="$(XamlLanguage)" RootNamespace="$(RootNamespace)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" PriIndexName="$(PriIndexName)" ProjectName="$(XamlProjectName)" IsPass1="True" CodeGenerationControlFlags="$(XamlCodeGenerationControlFlags)" CIncludeDirectories="$(XamlCppIncludeDirectories)" ProjectPath="$(MSBuildProjectFullPath)" OutputPath="$(XamlGeneratedOutputPath)" OutputType="$(OutputType)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" ReferenceAssemblies="@(ReferencePath)" ForceSharedStateShutdown="False" ContinueOnError="True" CompileMode="DesignTimeBuild" XAMLFingerprint="$(XAMLFingerprint)" FingerprintIgnorePaths="$(XAMLFingerprintIgnorePaths)" VCInstallDir="$(VCInstallDir)" SavedStateFile="$(XamlSavedStateFilePath)" SuppressWarnings="$(SuppressXamlWarnings)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" WindowsSdkPath="$(WindowsSdkPath)" XamlResourceMapName="$(XamlResourceMapName)" XamlComponentResourceLocation="$(XamlComponentResourceLocation)" EnableTypeInfoReflection="$(EnableTypeInfoReflection)" EnableXBindDiagnostics="$(EnableXBindDiagnostics)" UsingCsWinRT="$(EnableCsWinRTXamlCompilerGeneration)" ReduceGeneratedXamlTypeStaticInitializers="$(ReduceGeneratedXamlTypeStaticInitializers)" EnableRequiredAndInitOnlyFeatureSupport="$(EnableRequiredAndInitOnlyFeatureSupport)" EnableDefaultValidationContextGeneration="$(EnableDefaultValidationContextGeneration)" CppWinRTLocalAssembly="@(XamlCppWinRTLocalAssembly)">
      <Output Condition=" '$(ManagedAssembly)'!='false' " ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
      <!--
      Add to the list of files written.
      It is used in Microsoft.Common.Targets for a next clean build 
      -->
      <Output ItemName="FileWrites" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="_GeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="_GeneratedXamlFiles" TaskParameter="GeneratedXamlFiles" />
    </CompileXaml>
    <ItemGroup>
      <FileWrites Include="$(XamlSavedStateFilePath)" />
    </ItemGroup>
    <Message Text="(Out) ISenseCodeFiles: '@(_GeneratedCodeFiles)'" />
    <Message Text="(Out) ISenseXamlFiles: '@(_GeneratedXamlFiles)'" />
    <Message Text="(Out) ClCompile: '@(ClCompile)'" Condition="'%(ClCompile.CompilerIteration)' != 'XamlGenerated'" />
    <Message Text="(Out) Compile: '@(Compile)'" />
  </Target>
  <!--   
    ================================================================
                         MarkupCompilePass1
    ================================================================
    -->
  <Target Name="MarkupCompilePass1" DependsOnTargets="$(MarkupCompilePass1DependsOn)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != '' ">
    <MakeDir Condition="'$(ManagedAssembly)'!='false'" Directories="$(XamlGeneratedOutputPath)intermediatexaml\" />
    <ItemGroup>
      <ReferencePath Condition="'$(IsNativeLanguage)'=='true' and Exists($(FacadeWinmdPath))" Include="$(FacadeWinmdPath)" />
    </ItemGroup>
    <CompileXaml LanguageSourceExtension="$(DefaultLanguageSourceExtension)" Language="$(XamlLanguage)" RootNamespace="$(RootNamespace)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" PriIndexName="$(PriIndexName)" ProjectName="$(XamlProjectName)" IsPass1="True" CodeGenerationControlFlags="$(XamlCodeGenerationControlFlags)" ProjectPath="$(MSBuildProjectFullPath)" CIncludeDirectories="$(XamlCppIncludeDirectories)" OutputPath="$(XamlGeneratedOutputPath)" OutputType="$(OutputType)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" ReferenceAssemblies="@(ReferencePath)" ForceSharedStateShutdown="False" CompileMode="RealBuildPass1" XAMLFingerprint="$(XAMLFingerprint)" FingerprintIgnorePaths="$(XAMLFingerprintIgnorePaths)" VCInstallDir="$(VCInstallDir)" SavedStateFile="$(XamlSavedStateFilePath)" SuppressWarnings="$(SuppressXamlWarnings)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" WindowsSdkPath="$(WindowsSdkPath)" XamlResourceMapName="$(XamlResourceMapName)" XamlComponentResourceLocation="$(XamlComponentResourceLocation)" EnableTypeInfoReflection="$(EnableTypeInfoReflection)" EnableXBindDiagnostics="$(EnableXBindDiagnostics)" UsingCsWinRT="$(EnableCsWinRTXamlCompilerGeneration)" ReduceGeneratedXamlTypeStaticInitializers="$(ReduceGeneratedXamlTypeStaticInitializers)" EnableRequiredAndInitOnlyFeatureSupport="$(EnableRequiredAndInitOnlyFeatureSupport)" EnableDefaultValidationContextGeneration="$(EnableDefaultValidationContextGeneration)" CppWinRTLocalAssembly="@(XamlCppWinRTLocalAssembly)">
      <Output Condition=" '$(ManagedAssembly)'!='false' " ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
      <!--
      FileWrites is used in Microsoft.Common.Targets for "Clean" build 
      -->
      <Output ItemName="FileWrites" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXbfFiles" />
      <Output ItemName="_GeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="_GeneratedXamlFiles" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="_GeneratedXbfFiles" TaskParameter="GeneratedXbfFiles" />
    </CompileXaml>
    <ItemGroup>
      <FileWrites Include="$(XamlSavedStateFilePath)" />
    </ItemGroup>
    <Message Text="(Out) GeneratedCodeFiles: '@(_GeneratedCodeFiles)'" />
    <Message Text="(Out) GeneratedXamlFiles: '@(_GeneratedXamlFiles)'" />
    <Message Text="(Out) GeneratedXbfFiles: '@(_GeneratedXbfFiles)'" />
    <Message Text="(Out) ClCompile: '@(ClCompile)'" Condition="'$(ManagedAssembly)'=='false' and '%(ClCompile.CompilerIteration)'!='XamlGenerated'" />
    <Message Text="(Out) Compile: '@(Compile)'" Condition="'$(ManagedAssembly)'!='false'" />
    <PropertyGroup>
      <PrevWarningLevel>$(WarningLevel)</PrevWarningLevel>
      <WarningLevel Condition="'$(SuppressWarningsInPass1)'=='true'">0</WarningLevel>
    </PropertyGroup>
  </Target>
  <!--   
    ================================================================
                         MarkupCompilePass2
    ================================================================
    -->
  <Target Name="MarkupCompilePass2" DependsOnTargets="$(MarkupCompilePass2DependsOn)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != '' ">
    <PropertyGroup>
      <WarningLevel>$(PrevWarningLevel)</WarningLevel>
      <WarningLevel Condition="'$(WarningLevel)' == '' and '$(ExplicitResetWarningSuppression)' == 'true'">1</WarningLevel>
    </PropertyGroup>
    <!-- The Name of the Local Assembly in Managed and Native -->
    <PropertyGroup>
      <LocalAssembly Condition="'$(LocalAssembly)' == '' and Exists(@(XamlIntermediateAssembly))">
        @(XamlIntermediateAssembly->'%(Identity)')
      </LocalAssembly>
      <XamlLocalAssembly Condition="'$(XamlLocalAssembly)' == ''">$(LocalAssembly)</XamlLocalAssembly>
    </PropertyGroup>
    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput_xaml" />
    </CallTarget>
    <ItemGroup>
      <SdkXamlItems Include="@(_SDKRedistOutputGroupOutput_xaml)" Condition="'%(Extension)'=='.xaml'" />
    </ItemGroup>
    <ItemGroup>
      <!-- C++ provides a filtered Item that eliminates any Managed Assemblies on the ReferencePath (from SDKs for example) -->
      <XamlReferencesToCompile Condition="'$(IsNativeLanguage)'=='true'" Include="@(WinMDReferenceToCompile)" />
      <XamlReferencesToCompile Condition="'$(IsNativeLanguage)'=='true' and Exists($(FacadeWinmdPath))" Include="$(FacadeWinmdPath)" />
      <XamlReferencesToCompile Condition="'$(IsNativeLanguage)'!='true'" Include="@(ReferencePath)" />
    </ItemGroup>
    <CompileXaml LanguageSourceExtension="$(DefaultLanguageSourceExtension)" Language="$(XamlLanguage)" RootNamespace="$(RootNamespace)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" SdkXamlPages="@(SdkXamlItems)" PriIndexName="$(PriIndexName)" ProjectName="$(XamlProjectName)" IsPass1="False" DisableXbfGeneration="$(DisableXbfGeneration)" DisableXbfLineInfo="$(DisableXbfLineInfo)" CodeGenerationControlFlags="$(XamlCodeGenerationControlFlags)" ClIncludeFiles="@(ClInclude)" CIncludeDirectories="$(XamlCppIncludeDirectories)" LocalAssembly="$(XamlLocalAssembly)" ProjectPath="$(MSBuildProjectFullPath)" OutputPath="$(XamlGeneratedOutputPath)" OutputType="$(OutputType)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" ReferenceAssemblies="@(XamlReferencesToCompile)" ForceSharedStateShutdown="False" CompileMode="RealBuildPass2" XAMLFingerprint="$(XAMLFingerprint)" FingerprintIgnorePaths="$(XAMLFingerprintIgnorePaths)" VCInstallDir="$(VCInstallDir)" WindowsSdkPath="$(WindowsSdkPath)" SavedStateFile="$(XamlSavedStateFilePath)" RootsLog="$(XamlRootsLog)" SuppressWarnings="$(SuppressXamlWarnings)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" XamlResourceMapName="$(XamlResourceMapName)" XamlComponentResourceLocation="$(XamlComponentResourceLocation)" PlatformXmlDir="$(PlatformXmlDir)" EnableTypeInfoReflection="$(EnableTypeInfoReflection)" EnableXBindDiagnostics="$(EnableXBindDiagnostics)" UsingCsWinRT="$(EnableCsWinRTXamlCompilerGeneration)" ReduceGeneratedXamlTypeStaticInitializers="$(ReduceGeneratedXamlTypeStaticInitializers)" EnableRequiredAndInitOnlyFeatureSupport="$(EnableRequiredAndInitOnlyFeatureSupport)" EnableDefaultValidationContextGeneration="$(EnableDefaultValidationContextGeneration)" CppWinRTLocalAssembly="@(XamlCppWinRTLocalAssembly)">
      <Output Condition=" '$(ManagedAssembly)'!='false' " ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
      <Output Condition=" '$(ManagedAssembly)'=='false' " ItemName="XamlGFiles" TaskParameter="GeneratedCodeFiles" />
      <!--
      FileWrites is used in Microsoft.Common.Targets for "Clean" build 
      -->
      <Output ItemName="FileWrites" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXbfFiles" />
      <Output ItemName="FileWrites" TaskParameter="GeneratedXamlPagesFiles" />
      <Output ItemName="_GeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
      <Output ItemName="_GeneratedXamlFiles" TaskParameter="GeneratedXamlFiles" />
      <Output ItemName="_GeneratedXbfFiles" TaskParameter="GeneratedXbfFiles" />
      <Output ItemName="GeneratedXamlPagesFiles" TaskParameter="GeneratedXamlPagesFiles" />
    </CompileXaml>
    <ItemGroup>
      <FileWrites Include="$(XamlSavedStateFilePath)" />
      <FileWrites Condition="'$(XamlRootsLog)' != ''" Include="$(XamlRootsLog)" />
    </ItemGroup>
    <Message Text="(Out) GeneratedCodeFiles: '@(_GeneratedCodeFiles)'" />
    <Message Text="(Out) GeneratedXamlFiles: '@(_GeneratedXamlFiles)'" />
    <Message Text="(Out) GeneratedXbfFiles: '@(_GeneratedXbfFiles)'" />
    <Message Text="(Out) GeneratedXamlPagesFiles: '@(GeneratedXamlPagesFiles)'" />
    <Message Text="(Out) ClCompile: '@(ClCompile)'" Condition="'$(ManagedAssembly)'=='false'" />
    <Message Text="(Out) Compile: '@(Compile)'" Condition="'$(ManagedAssembly)'!='false'" />
    <ItemGroup>
      <ClCompile Include="@(GeneratedXamlPagesFiles)">
        <CompilerIteration>XamlGenerated</CompilerIteration>
      </ClCompile>
    </ItemGroup>
  </Target>
  <Target Name="_OnXamlPreCompileError" DependsOnTargets="$(_OnXamlPrecompileErrorDependsOn)">
    <CompileXaml ProjectPath="$(MSBuildProjectFullPath)" Language="$(XamlLanguage)" LanguageSourceExtension="$(DefaultLanguageSourceExtension)" OutputPath="$(XamlGeneratedOutputPath)" ReferenceAssemblies="@(ReferencePath)" ReferenceAssemblyPaths="@(ReferenceAssemblyPaths)" XamlPages="@(Page)" XamlApplications="@(ApplicationDefinition)" ForceSharedStateShutdown="True" CompileMode="OnErrorShutdown" SavedStateFile="$(XamlSavedStateFilePath)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)" XamlResourceMapName="$(XamlResourceMapName)" XamlComponentResourceLocation="$(XamlComponentResourceLocation)" />
  </Target>
  <Target Name="Prep_ComputeProcessXamlFiles" Condition="'@(ApplicationDefinition)'!='' or '@(Page)'!=''" DependsOnTargets="$(Prep_ComputeProcessXamlFilesDependsOn)">
    <!-- collect all the XAML pages from the Project file into one Item -->
    <ItemGroup>
      <AllProjectXamlPages Condition="'%(ApplicationDefinition.ExcludedFromBuild)'!='true'" Include="@(ApplicationDefinition)" />
      <AllProjectXamlPages Condition="'%(Page.ExcludedFromBuild)'!='true'" Include="@(Page)" />
    </ItemGroup>
    <!-- For items are outside the project core Link metadata tells us what the apparent project path should be.
         C++ doesn't use Link data, so for C++ add implied DefaultXamlLink metadata based on the Include Path -->
    <AddDefaultXamlLinkMetadata Condition="'$(ManagedAssembly)'=='false'" ProjectPath="$(ProjectPath)" XamlPages="@(AllProjectXamlPages)" CIncludeDirectories="$(XamlCppIncludeDirectories)">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AddDefaultXamlLinkMetadata>
    <!-- Remove the Items named in _Temp, then add the actual items from _Temp, then clear _Temp  -->
    <ItemGroup>
      <AllProjectXamlPages Remove="@(_Temp)" />
      <AllProjectXamlPages Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- transfer the DefaultXamlLink data to the Link attribute -->
    <ItemGroup>
      <AllProjectXamlPages Condition="'%(AllProjectXamlPages.DefaultXamlLink)'!=''">
        <Link>%(AllProjectXamlPages.DefaultXamlLink)</Link>
      </AllProjectXamlPages>
    </ItemGroup>
    <!-- Compute the Generated XAML source path and the bin dir Destination path -->
    <!-- If there is a Link use that, otherwise use the Given path from the Project file Item -->
    <ItemGroup>
      <GeneratedXamlSrc0 Condition="'%(AllProjectXamlPages.Link)'!=''" Include="@(AllProjectXamlPages->'$(XamlGeneratedOutputPath)%(Link)')" />
      <GeneratedXamlSrc0 Condition="'%(AllProjectXamlPages.Link)'==''" Include="@(AllProjectXamlPages->'$(XamlGeneratedOutputPath)%(Identity)')" />
      <GeneratedXamlDest0 Condition="'%(AllProjectXamlPages.Link)'!=''" Include="@(AllProjectXamlPages->'$(OutputPath)\%(Link)')" />
      <GeneratedXamlDest0 Condition="'%(AllProjectXamlPages.Link)'==''" Include="@(AllProjectXamlPages->'$(OutputPath)\%(Identity)')" />
    </ItemGroup>
    <!-- Swap in the XBF suffix if appropriate. -->
    <ItemGroup Condition="'$(DisableXbfGeneration)' == 'true'">
      <GeneratedXamlSrc Include="@(GeneratedXamlSrc0)" />
      <GeneratedXamlDest Include="@(GeneratedXamlDest0)" />
    </ItemGroup>
    <ItemGroup Condition="'$(DisableXbfGeneration)' != 'true'">
      <GeneratedXamlSrc Include="%(GeneratedXamlSrc0.RelativeDir)%(GeneratedXamlSrc0.Filename).xbf" />
      <GeneratedXamlDest Include="%(GeneratedXamlDest0.RelativeDir)%(GeneratedXamlDest0.Filename).xbf" />
    </ItemGroup>
    <!-- if we converted SDK XAML into XBF, add the XBF to the list, and remove the XAML from the list -->
    <ItemGroup Condition="'$(DisableXbfGeneration)' != 'true' and '@(SdkXamlItems)' != ''">
      <GeneratedSdkXamlSrc0 Include="@(SdkXamlItems->'$(XamlGeneratedOutputPath)%(TargetPath)')" />
      <GeneratedSdkXamlDest0 Include="@(SdkXamlItems->'$(OutputPath)\%(TargetPath)')" />
      <GeneratedXamlSrc Include="%(GeneratedSdkXamlSrc0.RelativeDir)%(GeneratedSdkXamlSrc0.Filename).xbf">
        <ReferenceSourceTarget>ExpandSDKReference</ReferenceSourceTarget>
      </GeneratedXamlSrc>
      <GeneratedXamlDest Include="%(GeneratedSdkXamlDest0.RelativeDir)%(GeneratedSdkXamlDest0.Filename).xbf">
        <ReferenceSourceTarget>ExpandSDKReference</ReferenceSourceTarget>
      </GeneratedXamlDest>
      <RemoveSdkFilesFromAppxPackage Include="@(SdkXamlItems)" />
    </ItemGroup>
    <ItemGroup Condition="'$(XamlRootsLog)' != ''">
      <GeneratedXamlSrc Include="$(XamlGeneratedOutputPath)\$(XamlRootsLog)" />
      <GeneratedXamlDest Include="$(OutputPath)\$(XamlRootsLog)" />
    </ItemGroup>
    <Message Importance="low" Text="(Out) Prep_GeneratedXamlSrc == @(GeneratedXamlSrc)" />
    <Message Importance="low" Text="(Out) Prep_GeneratedXamlDest == @(GeneratedXamlDest)" />
  </Target>
  <!-- if $GenerateLibraryLayout is True this is skipped and see the PrepareLibraryLayout target -->
  <Target Name="CopyGeneratedXaml" BeforeTargets="CopyFilesToOutputDirectory" DependsOnTargets="Prep_ComputeProcessXamlFiles" Condition="'$(GenerateLibraryLayout)' != 'true'">
    <Copy SourceFiles="@(GeneratedXamlSrc)" DestinationFiles="@(GeneratedXamlDest)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" />
    <ItemGroup>
      <FileWrites Include="@(GeneratedXamlDest)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeProcessXamlFiles" Returns="@(ProcessedXamlFiles)" DependsOnTargets="Prep_ComputeProcessXamlFiles">
    <ItemGroup>
      <!-- In the normal (non-SDK) build, AppX Packaging picks up the files from the bin aka OutputPath folder -->
      <ProcessedXamlFiles Condition="'$(GenerateLibraryLayout)' != 'true'" Include="@(GeneratedXamlDest)" />
      <!-- In the SDK build, AppX Packaging picks up the files from the XamlGeneratedOutput folder -->
      <!-- For SDK builds include both the XAML and XBF -->
      <ProcessedXamlFiles Condition="'$(GenerateLibraryLayout)' == 'true'" Include="@(GeneratedXamlSrc)" />
      <ProcessedXamlFiles Condition="'$(GenerateLibraryLayout)' == 'true' and '$(DisableXbfGeneration)' != 'true'" Include="@(GeneratedXamlSrc0)" />
    </ItemGroup>
    <Message Importance="Low" Text="(Out) GeneratedXamlDest == @(GeneratedXamlDest)" />
    <Message Importance="Low" Text="(Out) GeneratedXamlSrc == @(GeneratedXamlSrc)" />
    <Message Text="(Out) ProcessedXamlFiles == @(ProcessedXamlFiles)" />
  </Target>
  <Target Name="CustomOutputGroupForPackaging" DependsOnTargets="ComputeProcessXamlFiles" Returns="@(CustomOutputGroupForPackagingOutput)">
    <ItemGroup>
      <ProcessedXamlFilesFullPath Include="@(ProcessedXamlFiles->'%(FullPath)')" />
    </ItemGroup>
    <PropertyGroup>
      <XamlPackagingRootFolder Condition="'$(GenerateLibraryLayout)' == 'true'">$(XamlGeneratedOutputPath)</XamlPackagingRootFolder>
      <XamlPackagingRootFolder Condition="'$(GenerateLibraryLayout)' != 'true'">$(OutputPath)\</XamlPackagingRootFolder>
    </PropertyGroup>
    <AssignTargetPath Files="@(ProcessedXamlFilesFullPath)" RootFolder="$(XamlPackagingRootFolder)">
      <Output TaskParameter="AssignedFiles" ItemName="CustomOutputGroupForPackagingOutput" />
    </AssignTargetPath>
    <Message Text="(Out) Project='$(MsBuildProjectName)' ProcessedXamlFiles == @(ProcessedXamlFiles)" />
    <Message Text="(Out) XamlPackagingRootFolder == $(XamlPackagingRootFolder)" />
    <Message Text="(Out) ProcessedXamlFilesFullPath == @(ProcessedXamlFilesFullPath)" />
    <Message Text="(Out) Project='$(MsBuildProjectName)' CustomOutputGroupForPackagingOutput == @(CustomOutputGroupForPackagingOutput)" />
  </Target>
  <PropertyGroup>
    <PrepareLibraryLayoutDependsOn>
      GetPackagingOutputs;
      $(PrepareLibraryLayoutDependsOn)
    </PrepareLibraryLayoutDependsOn>
  </PropertyGroup>
  <!-- This builds the Bin Folder for DLL's that wish to have the SDK type layout -->
  <Target Name="PrepareLibraryLayout" Condition="'$(GenerateLibraryLayout)' == 'true'" DependsOnTargets="$(PrepareLibraryLayoutDependsOn)" BeforeTargets="CopyFilesToOutputDirectory">
    <ItemGroup>
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup'" />
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging'" />
    </ItemGroup>
    <Copy SourceFiles="@(_LayoutFile)" DestinationFiles="@(_LayoutFile->'$(OutputPath)\%(TargetPath)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" />
  </Target>
  <!--
    ============================================================
    Properties and Targets Common to Managed .NETCore projects
    ============================================================
    -->
  <!--
      The ImplicitlyExpandTargetFramework target will expand all 
      of the dll reference assemblies in the TargetFrameworkDirectory 
      for the project and place the items into the ReferencePath itemgroup 
      which contains resolved items.
    -->
  <PropertyGroup>
    <ResolveReferencesDependsOn>
      $(ResolveReferencesDependsOn);
      ImplicitlyExpandTargetFramework;
      ImplicitlyExpandTargetPlatform
    </ResolveReferencesDependsOn>
    <ImplicitlyExpandTargetFrameworkDependsOn>
      $(ImplicitlyExpandTargetFrameworkDependsOn);
      GetReferenceAssemblyPaths
    </ImplicitlyExpandTargetFrameworkDependsOn>
  </PropertyGroup>
  <Target Name="ImplicitlyExpandTargetFramework" Condition="'$(ImplicitlyExpandTargetFramework)' == 'true'" DependsOnTargets="$(ImplicitlyExpandTargetFrameworkDependsOn)">
    <ItemGroup>
      <ReferenceAssemblyPaths Include="$(_TargetFrameworkDirectories)" />
      <ReferencePath Include="%(ReferenceAssemblyPaths.Identity)*.dll">
        <WinMDFile>false</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGroupingDisplayName>.NET for Windows Store apps</ReferenceGroupingDisplayName>
        <ReferenceGrouping>$(TargetFrameworkMoniker)</ReferenceGrouping>
        <ResolvedFrom>ImplicitlyExpandTargetFramework</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </ReferencePath>
    </ItemGroup>
    <Message Importance="Low" Text="TargetMonikerDisplayName: $(TargetFrameworkMonikerDisplayName) ReferenceAssemblyPaths: @(ReferenceAssemblyPaths)" />
    <Message Importance="Low" Text="Including @(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
    <ItemGroup>
      <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandTargetFramework'" />
    </ItemGroup>
  </Target>
  <!--
      The ImplicitlyExpandTargetPlatform target will find the 
      appropriate platform in the requested SDK, gather the 
      list of references for that platform, and add them to the
      ReferencePath item which is the ItemGroup which contains
      resolved paths to pass to e.g. the compiler. 
    -->
  <Target Name="ImplicitlyExpandTargetPlatform" Condition="'$(ImplicitlyExpandTargetPlatform)' == 'true'">
    <ItemGroup>
      <_TargetPlatformWinMDs Condition="'$(TargetPlatformWinMDLocation)' != ''" Include="$(TargetPlatformWinMDLocation)\**\*.winmd">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>ImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </_TargetPlatformWinMDs>
      <_TargetPlatformWinMDs Condition="'$(TargetPlatformSdkRootOverride)' != '' AND '$(TargetPlatformWinMDLocation)' == ''" Include="$(TargetPlatformSdkRootOverride)\References\$(XeWin10TargetVersion)\**\*.winmd">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>ImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </_TargetPlatformWinMDs>
      <_TargetPlatformWinMDs Condition="'$(TargetPlatformSdkRootOverride)' == '' AND '$(TargetPlatformWinMDLocation)' == ''" Include="$([Microsoft.Build.Utilities.ToolLocationHelper]::GetTargetPlatformReferences($(SDKIdentifier), $(SDKVersion), $(TargetPlatformIdentifier), $(TargetPlatformMinVersion), $(TargetPlatformVersion)))">
        <WinMDFile>true</WinMDFile>
        <CopyLocal>false</CopyLocal>
        <ReferenceGrouping>$(TargetPlatformMoniker)</ReferenceGrouping>
        <ReferenceGroupingDisplayName>$(TargetPlatformDisplayName)</ReferenceGroupingDisplayName>
        <ResolvedFrom>ImplicitlyExpandTargetPlatform</ResolvedFrom>
        <IsSystemReference>True</IsSystemReference>
      </_TargetPlatformWinMDs>
    </ItemGroup>
    <Warning Condition="'@(_TargetPlatformWinMDs)' == ''" Text="Could not find target platform winmds for the SDK specified by [$(SDKIdentifier), $(SDKVersion), $(TargetPlatformIdentifier), $(TargetPlatformMinVersion), $(TargetPlatformVersion)]" />
    <Message Importance="Low" Text="Including @(_TargetPlatformWinMDs)" />
    <ItemGroup>
      <ReferencePath Include="@(_TargetPlatformWinMDs)" />
      <ReferencePath Include="$(FacadeWinmdPath)" Condition="Exists($(FacadeWinmdPath))" />
      <_ResolveAssemblyReferenceResolvedFiles Include="@(_TargetPlatformWinMDs)" />
      <!-- Clear out 'temporary' variable -->
      <_TargetPlatformWinMDs Remove="@(_TargetPlatformWinMDs)" />
    </ItemGroup>
  </Target>
  <!-- 
      Enable warning when referenced projects have higher version than the current project
      for Windows Store projects 
    -->
  <PropertyGroup>
    <FindInvalidProjectReferences Condition="'$(TargetPlatformIdentifier)' == 'Windows' and &#xD;&#xA;                                              '$(TargetPlatformVersion)' &gt;= '8.0'">true</FindInvalidProjectReferences>
  </PropertyGroup>
  <!-- 
      Enable warning when referenced ESDKs do not have MaxPlatformVersion 
      specified for Windows Store projects 
    -->
  <PropertyGroup>
    <SDKReferenceWarnOnMissingMaxPlatformVersion Condition="'$(SDKReferenceWarnOnMissingMaxPlatformVersion)' == '' and &#xD;&#xA;                                                             '$(TargetPlatformIdentifier)' == 'Windows' and &#xD;&#xA;                                                             '$(TargetPlatformVersion)' &gt;= '8.0'">true</SDKReferenceWarnOnMissingMaxPlatformVersion>
  </PropertyGroup>
  <!--<Import Project="ImportAfter\*" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\8.21\Microsoft.Windows.UI.Xaml.Common.targets
============================================================================================================================================
-->
  <!--
      Ensure that UAP headless applications' WINMDs are resolved so that GenerateAppxManifest has the required
      metadata to generate activatableClass extensions.  This should only execute for non-EXE projects that have
      <ContainsStartupTask>true</ContainsStartupTask> and create APPX packages.
  -->
  <Target Name="_ResolvePrimaryProjectWinmdFiles" BeforeTargets="BeforeGenerateAppxManifest" AfterTargets="_GetPackagingOutputs" Condition="'$(OutputType)' != 'exe' and '$(AppxPackage)' == 'true' AND '$(ContainsStartupTask)' == 'true'">
    <ItemGroup>
      <_AppxWinmdFilesToHarvest Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'&#xD;&#xA;                                             and '%(PackagingOutputs.ProjectName)' == '$(ProjectName)'&#xD;&#xA;                                             and '%(PackagingOutputs.ResolvedFrom)' != 'GetSDKReferenceFiles'">
        <!-- This covers the Managed Background Application winmd which does NOT have a WinMDFileType value set -->
        <ImageRuntime Condition="'$(PrimaryProjectWinmdImageRuntimeOverride)' == ''">WindowsRuntime 1.4;CLR v4.0.30319</ImageRuntime>
        <!-- This covers the C++ Background Application winmd which does NOT have a WinMDFileType value set -->
        <ImageRuntime Condition="'$(PrimaryProjectWinmdImageRuntimeOverride)' == ''&#xD;&#xA;                                 and '@(Language)' == 'C++'">WindowsRuntime 1.4</ImageRuntime>
        <!-- This covers Managed Windows Runtime Component winmds -->
        <ImageRuntime Condition="'$(PrimaryProjectWinmdImageRuntimeOverride)' == ''&#xD;&#xA;                                 and '%(PackagingOutputs.WinMDFileType)' == 'Managed'">WindowsRuntime 1.4;CLR v4.0.30319</ImageRuntime>
        <!-- This covers Native Windows Runtime Component winmds -->
        <ImageRuntime Condition="'$(PrimaryProjectWinmdImageRuntimeOverride)' == ''&#xD;&#xA;                                 and '%(PackagingOutputs.WinMDFileType)' == 'Native'">WindowsRuntime 1.4</ImageRuntime>
        <!-- This covers Native Windows Runtime Component winmds for DynamicLibrary projects -->
        <ImageRuntime Condition="'$(PrimaryProjectWinmdImageRuntimeOverride)' == ''&#xD;&#xA;                                 and '%(PackagingOutputs.ProjectType)' == 'DynamicLibrary'">WindowsRuntime 1.4</ImageRuntime>
        <!-- This provides an override -->
        <ImageRuntime Condition="'$(PrimaryProjectWinmdImageRuntimeOverride)' != ''">$(PrimaryProjectWinmdImageRuntimeOverride)</ImageRuntime>
      </_AppxWinmdFilesToHarvest>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <AddProcessedXamlFilesToCopyLocalDependsOn>
      ContentFilesProjectOutputGroup;
      Prep_ComputeProcessXamlFiles;
      $(AddProcessedXamlFilesToCopyLocalDependsOn)
    </AddProcessedXamlFilesToCopyLocalDependsOn>
    <AddProcessedXamlFilesToCopyLocalDependsOn Condition="'$(WindowsAppContainer)' == 'true'">
      _CalculateXbfSupport;
      $(AddProcessedXamlFilesToCopyLocalDependsOn)
    </AddProcessedXamlFilesToCopyLocalDependsOn>
  </PropertyGroup>
  <Target Name="AddProcessedXamlFilesToCopyLocal" Condition="'$(AppxPackage)' != 'true'" DependsOnTargets="$(AddProcessedXamlFilesToCopyLocalDependsOn)" BeforeTargets="GetCopyToOutputDirectoryItems">
    <ItemGroup>
      <_ProcessedXamlFilesToCopyLocal Include="@(GeneratedXamlSrc->'%(FullPath)')" />
      <_ProcessedXamlFilesToCopyLocal Condition="'$(GenerateLibraryLayout)' == 'true' and '$(DisableXbfGeneration)' != 'true'" Include="@(GeneratedXamlSrc0->'%(FullPath)')" />
    </ItemGroup>
    <AssignTargetPath Files="@(_ProcessedXamlFilesToCopyLocal)" RootFolder="$(XamlGeneratedOutputPath)">
      <Output TaskParameter="AssignedFiles" ItemName="_ProcessedXamlFilesToCopyLocalWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Include="@(_ProcessedXamlFilesToCopyLocalWithTargetPath)" Condition="'%(Extension)' != '.xbf' OR ('%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' != 'true')">
        <TargetPath Condition="'$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(_ProcessedXamlFilesToCopyLocalWithTargetPath.TargetPath)</TargetPath>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </_AllChildProjectItemsWithTargetPath>
    </ItemGroup>
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Include="@(ContentFilesProjectOutputGroupOutput)">
        <TargetPath Condition="'$(AppxPriInitialPath)' != ''">$(AppxPriInitialPath)\%(ContentFilesProjectOutputGroupOutput.TargetPath)</TargetPath>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </_AllChildProjectItemsWithTargetPath>
    </ItemGroup>
    <Message Importance="Low" Text="(Out) _ProcessedXamlFilesToCopyLocal == @(_ProcessedXamlFilesToCopyLocal)" />
    <Message Importance="Low" Text="(Out) _XamlFilesToCopyLocal == @(_XamlFilesToCopyLocal)" />
  </Target>
  <!--
       This builds the Bin Folder for DLL's that wish to have the SDK type layout
       This needs to be imported after the Microsoft.Windows.UI.Xaml.Common.targets project as we are overriding it there due to a bug in the DestinationFiles using $(OutputPath) instead of $(OutDir)
  -->
  <Target Name="PrepareLibraryLayout" Condition="'$(GenerateLibraryLayout)' == 'true'" DependsOnTargets="GetPackagingOutputs" BeforeTargets="CopyFilesToOutputDirectory">
    <ItemGroup>
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup'" />
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging'" />
    </ItemGroup>
    <Copy SourceFiles="@(_LayoutFile)" DestinationFiles="@(_LayoutFile->'$(OutDir)\%(TargetPath)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" />
  </Target>
  <!--<Import Project="ImportAfter\*" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\8.21\Microsoft.Windows.UI.Xaml.Cpp.targets
============================================================================================================================================
-->
  <ItemGroup>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)$(LangName)\Cpp.ProjectItemsSchema.xaml" />
  </ItemGroup>
  <!-- Generated files output group population -->
  <PropertyGroup>
    <GeneratedFilesOutputGroupDependsOn>XamlGeneratedFilesOutputGroup;$(GeneratedFilesOutputGroupDependsOn)</GeneratedFilesOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="XamlGeneratedFilesOutputGroup" DependsOnTargets="$(XamlGeneratedFilesOutputGroupDependsOn)" Condition="'@(Page)@(ApplicationDefinition)' != ''">
    <ItemGroup>
      <GeneratedFilesOutputGroup Condition="'%(Page.ExcludedFromBuild)'!='true'" Include="@(Page->'$(XamlGeneratedOutputPath)%(Filename).g.h')" />
      <GeneratedFilesOutputGroup Condition="'%(Page.ExcludedFromBuild)'!='true'" Include="@(Page->'$(XamlGeneratedOutputPath)%(Filename).g.cpp')" />
      <GeneratedFilesOutputGroup Condition="'%(ApplicationDefinition.ExcludedFromBuild)'!='true'" Include="@(ApplicationDefinition->'$(XamlGeneratedOutputPath)%(Filename).g.h')" />
      <GeneratedFilesOutputGroup Condition="'%(ApplicationDefinition.ExcludedFromBuild)'!='true'" Include="@(ApplicationDefinition->'$(XamlGeneratedOutputPath)%(Filename).g.cpp')" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeXamlGeneratedCompileInputs" DependsOnTargets="$(ComputeXamlGeneratedCompileInputsDependsOn)" Condition="'@(Page)@(ApplicationDefinition)' != ''">
    <ItemGroup>
      <ClCompile Include="$(XamlGeneratedOutputPath)XamlTypeInfo.g.cpp">
        <CompilerIteration>XamlGenerated</CompilerIteration>
      </ClCompile>
      <ClCompile Include="$(XamlGeneratedOutputPath)XamlTypeInfo.Impl.g.cpp" />
      <ClCompile Condition="'$(OutputType)' == 'Library'" Include="$(XamlGeneratedOutputPath)XamlLibMetadataProvider.g.cpp" />
    </ItemGroup>
    <!-- The build only wants to generate winmd once, either during Link target or Createwinmd target, not both.  
        Link and Createwinmd targets will execute link.exe, so it is best to run link.exe only once.
        However, there are two cases where that isn't possible.
        1) when build is building XAML and 
        2) when building in passes.  -->
    <PropertyGroup>
      <GenerateBuildCompilePassWinMD Condition="'$(GenerateBuildCompilePassWinMD)' == ''">true</GenerateBuildCompilePassWinMD>
    </PropertyGroup>
  </Target>
  <Target Name="ComputeInvalidXamlGenerated">
    <ItemGroup>
      <!-- Some files dont exists because XAML files do not always generate .g.cpp -->
      <ClCompile Remove="@(ClCompile)" Condition="'%(ClCompile.CompilerIteration)' == 'XamlGenerated' and !Exists('%(Identity)')" />
    </ItemGroup>
  </Target>
  <!-- Add CL generates .obj files to Obj item group, it will be used by lib or link -->
  <Target Name="ComputeXamlGeneratedCLOutputs" DependsOnTargets="ComputeXamlGeneratedCompileInputs;ComputeInvalidXamlGenerated" Condition="'@(ClCompile)' != ''">
    <ItemGroup>
      <!-- Some files dont exists because XAML files do not always generate .g.cpp -->
      <ClCompile Remove="@(ClCompile)" Condition="'%(ClCompile.CompilerIteration)' == 'XamlGenerated' and !Exists('%(Identity)')" />
      <!-- No object file name defined: filename.obj -->
      <Obj Condition="'%(ClCompile.ObjectFileName)'=='' and '%(ClCompile.ExcludedFromBuild)'!='true'" Include="@(ClCompile->'%(Filename).obj')" />
      <!-- Object file name is a directory (has trailing slash): ofn\filename.obj -->
      <Obj Condition="HasTrailingSlash('%(ClCompile.ObjectFileName)') and '%(ClCompile.ExcludedFromBuild)'!='true'" Include="@(ClCompile->'%(ObjectFileName)%(Filename).obj')" />
      <!-- Object file name is a file (does not has trailing slash): ofn -->
      <Obj Condition="'%(ClCompile.ObjectFileName)' != '' and !HasTrailingSlash('%(ClCompile.ObjectFileName)') and '%(ClCompile.ExcludedFromBuild)'!='true'" Include="@(ClCompile->'%(ObjectFileName)')" />
      <Lib Include="@(Obj-&gt;WithMetadataValue('CompilerIteration', 'XamlGenerated')-&gt;ClearMetadata())" />
      <Link Include="@(Obj-&gt;WithMetadataValue('CompilerIteration', 'XamlGenerated')-&gt;ClearMetadata())" />
    </ItemGroup>
  </Target>
  <!-- Enable design time build as well as selected file(s) compile support -->
  <PropertyGroup>
    <EnableDesignTimeBuild>true</EnableDesignTimeBuild>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <Page>
      <GeneratorTarget>DesignTimeMarkupCompilation</GeneratorTarget>
    </Page>
    <ApplicationDefinition>
      <GeneratorTarget>DesignTimeMarkupCompilation</GeneratorTarget>
    </ApplicationDefinition>
  </ItemDefinitionGroup>
  <PropertyGroup>
    <MarkupCompilePass1DependsOn>CppDesignTimeMarkupCompilation;$(MarkupCompilePass1DependsOn)</MarkupCompilePass1DependsOn>
  </PropertyGroup>
  <Target Name="CppDesignTimeMarkupCompilation" DependsOnTargets="_SelectedFiles;SelectCustomBuild;ResolveReferences">
    <!-- Ideally we'd like to be able to build just the requested files (if it makes sense). -->
    <!--<ItemGroup Condition="'@(SelectedFiles)'!=''">
          <Page Remove="@(Page)" Condition="'%(Identity)'!='@(SelectedFiles)'"/>
          <ApplicationDefinition Remove="@(ApplicationDefinition)" Condition="'%(Identity)'!='@(SelectedFiles)'"/>
        </ItemGroup>-->
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\WindowsXaml\v17.0\Microsoft.Windows.UI.Xaml.Cpp.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(DesignTimeBuild)' != 'true'">
    <MarkupCompilePass1DependsOn>$(MarkupCompilePass1DependsOn);_WriteXamlTlogs</MarkupCompilePass1DependsOn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'UAP' And '$(UnitTestPlatformVersion)' != '' and '$(VisualStudioVersion)' != ''">
    <UnitTestPlatformNetVersion Condition="'$(UnitTestPlatformNetVersion)' == '' and $([MSBuild]::VersionGreaterThanOrEquals('$(VisualStudioVersion)','17.0'))">$([System.Version]::Parse($(VisualStudioVersion)).Major).1</UnitTestPlatformNetVersion>
  </PropertyGroup>
  <Target Name="_WriteXamlTlogs" Condition="'@(SelectedFiles)' == ''">
    <ItemGroup Condition="'@(Page)' != ''">
      <_XamlReadTlog Include="^%(Page.FullPath)" Condition="'%(Page.ExcludedFromBuild)' != 'true'" />
    </ItemGroup>
    <ItemGroup Condition="'@(ApplicationDefinition)' != ''">
      <_XamlReadTlog Include="^%(ApplicationDefinition.FullPath)" Condition="'%(ApplicationDefinition.ExcludedFromBuild)' != 'true'" />
    </ItemGroup>
    <WriteLinesToFile Condition="'@(_XamlReadTlog)' != ''" File="$(TLogLocation)Xaml.read.1u.tlog" Lines="@(_XamlReadTlog-&gt;MetaData('Identity')-&gt;ToUpperInvariant());" Overwrite="true" Encoding="Unicode" />
    <Delete Condition="'@(_XamlReadTlog)' == '' and Exists('$(TLogLocation)Xaml.read.1u.tlog')" Files="$(TLogLocation)Xaml.read.1u.tlog" />
    <ItemGroup>
      <_XamlReadTlog Remove="@(_XamlReadTlog)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Analysis.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Analysis.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.Analysis.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Determine which analysis tools are enabled/disabled -->
  <PropertyGroup>
    <RunClangCppAnalysis>false</RunClangCppAnalysis>
    <RunClangCppAnalysis Condition="'$(RunCppAnalysis)'=='true' AND '$(EnableClangTidyCodeAnalysis)'=='true' AND '$(ApplicationType)' != 'Linux'">true</RunClangCppAnalysis>
  </PropertyGroup>
  <Target Name="NoAnalysisToolEnabledWarning" Condition="'$(RunCppAnalysis)'=='true' AND '$(EnableMicrosoftCodeAnalysis)'=='false' AND '$(EnableClangTidyCodeAnalysis)'=='false'" AfterTargets="ClCompile">
    <VCMessage Code="MSB8061" Type="Warning" />
  </Target>
  <!-- ClangTidy Run Code Analysis support -->
  <PropertyGroup Condition="'$(RunClangCppAnalysis)'=='true'">
    <ClangTidyAfterTargets>$(ClangTidyAfterTargets);ClCompile</ClangTidyAfterTargets>
  </PropertyGroup>
  <!-- Special case that runs analysis for selected file compile -->
  <Target Name="RunSelectedFileClangTidy" Condition="'$(RunClangCppAnalysis)'=='true' AND '$(SelectedFiles)'!=''" DependsOnTargets="ClangTidy;AddSarifLogFileMetadata;WriteAnalysisResultManifest" AfterTargets="ClCompile">
    <Message Text="Running clang analysis targets for selected files $(SelectedFiles)" />
  </Target>
  <!-- ClangCl Toolset handling -->
  <!-- Microsoft Code Analysis is not supported with the clang-cl toolset. -->
  <Target Name="MicrosoftAnalysisIncompatiableWithClangCl" Condition="'$(RunCppAnalysis)'=='true' AND '$(EnableMicrosoftCodeAnalysis)'=='true' AND '$(UseClangCl)'=='true'" AfterTargets="ClCompile">
    <VCMessage Code="MSB8060" Type="Error" />
  </Target>
  <PropertyGroup Condition="'$(EnableMicrosoftCodeAnalysis)'=='true' OR '$(EnableClangTidyCodeAnalysis)'=='true'">
    <AnalysisResultManifestFile>$(IntDir)CodeAnalysisResultManifest.txt</AnalysisResultManifestFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RunCppAnalysis)'=='true' AND '$(EnableMicrosoftCodeAnalysis)'=='true' AND '$(VCCodeAnalysisUX)'=='true'">
    <AfterClCompileTargets>$(AfterClCompileTargets);AddSarifLogFileMetadata</AfterClCompileTargets>
    <WriteAnalysisResultManifestDependsOn>$(WriteAnalysisResultManifestDependsOn);AddSarifLogFileMetadata</WriteAnalysisResultManifestDependsOn>
  </PropertyGroup>
  <!-- Special case for individual file compilation. -->
  <Target Name="SelectAnalysisManifest" Condition="'$(RunMsvcAnalysis)'=='true' and '$(SelectedFiles)'!=''" DependsOnTargets="AddSarifLogFileMetadata;WriteAnalysisResultManifest" AfterTargets="SelectClCompile" />
  <PropertyGroup Condition="'$(RunCppAnalysis)'=='true' AND ('$(EnableMicrosoftCodeAnalysis)'=='true' OR '$(EnableClangTidyCodeAnalysis)'=='true') AND '$(VCCodeAnalysisUX)'=='true'">
    <AfterClCompileTargets>$(AfterClCompileTargets);WriteAnalysisResultManifest</AfterClCompileTargets>
  </PropertyGroup>
  <!-- Add Sarif file metadata to each CL item. -->
  <Target Name="AddSarifLogFileMetadata">
    <ItemGroup>
      <ClCompile>
        <SarifLogFile>%(ObjectFileName)%(FileName).nativecodeanalysis.sarif</SarifLogFile>
      </ClCompile>
    </ItemGroup>
  </Target>
  <!-- Create the analysis result manifest file. -->
  <Target Name="WriteAnalysisResultManifest" DependsOnTargets="$(WriteAnalysisResultManifestDependsOn)">
    <Delete Condition="Exists($(AnalysisResultManifestFile))" Files="$(AnalysisResultManifestFile)" />
    <!-- Write CL result paths. -->
    <WriteLinesToFile Condition="'$(EnableMicrosoftCodeAnalysis)'=='true'" File="$(AnalysisResultManifestFile)" Lines="@(ClCompile->'%(SarifLogFile)')" Encoding="Unicode" Overwrite="false" />
    <!-- Write ClangTidy result path. -->
    <WriteLinesToFile Condition="'$(EnableClangTidyCodeAnalysis)'=='true'" File="$(AnalysisResultManifestFile)" Lines="$(IntDir)$(ClangTidyLogFile)" Encoding="Unicode" Overwrite="false" />
    <!-- Write experimental diagnostic result paths. -->
    <WriteLinesToFile Condition="'$(EnableMicrosoftCodeAnalysis)'=='true'" File="$(AnalysisResultManifestFile)" Lines="@(ClCompile->'%(ExpSarifLogFile)')" Encoding="Unicode" Overwrite="false" />
  </Target>
  <!-- Properties page for C++ Code Analysis configuration -->
  <ItemGroup Condition="'$(ConfigurationType)'!='Utility' AND '$(ApplicationType)' != 'Linux'">
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)$(LangID)\code_analysis.xml" />
  </ItemGroup>
  <!-- Experimental tooling diagnostics. -->
  <PropertyGroup Condition="'$(EnableExperimentalDiagnostics)'=='true'">
    <AfterClCompileTargets>$(AfterClCompileTargets);AddExperimentalSarifLogFileMetadata;WriteAnalysisResultManifest</AfterClCompileTargets>
    <OnClCompileErrorTargets>$(OnClCompileErrorTargets);AddExperimentalSarifLogFileMetadata;WriteAnalysisResultManifest</OnClCompileErrorTargets>
    <WriteAnalysisResultManifestDependsOn>$(WriteAnalysisResultManifestDependsOn);AddExperimentalSarifLogFileMetadata</WriteAnalysisResultManifestDependsOn>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(EnableExperimentalDiagnostics)'=='true'">
    <ClCompile>
      <AdditionalOptions>%(AdditionalOptions) /experimental:log$(IntDir)\</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <!-- Add Experimental Sarif file metadata to each CL item. -->
  <Target Name="AddExperimentalSarifLogFileMetadata">
    <ItemGroup>
      <ClCompile>
        <ExpSarifLogFile>%(ObjectFileName)%(FileName).sarif</ExpSarifLogFile>
      </ClCompile>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.ClangTidy.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.ClangTidy.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.ClangTidy.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will impact
          the way you build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="ClangTidy" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <UsingTask TaskName="CLCommandLine" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <!-- *******************************************************************************************
        Clang Tidy Section
       ******************************************************************************************* -->
  <ItemGroup Condition="'$(ConfigurationType)'!='Utility' AND '$(ApplicationType)' != 'Linux'">
    <!-- Properties page for Clang Tidy configuration -->
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)$(LangID)\clangtidy.xml" />
  </ItemGroup>
  <PropertyGroup>
    <ClangTidyDependsOn>
      BeforeClangTidy;
      $(ClangTidyDependsOn);
      AfterClangTidy;
    </ClangTidyDependsOn>
  </PropertyGroup>
  <!-- BeforeClangTidy: Redefine this target in your project in order to run tasks just before ClangTidy. -->
  <Target Name="BeforeClangTidy" />
  <!-- AfterClangTidy: Redefine this target in your project in order to run tasks just after ClangTidy. -->
  <Target Name="AfterClangTidy" />
  <PropertyGroup>
    <ClangTidyLogFile>$(TargetName).ClangTidy.log</ClangTidyLogFile>
    <ClangTidyProjectDirectory>$(TargetName).ClangTidy</ClangTidyProjectDirectory>
  </PropertyGroup>
  <PropertyGroup>
    <ClangAnalysisToolsPath Condition="'$(ClangAnalysisToolsPath)'==''">$(ClangTidyToolPath)</ClangAnalysisToolsPath>
  </PropertyGroup>
  <ItemGroup>
    <CoreClangTidy Include="$(IntDir)" />
    <CoreClangTidy Condition="'$(TLogLocation)' != '$(IntDir)'" Include="$(TLogLocation)" />
  </ItemGroup>
  <Target Name="GetCompileCommands" Returns="@(CompileCommands)" Condition="'@(ClCompile)' != ''">
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntDir)" />
    <ItemGroup>
      <_ClCompile Condition="'%(ClCompile.ExcludedFromBuild)'!='true' and&#xD;&#xA;                             '%(ClCompile.CompilerIteration)' == ''" Include="@(ClCompile)" />
    </ItemGroup>
    <ItemGroup>
      <_ClCompile>
        <!-- add command line options that only clang-tidy compile commands will see -->
        <AdditionalOptions Condition="'$(ClangTidyMergeAdditionalOptions)' != 'false'">$(ClangTidyAdditionalOptions) %(_ClCompile.AdditionalOptions)</AdditionalOptions>
        <AdditionalOptions Condition="'$(ClangTidyMergeAdditionalOptions)' == 'false'">$(ClangTidyAdditionalOptions)</AdditionalOptions>
        <!-- remove precompiled headers as compiler may not match clang-tidy toolset -->
        <PrecompiledHeader />
        <PrecompiledHeaderFile />
        <PrecompiledHeaderOutputFile />
        <!-- remove settings which don't apply to clang -->
        <BrowseInformation />
        <BrowseInformationFile />
        <CompileAsManaged />
        <CompileAsWinRT />
        <DebugInformationFormat />
        <DisableLanguageExtensions />
        <DisableSpecificWarnings />
        <EnableFiberSafeOptimizations />
        <MultiProcessorCompilation />
        <EnableParallelCodeGeneration />
        <EnablePREfast />
        <EnforceTypeConversionRules />
        <ErrorReporting />
        <ExpandAttributedSource />
        <ForceConformanceInForLoopScope />
        <ForcedUsingFiles />
        <GenerateXMLDocumentationFiles />
        <IgnoreStandardIncludePath />
        <MinimalRebuild />
        <OpenMPSupport />
        <PREfastAdditionalOptions />
        <PREfastAdditionalPlugins />
        <PREfastLog />
        <PREfastProjectDirectory />
        <PREfastRulesetDirectories />
        <PREfastRulesetFile />
        <ProgramDataBaseFileName />
        <RemoveUnreferencedCodeData />
        <SDLCheck />
        <SpectreMitigation />
        <StringPooling />
        <SupportJustMyCode />
        <TreatSpecificWarningsAsErrors />
        <TreatWChar_tAsBuiltInType />
        <UseFullPaths />
        <WholeProgramOptimization />
      </_ClCompile>
    </ItemGroup>
    <CLCommandLine Condition="'@(_ClCompile)' != ''" BuildingInIDE="$(BuildingInsideVisualStudio)" Sources="@(_ClCompile)" AdditionalIncludeDirectories="%(_ClCompile.AdditionalIncludeDirectories)" AdditionalOptions="%(_ClCompile.AdditionalOptions)" AdditionalUsingDirectories="%(_ClCompile.AdditionalUsingDirectories)" AssemblerListingLocation="%(_ClCompile.AssemblerListingLocation)" AssemblerOutput="%(_ClCompile.AssemblerOutput)" BasicRuntimeChecks="%(_ClCompile.BasicRuntimeChecks)" BrowseInformation="%(_ClCompile.BrowseInformation)" BrowseInformationFile="%(_ClCompile.BrowseInformationFile)" BufferSecurityCheck="%(_ClCompile.BufferSecurityCheck)" CallingConvention="%(_ClCompile.CallingConvention)" ControlFlowGuard="%(_ClCompile.ControlFlowGuard)" CompileAsManaged="%(_ClCompile.CompileAsManaged)" CompileAsWinRT="%(_ClCompile.CompileAsWinRT)" CompileAs="%(_ClCompile.CompileAs)" ConformanceMode="%(_ClCompile.ConformanceMode)" DebugInformationFormat="%(_ClCompile.DebugInformationFormat)" DiagnosticsFormat="%(_ClCompile.DiagnosticsFormat)" DisableLanguageExtensions="%(_ClCompile.DisableLanguageExtensions)" DisableSpecificWarnings="%(_ClCompile.DisableSpecificWarnings)" EnableEnhancedInstructionSet="%(_ClCompile.EnableEnhancedInstructionSet)" EnableFiberSafeOptimizations="%(_ClCompile.EnableFiberSafeOptimizations)" EnableParallelCodeGeneration="%(_ClCompile.EnableParallelCodeGeneration)" EnablePREfast="%(_ClCompile.EnablePREfast)" EnforceTypeConversionRules="%(_ClCompile.EnforceTypeConversionRules)" ErrorReporting="%(_ClCompile.ErrorReporting)" ExceptionHandling="%(_ClCompile.ExceptionHandling)" ExcludedInputPaths="%(_ClCompile.ExcludedInputPaths)" ExpandAttributedSource="%(_ClCompile.ExpandAttributedSource)" FavorSizeOrSpeed="%(_ClCompile.FavorSizeOrSpeed)" FloatingPointExceptions="%(_ClCompile.FloatingPointExceptions)" FloatingPointModel="%(_ClCompile.FloatingPointModel)" ForceConformanceInForLoopScope="%(_ClCompile.ForceConformanceInForLoopScope)" ForcedIncludeFiles="%(_ClCompile.ForcedIncludeFiles)" ForcedUsingFiles="%(_ClCompile.ForcedUsingFiles)" FunctionLevelLinking="%(_ClCompile.FunctionLevelLinking)" GenerateXMLDocumentationFiles="%(_ClCompile.GenerateXMLDocumentationFiles)" IgnoreStandardIncludePath="%(_ClCompile.IgnoreStandardIncludePath)" InlineFunctionExpansion="%(_ClCompile.InlineFunctionExpansion)" IntrinsicFunctions="%(_ClCompile.IntrinsicFunctions)" LanguageStandard="%(_ClCompile.LanguageStandard)" MinimalRebuild="%(_ClCompile.MinimalRebuild)" MultiProcessorCompilation="%(_ClCompile.MultiProcessorCompilation)" ObjectFileName="%(_ClCompile.ObjectFileName)" OmitDefaultLibName="%(_ClCompile.OmitDefaultLibName)" OmitFramePointers="%(_ClCompile.OmitFramePointers)" OpenMPSupport="%(_ClCompile.OpenMPSupport)" Optimization="%(_ClCompile.Optimization)" PrecompiledHeader="%(_ClCompile.PrecompiledHeader)" PrecompiledHeaderFile="%(_ClCompile.PrecompiledHeaderFile)" PrecompiledHeaderOutputFile="%(_ClCompile.PrecompiledHeaderOutputFile)" PREfastAdditionalOptions="%(_ClCompile.PREfastAdditionalOptions)" PREfastAdditionalPlugins="%(_ClCompile.PREfastAdditionalPlugins)" PREfastLog="%(_ClCompile.PREfastLog)" PREfastRulesetFile="%(_ClCompile.PREfastRulesetFile)" PREfastProjectDirectory="%(_ClCompile.PREfastProjectDirectory)" PREfastRulesetDirectories="%(_ClCompile.PREfastRulesetDirectories)" PreprocessKeepComments="%(_ClCompile.PreprocessKeepComments)" PreprocessorDefinitions="%(_ClCompile.PreprocessorDefinitions)" PreprocessSuppressLineNumbers="%(_ClCompile.PreprocessSuppressLineNumbers)" PreprocessToFile="%(_ClCompile.PreprocessToFile)" ProcessorNumber="%(_ClCompile.ProcessorNumber)" ProgramDataBaseFileName="%(_ClCompile.ProgramDataBaseFileName)" RemoveUnreferencedCodeData="%(_ClCompile.RemoveUnreferencedCodeData)" RuntimeLibrary="%(_ClCompile.RuntimeLibrary)" RuntimeTypeInfo="%(_ClCompile.RuntimeTypeInfo)" SDLCheck="%(_ClCompile.SDLCheck)" ShowIncludes="%(_ClCompile.ShowIncludes)" WarningVersion="%(_ClCompile.WarningVersion)" SmallerTypeCheck="%(_ClCompile.SmallerTypeCheck)" SpectreMitigation="%(_ClCompile.SpectreMitigation)" StringPooling="%(_ClCompile.StringPooling)" StructMemberAlignment="%(_ClCompile.StructMemberAlignment)" SupportJustMyCode="%(_ClCompile.SupportJustMyCode)" SuppressStartupBanner="%(_ClCompile.SuppressStartupBanner)" TreatSpecificWarningsAsErrors="%(_ClCompile.TreatSpecificWarningsAsErrors)" TreatWarningAsError="%(_ClCompile.TreatWarningAsError)" TreatWChar_tAsBuiltInType="%(_ClCompile.TreatWChar_tAsBuiltInType)" UndefineAllPreprocessorDefinitions="%(_ClCompile.UndefineAllPreprocessorDefinitions)" UndefinePreprocessorDefinitions="%(_ClCompile.UndefinePreprocessorDefinitions)" UseFullPaths="%(_ClCompile.UseFullPaths)" UseUnicodeForAssemblerListing="%(_ClCompile.UseUnicodeForAssemblerListing)" WarningLevel="%(_ClCompile.WarningLevel)" WholeProgramOptimization="%(_ClCompile.WholeProgramOptimization)" WinRTNoStdLib="%(_ClCompile.WinRTNoStdLib)" XMLDocumentationFileName="%(_ClCompile.XMLDocumentationFileName)" CreateHotpatchableImage="%(_ClCompile.CreateHotpatchableImage)" TrackerLogDirectory="%(_ClCompile.TrackerLogDirectory)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolPath="$(CLToolPath)" ToolExe="$(CLToolExe)" TrackFileAccess="$(TrackFileAccess)" MinimalRebuildFromTracking="%(_ClCompile.MinimalRebuildFromTracking)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)" TrackedInputFilesToIgnore="@(ClNoDependencies)" DeleteOutputOnExecute="$(CLDeleteOutputOnExecute)" AcceptableNonZeroExitCodes="%(_ClCompile.AcceptableNonZeroExitCodes)" YieldDuringToolExecution="$(ClYieldDuringToolExecution)">
      <Output TaskParameter="CommandLines" ItemName="CompileCommands" />
    </CLCommandLine>
    <ItemGroup>
      <_ClCompile Remove="@(_ClCompile)" />
    </ItemGroup>
  </Target>
  <Target Name="ClangTidy" DependsOnTargets="$(ClangTidyDependsOn);GetCompileCommands" AfterTargets="$(ClangTidyAfterTargets)">
    <ClangTidy Condition="'@(CompileCommands)'!=''" CompileCommands="@(CompileCommands)" OutputFile="$(IntDir)$(ClangTidyLogFile)" BuildPath="$(IntDir)$(ClangTidyProjectDirectory)" AdditionalOptions="$(ClangTidyToolExeAdditionalOptions)" Checks="$(ClangTidyChecks)" HeaderFilter="$(ClangTidyHeaderFilter)" WarningsInSystemHeaders="$(ClangTidyWarningsInSystemHeaders)" ToolPath="$(ClangTidyToolPath)" ToolExe="$(ClangTidyToolExe)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppCommon.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\PlatformToolsets\v143\Toolset.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.WindowsSDK.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.WindowsSDK.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.WindowsSDK.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DesignTimeBuild)' != 'true' and '$(TargetPlatformVersion)' != '7.0' and '$(DisableRegistryUse)' != 'true'">
    <PrepareForBuildDependsOn>_CheckWindowsSDKInstalled;$(PrepareForBuildDependsOn)</PrepareForBuildDependsOn>
  </PropertyGroup>
  <!-- this target is supposed to run only for projects usign Windows SDKs 8.1 and later -->
  <Target Name="_CheckWindowsSDKInstalled" DependsOnTargets="$(_CheckWindowsSDKInstalledDependsOn)">
    <!-- 8.1 -->
    <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.1' and '$(WindowsSDKInstalled)' == '' and '$(WindowsSDK_UAP_Support)' == '' and '$(WindowsSDK_Desktop_Support)' == ''">
      <WindowsSDKInstalled>false</WindowsSDKInstalled>
      <WindowsSDK_UAP_Support>false</WindowsSDK_UAP_Support>
      <WindowsSDK_Desktop_Support>false</WindowsSDK_Desktop_Support>
      <WindowsSDK_UAP_Support Condition="Exists('$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\$(TargetPlatformVersion)\UAP.props')">true</WindowsSDK_UAP_Support>
      <WindowsSDK_Desktop_Support Condition="Exists('$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\Windows.props')">true</WindowsSDK_Desktop_Support>
      <WindowsSDKInstalled Condition="'$(WindowsSDK_UAP_Support)' == 'true' or '$(WindowsSDK_Desktop_Support)' == 'true'">true</WindowsSDKInstalled>
    </PropertyGroup>
    <!-- 10.0 -->
    <PropertyGroup Condition="'$(WindowsSDKInstalled)' == '' and '$(WindowsSDK_UAP_Support)' == '' and '$(WindowsSDK_Desktop_Support)' == ''">
      <WindowsSDKInstalled>false</WindowsSDKInstalled>
      <WindowsSDK_UAP_Support>false</WindowsSDK_UAP_Support>
      <WindowsSDK_Desktop_Support>false</WindowsSDK_Desktop_Support>
      <WindowsSDKInstalled Condition="Exists('$(WindowsSdkDir)\DesignTime\CommonConfiguration\Neutral\UAP\$(TargetPlatformVersion)\UAP.props')">true</WindowsSDKInstalled>
      <!-- Currently we assume that UWP SDK portion is installed when UAP.props is found-->
      <WindowsSDK_UAP_Support> $(WindowsSDKInstalled)</WindowsSDK_UAP_Support>
      <WindowsSDK_Desktop_Support Condition="Exists('$(WindowsSdkDir)\Include\$(TargetPlatformVersion)\shared\sdkddkver.h') and&#xD;&#xA;                                             Exists('$(WindowsSdkDir)\Lib\$(TargetPlatformVersion)\um\$(PlatformTarget)\gdi32.lib')">true</WindowsSDK_Desktop_Support>
    </PropertyGroup>
    <!-- general error message if windows SDK is not installed -->
    <VCMessage Code="MSB8036" Type="Error" Arguments="$(TargetPlatformVersion)" Condition="'$(WindowsSDKInstalled)' != 'true'" />
    <!-- error message for users targeting ARM platform with Windows SDKs that no longer include support for ARM -->
    <VCMessage Code="MSB8087" Type="Error" Arguments="$(TargetPlatformVersion)" Condition="'$(Platform)' == 'ARM' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetPlatformVersion)','$(WindowsSdkVersionARMSupportRemoved)'))" />
    <!-- special error message if Desktop support for a particular platform is not installed -->
    <VCMessage Code="MSB8037" Type="Error" Arguments="$(TargetPlatformVersion);$(PlatformTarget)" Condition="'$(WindowsAppContainer)' != 'true' and '$(WindowsSDK_Desktop_Support)' != true" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\PlatformToolsets\v143\Toolset.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)ImportAfter\*.targets" Condition="Exists('$(MSBuildThisFileDirectory)ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Platform.targets
============================================================================================================================================
-->
  <!-- Import After -->
  <!--<Import Project="$(_PlatformFolder)ImportAfter\*.targets" Condition="'$(_ToolsetFound)' == 'true' and Exists('$(_PlatformFolder)ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Application Type\Windows Store\10.0\Platforms\x64\Platform.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Current.targets
============================================================================================================================================
-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.Unity.targets" Condition="'$(_ToolsetFound)' == 'true' and '$(EnableUnitySupport)' == 'true'" />-->
  <!--<Import Project="$(_DefaultPlatformTargets)" Condition="'$(_UseDefaultToolset)' == 'true'" />-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.Cpp.MissingToolset.targets" Condition="'$(_ToolsetFound)' != 'true' and '$(_UseDefaultToolset)' != 'true'" />-->
  <!--</ImportGroup>-->
  <!--<Import Project="$(VCTargetsPath)\Microsoft.MakeFile.Targets" Condition="'$(ConfigurationType)' == 'Makefile'" />-->
  <!-- *******************************************************************************************
        Cleaning targets
       ******************************************************************************************* -->
  <!--
============================================================================================================================================
  <Import Project="$(VCTargetsPath)\Microsoft.CppClean.targets">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.CppClean.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CppClean.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will impact
          the way you build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="CppClean" AssemblyFile="$(MSBuildThisFileDirectory)Microsoft.Build.CppTasks.Common.dll" />
  <!-- *******************************************************************************************
        Cpp Clean Section
       ******************************************************************************************* -->
  <!-- CppClean: Delete all intermediate and final build outputs. -->
  <PropertyGroup>
    <CleanDependsOn>
      $(CleanDependsOn);
      CppClean
    </CleanDependsOn>
    <CppCleanDependsOn>
      BeforeCppClean;
      $(CppCleanDependsOn);
      CoreCppClean;
      AfterCppClean;
    </CppCleanDependsOn>
  </PropertyGroup>
  <Target Name="CppClean" DependsOnTargets="$(CppCleanDependsOn)" />
  <!-- BeforeCppClean: Redefine this target in your project in order to run tasks just before Clean. -->
  <Target Name="BeforeCppClean" />
  <!-- AfterCppClean: Redefine this target in your project in order to run tasks just after Clean. -->
  <Target Name="AfterCppClean" />
  <!-- CoreCppClean -->
  <PropertyGroup>
    <CoreCppCleanDependsOn />
    <CppCleanLogFile>$(TargetName).Build.CppClean.log</CppCleanLogFile>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <CoreCppClean>
      <DoDelete Condition="'%(CoreCppClean.DoDelete)'               == ''">TRUE</DoDelete>
      <FilePatternsToDelete Condition="'%(CoreCppClean.FilePatternsToDelete)'   == ''">$(ExtensionsToDeleteOnClean)</FilePatternsToDelete>
      <FilesExcludedFromClean Condition="'%(CoreCppClean.FilesExcludedFromClean)' == ''">$(CppCleanLogFile)</FilesExcludedFromClean>
    </CoreCppClean>
  </ItemDefinitionGroup>
  <ItemGroup>
    <CoreCppClean Include="$(IntDir)" />
    <CoreCppClean Condition="'$(TLogLocation)' != '$(IntDir)'" Include="$(TLogLocation)" />
    <CoreCppClean Condition="'$(TLogLocation_ModuleDependencies)' != ''" Include="$(TLogLocation_ModuleDependencies)" />
    <CoreCppClean Condition="'$(GeneratedFilesDir)' != ''" Include="$(GeneratedFilesDir)" />
    <!-- Files in OutDir will be deleted using the filepattern which will get evaluated to real full paths -->
  </ItemGroup>
  <Target Name="CoreCppClean" DependsOnTargets="$(CoreCppCleanDependsOn)">
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntDir)" />
    <!-- Delete all the files based on the FoldersToClean and ExtensionsToDeleteOnClean -->
    <CppClean FoldersToClean="@(CoreCppClean)" FilesExcludedFromClean="%(CoreCppClean.FilesExcludedFromClean)" DoDelete="%(CoreCppClean.DoDelete)" FilePatternsToDeleteOnClean="%(CoreCppClean.FilePatternsToDelete)">
      <Output TaskParameter="DeletedFiles" ItemName="DeletedFilesByCppCleanTask" />
    </CppClean>
    <!-- Write new list of current files back to disk. -->
    <WriteLinesToFile File="$(IntDir)$(CppCleanLogFile)" Lines="@(DeletedFilesByCppCleanTask)" Overwrite="true" />
  </Target>
  <PropertyGroup>
    <CppCleanDependsOn>$(CppCleanDependsOn);PGInstrumentedClean</CppCleanDependsOn>
  </PropertyGroup>
  <Target Name="PGInstrumentedClean">
    <ItemGroup>
      <InstrumentedClean Include="$(OutDir)$(TargetName)!*.pgc" />
    </ItemGroup>
    <Delete Files="@(InstrumentedClean)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.Current.targets
============================================================================================================================================
-->
  <!--<Import Project="$(ForceImportAfterCppTargets)" Condition="Exists('$(ForceImportAfterCppTargets)')" />-->
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.targets
============================================================================================================================================
-->
  <!-- If (_Redirect) flag is set, redirect to older versions of VS -->
  <!--<Import Project="Microsoft.Cpp.Redirect.targets" Condition="'$(_Redirect)' == 'true'" />-->
  <PropertyGroup Condition="'$(VcpkgManifestDirectory)' != '' and '$(VcpkgActivationOptions)' != '' and '$(DesignTimeBuild)' != 'true'">
    <InstallBuildTools>true</InstallBuildTools>
    <SetBuildDefaultEnvironmentVariablesDependsOn>
      InstallBuildTools;
      $(SetBuildDefaultEnvironmentVariablesDependsOn)
    </SetBuildDefaultEnvironmentVariablesDependsOn>
  </PropertyGroup>
  <Target Name="InstallBuildTools" AfterTargets="_GenerateRestoreProjectPathWalk" DependsOnTargets="$(InstallBuildToolsDependesOn)" Condition="'$(InstallBuildTools)' == 'true'">
    <ItemGroup Condition="'$(InstallBuildToolsForConfigurations)' != ''">
      <_RequestedProjectConfigurations Include="$(InstallBuildToolsForConfigurations)" />
      <_InstallProjectConfiguration Include="@(ProjectConfiguration)" Condition="'%(Identity)' == '@(_RequestedProjectConfigurations)'" />
    </ItemGroup>
    <PropertyGroup>
      <_InstallToolsForThisConfiguration Condition="'$(InstallBuildToolsForConfigurations)' == '' or&#xD;&#xA;            @(_InstallProjectConfiguration-&gt;AnyHaveMetadataValue('Identity', $(Configuration)|$(Platform)))">true</_InstallToolsForThisConfiguration>
    </PropertyGroup>
    <ItemGroup>
      <_InstallProjectConfiguration Remove="$(Configuration)|$(Platform)" />
    </ItemGroup>
    <CallVcpkg Condition="'$(_InstallToolsForThisConfiguration)' == 'true'" VcpkgRoot="$(VcpkgRoot)" ManifestDirectory="$(VcpkgManifestDirectory)" Options="$(VcpkgActivationOptions)" TlogLocation="$(TlogLocation)" TrackFileAccess="$(TrackFileAccess)" />
    <MSBuild Condition="'@(_InstallProjectConfiguration)' != ''" Projects="$(MsbuildProjectFile)" Targets="InstallBuildTools" Properties="Configuration=%(_InstallProjectConfiguration.Configuration);Platform=%(_InstallProjectConfiguration.Platform);InstallBuildToolsForConfigurations=;BuildReferencedProjects=false" BuildInParallel="true" />
  </Target>
  <!--<Import Project="Imports.props" Sdk="vcpkg:ManifestDirectory=$(VcpkgManifestDirectory);ImportFiles=$(ImportAfterCppTargets)" Condition="'$(VcpkgManifestDirectory)' != '' and '$(ImportAfterCppTargets)' != ''" />-->
  <!-- *******************************************************************************************
        DesignTime targets, used by IDE only (not real build). 
        They are VS version specific, not toolset specific.
       ******************************************************************************************* -->
  <!--
============================================================================================================================================
  <Import Project="$(CurrentVCTargetsPath)\Microsoft.Cpp.DesignTime.targets" Condition="'$(_ImportMicrosoftCppDesignTime)' != 'false'">

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.DesignTime.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Cpp.DesignTime.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains targets that are only used by IDE and not the real build

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Fix up for old Smart Devices projects-->
  <PropertyGroup Condition="'$(_UIModelDllPath)' == '' and '$(SmartDeviceProject)' != ''">
    <_UIModelDllPath>$(VCIDEInstallDir)\VCPackages\CE.dll</_UIModelDllPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DesignTimeBuild)' == 'true'">
    <!-- This will make GetTargetPathWithTargetPlatformMoniker during ResolveProjectReferences -->
    <IntelliSenseBuild>true</IntelliSenseBuild>
    <!-- Disable warning targets, they are not useful in designtime build -->
    <IgnoreWarnCompileDuplicatedFilename>true</IgnoreWarnCompileDuplicatedFilename>
    <_FindDependencies>false</_FindDependencies>
    <BuildingProject>false</BuildingProject>
  </PropertyGroup>
  <PropertyGroup>
    <!-- We want to make sure we run these targets identically for all designtime build to ensure consistent results when they are bundled -->
    <DesignTimeBuildInitTargets>$(DetermineProjectTypeTargets);InitGetClCommandLines;ResolveReferences;FixupReferences</DesignTimeBuildInitTargets>
  </PropertyGroup>
  <PropertyGroup>
    <AddManagedCapability Condition="'$(AddManagedCapability)' == '' and '$(ManagedAssembly)' == 'true'">true</AddManagedCapability>
  </PropertyGroup>
  <!-- Capabilities for all vc projects. -->
  <ItemGroup>
    <ProjectCapability Include="AssemblyReferences;COMReferences;ProjectReferences;WinRTReferences;SDKReferences;SharedProjectReferences" Condition="'$(IncludeVCDefaultReferenceCapabilities)' != 'false'" />
    <ProjectCapability Include="OutputGroups;AllTargetOutputGroups;VisualStudioWellKnownOutputGroups" Condition="'$(IncludeVCDefaultOutputGroupsCapabilities)' != 'false'" />
    <ProjectCapability Include="ProjectConfigurationsDeclaredAsItems" />
    <ProjectCapability Include="PropertyManager" Condition="'$(PropertyManagerSupported)' != 'false'" />
    <ProjectCapability Include="managed" Condition="'$(AddManagedCapability)' == 'true'" />
    <ProjectCapability Include="native" Condition="'$(AddManagedCapability)' != 'true'" />
    <!-- enables local windows debugger check if the exe is a console application -->
    <ProjectCapability Include="IntegratedConsoleDebugging" />
    <ProjectCapability Include="SupportsOnlineEnvironments" Condition="'$(ApplicationType)' == ''" />
  </ItemGroup>
  <!-- Additional metadata needed in resolved project references -->
  <ItemDefinitionGroup>
    <TargetPathWithTargetPlatformMoniker>
      <ProjectGuid Condition="'%(TargetPathWithTargetPlatformMoniker.ProjectGuid)' == ''">$(ProjectGuid)</ProjectGuid>
      <ReferenceSourceTarget Condition="'%(TargetPathWithTargetPlatformMoniker.ReferenceSourceTarget)' == ''">ProjectReference</ReferenceSourceTarget>
      <MsbuildSourceProjectFile Condition="'%(TargetPathWithTargetPlatformMoniker.MsbuildSourceProjectFile)' == ''">$(MSBuildProjectFullPath)</MsbuildSourceProjectFile>
    </TargetPathWithTargetPlatformMoniker>
  </ItemDefinitionGroup>
  <Target Name="InitGetClCommandLines">
    <!-- Add a fake cpp file to get Configuration options. It needs to be done before other targets running to ensure correct results -->
    <ItemGroup>
      <ClCompile Include="__temporary.cpp">
        <ConfigurationOptions>true</ConfigurationOptions>
      </ClCompile>
    </ItemGroup>
    <PropertyGroup>
      <!-- Disable ref resolution if we know we won't get anything useful from it. Set AlwaysResolveReferencesDesignTime to true to override this behavior -->
      <ResolveReferencesDependsOn Condition="'$(WinMDAssembly)' != 'true' and '$(ManagedAssembly)' != 'true' and '$(AlwaysResolveReferencesDesignTime)' != 'true'" />
      <ReferenceResolutionDisabled Condition="'$(ResolveReferencesDependsOn)' == ''">true</ReferenceResolutionDisabled>
    </PropertyGroup>
  </Target>
  <Target Name="FixupReferences">
    <ItemGroup>
      <ReferencePath>
        <!-- when winmd file does not exist yet <WinMdFile> metadata is not set by RAR. Add it here so it is still included in IntelliSense command line -->
        <WinMDFile Condition="'%(ReferencePath.WinMDFile)' == '' and '%(ReferencePath.Extension)' == '.winmd'">true</WinMDFile>
      </ReferencePath>
    </ItemGroup>
  </Target>
  <UsingTask TaskName="CLCommandLine" AssemblyFile="$(CurrentVCTargetsPath)\Microsoft.Build.CPPTasks.Common.dll" />
  <Target Name="GetClCommandLines" Returns="@(ClCommandLines)" DependsOnTargets="$(DesignTimeBuildInitTargets);$(ComputeCompileInputsTargets)">
    <ItemGroup>
      <ClCompile>
        <!-- figure out obj file directory which IntelliSense needs for #import support, but we don't want to use '%(ClCompile.ObjectFileName)' as it breaks MsBuild batching -->
        <ObjectFileDirectory Condition="'%(ClCompile.ObjectFileName)' != ''">$([System.IO.Path]::GetDirectoryName('%(ClCompile.ObjectFileName))'))\</ObjectFileDirectory>
        <ModuleOutputDirectory Condition="'%(ClCompile.ModuleOutputFile)' != ''">$([System.IO.Path]::GetDirectoryName('%(ClCompile.ModuleOutputFile))'))\</ModuleOutputDirectory>
        <!-- Option to include files that are excluded from build for IntelliSense. -->
        <ExcludedFromBuild Condition="'$(IgnoreExcludedFromBuild)' == 'true'" />
      </ClCompile>
    </ItemGroup>
    <CLCommandLine Condition="'%(ClCompile.ExcludedFromBuild)' != 'true'" BuildingInIDE="true" Sources="@(ClCompile)" ClangMode="%(ClCompile.ClangMode)" ClangClMode="%(ClCompile.ClangClMode)" AdditionalHeaderUnitDependencies="%(ClCompile.AdditionalHeaderUnitDependencies)" AdditionalIncludeDirectories="%(ClCompile.AdditionalIncludeDirectories)" AdditionalModuleDependencies="%(ClCompile.AdditionalModuleDependencies)" AdditionalBMIDirectories="%(ClCompile.AdditionalBMIDirectories)" AdditionalOptions="%(ClCompile.AdditionalOptions)" AdditionalUsingDirectories="%(ClCompile.AdditionalUsingDirectories)" CallingConvention="%(ClCompile.CallingConvention)" CompileAsManaged="%(ClCompile.CompileAsManaged)" CompileAsWinRT="%(ClCompile.CompileAsWinRT)" CompileAs="%(ClCompile.CompileAs)" ConformanceMode="%(ClCompile.ConformanceMode)" DisableLanguageExtensions="%(ClCompile.DisableLanguageExtensions)" DisableSpecificWarnings="%(ClCompile.DisableSpecificWarnings)" EnableEnhancedInstructionSet="%(ClCompile.EnableEnhancedInstructionSet)" EnableVectorLength="%(ClCompile.EnableVectorLength)" EnableModules="%(ClCompile.EnableModules)" ErrorReporting="%(ClCompile.ErrorReporting)" ExceptionHandling="%(ClCompile.ExceptionHandling)" ExcludedInputPaths="$(ExcludePath)" ExpandAttributedSource="%(ClCompile.ExpandAttributedSource)" ExternalTemplatesDiagnostics="%(ClCompile.ExternalTemplatesDiagnostics)" ExternalWarningLevel="%(ClCompile.ExternalWarningLevel)" FloatingPointExceptions="%(ClCompile.FloatingPointExceptions)" FloatingPointModel="%(ClCompile.FloatingPointModel)" ForceConformanceInForLoopScope="%(ClCompile.ForceConformanceInForLoopScope)" ForcedIncludeFiles="%(ClCompile.ForcedIncludeFiles)" ForcedUsingFiles="%(ClCompile.ForcedUsingFiles)" IgnoreStandardIncludePath="%(ClCompile.IgnoreStandardIncludePath)" InlineFunctionExpansion="%(ClCompile.InlineFunctionExpansion)" IntrinsicFunctions="%(ClCompile.IntrinsicFunctions)" LanguageStandard="%(ClCompile.LanguageStandard)" LanguageStandard_C="%(ClCompile.LanguageStandard_C)" ModuleOutputFile="%(ClCompile.ModuleOutputDirectory)" OpenMPSupport="%(ClCompile.OpenMPSupport)" ObjectFileName="%(ClCompile.ObjectFileDirectory)" PrecompiledHeader="%(ClCompile.PrecompiledHeader)" PrecompiledHeaderFile="%(ClCompile.PrecompiledHeaderFile)" PrecompiledHeaderOutputFile="%(ClCompile.PrecompiledHeaderOutputFile)" PreprocessKeepComments="%(ClCompile.PreprocessKeepComments)" PreprocessorDefinitions="%(ClCompile.PreprocessorDefinitions)" PreprocessSuppressLineNumbers="%(ClCompile.PreprocessSuppressLineNumbers)" PreprocessToFile="%(ClCompile.PreprocessToFile)" RuntimeLibrary="%(ClCompile.RuntimeLibrary)" RuntimeTypeInfo="%(ClCompile.RuntimeTypeInfo)" SmallerTypeCheck="%(ClCompile.SmallerTypeCheck)" StdIfcDirectory="%(ClCompile.StdIfcDirectory)" StructMemberAlignment="%(ClCompile.StructMemberAlignment)" TranslateIncludes="%(ClCompile.TranslateIncludes)" TreatAngleIncludeAsExternal="%(ClCompile.TreatAngleIncludeAsExternal)" TreatSpecificWarningsAsErrors="%(ClCompile.TreatSpecificWarningsAsErrors)" TreatWarningAsError="%(ClCompile.TreatWarningAsError)" TreatWChar_tAsBuiltInType="%(ClCompile.TreatWChar_tAsBuiltInType)" UndefineAllPreprocessorDefinitions="%(ClCompile.UndefineAllPreprocessorDefinitions)" UndefinePreprocessorDefinitions="%(ClCompile.UndefinePreprocessorDefinitions)" UseStandardPreprocessor="%(ClCompile.UseStandardPreprocessor)" WarningLevel="%(ClCompile.WarningLevel)" WinRTNoStdLib="%(ClCompile.WinRTNoStdLib)" CLanguageStandard="%(ClCompile.CLanguageStandard)" CppLanguageStandard="%(ClCompile.CppLanguageStandard)" UseShortEnums="%(ClCompile.UseShortEnums)" MSExtensions="%(ClCompile.MSExtensions)" MSCompatibility="%(ClCompile.MSCompatibility)" MSCVersion="%(ClCompile.MSCVersion)" ScanSourceForModuleDependencies="%(ClCompile.ScanSourceForModuleDependencies)" LibraryModuleName="%(ClCompile.LibraryModuleName)" TrackerLogDirectory="%(ClCompile.TrackerLogDirectory)" TLogReadFiles="@(CLTLogReadFiles)" TLogWriteFiles="@(CLTLogWriteFiles)" ToolExe="$(CLToolExe)" ToolPath="$(CLToolPath)" ToolArchitecture="$(CLToolArchitecture)" TrackerFrameworkPath="$(CLTrackerFrameworkPath)" TrackerSdkPath="$(CLTrackerSdkPath)">
      <Output TaskParameter="CommandLines" ItemName="ClCommandLines" />
    </CLCommandLine>
    <CLCommandLine Condition="'@(FxCompile)' != ''" BuildingInIDE="true" Sources="@(FxCompile)" AdditionalIncludeDirectories="%(FxCompile.AdditionalIncludeDirectories)" PreprocessorDefinitions="%(FxCompile.PreprocessorDefinitions)">
      <Output TaskParameter="CommandLines" ItemName="ClCommandLines" />
    </CLCommandLine>
    <ItemGroup>
      <ClCommandLines>
        <ContainsReferencedProjectsData Condition="'$(ResolveReferencesDependsOn)' != ''">true</ContainsReferencedProjectsData>
      </ClCommandLines>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <GetClCommandLineForReferenceSupported>true</GetClCommandLineForReferenceSupported>
  </PropertyGroup>
  <!-- This target returns additional cl command line which projects that reference this project can use instead of using msbuild's resolve references  -->
  <Target Name="GetClCommandLineForReference" Returns="@(ClCommandLineForReference)" DependsOnTargets="$(DesignTimeBuildInitTargets);$(GetClCommandLineForReferenceDependsOn)">
    <PropertyGroup Condition="'@(PublicIncludeDirectories)' != ''">
      <CreateCommandLineForReference>true</CreateCommandLineForReference>
    </PropertyGroup>
    <ItemGroup Condition="'@(PublicIncludeDirectories)' != ''">
      <ProjectDataForReference Include="__temp__.cpp">
        <AdditionalIncludeDirectories>%(ProjectDataForReference.AdditionalIncludeDirectories);@(PublicIncludeDirectories-&gt;Metadata('FullPath'))</AdditionalIncludeDirectories>
        <!--<ForcedUsingFiles Condition ="'$(WinMDAssembly)' == 'true'">@(GetResolvedWinMD)</ForcedUsingFiles>
          <ForcedUsingFiles Condition ="'$(ManagedAssembly)' == 'true'">$(TargetPath)</ForcedUsingFiles>-->
      </ProjectDataForReference>
    </ItemGroup>
    <CLCommandLine Condition="'$(CreateCommandLineForReference)' == 'true'" BuildingInIDE="true" Sources="@(ProjectDataForReference)" ClangMode="false" EmitCompileOnlySwitch="false" AdditionalIncludeDirectories="%(ProjectDataForReference.AdditionalIncludeDirectories)">
      <Output TaskParameter="CommandLines" ItemName="ClCommandLineForReference" />
    </CLCommandLine>
  </Target>
  <Target Name="GetProjectDirectories" Returns="@(_ProjectDirectories)" DependsOnTargets="$(DetermineProjectTypeTargets)">
    <PropertyGroup Condition="'$(UseEnv)' == 'true'">
      <IncludePath>$(INCLUDE)</IncludePath>
      <LibraryPath>$(LIB)</LibraryPath>
      <ReferencePath>$(LIBPATH)</ReferencePath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(ConfigurationType)' == 'Makefile'">
      <IncludePath>$(NMakeIncludeSearchPath);$(IncludePath)</IncludePath>
      <ReferencePath>$(NMakeAssemblySearchPath);$(ReferencePath)</ReferencePath>
    </PropertyGroup>
    <ItemGroup>
      <_ProjectDirectories Include="dummy">
        <IncludePath>$(IncludePath)</IncludePath>
        <ExternalIncludePath>$(ExternalIncludePath)</ExternalIncludePath>
        <FrameworkIncludePath>$(FrameworkIncludePath)</FrameworkIncludePath>
        <ExcludePath>$(ExcludePath)</ExcludePath>
        <ReferencePath>$(ReferencePath);$(LibraryPath)</ReferencePath>
        <ProjectDir>$(ProjectDir)</ProjectDir>
        <ToolsetISenseIdentifier>$(ToolsetISenseIdentifier)</ToolsetISenseIdentifier>
      </_ProjectDirectories>
    </ItemGroup>
  </Target>
  <Target Name="GetGeneratedFiles" Returns="@(_GeneratedFiles)" DependsOnTargets="$(DesignTimeBuildInitTargets);$(GeneratedFilesOutputGroupDependsOn)">
    <ItemGroup>
      <_GeneratedFiles Include="%(GeneratedFilesOutputGroup.FullPath)" />
    </ItemGroup>
  </Target>
  <Target Name="GetProjectReferencesInfo" Returns="@(_ProjectReferencesInfo)" DependsOnTargets="$(DesignTimeBuildInitTargets)">
    <ItemGroup>
      <_ProjectReferencesInfo Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))" Condition="'%(ReferencePath.ReferenceOutputAssembly)' != 'false'" />
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)' ==  'true'" Text="ProjectReferenceResolvedPath=%(_ProjectReferencesInfo.Identity)&#xA;&#xD;&#xA;                   ProjectGuid=%(_ProjectReferencesInfo.Project)&#xA;&#xD;&#xA;                   ProjectFile=%(_ProjectReferencesInfo.MsbuildSourceProjectFile)&#xA;" Importance="High" />
    <Message Condition="'$(_REFERENCE_DEBUG)' ==  'true'" Text="ReferencePath=%(ReferencePath.Identity)&#xA;&#xD;&#xA;                   ReferenceSourceTarget=%(ReferencePath.ReferenceSourceTarget)&#xA;&#xD;&#xA;                   ReferenceOutputAssembly=%(ReferencePath.ReferenceOutputAssembly)&#xA;" Importance="High" />
  </Target>
  <Target Name="GetAssemblyReferences" Returns="@(_AssemblyReferences)" DependsOnTargets="$(DesignTimeBuildInitTargets)">
    <ItemGroup Condition="'$(ManagedAssembly)' == 'true'">
      <_AssemblyReferences Include="@(Reference)" Condition="'%(Reference.IsWinMDFile)' != 'true' and '%(Reference.FrameworkReferenceName)' == ''">
        <!-- this will be overriden with Full path if reference is resolved-->
        <VCReferenceIdentifier Condition="'%(Reference.HintPath)' != ''">%(Reference.HintPath)</VCReferenceIdentifier>
        <VCReferenceIdentifier Condition="'%(Reference.HintPath)' == ''">%(Reference.Identity)</VCReferenceIdentifier>
        <Kind>VCAssemblyReference</Kind>
      </_AssemblyReferences>
    </ItemGroup>
  </Target>
  <Target Name="GetWinMDReferences" Returns="@(_WinMDReferences)" DependsOnTargets="$(DesignTimeBuildInitTargets)">
    <ItemGroup Condition="'$(WinMDAssembly)' == 'true'">
      <_WinMDReferences Include="@(Reference)" Condition="'%(Reference.IsWinMDFile)' == 'true'">
        <!-- this will be overriden with Full path if reference is resolved-->
        <VCReferenceIdentifier Condition="'%(Reference.HintPath)' != ''">%(Reference.HintPath)</VCReferenceIdentifier>
        <VCReferenceIdentifier Condition="'%(Reference.HintPath)' == ''">%(Reference.Identity)</VCReferenceIdentifier>
        <Kind>VCWinRTReference</Kind>
      </_WinMDReferences>
    </ItemGroup>
  </Target>
  <Target Name="GetComReferences" Returns="@(ComReference)" DependsOnTargets="$(DesignTimeBuildInitTargets)">
    <ItemGroup Condition="'$(ManagedAssembly)' == 'true'">
      <ComReference>
        <VCReferenceIdentifier>{%(ComReference.Guid)}\%(ComReference.VersionMajor).%(ComReference.VersionMinor)</VCReferenceIdentifier>
        <ControlGUID>{%(ComReference.Guid)}</ControlGUID>
        <ControlLocale>%(ComReference.Lcid)</ControlLocale>
        <ControlVersion>%(ComReference.VersionMajor).%(ComReference.VersionMinor)</ControlVersion>
        <TypeLibraryName>%(ComReference.FileName)</TypeLibraryName>
        <Kind>VCActiveXReference</Kind>
      </ComReference>
    </ItemGroup>
  </Target>
  <Target Name="GetSDKReferences" Returns="@(SdkReference)" DependsOnTargets="$(DesignTimeBuildInitTargets)">
    <ItemGroup Condition="'$(WinMDAssembly)' == 'true'">
      <SdkReference>
        <VCReferenceIdentifier>%(SdkReference.Identity)</VCReferenceIdentifier>
        <Kind>VCSdkReference</Kind>
      </SdkReference>
    </ItemGroup>
  </Target>
  <Target Name="GetProjectReferences" Returns="@(ProjectReference)" DependsOnTargets="$(DesignTimeBuildInitTargets)">
    <ItemGroup>
      <ProjectReference>
        <Name Condition="'%(ProjectReference.Name)' == ''">%(ProjectReference._ReferencedProjectName)</Name>
        <VCReferenceIdentifier>%(ProjectReference.Project)</VCReferenceIdentifier>
        <!-- ItemIdentifier is used to match resolved reference's 'OriginalItemSpec' metadata -->
        <ItemIdentifier>%(ProjectReference.Project)</ItemIdentifier>
        <Kind>VCProjectReference</Kind>
        <ProjectFile>%(ProjectReference.FullPath)</ProjectFile>
      </ProjectReference>
      <ProjectReference>
        <Name Condition="'%(ProjectReference.Name)' == ''">%(ProjectReference.FileName)</Name>
      </ProjectReference>
    </ItemGroup>
  </Target>
  <Target Name="GetForeignReferences" Returns="@(_ForeignReferences)" DependsOnTargets="$(DesignTimeBuildInitTargets);$(GetForeignReferencesDependsOn)" />
  <Target Name="GetResolvedReferences" Returns="@(ReferencePath)" DependsOnTargets="$(DesignTimeBuildInitTargets);$(GetAllReferencesInfoDependsOn)">
    <ItemGroup>
      <!-- Fix/assign VCReferenceIdentifier to implcit references added by targets -->
      <ReferencePath Condition="'%(ReferencePath.ReferenceSourceTarget)' == 'ResolveAssemblyReference'">
        <VCReferenceIdentifier Condition="'%(ReferencePath.FullPath)' != ''">%(ReferencePath.FullPath)</VCReferenceIdentifier>
        <Kind Condition="'%(ReferencePath.Implicit)' == 'true' and '%(ReferencePath.IsWinMD)' != true">VCImplicitAssemblyReference</Kind>
        <Kind Condition="'%(ReferencePath.Implicit)' == 'true' and '%(ReferencePath.IsWinMD)' == true">VCImplicitWinRTReference</Kind>
      </ReferencePath>
      <ReferencePath Condition="'%(ReferencePath.ReferenceSourceTarget)' == 'ResolveComReference'">
        <VCReferenceIdentifier>{%(ReferencePath.Guid)}\%(ReferencePath.VersionMajor).%(ReferencePath.VersionMinor)</VCReferenceIdentifier>
        <Kind Condition="'%(ReferencePath.Implicit)' == 'true'">VCImplicitActivXReference</Kind>
        <ControlFullPath>%(ReferencePath.FullPath)</ControlFullPath>
      </ReferencePath>
      <ReferencePath Condition="'%(ReferencePath.ReferenceSourceTarget)' == 'ResolveSdkReference'">
        <VCReferenceIdentifier>%(ReferencePath.OriginalItemSpec)</VCReferenceIdentifier>
        <Kind Condition="'%(ReferencePath.Implicit)' == 'true'">VCImplicitSdkReference</Kind>
      </ReferencePath>
      <ReferencePath Condition="'%(ReferencePath.ReferenceSourceTarget)' == 'ResolveProjectReference'">
        <VCReferenceIdentifier>%(ReferencePath.Project)</VCReferenceIdentifier>
      </ReferencePath>
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)' ==  'true'" Text="ReferencePath=%(ReferencePath.Identity)&#xA;&#xD;&#xA;                   ReferenceSourceTarget=%(ReferencePath.ReferenceSourceTarget)&#xA;&#xD;&#xA;                   ReferenceOutputAssembly=%(ReferencePath.ReferenceOutputAssembly)&#xA;" Importance="High" />
  </Target>
  <Target Name="GetTargetPathWithTargetPlatformMoniker" BeforeTargets="GetTargetPath" DependsOnTargets="$(GetTargetPathWithTargetPlatformMonikerDependsOn);" Returns="@(TargetPathWithTargetPlatformMoniker)">
    <!-- If GetTargetPath from older versions (or overriden GetTargetPath) did not populate the group, we'll do it here -->
    <ItemGroup Condition="'@(TargetPathWithTargetPlatformMoniker)' == ''">
      <TargetPathWithTargetPlatformMoniker Include="@(WinMDFullPath)" />
      <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)" Condition="'@(TargetPathWithTargetPlatformMoniker)' == ''">
        <ResolveableAssembly Condition="'$(ConfigurationType)' != 'StaticLibrary'">$(ManagedAssembly)</ResolveableAssembly>
        <ResolveableAssembly Condition="'$(ConfigurationType)' == 'StaticLibrary'">false</ResolveableAssembly>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
    <ItemGroup>
      <TargetPathWithTargetPlatformMoniker>
        <TargetPlatformMoniker Condition="'%(TargetPathWithTargetPlatformMoniker.TargetPlatformMoniker)' == ''">$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier Condition="'%(TargetPathWithTargetPlatformMoniker.TargetPlatformIdentifier)' == ''">$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
    <Message Condition="'$(_REFERENCE_DEBUG)' ==  'true'" Text="****** GetTargetPathWithTargetPlatformMoniker:TargetPathWithTargetPlatformMoniker=%(TargetPathWithTargetPlatformMoniker.Identity)&#xA;&#xD;&#xA;                                                                ****** ProjectGuid=%(TargetPathWithTargetPlatformMoniker.ProjectGuid)&#xA;&#xD;&#xA;                                                                ****** ProjectFile=%(TargetPathWithTargetPlatformMoniker.MsbuildSourceProjectFile)&#xA;&#xD;&#xA;                                                                ****** TargetPlatformMoniker=%(TargetPathWithTargetPlatformMoniker.TargetPlatformMoniker)&#xA;&#xD;&#xA;                                                                ****** TargetPlatformIdentifier=%(TargetPathWithTargetPlatformMoniker.TargetPlatformIdentifier)&#xA;&#xD;&#xA;                                                                " Importance="High" />
  </Target>
  <Target Name="_PrintPropertyPages">
    <ItemGroup>
      <PropertyPageSchema>
        <ExistsOnDisk Condition="Exists(%(PropertyPageSchema.Identity))">true</ExistsOnDisk>
      </PropertyPageSchema>
    </ItemGroup>
    <Message Text="PropertyPageSchema='%(PropertyPageSchema.Identity)'&#xA;ExistsOnDisk='%(PropertyPageSchema.ExistsOnDisk)'&#xA;Context='%(PropertyPageSchema.Context)'&#xA;" Importance="High" />
    <Message Text="ProjectTools=@(ProjectTools)&#xA;" Importance="High" />
  </Target>
  <Target Name="_PrintIntellisenseInfo" DependsOnTargets="GetProjectDirectories;GetClCommandLines;GetClCommandLineForReference;GetGeneratedFiles;GetProjectReferencesInfo">
    <Message Text="****** Configuration Settings:" Importance="High" />
    <Message Condition="'%(ClCommandLines.ConfigurationOptions)' == 'true'" Text="****** Files=%(ClCommandLines.Files)&#xA;****** CommandLine=%(ClCommandLines.Identity)&#xA;" Importance="High" />
    <Message Condition="'%(ClCommandLines.ConfigurationOptions)' != 'true'" Text="****** Files=%(ClCommandLines.Files)&#xA;****** CommandLine=%(ClCommandLines.Identity)&#xA;" Importance="High" />
    <Message Text="****** ExecutablePath=$(ExecutablePath)&#xA;" Importance="High" />
    <Message Text="****** GeneratedFiles=@(_GeneratedFiles)&#xA;" Importance="High" />
    <Message Text="****** IncludePath=%(_ProjectDirectories.IncludePath)&#xA;" Importance="High" />
    <Message Text="****** FrameworkIncludePath=%(_ProjectDirectories.FrameworkIncludePath)&#xA;" Importance="High" />
    <Message Text="****** ExcludePath=%(_ProjectDirectories.ExcludePath)&#xA;" Importance="High" />
    <Message Text="****** ReferencePath=%(_ProjectDirectories.ReferencePath)&#xA;" Importance="High" />
    <Message Text="****** LibraryPath=$(LibraryPath)&#xA;" Importance="High" />
    <Message Text="****** ToolsetISenseIdentifier=%(_ProjectDirectories.ToolsetISenseIdentifier)&#xA;" Importance="High" />
    <Message Condition="'@(_ProjectReferencesInfo)' != ''" Text="ProjectReferenceResolvedPath=%(_ProjectReferencesInfo.Identity)&#xA;&#xD;&#xA;                   ReferencedProjectGuid=%(_ProjectReferencesInfo.Project)&#xA;&#xD;&#xA;                   ReferencedProjectFile=%(_ProjectReferencesInfo.MsbuildSourceProjectFile)&#xA;" Importance="High" />
    <Message Text="****** Command Line for referencing projects=%(ClCommandLineForReference.Identity)&#xA;" Importance="High" />
  </Target>
  <Target Name="_ValidatePathInfo" DependsOnTargets="GetProjectDirectories;GetClCommandLines;GetGeneratedFiles;GetProjectReferencesInfo">
    <ItemGroup>
      <Link Include="__Tempfile__">
        <Temp>true</Temp>
      </Link>
    </ItemGroup>
    <ItemGroup>
      <AllPaths Include="%(_ProjectDirectories.IncludePath);%(_ProjectDirectories.FrameworkIncludePath);%(_ProjectDirectories.ReferencePath);%(_ProjectDirectories.ExcludePath)">
        <SourceLocaltion>ProjectDirectories</SourceLocaltion>
      </AllPaths>
      <AllPaths Include="$(ExecutablePath)" Exclude="$(Path)">
        <SourceLocaltion>ProjectDirectories</SourceLocaltion>
      </AllPaths>
      <AllPaths Include="$(LibraryPath)">
        <SourceLocaltion>ProjectDirectories</SourceLocaltion>
      </AllPaths>
      <AllPaths Include="%(ClCompile.AdditionalIncludeDirectories)">
        <SourceLocaltion>ClCompile.AdditionalIncludeDirectories</SourceLocaltion>
      </AllPaths>
      <AllPaths Include="%(ClCompile.AdditionalUsingDirectories)">
        <SourceLocaltion>ClCompile.AdditionalUsingDirectories</SourceLocaltion>
      </AllPaths>
      <AllPaths Include="@(ClCompile)" Condition="'%(ClCompile.ConfigurationOptions)' != 'true'">
        <SourceLocaltion>ClCompile</SourceLocaltion>
      </AllPaths>
      <AllPaths Include="%(Link.AdditionalLibraryDirectories)">
        <SourceLocaltion>Link.AdditionalLibrary</SourceLocaltion>
      </AllPaths>
      <AllPaths Remove="@(AllPaths)" Condition="Exists('%(AllPaths.FullPath)')" />
    </ItemGroup>
    <Message Condition="'@(AllPaths)' == ''" Text="All Paths Validated." />
    <Message Condition="'@(AllPaths)' != ''" Text="****** @(AllPaths-&gt;Count()) missing path detected:" Importance="High" />
    <Message Condition="'@(AllPaths)' != ''" Text="Missing path: '%(AllPaths.FullPath)' from '%(AllPaths.SourceLocaltion)'" />
  </Target>
  <Target Name="_PerfIntellisenseInfo" DependsOnTargets="GetProjectDirectories;GetClCommandLines;GetClCommandLineForReference;GetGeneratedFiles;GetProjectReferencesInfo" />
  <Target Name="_PrintResolvedProjectReferences" DependsOnTargets="ResolveProjectReferencesDesignTime">
    <Message Text="ProjectReference=%(ProjectReference.Identity)&#xA;&#xD;&#xA;                   ReferenceOutputAssembly=%(ProjectReference.ReferenceOutputAssembly)&#xA;&#xD;&#xA;                   OutputItemType=%(ProjectReference.OutputItemType)&#xA;" Importance="High" />
    <Message Text="_ResolvedNativeProjectReferencePaths=%(_ResolvedNativeProjectReferencePaths.Identity)&#xA;&#xD;&#xA;                   ReferenceSourceTarget=%(_ResolvedNativeProjectReferencePaths.ReferenceSourceTarget)&#xA;&#xD;&#xA;                   ReferenceOutputAssembly=%(_ResolvedNativeProjectReferencePaths.ReferenceOutputAssembly)&#xA;" Importance="High" />
    <Message Text="_ResolvedProjectReferencePaths=%(_ResolvedProjectReferencePaths.Identity)&#xA;&#xD;&#xA;                   ReferenceSourceTarget=%(_ResolvedProjectReferencePaths.ReferenceSourceTarget)&#xA;&#xD;&#xA;                   ReferenceOutputAssembly=%(_ResolvedProjectReferencePaths.ReferenceOutputAssembly)&#xA;" Importance="High" />
  </Target>
  <PropertyGroup>
    <BuildDependsOn>SetTelemetryEnvironmentVariables;$(BuildDependsOn)</BuildDependsOn>
    <RebuildDependsOn>SetTelemetryEnvironmentVariables;$(RebuildDependsOn)</RebuildDependsOn>
  </PropertyGroup>
  <!-- these env vars will be set for all toolsets (current and old) -->
  <Target Name="SetTelemetryEnvironmentVariables" Condition="'$(DesignTimeBuild)' != 'true'">
    <!-- used by vctip -->
    <SetEnv Name="VSTEL_SolutionSessionID" Value="$(VSTEL_SolutionSessionID)" Prefix="false" />
    <SetEnv Name="VSTEL_CurrentSolutionBuildID" Value="$(VSTEL_CurrentSolutionBuildID)" Prefix="false" />
    <SetEnv Name="VSTEL_ProjectID" Value="$(ProjectGuid)" Prefix="false">
      <Output TaskParameter="OutputEnvironmentVariable" PropertyName="VSTEL_ProjectID" />
    </SetEnv>
    <!-- used by BuildInsights-->
    <SetEnv Name="VSTEL_SolutionPath" Value="$(SolutionPath)" Prefix="false" />
    <SetEnv Name="VSTEL_MSBuildProjectFullPath" Value="$(MSBuildProjectFullPath)" Prefix="false" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\MSBuild\Microsoft\VC\v170\Microsoft.Cpp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <!--<ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets" Condition="Exists('$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  This file will be consumed by ALL UWP C++ app projects (both inside
  and outside of this repo) that build on top of Microsoft.ReactNative.
  Do not make any changes here unless it applies to ALL such projects.
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Common.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Common.targets
============================================================================================================================================
-->
  <!--
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.

  This file will be consumed by all app and module projects (Desktop & UWP,
  both inside and outside of this repo) that build on top of
  Microsoft.ReactNative.
-->
  <Target Name="ReactNativeWindowsValidateProps">
    <Error Condition="'$(ReactNativeWindowsDirNotSet)' == 'true'" Text="'ReactNativeWindowsDir' should be set to the resolved location of the `react-native-windows` package. See https://aka.ms/ReactNativeWindowsDir." />
  </Target>
  <!-- Should match entry in $(ReactNativeWindowsDir)vnext\Directory.Build.targets -->
  <!--Allow implicitly restoring NuGet dependencies in C++ projects using the Visual Studio IDE.-->
  <Target Name="BeforeResolveReferences" Condition="'$(BuildingInsideVisualStudio)' == 'true' AND '$(MSBuildProjectExtension)' == '.vcxproj'">
    <!--
      Ensure restoring of PackageReference dependencies.
    -->
    <MSBuild Projects="$(MSBuildProjectFile)" Targets="Restore" Properties="RestoreProjectStyle=PackageReference" />
    <!--
      Ensure restoring of packages.config dependencies.

      RestoreProjectStyle=PackagesConfig    - Required to use the packages.config mechanism
      RestorePackagesConfig=true            - Required to use the packages.config mechanism
      RestoreUseStaticGraphEvaluation=false - Override setting from Microsoft.ReactNative.Common.props
    -->
    <MSBuild Projects="$(MSBuildProjectFile)" Targets="Restore" Properties="RestoreProjectStyle=PackagesConfig;RestorePackagesConfig=true;RestoreUseStaticGraphEvaluation=false" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!-- Due to visual studio unconditionally showing references, we have to trick it by making it impossible for VS to find the reference differences between building as source and building as NuGet -->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)PropertySheets\External\Microsoft.ReactNative.Cpp.ProjectReferences.props" Condition="!$(UseExperimentalNuget)">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Cpp.ProjectReferences.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.
-->
  <PropertyGroup>
    <RNExternalReferences>true</RNExternalReferences>
  </PropertyGroup>
  <!-- To avoid having these references show in in Visual Studio which ignores conditions on items we have to put the source references in source. -->
  <!--<ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\Microsoft.ReactNative.Cxx\Microsoft.ReactNative.Cxx.vcxitems">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\Microsoft.ReactNative.Cxx\Microsoft.ReactNative.Cxx.vcxitems
============================================================================================================================================
-->
  <PropertyGroup Label="Globals">
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <ItemsProjectGuid>{da8b35b3-da00-4b02-bde6-6a397b3fd46b}</ItemsProjectGuid>
    <ReactNativeDir Condition="'$(ReactNativeDir)' == '' AND Exists('$(MSBuildThisFileDirectory)..\..\node_modules\react-native\package.json')">$(MSBuildThisFileDirectory)..\..\node_modules\react-native</ReactNativeDir>
    <ReactNativeDir Condition="'$(ReactNativeDir)' == '' AND Exists('$(MSBuildThisFileDirectory)..\..\..\node_modules\react-native\package.json')">$(MSBuildThisFileDirectory)..\..\..\node_modules\react-native</ReactNativeDir>
    <JSI_SourcePath Condition="'$(JSI_SourcePath)' == '' AND '$(ReactNativeDir)' != ''">$(ReactNativeDir)\ReactCommon\jsi</JSI_SourcePath>
    <JSI_SourcePath Condition="'$(JSI_SourcePath)' == '' AND Exists('$(MSBuildThisFileDirectory)jsi\jsi.h')">$(MSBuildThisFileDirectory)</JSI_SourcePath>
    <CallInvoker_SourcePath Condition="'$(CallInvoker_SourcePath)' == '' AND '$(ReactNativeDir)' != ''">$(ReactNativeDir)\ReactCommon\callinvoker</CallInvoker_SourcePath>
    <CallInvoker_SourcePath Condition="'$(CallInvoker_SourcePath)' == '' AND Exists('$(MSBuildThisFileDirectory)ReactCommon\CallInvoker.h')">$(MSBuildThisFileDirectory)</CallInvoker_SourcePath>
    <CallInvoker_SourcePath Condition="'$(CallInvoker_SourcePath)' == '' AND Exists('$(MSBuildThisFileDirectory)ReactCommon\SchedulerPriority.h')">$(MSBuildThisFileDirectory)</CallInvoker_SourcePath>
    <TurboModule_SourcePath Condition="'$(TurboModule_SourcePath)' == '' AND '$(ReactNativeDir)' != ''">$(ReactNativeDir)\ReactCommon\react\nativemodule\core</TurboModule_SourcePath>
    <TurboModule_SourcePath Condition="'$(TurboModule_SourcePath)' == '' AND Exists('$(MSBuildThisFileDirectory)ReactCommon\TurboModule.h')">$(MSBuildThisFileDirectory)</TurboModule_SourcePath>
    <Bridging_SourcePath Condition="'$(Bridging_SourcePath)' == '' AND '$(ReactNativeDir)' != ''">$(ReactNativeDir)\ReactCommon\react\bridging</Bridging_SourcePath>
    <Bridging_SourcePath Condition="'$(Bridging_SourcePath)' == '' AND Exists('$(MSBuildThisFileDirectory)ReactCommon\CallbackWrapper.h')">$(MSBuildThisFileDirectory)ReactCommon</Bridging_SourcePath>
    <NodeApiJsiCommitHash>6506206ee0519da5ab688f6725cfa46441fd8650</NodeApiJsiCommitHash>
    <NodeApiJsiLocal Condition="Exists('$(MSBuildThisFileDirectory)NodeApiJsiRuntime.cpp')">true</NodeApiJsiLocal>
    <NodeApiJsiDir Condition="'$(NodeApiJsiDir)' == '' AND '$(NodeApiJsiLocal)' == 'true'">$(MSBuildThisFileDirectory)</NodeApiJsiDir>
    <NodeApiJsiDir Condition="'$(NodeApiJsiDir)' == '' AND '$(ReactNativeDir)' != ''">$(ReactNativeDir)\..\..\node_modules\.node-api-jsi\node-api-jsi-$(NodeApiJsiCommitHash)\</NodeApiJsiDir>
    <NodeApiJsiSrcDir Condition="'$(NodeApiJsiSrcDir)' == '' AND '$(NodeApiJsiLocal)' != 'true'">$(NodeApiJsiDir)src\</NodeApiJsiSrcDir>
    <NodeApiJsiSrcDir Condition="'$(NodeApiJsiSrcDir)' == ''">$(MSBuildThisFileDirectory)</NodeApiJsiSrcDir>
    <NodeApiDir Condition="'$(NodeApiDir)' == ''">$(NodeApiJsiDir)node-api\</NodeApiDir>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>
        $(MSBuildThisFileDirectory);
        $(JSI_SourcePath);
        $(CallInvoker_SourcePath);
        $(TurboModule_SourcePath);
        $(Bridging_SourcePath);
        $(NodeApiDir);
        $(NodeApiJsiSrcDir);
        %(AdditionalIncludeDirectories)
      </AdditionalIncludeDirectories>
      <PreprocessorDefinitions>JSI_VERSION=10;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Midl>
      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </Midl>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="SourceItemsFromImports" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="$(JSI_SourcePath)\jsi\instrumentation.h" />
    <ClInclude Include="$(JSI_SourcePath)\jsi\jsi-inl.h" />
    <ClInclude Include="$(JSI_SourcePath)\jsi\jsi.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)CoreApp.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)DesktopWindowBridge.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSI\LongLivedJsiValue.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)TurboModuleProvider.h" />
    <ClInclude Include="$(CallInvoker_SourcePath)\ReactCommon\CallInvoker.h" />
    <ClInclude Include="$(CallInvoker_SourcePath)\ReactCommon\SchedulerPriority.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)XamlUtils.h" />
    <ClInclude Include="$(TurboModule_SourcePath)\ReactCommon\LongLivedObject.h" />
    <ClInclude Include="$(Bridging_SourcePath)\CallbackWrapper.h" />
    <ClInclude Include="$(TurboModule_SourcePath)\ReactCommon\TurboModule.h" />
    <ClInclude Include="$(TurboModule_SourcePath)\ReactCommon\TurboModuleUtils.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)CppWinRTIncludes.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)Crash.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSI\JsiAbiApi.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSI\JsiApiContext.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSI\JsiValueHelpers.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactHandleHelper.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSValue.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSValueReader.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSValueTreeReader.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSValueTreeWriter.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSValueWriter.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)JSValueXaml.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ModuleRegistration.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)NamespaceRedirect.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)NativeModules.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactDispatcher.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactNonAbiValue.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactNotificationService.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactPropertyBag.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactContext.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactError.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)ReactPromise.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)StructInfo.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Composition.Effects.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Composition.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Input.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Popups.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Text.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Automation.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Automation.Peers.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Controls.Primitives.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Documents.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Hosting.DesktopWindowXamlSource.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Hosting.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Input.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Markup.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Media.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Controls.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Media.Imaging.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Media.Media3D.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Navigation.h" />
    <ClInclude Include="$(MSBuildThisFileDirectory)UI.Xaml.Shapes.h" />
    <ClInclude Include="$(NodeApiDir)js_native_api.h" />
    <ClInclude Include="$(NodeApiDir)js_native_api_types.h" />
    <ClInclude Include="$(NodeApiDir)js_runtime_api.h" />
    <ClInclude Include="$(NodeApiJsiSrcDir)ApiLoaders\NodeApi.h" />
    <ClInclude Include="$(NodeApiJsiSrcDir)ApiLoaders\NodeApi.inc" />
    <ClInclude Include="$(NodeApiJsiSrcDir)ApiLoaders\JSRuntimeApi.h" />
    <ClInclude Include="$(NodeApiJsiSrcDir)ApiLoaders\JSRuntimeApi.inc" />
    <ClInclude Include="$(NodeApiJsiSrcDir)NodeApiJsiRuntime.h" />
  </ItemGroup>
  <ItemGroup Condition="'$(BuildMSRNCxx)' != 'false'">
    <ClCompile Include="$(MSBuildThisFileDirectory)JSI\JsiAbiApi.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)JSI\JsiApiContext.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)JSI\JsiValueHelpers.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)JSValue.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)JSValueTreeReader.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)JSValueTreeWriter.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)ModuleRegistration.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)ReactPromise.cpp" />
    <ClCompile Include="$(MSBuildThisFileDirectory)TurboModuleProvider.cpp" />
  </ItemGroup>
  <ItemGroup Condition="'$(BuildMSRNCxxJsi)' != 'false'">
    <ClCompile Include="$(JSI_SourcePath)\jsi\jsi.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <DisableSpecificWarnings>%(DisableSpecificWarnings);4100</DisableSpecificWarnings>
    </ClCompile>
  </ItemGroup>
  <ItemGroup Condition="'$(BuildMSRNCxxReactCommon)' != 'false'">
    <!--
      Make sure all Meta code uses the same flags to improve build parallelism.
      This is because msbuild has to invoke different cl.exe invocations for each
      set of flags and msbuild inside a project is single threaded.
    -->
    <ClCompile Include="$(Bridging_SourcePath)\LongLivedObject.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <DisableSpecificWarnings>%(DisableSpecificWarnings);4100</DisableSpecificWarnings>
    </ClCompile>
    <ClCompile Include="$(TurboModule_SourcePath)\ReactCommon\TurboModule.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <DisableSpecificWarnings>%(DisableSpecificWarnings);4100</DisableSpecificWarnings>
    </ClCompile>
    <ClCompile Include="$(TurboModule_SourcePath)\ReactCommon\TurboModuleUtils.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <DisableSpecificWarnings>%(DisableSpecificWarnings);4100</DisableSpecificWarnings>
    </ClCompile>
  </ItemGroup>
  <ItemGroup Condition="'$(BuildMSRNCxxNodeApiJsi)' != 'false'">
    <ClCompile Include="$(NodeApiJsiSrcDir)ApiLoaders\NodeApi.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(NodeApiJsiSrcDir)ApiLoaders\JSRuntimeApi.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="$(NodeApiJsiSrcDir)NodeApiJsiRuntime.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup Condition="'$(BuildMSRNCxxNodeApiJsiLoader)' != 'false'">
    <ClCompile Include="$(MSBuildThisFileDirectory)JSI\NodeApiJsiLoader.cpp">
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="$(MSBuildThisFileDirectory)README.md" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Cpp.ProjectReferences.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <ItemGroup>
    <ProjectReference Include="$(ReactNativeWindowsDir)Microsoft.ReactNative\Microsoft.ReactNative.vcxproj">
      <Project>{f7d32bd0-2749-483e-9a0d-1635ef7e3136}</Project>
      <Name>Microsoft.ReactNative</Name>
      <Private Condition="'$(ConfigurationType)' != 'Application'">false</Private>
    </ProjectReference>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--<Import Project="$(ReactNativeWindowsDir)PropertySheets\External\Microsoft.ReactNative.Cpp.PackageReferences.props" Condition="$(UseExperimentalNuget)" />-->
  <ItemGroup>
    <PackageReference Include="Microsoft.Windows.CppWinRT" Version="$(CppWinRTVersion)" PrivateAssets="all" />
    <!-- WinUI package name and version are set by WinUI.props -->
    <PackageReference Include="$(WinUIPackageName)" Version="$(WinUIPackageVersion)" Condition="'$(OverrideWinUIPackage)'!='true'" />
    <!-- Hermes version is set by JSEngine.props -->
    <PackageReference Include="Microsoft.JavaScript.Hermes" Version="$(HermesVersion)" Condition="$(UseHermes)" />
  </ItemGroup>
  <!-- The props file for bundling is not set up to be just defaults, it assumes to be run at the end of the project. -->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Bundle.props">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Bundle.props
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.
-->
  <!--<Import Project="$(ReactNativeWindowsDir)PropertySheets\JSEngine.props" Condition="'$(JsEnginePropsDefined)' == ''" />-->
  <PropertyGroup>
    <!-- 
      UseBundle causes the bundle to be created and included inside the application install.  And defines the BUNDLE #define in code,
      which causes the app to load from the bundle file rather than loading the bundle from a bundle server
    -->
    <UseBundle Condition=" '$(Configuration)' == 'Debug' and '$(UseBundle)' == '' ">false</UseBundle>
    <UseBundle Condition=" '$(Configuration)' == 'Release' and '$(UseBundle)' == '' ">true</UseBundle>
    <!-- Root directory where bundle assets will be copied to, be sure to update BundleContent if you change this -->
    <BundleContentRoot Condition=" '$(BundleContentRoot)' == '' ">$([MSBuild]::NormalizePath('$(ProjectDir)\Bundle'))</BundleContentRoot>
    <!-- Files included in BundleContent will be included in the application install - by default this includes the bundle file, and assets from the bundler  -->
    <BundleContent Condition=" '$(BundleContent)' == '' and '$(BundleContentRoot)' != '' ">$(BundleContentRoot)\**\*</BundleContent>
    <!-- The name of the JS bundle assert to be placed in $(BundleOutputPath)-->
    <BundleAssetName Condition="'$(BundleAssetName)' == ''">index.windows.bundle</BundleAssetName>
    <!-- What directory should the final JS bundle be written to -->
    <BundleOutputPath Condition="'$(BundleOutputPath)' == ''">$([MSBuild]::NormalizePath('$(ProjectDir)\Bundle'))</BundleOutputPath>
    <!-- File path of the final JS bundle -->
    <BundleOutputFile Condition="'$(BundleOutputFile)' == ''">$(BundleOutputPath)\$(BundleAssetName)</BundleOutputFile>
    <!-- Should the bundle created be a dev bundle -->
    <UseDevBundle Condition="'$(UseDevBundle)' == '' and '$(Configuration)' == 'Debug'">true</UseDevBundle>
    <UseDevBundle Condition="'$(UseDevBundle)' == '' and '$(Configuration)' != 'Debug'">false</UseDevBundle>
    <!-- Extra arguments to pass to the bundler command -->
    <BundlerExtraArgs Condition="'$(BundlerExtraArgs)' == '' AND '$(UseHermes)' == 'true'">--minify false</BundlerExtraArgs>
    <!-- Command to use to create a bundle -->
    <BundleCliCommand Condition="'$(BundleCliCommand)' == ''">npx react-native bundle</BundleCliCommand>
    <!-- This should be the app package root, this is where the bundle command will be run from -->
    <BundleCommandWorkingDir Condition="'$(BundleCommandWorkingDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(ProjectDir), 'package.json'))</BundleCommandWorkingDir>
    <!-- Entry file of the JS bundle. Defaults to use index.windows.js if it exists, otherwise index.js -->
    <BundleEntryFile Condition="'$(BundleEntryFile)' == '' and Exists('$(BundleCommandWorkingDir)\index.windows.js')">index.windows.js</BundleEntryFile>
    <BundleEntryFile Condition="'$(BundleEntryFile)' == ''">index.js</BundleEntryFile>
    <FullOutDir Condition="'$([System.IO.Path]::GetFullPath($(OutDir)))' == '$(OutDir)'">$(OutDir)</FullOutDir>
    <FullOutDir Condition="'$([System.IO.Path]::GetFullPath($(OutDir)))' != '$(OutDir)'">$(ProjectDir)$(OutDir)</FullOutDir>
    <!-- Location where source map file for the JS bundle will be created -->
    <BundleSourceMapDir Condition="'$(BundleSourceMapDir)' == ''">$([MSBuild]::NormalizePath('$(FullOutDir)\sourcemaps\react'))</BundleSourceMapDir>
    <!-- Base (extensionless) filename for bundle sourcemaps -->
    <BaseBundleSourceMap Condition="'$(BaseBundleSourceMap)' == ''">$(BundleSourceMapDir)\$(BundleAssetName)</BaseBundleSourceMap>
    <!-- Source map file for the bundle (composed from packager + compiler if using Hermes) -->
    <BundleSourceMap Condition="'$(BundleSourceMap)' == ''">$(BaseBundleSourceMap).map</BundleSourceMap>
    <!-- Filename for source maps generated by metro-->
    <PackagerSourceMapExtension Condition="'$(PackagerSourceMapExtension)' == '' AND '$(UseHermes)' != 'true'">.map</PackagerSourceMapExtension>
    <PackagerSourceMapExtension Condition="'$(PackagerSourceMapExtension)' == '' AND '$(UseHermes)' == 'true'">.packager.map</PackagerSourceMapExtension>
    <PackagerSourceMap Condition="'$(PackagerSourceMap)' == ''">$(BaseBundleSourceMap)$(PackagerSourceMapExtension)</PackagerSourceMap>
    <!-- Filename for source maps generated by Hermes -->
    <HermesSourceMap Condition="'$(HermesSourceMap)' == '' AND '$(UseHermes)' == 'true'">$(BaseBundleSourceMap).compiler.map</HermesSourceMap>
    <!-- Command to compile Hermes bytecode -->
    <HermesCompilerCommand Condition="'$(HermesCompilerCommand)' == ''">$(HermesPackage)\tools\native\release\x86\hermes.exe</HermesCompilerCommand>
    <!-- Flags passed to Hermes when compiling a bundle -->
    <HermesCompilerFlags Condition="'$(HermesCompilerFlags)' == '' AND '$(Configuration)' != 'Debug'">-O</HermesCompilerFlags>
  </PropertyGroup>
  <PropertyGroup>
    <DefineConstants Condition=" '$(DefineConstants)' != ''  and '$(UseBundle)' == 'true' ">$(DefineConstants);BUNDLE</DefineConstants>
    <DefineConstants Condition=" '$(DefineConstants)' == ''  and '$(UseBundle)' == 'true' ">BUNDLE</DefineConstants>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Bundle.Cpp.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Bundle.Cpp.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)\Bundle.Common.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Bundle.Common.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation.
  Licensed under the MIT License.
-->
  <PropertyGroup>
    <ReactNativeDir Condition="'$(ReactNativeDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), 'node_modules\react-native\package.json'))\node_modules\react-native\</ReactNativeDir>
  </PropertyGroup>
  <Target Name="MakeBundle" BeforeTargets="PrepareForBuild" Condition="'$(UseBundle)' == 'true' And ('$(BuildingInsideVisualStudio)'!='true' Or '$(BuildingProject)'=='true')">
    <MakeDir Directories="$(BundleContentRoot)" />
    <MakeDir Directories="$(BundleSourceMapDir)" />
    <Message Importance="High" Text="Running [$(BundleCliCommand) --platform windows --entry-file $(BundleEntryFile) --bundle-output $(BundleOutputFile) --assets-dest $(BundleContentRoot) --dev $(UseDevBundle) --reset-cache --sourcemap-output $(PackagerSourceMap) $(BundlerExtraArgs)] to build bundle file." />
    <Exec Command="$(BundleCliCommand) --platform windows --entry-file &quot;$(BundleEntryFile)&quot; --bundle-output &quot;$(BundleOutputFile)&quot; --assets-dest &quot;$(BundleContentRoot)&quot; --dev $(UseDevBundle) --reset-cache --sourcemap-output &quot;$(PackagerSourceMap)&quot; $(BundlerExtraArgs)" ConsoleToMSBuild="true" WorkingDirectory="$(BundleCommandWorkingDir)" />
  </Target>
  <!-- See https://github.com/facebook/react-native/blob/07d090dbc6c46b8f3760dbd25dbe0540c18cb3f3/react.gradle#L190 for reference -->
  <Target Name="CompileHermesBytecode" AfterTargets="MakeBundle" Condition="'$(UseBundle)' == 'true' AND '$(UseHermes)' == 'true'">
    <Message Importance="High" Text="Running [$(HermesCompilerCommand) -emit-binary -out $(BundleOutputFile).hbc $(BundleOutputFile) $(HermesCompilerFlags) -output-source-map] to precompile bundle file." />
    <Exec Command="$(HermesCompilerCommand) -emit-binary -out &quot;$(BundleOutputFile).hbc&quot; &quot;$(BundleOutputFile)&quot; $(HermesCompilerFlags) -output-source-map" ConsoleToMSBuild="true" WorkingDirectory="$(BundleCommandWorkingDir)" />
    <Move SourceFiles="$(BundleOutputFile).hbc" DestinationFiles="$(BundleOutputFile)" />
    <Move SourceFiles="$(BundleOutputFile).hbc.map" DestinationFiles="$(HermesSourceMap)" />
    <Exec Command="node &quot;$(ReactNativeDir)\scripts\compose-source-maps.js&quot; &quot;$(PackagerSourceMap)&quot; &quot;$(HermesSourceMap)&quot; -o &quot;$(BundleSourceMap)&quot;" ConsoleToMSBuild="true" WorkingDirectory="$(BundleCommandWorkingDir)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Bundle.Cpp.targets
============================================================================================================================================
-->
  <Target Name="InjectBundleContent" BeforeTargets="PrepareForBuild" AfterTargets="MakeBundle">
    <ItemGroup Condition="'$(UseBundle)' == 'true' and '$(BundleContent)' != '' and '$(BundleContentRoot)' != '' ">
      <BundleContentToBePackaged Include="$(BundleContent)" />
      <None Include="@(BundleContentToBePackaged)">
        <Link>$([MSBuild]::MakeRelative($(ProjectDir),'$(BundleContentRoot)\%(RecursiveDir)%(Filename)%(Extension)'))</Link>
        <DeploymentContent>true</DeploymentContent>
      </None>
    </ItemGroup>
  </Target>
  <ItemDefinitionGroup Condition=" '$(UseBundle)' == 'true' ">
    <ClCompile>
      <PreprocessorDefinitions>BUNDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Autolink.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Autolink.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <!--
    Visual Studio has its own incremental build logic on top of MSBuild's that
    will skip targets if it thinks inputs haven't changed. This falls over for
    changes dependent on anything outside of our project. 
  -->
  <PropertyGroup>
    <DisableFastUpToDateCheck>True</DisableFastUpToDateCheck>
  </PropertyGroup>
  <Target Name="AutolinkCheck" BeforeTargets="PrepareForBuild" Condition="'$(RunAutolinkCheck)' == 'true'">
    <Exec Command="$(AutolinkCommand) $(AutolinkCommandArgs)" WorkingDirectory="$(AutolinkCommandWorkingDir)" CustomWarningRegularExpression="Warning: " CustomErrorRegularExpression="Error: " />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ProjectDir)\AutolinkedNativeModules.g.targets" Condition="Exists('$(ProjectDir)\AutolinkedNativeModules.g.targets')">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\AutolinkedNativeModules.g.targets
============================================================================================================================================
-->
  <!-- AutolinkedNativeModules.g.targets contents generated by "react-native autolink-windows" -->
  <ItemGroup>
    <!-- Projects from @react-native-async-storage/async-storage -->
    <ProjectReference Include="$(ProjectDir)..\..\node_modules\@react-native-async-storage\async-storage\windows\ReactNativeAsyncStorage\ReactNativeAsyncStorage.vcxproj">
      <Project>{4855D892-E16C-404D-8286-0089E0F7F9C4}</Project>
    </ProjectReference>
    <!-- Projects from react-native-document-picker -->
    <ProjectReference Include="$(ProjectDir)..\..\node_modules\react-native-document-picker\windows\ReactNativeDocumentPicker\ReactNativeDocumentPicker.csproj">
      <Project>{A4C9C727-0AEB-4A3D-B547-BEDB812B172D}</Project>
    </ProjectReference>
    <!-- Projects from react-native-screens -->
    <ProjectReference Include="$(ProjectDir)..\..\node_modules\react-native-screens\windows\RNScreens\RNScreens.vcxproj">
      <Project>{d638f49e-29d2-4699-ac52-facd82fa7138}</Project>
    </ProjectReference>
    <!-- Projects from react-native-share -->
    <ProjectReference Include="$(ProjectDir)..\..\node_modules\react-native-share\windows\ReactNativeShare\ReactNativeShare.vcxproj">
      <Project>{bd58576e-3205-4762-8b1b-ea33774079b7}</Project>
    </ProjectReference>
    <!-- Projects from react-native-sqlite-storage -->
    <ProjectReference Include="$(ProjectDir)..\..\node_modules\react-native-sqlite-storage\platforms\windows\SQLitePlugin\SQLitePlugin.vcxproj">
      <Project>{a09b9a47-e2b9-4294-9746-ac55213fc642}</Project>
    </ProjectReference>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\Codegen.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\Codegen.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <!--
    Visual Studio has its own incremental build logic on top of MSBuild's that
    will skip targets if it thinks inputs haven't changed. This falls over for
    changes dependent on anything outside of our project. 
  -->
  <PropertyGroup>
    <DisableFastUpToDateCheck>True</DisableFastUpToDateCheck>
  </PropertyGroup>
  <Target Name="CodegenWindows" BeforeTargets="PrepareForBuild" Condition="'$(RunCodegenWindows)' == 'true'">
    <Exec Command="$(CodegenCommand) $(CodegenCommandArgs)" WorkingDirectory="$(CodegenCommandWorkingDir)" CustomWarningRegularExpression="Warning: " CustomErrorRegularExpression="Error: " />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--<Import Project="$(OutputPath)$(AssemblyName).Build.appxrecipe" Condition="Exists('$(OutputPath)$(AssemblyName).Build.appxrecipe') And '$(DeployLayout)'=='true'" />-->
  <Target Name="Deploy" Condition="'$(DeployLayout)'=='true'">
    <Error Condition="!Exists('$(OutputPath)$(AssemblyName).Build.appxrecipe')" Text="You must first build the project before deploying it" />
    <Copy SourceFiles="%(AppxPackagedFile.Identity)" DestinationFiles="$(OutputPath)Appx\%(AppxPackagedFile.PackagePath)" />
    <Copy SourceFiles="%(AppXManifest.Identity)" DestinationFiles="$(OutputPath)Appx\%(AppxManifest.PackagePath)" Condition="'%(AppxManifest.SubType)'!='Designer'" />
    <Exec Command="powershell -NonInteractive -NoProfile -Command Add-AppxPackage -Register $(OutputPath)Appx\AppxManifest.xml" ContinueOnError="false" />
  </Target>
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\CppAppConsumeCSharpModule.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <!-- Add a workaround to make sure the .NET framework libraries are correctly copied to the AppX folder in Debug (CoreCLR) mode -->
  <Target Name="AfterInjectNetCoreFramework" AfterTargets="InjectNetCoreFramework" Condition="'$(ConsumeCSharpModules)' == 'true'">
    <ItemGroup>
      <PackagingOutputs Include="@(_InjectNetCoreFrameworkPayload)" Condition="'%(_InjectNetCoreFrameworkPayload.NuGetPackageId)' == '$(_CoreRuntimePackageId)' and '$(UseDotNetNativeToolchain)' != 'true'">
        <TargetPath>%(Filename)%(Extension)</TargetPath>
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
      </PackagingOutputs>
    </ItemGroup>
  </Target>
  <!--<ImportGroup Condition="'$(ConsumeCSharpModules)' == 'true'">-->
  <!-- Start Custom .NET Native targets -->
  <!-- Import all of the .NET Native / CoreCLR targets at the end of the project -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk\$(UWPCoreRuntimeSdkVersion)\build\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\build\runtime.win10-x86.Microsoft.Net.UWPCoreRuntimeSdk.targets
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreRuntime.2.2.appx" Condition="'$(_TargetsCoreRuntime)' == 'true'">
      <Architecture>x86</Architecture>
      <Version>2.2.31331.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <DesignTimeAppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreRuntime.2.2.appx">
      <Architecture>x86</Architecture>
      <Version>2.2.31331.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </DesignTimeAppxPackageRegistration>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreFramework.Debug.2.2.appx" Condition="'$(_TargetsCoreRuntime)' == 'true' AND '$(Platform)' != 'arm64' AND '$(UseAppLocalCoreFramework)' != 'true'">
      <Architecture>x86</Architecture>
      <Version>2.2.31327.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <DesignTimeAppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreFramework.Debug.2.2.appx" Condition="'$(Platform)' != 'arm64'">
      <Architecture>x86</Architecture>
      <Version>2.2.31327.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </DesignTimeAppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk\$(UWPCoreRuntimeSdkVersion)\build\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk\2.2.14\build\runtime.win10-x64.Microsoft.Net.UWPCoreRuntimeSdk.targets
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreRuntime.2.2.appx" Condition="'$(_TargetsCoreRuntime)' == 'true'">
      <Architecture>x64</Architecture>
      <Version>2.2.31331.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <DesignTimeAppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreRuntime.2.2.appx">
      <Architecture>x64</Architecture>
      <Version>2.2.31331.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </DesignTimeAppxPackageRegistration>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreFramework.Debug.2.2.appx" Condition="'$(_TargetsCoreRuntime)' == 'true' AND '$(Platform)' != 'arm64' AND '$(UseAppLocalCoreFramework)' != 'true'">
      <Architecture>x64</Architecture>
      <Version>2.2.31327.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <DesignTimeAppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Appx\Microsoft.NET.CoreFramework.Debug.2.2.appx" Condition="'$(Platform)' != 'arm64'">
      <Architecture>x64</Architecture>
      <Version>2.2.31327.1</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </DesignTimeAppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\Microsoft.Net.Native.Compiler.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\Microsoft.Net.Native.Compiler.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.Native.Compiler.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <BuildDependsOn>
      CheckMicrosoftNetNativeCompilerCompatibility;
      $(BuildDependsOn);
    </BuildDependsOn>
  </PropertyGroup>
  <Target Name="CheckMicrosoftNetNativeCompilerCompatibility">
    <Error Text="The Microsoft.Net.Native.Compiler package, included in Microsoft.NETCore.UniversalWindowsPlatform 5.3 and later, is only supported in Visual Studio 2017 and later. You can downgrade the version of the Microsoft.NETCore.UniversalWindowsPlatorm NuGet package to 5.2.* or earlier for Visual Studio 2015." Condition="'$(VisualStudioVersion)' &lt; '15.0'" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\runtime.win10-x86.Microsoft.Net.Native.Compiler.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\runtime.win10-x86.Microsoft.Net.Native.Compiler.targets
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Runtime\x86\Microsoft.NET.Native.Runtime.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true'">
      <Architecture>x86</Architecture>
      <Version>2.2.28604.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\runtime.win10-x64.Microsoft.Net.Native.Compiler.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\runtime.win10-x64.Microsoft.Net.Native.Compiler.targets
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Runtime\x64\Microsoft.NET.Native.Runtime.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true'">
      <Architecture>x64</Architecture>
      <Version>2.2.28604.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.Compiler\$(DotNetNativeVersion)\build\runtime.win10-arm64.Microsoft.Net.Native.Compiler.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.Compiler\2.2.12-rel-31116-00\build\runtime.win10-arm64.Microsoft.Net.Native.Compiler.targets
============================================================================================================================================
-->
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\Runtime\arm64\Microsoft.NET.Native.Runtime.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true'">
      <Architecture>arm64</Architecture>
      <Version>2.2.28604.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\$(DotNetNativeRuntimeVersion)\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-x86.Microsoft.Net.Native.SharedLibrary.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <DotNetNativeBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' == 'true'">Debug</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' != 'true'">Retail</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' == 'true'">Retail</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' != 'true'">Debug</DotNetNativeBuildType>
  </PropertyGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\SharedLibrary\ret\Native\Microsoft.NET.Native.Framework.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true' and '$(DotNetNativeBuildType)' == 'Retail'">
      <Architecture>x86</Architecture>
      <Version>2.2.29512.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\SharedLibrary\chk\Native\Microsoft.NET.Native.Framework.Debug.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true' and '$(DotNetNativeBuildType)' == 'Debug'">
      <Architecture>x86</Architecture>
      <Version>2.2.29512.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary\$(DotNetNativeRuntimeVersion)\build\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-x64.Microsoft.Net.Native.SharedLibrary.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <DotNetNativeBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' == 'true'">Debug</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' != 'true'">Retail</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' == 'true'">Retail</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' != 'true'">Debug</DotNetNativeBuildType>
  </PropertyGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\SharedLibrary\ret\Native\Microsoft.NET.Native.Framework.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true' and '$(DotNetNativeBuildType)' == 'Retail'">
      <Architecture>x64</Architecture>
      <Version>2.2.29512.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\SharedLibrary\chk\Native\Microsoft.NET.Native.Framework.Debug.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true' and '$(DotNetNativeBuildType)' == 'Debug'">
      <Architecture>x64</Architecture>
      <Version>2.2.29512.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProgramFiles32)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary\$(DotNetNativeRuntimeVersion)\build\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary.targets">

C:\Program Files (x86)\Microsoft SDKs\UWPNuGetPackages\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary\2.2.8-rel-31116-00\build\runtime.win10-arm64.Microsoft.Net.Native.SharedLibrary.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <DotNetNativeBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' == 'true'">Debug</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' == 'C++' and '$(UseDebugLibraries)' != 'true'">Retail</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' == 'true'">Retail</DotNetNativeBuildType>
    <DotNetNativeBuildType Condition="'$(Language)' != 'C++' and '$(Optimize)' != 'true'">Debug</DotNetNativeBuildType>
  </PropertyGroup>
  <ItemGroup>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\SharedLibrary\ret\Native\Microsoft.NET.Native.Framework.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true' and '$(DotNetNativeBuildType)' == 'Retail'">
      <Architecture>arm64</Architecture>
      <Version>2.2.29512.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
    <AppxPackageRegistration Include="$(MSBuildThisFileDirectory)..\tools\SharedLibrary\chk\Native\Microsoft.NET.Native.Framework.Debug.2.2.appx" Condition="'$(ProjectNProfileEnabled)' == 'true' and '$(UseDotNetNativeToolchain)' == 'true' and '$(DotNetNativeBuildType)' == 'Debug'">
      <Architecture>arm64</Architecture>
      <Version>2.2.29512.0</Version>
      <Publisher>'CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US'</Publisher>
    </AppxPackageRegistration>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\CppAppConsumeCSharpModule.targets
============================================================================================================================================
-->
  <!-- End Custom .NET Native targets -->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\RequireSolution.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\RequireSolution.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <Target Name="RequireSolutionTargets" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>The property {0} is not defined. This project requires being built via a valid solution file.</ErrorText>
    </PropertyGroup>
    <Error Condition="'$(SolutionPath)' == '' OR '$(SolutionPath)' == '*Undefined*'" Text="$([System.String]::Format('$(ErrorText)', 'SolutionPath'))" />
    <Error Condition="'$(SolutionDir)' == '' OR '$(SolutionDir)' == '*Undefined*'" Text="$([System.String]::Format('$(ErrorText)', 'SolutionDir'))" />
    <Error Condition="'$(SolutionFileName)' == '' OR '$(SolutionFileName)' == '*Undefined*'" Text="$([System.String]::Format('$(ErrorText)', 'SolutionFileName'))" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\FixupRoslynCscWarnings.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\FixupRoslynCscWarnings.targets
============================================================================================================================================
-->
  <!--
    ARM64 C++ projects will by default add $(DotNetSdk_LibraryPath_arm64) and
    $(VC_LibraryPath_ATL_ARM64) to the LIB environment variable, even if the
    paths do not exist. This causes compiler warnings from the csc instance
    spawned by RoslynCodeTaskFactory in our inline tasks.

    This target alters the build environment to prevent the warning from the
    RoslynCodeTaskFactory assembly spawned csc process.
  -->
  <Target Name="ReactNativeWindowsFixupRoslynCscWarnings" AfterTargets="SetBuildDefaultEnvironmentVariables" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <_FixedUpLib>$(LIB)</_FixedUpLib>
    </PropertyGroup>
    <PropertyGroup Condition="'$(DotNetSdk_LibraryPath_arm64)' != '' and $(LIB.Contains('$(DotNetSdk_LibraryPath_arm64)')) and !Exists('$(DotNetSdk_LibraryPath_arm64)')">
      <_FixedUpLib>$(_FixedUpLib.Replace('$(DotNetSdk_LibraryPath_arm64)', ''))</_FixedUpLib>
    </PropertyGroup>
    <PropertyGroup Condition="'$(VC_LibraryPath_ATL_ARM64)' != '' and $(LIB.Contains('$(VC_LibraryPath_ATL_ARM64)')) and !Exists('$(VC_LibraryPath_ATL_ARM64)')">
      <_FixedUpLib>$(_FixedUpLib.Replace('$(VC_LibraryPath_ATL_ARM64)', ''))</_FixedUpLib>
    </PropertyGroup>
    <SetEnv Condition="'$(LIB)' != '$(_FixedUpLib)'" Name="LIB" Value="$(_FixedUpLib)" Prefix="False" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(ReactNativeWindowsDir)\PropertySheets\OutputMSBuildProperties.targets">

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\OutputMSBuildProperties.targets
============================================================================================================================================
-->
  <!-- 
  Copyright (c) Microsoft Corporation. All rights reserved.
 Licensed under the MIT License.. 
-->
  <Target Name="OutputMSBuildProperties" AfterTargets="PrepareForBuild">
    <PropertyGroup>
      <!--
      These are the properties we will report in telemetry. Do NOT add properties that may contain PII.
      You can add new properties following the format "PropertyName": "$(PropertyName)",
    -->
      <MSBuildPropertiesJSON>
      {
        "WinUIPackageName": "$(WinUIPackageName)",
        "WinUIPackageVersion": "$(WinUIPackageVersion)",
        "WindowsTargetPlatformVersion": "$(WindowsTargetPlatformVersion)",
        "UseExperimentalNuGet": "$(UseExperimentalNuGet)",
        "UseHermes": "$(UseHermes)",
        "UseWinUI3": "$(UseWinUI3)"
      }
      </MSBuildPropertiesJSON>
    </PropertyGroup>
    <WriteLinesToFile File="$([MSBuild]::NormalizePath($(ProjectDir)\Generated Files))\msbuildproperties.g.json" Overwrite="true" Lines="$(MSBuildPropertiesJSON)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\node_modules\react-native-windows\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets
============================================================================================================================================
-->
  <ItemDefinitionGroup>
    <Reference>
      <Private Condition="'$(ConfigurationType)' != 'Application'">false</Private>
    </Reference>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

C:\Users\tubbeTEC\Desktop\Projects\Anamnese-App\Anamnese-App\windows\anamnese-mobile\anamnese-mobile.vcxproj
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <Target Name="EnsureReactNativeWindowsTargets" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references targets in your node_modules\react-native-windows folder that are missing. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.props')" Text="$([System.String]::Format('$(ErrorText)', '$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.props'))" />
    <Error Condition="!Exists('$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets')" Text="$([System.String]::Format('$(ErrorText)', '$(ReactNativeWindowsDir)\PropertySheets\External\Microsoft.ReactNative.Uwp.CppApp.targets'))" />
  </Target>
</Project>